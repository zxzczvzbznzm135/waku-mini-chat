import { TypedEventEmitter } from "@libp2p/interface";
export class MockWakuNode {
    mockMessageEmitter;
    relay;
    store;
    filter;
    lightPush;
    protocols;
    subscriptions;
    constructor(mockMessageEmitter) {
        this.mockMessageEmitter = mockMessageEmitter;
        this.protocols = [];
        this.events = new TypedEventEmitter();
        this.subscriptions = [];
        this.lightPush = {
            multicodec: [],
            send: this._send.bind(this),
            start() { },
            stop() { }
        };
        this.filter = {
            start: async () => { },
            stop: async () => { },
            multicodec: "filter",
            subscribe: this._subscribe.bind(this),
            unsubscribe(_decoders) {
                throw "Not implemented";
            },
            unsubscribeAll() {
                throw "Not implemented";
            }
        };
    }
    get libp2p() {
        throw "No libp2p on MockWakuNode";
    }
    async _send(encoder, message, _sendOptions) {
        for (const { decoders, callback } of this.subscriptions) {
            const protoMessage = await encoder.toProtoObj(message);
            if (!protoMessage)
                throw "Issue in mock encoding message";
            for (const decoder of decoders) {
                const decodedMessage = await decoder.fromProtoObj(decoder.pubsubTopic, protoMessage);
                if (!decodedMessage)
                    throw "Issue in mock decoding message";
                await callback(decodedMessage);
                if (this.mockMessageEmitter) {
                    this.mockMessageEmitter.dispatchEvent(new CustomEvent("new-message", {
                        detail: decodedMessage
                    }));
                }
            }
        }
        return {
            failures: [],
            successes: []
        };
    }
    async _subscribe(decoders, callback) {
        this.subscriptions.push({
            decoders: Array.isArray(decoders) ? decoders : [decoders],
            callback
        });
        if (this.mockMessageEmitter) {
            this.mockMessageEmitter.addEventListener("new-message", (event) => {
                void callback(event.detail);
            });
        }
        return Promise.resolve(true);
    }
    events;
    get peerId() {
        throw "no peerId on MockWakuNode";
    }
    get health() {
        throw "no health on MockWakuNode";
    }
    dial(_peer, _protocols) {
        throw new Error("Method not implemented.");
    }
    hangUp(_peer) {
        throw new Error("Method not implemented.");
    }
    start() {
        return Promise.resolve();
    }
    stop() {
        throw new Error("Method not implemented.");
    }
    waitForPeers(_protocols, _timeoutMs) {
        throw new Error("Method not implemented.");
    }
    createDecoder(_params) {
        throw new Error("Method not implemented.");
    }
    createEncoder(_params) {
        throw new Error("Method not implemented.");
    }
    isStarted() {
        throw new Error("Method not implemented.");
    }
    isConnected() {
        throw new Error("Method not implemented.");
    }
    getConnectedPeers() {
        throw new Error("Method not implemented.");
    }
}
//# sourceMappingURL=mock_node.js.map