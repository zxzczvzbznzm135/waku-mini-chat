import { TypedEventEmitter } from "@libp2p/interface";
import { MessageChannelEvents } from "./events.js";
import { ChannelId, ContentMessage, HistoryEntry, Message, MessageId, ParticipantId, SyncMessage } from "./message.js";
import { RepairConfig } from "./repair/repair.js";
export declare const DEFAULT_BLOOM_FILTER_OPTIONS: {
    capacity: number;
    errorRate: number;
};
export interface MessageChannelOptions {
    causalHistorySize?: number;
    /**
     * The time in milliseconds after which a message dependencies that could not
     * be resolved is marked as irretrievable.
     * Disabled if undefined or `0`.
     *
     * @default undefined because it is coupled to processTask calls frequency
     */
    timeoutForLostMessagesMs?: number;
    /**
     * How many possible acks does it take to consider it a definitive ack.
     */
    possibleAcksThreshold?: number;
    /**
     * Whether to enable SDS-R repair protocol.
     * @default true
     */
    enableRepair?: boolean;
    /**
     * SDS-R repair configuration. Only used if enableRepair is true.
     */
    repairConfig?: RepairConfig;
}
export type ILocalHistory = Pick<Array<ContentMessage>, "some" | "push" | "slice" | "find" | "length" | "findIndex">;
export declare class MessageChannel extends TypedEventEmitter<MessageChannelEvents> {
    readonly channelId: ChannelId;
    readonly senderId: ParticipantId;
    private lamportTimestamp;
    private filter;
    private outgoingBuffer;
    private possibleAcks;
    private incomingBuffer;
    private readonly localHistory;
    private timeReceived;
    private readonly causalHistorySize;
    private readonly possibleAcksThreshold;
    private readonly timeoutForLostMessagesMs?;
    private readonly repairManager?;
    private tasks;
    private handlers;
    constructor(channelId: ChannelId, senderId: ParticipantId, options?: MessageChannelOptions, localHistory?: ILocalHistory);
    static getMessageId(payload: Uint8Array): MessageId;
    /**
     * Processes all queued tasks sequentially to ensure proper message ordering.
     *
     * This method should be called periodically by the library consumer to execute
     * queued send/receive operations in the correct sequence.
     *
     * @example
     * ```typescript
     * const channel = new MessageChannel("my-channel");
     *
     * // Queue some operations
     * await channel.pushOutgoingMessage(payload, callback);
     * channel.pushIncomingMessage(incomingMessage);
     *
     * // Process all queued operations
     * await channel.processTasks();
     * ```
     *
     * @emits CustomEvent("taskError", { detail: { command, error, params } }
     * if any task fails, but continues processing remaining tasks
     */
    processTasks(): Promise<void>;
    /**
     * Queues a message to be sent on this channel.
     *
     * The message will be processed sequentially when processTasks() is called.
     * This ensures proper lamport timestamp ordering and causal history tracking.
     *
     * @param payload - The message content as a byte array
     * @param callback - callback function that should propagate the message
     * on the routing layer; `success` should be false if sending irremediably fails,
     * when set to true, the message is finalized into the channel locally.
     * @returns Promise that resolves when the message is queued (not sent)
     *
     * @example
     * ```typescript
     * const channel = new MessageChannel("chat-room");
     * const message = new TextEncoder().encode("Hello, world!");
     *
     * await channel.pushOutgoingMessage(message, async (processedMessage) => {
     *   console.log("Message processed:", processedMessage.messageId);
     *   return { success: true };
     * });
     *
     * // Actually send the message
     * await channel.processTasks();
     * ```
     *
     * @throws Error if the payload is empty
     */
    pushOutgoingMessage(payload: Uint8Array, callback?: (processedMessage: ContentMessage) => Promise<{
        success: boolean;
        retrievalHint?: Uint8Array;
    }>): void;
    /**
     * Sends a short-lived message without synchronization or reliability requirements.
     *
     * Sends a message without a timestamp, causal history, or bloom filter.
     * Ephemeral messages are not added to the outgoing buffer.
     * Upon reception, ephemeral messages are delivered immediately without
     * checking for causal dependencies or including in the local log.
     *
     * See https://rfc.vac.dev/vac/raw/sds/#ephemeral-messages
     *
     * @param payload - The payload to send.
     * @param callback - A callback function that returns a boolean indicating whether the message was sent successfully.
     */
    pushOutgoingEphemeralMessage(payload: Uint8Array, callback?: (processedMessage: Message) => Promise<boolean>): Promise<void>;
    /**
     * Queues a received message for processing.
     *
     * The message will be processed when processTasks() is called, ensuring
     * proper dependency resolution and causal ordering.
     *
     * @param message - The message to receive and process
     * @param retrievalHint - The retrieval hint for the message, provided by the transport layer
     * @example
     * ```typescript
     * const channel = new MessageChannel("chat-room");
     *
     * // Receive a message from the network
     * channel.pushIncomingMessage(incomingMessage);
     *
     * // Process the received message
     * await channel.processTasks();
     * ```
     */
    pushIncomingMessage(message: Message, retrievalHint: Uint8Array | undefined): void;
    /**
     * Processes messages in the incoming buffer, delivering those with satisfied dependencies.
     *
     * @returns Array of history entries for messages still missing dependencies
     */
    sweepIncomingBuffer(): HistoryEntry[];
    sweepOutgoingBuffer(): {
        unacknowledged: ContentMessage[];
        possiblyAcknowledged: ContentMessage[];
    };
    /**
     * Sweep repair incoming buffer and rebroadcast messages ready for repair.
     * Per SDS-R spec: periodically check for repair responses that are due.
     *
     * @param callback - callback to rebroadcast the message
     * @returns Promise that resolves when all ready repairs have been sent
     */
    sweepRepairIncomingBuffer(callback?: (message: Message) => Promise<boolean>): Promise<Message[]>;
    /**
     * Send a sync message to the SDS channel.
     *
     * Increments the lamport timestamp, constructs a `Message` object
     * with an empty load. Skips outgoing buffer, filter, and local log.
     *
     * See https://rfc.vac.dev/vac/raw/sds/#send-sync-message
     *
     * @param callback - A callback function that returns a boolean indicating whether the message was sent successfully.
     */
    pushOutgoingSyncMessage(callback?: (message: SyncMessage) => Promise<boolean>): Promise<boolean>;
    private _pushIncomingMessage;
    private executeTask;
    private safeSendEvent;
    private _pushOutgoingMessage;
    private _pushOutgoingEphemeralMessage;
    /**
     * Check if a message is available (either in localHistory or incomingBuffer)
     * This prevents treating messages as "missing" when they've already been received
     * but are waiting in the incoming buffer for their dependencies.
     *
     * @param messageId - The ID of the message to check
     * @private
     */
    private isMessageAvailable;
    /**
     * Return true if the message was "delivered"
     *
     * @param message
     * @private
     */
    private deliverMessage;
    private reviewAckStatus;
}
export declare function lamportTimestampIncrement(lamportTimestamp: bigint): bigint;
