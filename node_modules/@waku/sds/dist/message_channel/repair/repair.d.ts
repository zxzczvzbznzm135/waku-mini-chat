import type { HistoryEntry, MessageId } from "../message.js";
import { Message } from "../message.js";
import type { ILocalHistory } from "../message_channel.js";
import { ParticipantId } from "./utils.js";
/**
 * Event emitter callback for repair events
 */
export type RepairEventEmitter = (event: string, detail: unknown) => void;
/**
 * Configuration for SDS-R repair protocol
 */
export interface RepairConfig {
    /** Minimum wait time before requesting repair (milliseconds) */
    tMin?: number;
    /** Maximum wait time for repair window (milliseconds) */
    tMax?: number;
    /** Number of response groups for load distribution */
    numResponseGroups?: number;
    /** Maximum buffer size for repair requests */
    bufferSize?: number;
}
/**
 * Default configuration values based on spec recommendations
 */
export declare const DEFAULT_REPAIR_CONFIG: Required<RepairConfig>;
/**
 * Manager for SDS-R repair protocol
 * Handles repair request/response timing and coordination
 */
export declare class RepairManager {
    private readonly participantId;
    private readonly config;
    private readonly outgoingBuffer;
    private readonly incomingBuffer;
    private readonly eventEmitter?;
    constructor(participantId: ParticipantId, config?: RepairConfig, eventEmitter?: RepairEventEmitter);
    /**
     * Calculate T_req - when to request repair for a missing message
     * Per spec: T_req = current_time + hash(participant_id, message_id) % (T_max - T_min) + T_min
     */
    calculateTReq(messageId: MessageId, currentTime?: number): number;
    /**
     * Calculate T_resp - when to respond with a repair
     * Per spec: T_resp = current_time + (distance * hash(message_id)) % T_max
     * where distance = participant_id XOR sender_id
     */
    calculateTResp(senderId: ParticipantId, messageId: MessageId, currentTime?: number): number;
    /**
     * Determine if this participant is in the response group for a message
     * Per spec: (hash(participant_id, message_id) % num_response_groups) ==
     *           (hash(sender_id, message_id) % num_response_groups)
     */
    isInResponseGroup(senderId: ParticipantId, messageId: MessageId): boolean;
    /**
     * Handle missing dependencies by adding them to outgoing repair buffer
     * Called when causal dependencies are detected as missing
     */
    markDependenciesMissing(missingEntries: HistoryEntry[], currentTime?: number): void;
    /**
     * Handle receipt of a message - remove from repair buffers
     * Called when a message is successfully received
     */
    markMessageReceived(messageId: MessageId): void;
    /**
     * Get repair requests that are eligible to be sent
     * Returns up to maxRequests entries where T_req <= currentTime
     */
    getRepairRequests(maxRequests?: number, currentTime?: number): HistoryEntry[];
    /**
     * Process incoming repair requests from other participants
     * Adds to incoming buffer if we can fulfill and are in response group
     */
    processIncomingRepairRequests(requests: HistoryEntry[], localHistory: ILocalHistory, currentTime?: number): void;
    /**
     * Sweep outgoing buffer for repairs that should be requested
     * Returns entries where T_req <= currentTime
     */
    sweepOutgoingBuffer(maxRequests?: number, currentTime?: number): HistoryEntry[];
    /**
     * Sweep incoming buffer for repairs ready to be sent
     * Returns messages that should be rebroadcast
     */
    sweepIncomingBuffer(localHistory: ILocalHistory, currentTime?: number): Message[];
    /**
     * Clear all buffers
     */
    clear(): void;
    /**
     * Update number of response groups (e.g., when participants change)
     */
    updateResponseGroups(numParticipants: number): void;
}
