import { Logger } from "@waku/utils";
const log = new Logger("sds:repair:buffers");
/**
 * Buffer for outgoing repair requests (messages we need)
 * Maintains a sorted array by T_req for efficient retrieval of eligible entries
 */
export class OutgoingRepairBuffer {
    // Sorted array by T_req (ascending - earliest first)
    items = [];
    maxSize;
    constructor(maxSize = 1000) {
        this.maxSize = maxSize;
    }
    /**
     * Add a missing message to the outgoing repair request buffer
     * If message already exists, it is not updated (keeps original T_req)
     * @returns true if the entry was added, false if it already existed
     */
    add(entry, tReq) {
        const messageId = entry.messageId;
        // Check if already exists - do NOT update T_req per spec
        if (this.has(messageId)) {
            log.info(`Message ${messageId} already in outgoing buffer, keeping original T_req`);
            return false;
        }
        // Check buffer size limit
        if (this.items.length >= this.maxSize) {
            // Evict furthest T_req entry (last in sorted array) to preserve repairs that need to be sent the soonest
            const evicted = this.items.pop();
            log.warn(`Buffer full, evicted furthest entry ${evicted.entry.messageId} with T_req ${evicted.tReq}`);
        }
        // Add new entry and re-sort
        const newEntry = { entry, tReq, requested: false };
        const combined = [...this.items, newEntry];
        // Sort by T_req (ascending)
        combined.sort((a, b) => a.tReq - b.tReq);
        this.items = combined;
        log.info(`Added ${messageId} to outgoing buffer with T_req: ${tReq}`);
        return true;
    }
    /**
     * Remove a message from the buffer (e.g., when received)
     */
    remove(messageId) {
        this.items = this.items.filter((item) => item.entry.messageId !== messageId);
    }
    /**
     * Get eligible repair requests (where T_req <= currentTime)
     * Returns up to maxRequests entries from the front of the sorted array
     * Marks returned entries as requested but keeps them in buffer until received
     */
    getEligible(currentTime = Date.now(), maxRequests = 3) {
        const eligible = [];
        // Iterate from front of sorted array (earliest T_req first)
        for (const item of this.items) {
            // Since array is sorted, once we hit an item with tReq > currentTime,
            // all remaining items also have tReq > currentTime
            if (item.tReq > currentTime) {
                break;
            }
            // Only return items that haven't been requested yet
            if (!item.requested && eligible.length < maxRequests) {
                eligible.push(item.entry);
                // Mark as requested so we don't request it again
                item.requested = true;
                log.info(`Repair request for ${item.entry.messageId} is eligible and marked as requested`);
            }
            // If we've found enough eligible items, exit early
            if (eligible.length >= maxRequests) {
                break;
            }
        }
        return eligible;
    }
    /**
     * Check if a message is in the buffer
     */
    has(messageId) {
        return this.items.some((item) => item.entry.messageId === messageId);
    }
    /**
     * Get the current buffer size
     */
    get size() {
        return this.items.length;
    }
    /**
     * Clear all entries
     */
    clear() {
        this.items = [];
    }
    /**
     * Get all entries (for testing/debugging)
     */
    getAll() {
        return this.items.map((item) => item.entry);
    }
    /**
     * Get items array directly (for testing)
     */
    getItems() {
        return [...this.items];
    }
}
/**
 * Buffer for incoming repair requests (repairs we need to send)
 * Maintains a sorted array by T_resp for efficient retrieval of ready entries
 */
export class IncomingRepairBuffer {
    // Sorted array by T_resp (ascending - earliest first)
    items = [];
    maxSize;
    constructor(maxSize = 1000) {
        this.maxSize = maxSize;
    }
    /**
     * Add a repair request that we can fulfill
     * If message already exists, it is ignored (not updated)
     * @returns true if the entry was added, false if it already existed
     */
    add(entry, tResp) {
        const messageId = entry.messageId;
        // Check if already exists - ignore per spec
        if (this.has(messageId)) {
            log.info(`Message ${messageId} already in incoming buffer, ignoring`);
            return false;
        }
        // Check buffer size limit
        if (this.items.length >= this.maxSize) {
            // Evict furthest T_resp entry (last in sorted array)
            const evicted = this.items.pop();
            log.warn(`Buffer full, evicted furthest entry ${evicted.entry.messageId} with T_resp ${evicted.tResp}`);
        }
        // Add new entry and re-sort
        const newEntry = { entry, tResp };
        const combined = [...this.items, newEntry];
        // Sort by T_resp (ascending)
        combined.sort((a, b) => a.tResp - b.tResp);
        this.items = combined;
        log.info(`Added ${messageId} to incoming buffer with T_resp: ${tResp}`);
        return true;
    }
    /**
     * Remove a message from the buffer
     */
    remove(messageId) {
        this.items = this.items.filter((item) => item.entry.messageId !== messageId);
    }
    /**
     * Get repairs ready to be sent (where T_resp <= currentTime)
     * Removes and returns ready entries
     */
    getReady(currentTime) {
        // Find cutoff point - first item with tResp > currentTime
        // Since array is sorted, all items before this are ready
        let cutoff = 0;
        for (let i = 0; i < this.items.length; i++) {
            if (this.items[i].tResp > currentTime) {
                cutoff = i;
                break;
            }
            // If we reach the end, all items are ready
            cutoff = i + 1;
        }
        // Extract ready items and log them
        const ready = this.items.slice(0, cutoff).map((item) => {
            log.info(`Repair for ${item.entry.messageId} is ready to be sent`);
            return item.entry;
        });
        // Keep only items after cutoff
        this.items = this.items.slice(cutoff);
        return ready;
    }
    /**
     * Check if a message is in the buffer
     */
    has(messageId) {
        return this.items.some((item) => item.entry.messageId === messageId);
    }
    /**
     * Get the current buffer size
     */
    get size() {
        return this.items.length;
    }
    /**
     * Clear all entries
     */
    clear() {
        this.items = [];
    }
    /**
     * Get all entries (for testing/debugging)
     */
    getAll() {
        return this.items.map((item) => item.entry);
    }
    /**
     * Get items array directly (for testing)
     */
    getItems() {
        return [...this.items];
    }
}
//# sourceMappingURL=buffers.js.map