const isValidStoredPeer = (peer) => {
    return (!!peer &&
        typeof peer === "object" &&
        "id" in peer &&
        typeof peer.id === "string" &&
        "multiaddrs" in peer &&
        Array.isArray(peer.multiaddrs));
};
/**
 * A noop cache that will be used in environments where localStorage is not available.
 */
class NoopCache {
    get() {
        return [];
    }
    set(_value) {
        return;
    }
    remove() {
        return;
    }
}
/**
 * A cache that uses localStorage to store peer information.
 */
class LocalStorageCache {
    get() {
        try {
            const cachedPeers = localStorage.getItem("waku:peers");
            const peers = cachedPeers ? JSON.parse(cachedPeers) : [];
            return peers.filter(isValidStoredPeer);
        }
        catch (e) {
            return [];
        }
    }
    set(_value) {
        try {
            localStorage.setItem("waku:peers", JSON.stringify(_value));
        }
        catch (e) {
            // ignore
        }
    }
    remove() {
        try {
            localStorage.removeItem("waku:peers");
        }
        catch (e) {
            // ignore
        }
    }
}
export const defaultCache = () => {
    try {
        if (typeof localStorage !== "undefined") {
            return new LocalStorageCache();
        }
    }
    catch (_e) {
        // ignore
    }
    return new NoopCache();
};
//# sourceMappingURL=utils.js.map