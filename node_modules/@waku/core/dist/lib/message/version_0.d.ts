import type { EncoderOptions, IDecodedMessage, IDecoder, IEncoder, IMessage, IMetaSetter, IProtoMessage, IRateLimitProof, IRoutingInfo, PubsubTopic } from "@waku/interfaces";
import { proto_message as proto } from "@waku/proto";
export declare const Version = 0;
export { proto };
export declare class DecodedMessage implements IDecodedMessage {
    pubsubTopic: string;
    private proto;
    private _hash;
    private _hashStr;
    constructor(pubsubTopic: string, proto: proto.WakuMessage);
    get ephemeral(): boolean;
    get payload(): Uint8Array;
    get contentTopic(): string;
    get hash(): Uint8Array;
    get hashStr(): string;
    get timestamp(): Date | undefined;
    get meta(): Uint8Array | undefined;
    get version(): number;
    get rateLimitProof(): IRateLimitProof | undefined;
}
export declare class Encoder implements IEncoder {
    contentTopic: string;
    ephemeral: boolean;
    routingInfo: IRoutingInfo;
    metaSetter?: IMetaSetter | undefined;
    constructor(contentTopic: string, ephemeral: boolean | undefined, routingInfo: IRoutingInfo, metaSetter?: IMetaSetter | undefined);
    get pubsubTopic(): PubsubTopic;
    toWire(message: IMessage): Promise<Uint8Array>;
    toProtoObj(message: IMessage): Promise<IProtoMessage>;
}
/**
 * Creates an encoder that encode messages without Waku level encryption or signature.
 *
 * An encoder is used to encode messages in the [14/WAKU2-MESSAGE](https://rfc.vac.dev/spec/14/)
 * format to be sent over the Waku network. The resulting encoder can then be
 * pass to { @link @waku/interfaces!ISender.send } to automatically encode outgoing
 * messages.
 *
 * Note that a routing info may be tied to a given content topic, this is not checked by the encoder.
 */
export declare function createEncoder({ contentTopic, routingInfo, ephemeral, metaSetter }: EncoderOptions): Encoder;
export declare class Decoder implements IDecoder<IDecodedMessage> {
    contentTopic: string;
    routingInfo: IRoutingInfo;
    constructor(contentTopic: string, routingInfo: IRoutingInfo);
    get pubsubTopic(): PubsubTopic;
    fromWireToProtoObj(bytes: Uint8Array): Promise<IProtoMessage | undefined>;
    fromProtoObj(pubsubTopic: string, proto: IProtoMessage): Promise<IDecodedMessage | undefined>;
}
/**
 * Creates a decoder that decode messages without Waku level encryption.
 *
 * A decoder is used to decode messages from the [14/WAKU2-MESSAGE](https://rfc.vac.dev/spec/14/)
 * format when received from the Waku network. The resulting decoder can then be
 * pass to { @link @waku/interfaces!IReceiver.subscribe } to automatically decode incoming
 * messages.
 *
 * @param contentTopic The resulting decoder will only decode messages with this content topic.
 * @param routingInfo Routing information such as cluster id and shard id on which the message is expected to be received.
 *
 * Note that a routing info may be tied to a given content topic, this is not checked by the encoder.
 */
export declare function createDecoder(contentTopic: string, routingInfo: IRoutingInfo): Decoder;
