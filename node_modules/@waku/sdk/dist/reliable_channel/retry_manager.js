export class RetryManager {
    retryIntervalMs;
    maxRetryNumber;
    timeouts;
    constructor(
    // TODO: back-off strategy
    retryIntervalMs, maxRetryNumber) {
        this.retryIntervalMs = retryIntervalMs;
        this.maxRetryNumber = maxRetryNumber;
        this.timeouts = new Map();
        if (!retryIntervalMs ||
            retryIntervalMs <= 0 ||
            !maxRetryNumber ||
            maxRetryNumber <= 0) {
            throw Error(`Invalid retryIntervalMs ${retryIntervalMs} or maxRetryNumber ${maxRetryNumber} values`);
        }
    }
    stopRetries(id) {
        const timeout = this.timeouts.get(id);
        if (timeout) {
            clearTimeout(timeout);
        }
    }
    startRetries(id, retry) {
        this.retry(id, retry, 0);
    }
    retry(id, retry, attemptNumber) {
        clearTimeout(this.timeouts.get(id));
        if (attemptNumber < this.maxRetryNumber) {
            const interval = setTimeout(() => {
                void retry();
                // Register for next retry until we are told to stop;
                this.retry(id, retry, ++attemptNumber);
            }, this.retryIntervalMs);
            this.timeouts.set(id, interval);
        }
    }
}
//# sourceMappingURL=retry_manager.js.map