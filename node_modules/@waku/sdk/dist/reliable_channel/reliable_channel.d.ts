import { TypedEventEmitter } from "@libp2p/interface";
import { type IDecodedMessage, type IDecoder, type IEncoder, type IWaku } from "@waku/interfaces";
import { type ChannelId, MessageChannel, type MessageChannelOptions, type SenderId } from "@waku/sds";
import { ReliableChannelEvents } from "./events.js";
export type ReliableChannelOptions = MessageChannelOptions & {
    /**
     * The minimum interval between 2 sync messages in the channel.
     *
     * Meaning, how frequently we want messages in the channel, noting that the
     * responsibility of sending a sync messages is shared between participants
     * of the channel.
     *
     * `0` means no sync messages will be sent.
     *
     * @default 30,000 (30 seconds) [[DEFAULT_SYNC_MIN_INTERVAL_MS]]
     */
    syncMinIntervalMs?: number;
    /**
     * How long to wait before re-sending a message that as not acknowledged.
     *
     * @default 60,000 (60 seconds) [[DEFAULT_RETRY_INTERVAL_MS]]
     */
    retryIntervalMs?: number;
    /**
     * How many times do we attempt resending messages that were not acknowledged.
     *
     * @default 10 [[DEFAULT_MAX_RETRY_ATTEMPTS]]
     */
    maxRetryAttempts?: number;
    /**
     * How often store queries are done to retrieve missing messages.
     *
     * @default 10,000 (10 seconds)
     */
    retrieveFrequencyMs?: number;
    /**
     * How often SDS message channel incoming buffer is swept.
     *
     * @default 5000 (every 5 seconds)
     */
    sweepInBufIntervalMs?: number;
    /**
     * Whether to automatically do a store query after connection to store nodes.
     *
     * @default true
     */
    queryOnConnect?: boolean;
    /**
     * Whether to auto start the message channel
     *
     * @default true
     */
    autoStart?: boolean;
    /** The minimum elapse time between calling the underlying channel process
     * task for incoming messages. This is to avoid overload when processing
     * a lot of messages.
     *
     * @default 1000 (1 second)
     */
    processTaskMinElapseMs?: number;
};
/**
 * An easy-to-use reliable channel that ensures all participants to the channel have eventual message consistency.
 *
 * Use events to track:
 * - if your outgoing messages are sent, acknowledged or error out
 * - for new incoming messages
 * @emits [[ReliableChannelEvents]]
 *
 */
export declare class ReliableChannel<T extends IDecodedMessage> extends TypedEventEmitter<ReliableChannelEvents> {
    node: IWaku;
    messageChannel: MessageChannel;
    private encoder;
    private decoder;
    private readonly _send;
    private readonly _subscribe;
    private readonly _retrieve?;
    private readonly syncMinIntervalMs;
    private syncTimeout;
    private sweepInBufInterval;
    private readonly sweepInBufIntervalMs;
    private processTaskTimeout;
    private readonly retryManager;
    private readonly missingMessageRetriever?;
    private readonly queryOnConnect?;
    private readonly processTaskMinElapseMs;
    private _started;
    private constructor();
    get isStarted(): boolean;
    /**
     * Used to identify messages, pass the payload of a message you are
     * about to send to track the events for this message.
     * This is pre-sds wrapping
     * @param messagePayload
     */
    static getMessageId(messagePayload: Uint8Array): string;
    /**
     * Create a new message channels. Message channels enables end-to-end
     * reliability by ensuring that all messages in the channel are received
     * by other users, and retrieved by this local node.
     *
     * emits events about outgoing messages, see [[`ReliableChannel`]] docs.
     *
     * Note that all participants in a message channels need to get the messages
     * from the channel. Meaning:
     * - all participants must be able to decrypt the messages
     * - all participants must be subscribing to content topic(s) where the messages are sent
     *
     * @param node The waku node to use to send and receive messages
     * @param channelId An id for the channel, all participants of the channel should use the same id
     * @param senderId An id for the sender, to ensure acknowledgements are only valid if originating from someone else; best if persisted between sessions
     * @param encoder A channel operates within a singular encryption layer, hence the same encoder is needed for all messages
     * @param decoder A channel operates within a singular encryption layer, hence the same decoder is needed for all messages
     * @param options
     */
    static create<T extends IDecodedMessage>(node: IWaku, channelId: ChannelId, senderId: SenderId, encoder: IEncoder, decoder: IDecoder<T>, options?: ReliableChannelOptions): Promise<ReliableChannel<T>>;
    /**
     * Sends a message in the channel, will attempt to re-send if not acknowledged
     * by other participants.
     *
     * @param messagePayload
     * @returns the message id
     */
    send(messagePayload: Uint8Array): string;
    private _wrapAndSend;
    private subscribe;
    /**
     * Don't forget to call `this.messageChannel.sweepIncomingBuffer();` once done.
     * @param msg
     * @private
     */
    private processIncomingMessage;
    private processIncomingMessages;
    private queueProcessTasks;
    start(): Promise<boolean>;
    stop(): void;
    private assertStarted;
    private startSweepIncomingBufferLoop;
    private stopSweepIncomingBufferLoop;
    private restartSync;
    private stopSync;
    private random;
    private safeSendEvent;
    private sendSyncMessage;
    private isChannelMessageWithCausalHistory;
    private setupEventListeners;
}
