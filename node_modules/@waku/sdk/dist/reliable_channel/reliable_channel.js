import { TypedEventEmitter } from "@libp2p/interface";
import { messageHash } from "@waku/core";
import { LightPushError } from "@waku/interfaces";
import { isContentMessage, MessageChannel, MessageChannelEvent, Message as SdsMessage } from "@waku/sds";
import { Logger } from "@waku/utils";
import { QueryOnConnect, QueryOnConnectEvent } from "../query_on_connect/index.js";
import { MissingMessageRetriever } from "./missing_message_retriever.js";
import { RetryManager } from "./retry_manager.js";
const log = new Logger("sdk:reliable-channel");
const DEFAULT_SYNC_MIN_INTERVAL_MS = 30 * 1000; // 30 seconds
const DEFAULT_RETRY_INTERVAL_MS = 30 * 1000; // 30 seconds
const DEFAULT_MAX_RETRY_ATTEMPTS = 10;
const DEFAULT_SWEEP_IN_BUF_INTERVAL_MS = 5 * 1000;
const DEFAULT_PROCESS_TASK_MIN_ELAPSE_MS = 1000;
const IRRECOVERABLE_SENDING_ERRORS = [
    LightPushError.ENCODE_FAILED,
    LightPushError.EMPTY_PAYLOAD,
    LightPushError.SIZE_TOO_BIG,
    LightPushError.RLN_PROOF_GENERATION
];
/**
 * An easy-to-use reliable channel that ensures all participants to the channel have eventual message consistency.
 *
 * Use events to track:
 * - if your outgoing messages are sent, acknowledged or error out
 * - for new incoming messages
 * @emits [[ReliableChannelEvents]]
 *
 */
export class ReliableChannel extends TypedEventEmitter {
    node;
    messageChannel;
    encoder;
    decoder;
    _send;
    _subscribe;
    _retrieve;
    syncMinIntervalMs;
    syncTimeout;
    sweepInBufInterval;
    sweepInBufIntervalMs;
    processTaskTimeout;
    retryManager;
    missingMessageRetriever;
    queryOnConnect;
    processTaskMinElapseMs;
    _started;
    constructor(node, messageChannel, encoder, decoder, options) {
        super();
        this.node = node;
        this.messageChannel = messageChannel;
        this.encoder = encoder;
        this.decoder = decoder;
        if (node.lightPush) {
            this._send = node.lightPush.send.bind(node.lightPush);
        }
        else if (node.relay) {
            this._send = node.relay.send.bind(node.relay);
        }
        else {
            throw "No protocol available to send messages";
        }
        if (node.filter) {
            this._subscribe = node.filter.subscribe.bind(node.filter);
        }
        else if (node.relay) {
            // TODO: Why do relay and filter have different interfaces?
            //  this._subscribe = node.relay.subscribeWithUnsubscribe;
            throw "Not implemented";
        }
        else {
            throw "No protocol available to receive messages";
        }
        if (node.store) {
            this._retrieve = node.store.queryGenerator.bind(node.store);
            const peerManagerEvents = node?.peerManager?.events;
            if (peerManagerEvents !== undefined &&
                (options?.queryOnConnect ?? true)) {
                this.queryOnConnect = new QueryOnConnect([this.decoder], this.isChannelMessageWithCausalHistory.bind(this), peerManagerEvents, node.events, this._retrieve.bind(this));
            }
        }
        this.syncMinIntervalMs =
            options?.syncMinIntervalMs ?? DEFAULT_SYNC_MIN_INTERVAL_MS;
        this.sweepInBufIntervalMs =
            options?.sweepInBufIntervalMs ?? DEFAULT_SWEEP_IN_BUF_INTERVAL_MS;
        const retryIntervalMs = options?.retryIntervalMs ?? DEFAULT_RETRY_INTERVAL_MS;
        const maxRetryAttempts = options?.maxRetryAttempts ?? DEFAULT_MAX_RETRY_ATTEMPTS;
        if (retryIntervalMs && maxRetryAttempts) {
            // TODO: there is a lot to improve. e.g. not point retry to send if node is offline.
            this.retryManager = new RetryManager(retryIntervalMs, maxRetryAttempts);
        }
        this.processTaskMinElapseMs =
            options?.processTaskMinElapseMs ?? DEFAULT_PROCESS_TASK_MIN_ELAPSE_MS;
        if (this._retrieve) {
            this.missingMessageRetriever = new MissingMessageRetriever(this.decoder, options?.retrieveFrequencyMs, this._retrieve, async (msg) => {
                await this.processIncomingMessage(msg);
            });
        }
        this._started = false;
    }
    get isStarted() {
        return this._started;
    }
    /**
     * Used to identify messages, pass the payload of a message you are
     * about to send to track the events for this message.
     * This is pre-sds wrapping
     * @param messagePayload
     */
    static getMessageId(messagePayload) {
        return MessageChannel.getMessageId(messagePayload);
    }
    /**
     * Create a new message channels. Message channels enables end-to-end
     * reliability by ensuring that all messages in the channel are received
     * by other users, and retrieved by this local node.
     *
     * emits events about outgoing messages, see [[`ReliableChannel`]] docs.
     *
     * Note that all participants in a message channels need to get the messages
     * from the channel. Meaning:
     * - all participants must be able to decrypt the messages
     * - all participants must be subscribing to content topic(s) where the messages are sent
     *
     * @param node The waku node to use to send and receive messages
     * @param channelId An id for the channel, all participants of the channel should use the same id
     * @param senderId An id for the sender, to ensure acknowledgements are only valid if originating from someone else; best if persisted between sessions
     * @param encoder A channel operates within a singular encryption layer, hence the same encoder is needed for all messages
     * @param decoder A channel operates within a singular encryption layer, hence the same decoder is needed for all messages
     * @param options
     */
    static async create(node, channelId, senderId, encoder, decoder, options) {
        const sdsMessageChannel = new MessageChannel(channelId, senderId, options);
        const messageChannel = new ReliableChannel(node, sdsMessageChannel, encoder, decoder, options);
        const autoStart = options?.autoStart ?? true;
        if (autoStart) {
            await messageChannel.start();
        }
        return messageChannel;
    }
    /**
     * Sends a message in the channel, will attempt to re-send if not acknowledged
     * by other participants.
     *
     * @param messagePayload
     * @returns the message id
     */
    send(messagePayload) {
        const messageId = ReliableChannel.getMessageId(messagePayload);
        if (!this._started) {
            this.safeSendEvent("sending-message-irrecoverable-error", {
                detail: { messageId: messageId, error: "channel is not started" }
            });
        }
        const wrapAndSendBind = this._wrapAndSend.bind(this, messagePayload);
        this.retryManager?.startRetries(messageId, wrapAndSendBind);
        wrapAndSendBind();
        return messageId;
    }
    _wrapAndSend(messagePayload) {
        this.messageChannel.pushOutgoingMessage(messagePayload, async (sdsMessage) => {
            // Callback is called once message has added to the SDS outgoing queue
            // We start by trying to send the message now.
            // `payload` wrapped in SDS
            const sdsPayload = sdsMessage.encode();
            const wakuMessage = {
                payload: sdsPayload
            };
            const messageId = ReliableChannel.getMessageId(messagePayload);
            // TODO: should the encoder give me the message hash?
            // Encoding now to fail early, used later to get message hash
            const protoMessage = await this.encoder.toProtoObj(wakuMessage);
            if (!protoMessage) {
                this.safeSendEvent("sending-message-irrecoverable-error", {
                    detail: {
                        messageId: messageId,
                        error: "could not encode message"
                    }
                });
                return { success: false };
            }
            const retrievalHint = messageHash(this.encoder.pubsubTopic, protoMessage);
            this.safeSendEvent("sending-message", {
                detail: messageId
            });
            const sendRes = await this._send(this.encoder, wakuMessage);
            // If it's a recoverable failure, we will try again to send later
            // If not, then we should error to the user now
            for (const { error } of sendRes.failures) {
                if (IRRECOVERABLE_SENDING_ERRORS.includes(error)) {
                    // Not recoverable, best to return it
                    log.error("Irrecoverable error, cannot send message: ", error);
                    this.safeSendEvent("sending-message-irrecoverable-error", {
                        detail: {
                            messageId,
                            error
                        }
                    });
                    return { success: false, retrievalHint };
                }
            }
            return {
                success: true,
                retrievalHint
            };
        });
        // Process outgoing messages straight away
        this.messageChannel
            .processTasks()
            .then(() => {
            this.messageChannel.sweepOutgoingBuffer();
        })
            .catch((err) => {
            log.error("error encountered when processing sds tasks", err);
        });
    }
    async subscribe() {
        this.assertStarted();
        return this._subscribe(this.decoder, async (message) => {
            await this.processIncomingMessage(message);
        });
    }
    /**
     * Don't forget to call `this.messageChannel.sweepIncomingBuffer();` once done.
     * @param msg
     * @private
     */
    async processIncomingMessage(msg) {
        // New message arrives, we need to unwrap it first
        const sdsMessage = SdsMessage.decode(msg.payload);
        if (!sdsMessage) {
            log.error("could not SDS decode message", msg);
            return;
        }
        if (sdsMessage.channelId !== this.messageChannel.channelId) {
            log.warn("ignoring message with different channel id", sdsMessage.channelId);
            return;
        }
        const retrievalHint = msg.hash;
        log.info(`processing message ${sdsMessage.messageId}:${msg.hashStr}`);
        // SDS Message decoded, let's pass it to the channel so we can learn about
        // missing messages or the status of previous outgoing messages
        this.messageChannel.pushIncomingMessage(sdsMessage, retrievalHint);
        this.missingMessageRetriever?.removeMissingMessage(sdsMessage.messageId);
        if (sdsMessage.content && sdsMessage.content.length > 0) {
            // Now, process the message with callback
            // Overrides msg.payload with unwrapped payload
            // TODO: can we do better?
            const { payload: _p, ...allButPayload } = msg;
            const unwrappedMessage = Object.assign(allButPayload, {
                payload: sdsMessage.content,
                hash: msg.hash,
                hashStr: msg.hashStr,
                version: msg.version,
                contentTopic: msg.contentTopic,
                pubsubTopic: msg.pubsubTopic,
                timestamp: msg.timestamp,
                rateLimitProof: msg.rateLimitProof,
                ephemeral: msg.ephemeral,
                meta: msg.meta
            });
            this.safeSendEvent("message-received", {
                detail: unwrappedMessage
            });
        }
        this.queueProcessTasks();
    }
    async processIncomingMessages(messages) {
        for (const message of messages) {
            await this.processIncomingMessage(message);
        }
    }
    // TODO: For now we only queue process tasks for incoming messages
    // As this is where there is most volume
    queueProcessTasks() {
        // If one is already queued, then we can ignore it
        if (this.processTaskTimeout === undefined) {
            this.processTaskTimeout = setTimeout(() => {
                void this.messageChannel.processTasks().catch((err) => {
                    log.error("error encountered when processing sds tasks", err);
                });
                // Clear timeout once triggered
                clearTimeout(this.processTaskTimeout);
                this.processTaskTimeout = undefined;
            }, this.processTaskMinElapseMs); // we ensure that we don't call process tasks more than once per second
        }
    }
    async start() {
        if (this._started)
            return true;
        this._started = true;
        this.setupEventListeners();
        this.restartSync();
        this.startSweepIncomingBufferLoop();
        if (this._retrieve) {
            this.missingMessageRetriever?.start();
            this.queryOnConnect?.start();
        }
        return this.subscribe();
    }
    stop() {
        if (!this._started)
            return;
        this._started = false;
        this.stopSync();
        this.stopSweepIncomingBufferLoop();
        this.missingMessageRetriever?.stop();
        this.queryOnConnect?.stop();
        // TODO unsubscribe
        // TODO unsetMessageListeners
    }
    assertStarted() {
        if (!this._started)
            throw Error("Message Channel must be started");
    }
    startSweepIncomingBufferLoop() {
        this.stopSweepIncomingBufferLoop();
        this.sweepInBufInterval = setInterval(() => {
            log.info("sweep incoming buffer");
            this.messageChannel.sweepIncomingBuffer();
        }, this.sweepInBufIntervalMs);
    }
    stopSweepIncomingBufferLoop() {
        if (this.sweepInBufInterval)
            clearInterval(this.sweepInBufInterval);
    }
    restartSync(multiplier = 1) {
        if (this.syncTimeout) {
            clearTimeout(this.syncTimeout);
        }
        if (this.syncMinIntervalMs) {
            const timeoutMs = this.random() * this.syncMinIntervalMs * multiplier;
            this.syncTimeout = setTimeout(() => {
                void this.sendSyncMessage();
                // Always restart a sync, no matter whether the message was sent.
                // Set a multiplier so we wait a bit longer to not hog the conversation
                void this.restartSync(2);
            }, timeoutMs);
        }
    }
    stopSync() {
        if (this.syncTimeout) {
            clearTimeout(this.syncTimeout);
        }
    }
    // Used to enable overriding when testing
    random() {
        return Math.random();
    }
    safeSendEvent(event, eventInit) {
        try {
            this.dispatchEvent(new CustomEvent(event, eventInit));
        }
        catch (error) {
            log.error(`Failed to dispatch event ${event}:`, error);
        }
    }
    async sendSyncMessage() {
        this.assertStarted();
        await this.messageChannel.pushOutgoingSyncMessage(async (syncMessage) => {
            // Callback is called once message has added to the SDS outgoing queue
            // We start by trying to send the message now.
            // `payload` wrapped in SDS
            const sdsPayload = syncMessage.encode();
            const wakuMessage = {
                payload: sdsPayload
            };
            const sendRes = await this._send(this.encoder, wakuMessage);
            if (sendRes.failures.length > 0) {
                log.error("Error sending sync message: ", sendRes);
                return false;
            }
            return true;
        });
        // Process outgoing messages straight away
        // TODO: review and optimize
        await this.messageChannel.processTasks();
        this.messageChannel.sweepOutgoingBuffer();
    }
    isChannelMessageWithCausalHistory(msg) {
        // TODO: we do end-up decoding messages twice as this is used to stop store queries.
        const sdsMessage = SdsMessage.decode(msg.payload);
        if (!sdsMessage) {
            return false;
        }
        if (sdsMessage.channelId !== this.messageChannel.channelId) {
            return false;
        }
        return sdsMessage.causalHistory && sdsMessage.causalHistory.length > 0;
    }
    setupEventListeners() {
        this.messageChannel.addEventListener(MessageChannelEvent.OutMessageSent, (event) => {
            if (event.detail.content) {
                const messageId = ReliableChannel.getMessageId(event.detail.content);
                this.safeSendEvent("message-sent", {
                    detail: messageId
                });
            }
        });
        this.messageChannel.addEventListener(MessageChannelEvent.OutMessageAcknowledged, (event) => {
            if (event.detail) {
                this.safeSendEvent("message-acknowledged", {
                    detail: event.detail
                });
                // Stopping retries
                this.retryManager?.stopRetries(event.detail);
            }
        });
        this.messageChannel.addEventListener(MessageChannelEvent.OutMessagePossiblyAcknowledged, (event) => {
            if (event.detail) {
                this.safeSendEvent("message-possibly-acknowledged", {
                    detail: {
                        messageId: event.detail.messageId,
                        possibleAckCount: event.detail.count
                    }
                });
            }
        });
        this.messageChannel.addEventListener(MessageChannelEvent.InSyncReceived, (_event) => {
            // restart the timeout when a sync message has been received
            this.restartSync();
        });
        this.messageChannel.addEventListener(MessageChannelEvent.InMessageReceived, (event) => {
            // restart the timeout when a content message has been received
            if (isContentMessage(event.detail)) {
                // send a sync message faster to ack someone's else
                this.restartSync(0.5);
            }
        });
        this.messageChannel.addEventListener(MessageChannelEvent.OutMessageSent, (event) => {
            // restart the timeout when a content message has been sent
            if (isContentMessage(event.detail)) {
                this.restartSync();
            }
        });
        this.messageChannel.addEventListener(MessageChannelEvent.InMessageMissing, (event) => {
            for (const { messageId, retrievalHint } of event.detail) {
                if (retrievalHint && this.missingMessageRetriever) {
                    this.missingMessageRetriever.addMissingMessage(messageId, retrievalHint);
                }
            }
        });
        if (this.queryOnConnect) {
            this.queryOnConnect.addEventListener(QueryOnConnectEvent.MessagesRetrieved, (event) => {
                void this.processIncomingMessages(event.detail);
            });
        }
    }
}
//# sourceMappingURL=reliable_channel.js.map