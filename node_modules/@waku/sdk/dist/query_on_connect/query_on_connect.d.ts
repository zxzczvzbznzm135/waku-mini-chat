import { TypedEventEmitter } from "@libp2p/interface";
import { type IDecodedMessage, type IDecoder, IWakuEventEmitter, QueryRequestParams } from "@waku/interfaces";
import { IPeerManagerEvents } from "../peer_manager/peer_manager.js";
export declare const DEFAULT_FORCE_QUERY_THRESHOLD_MS: number;
export declare const MAX_TIME_RANGE_QUERY_MS: number;
export interface QueryOnConnectOptions {
    /**
     * Elapsed time since the last successful query, after which we proceed with
     * a store query, on a connection event, no matter the conditions.
     * @default [[DEFAULT_FORCE_QUERY_THRESHOLD_MS]]
     */
    forceQueryThresholdMs?: number;
}
export declare enum QueryOnConnectEvent {
    /**
     * A message has been retrieved.
     */
    MessagesRetrieved = "messages:retrieved"
}
export type QueryOnConnectEvents = {
    [QueryOnConnectEvent.MessagesRetrieved]: CustomEvent<IDecodedMessage[]>;
};
/**
 * Proceed with time-range store queries after connection to a store node.
 * Partial implementation of [Waku P2P Reliability](https://github.com/waku-org/specs/blob/master/standards/application/p2p-reliability.md)
 *
 * @emits <T extends IDecodedMessage> message retrieved on "messages"
 */
export declare class QueryOnConnect<T extends IDecodedMessage> extends TypedEventEmitter<QueryOnConnectEvents> {
    decoders: IDecoder<T>[];
    stopIfTrue: (msg: T) => boolean;
    private readonly peerManagerEventEmitter;
    private readonly wakuEventEmitter;
    private readonly _queryGenerator;
    private lastSuccessfulQuery;
    private lastTimeOffline;
    private readonly forceQueryThresholdMs;
    constructor(decoders: IDecoder<T>[], stopIfTrue: (msg: T) => boolean, peerManagerEventEmitter: TypedEventEmitter<IPeerManagerEvents>, wakuEventEmitter: IWakuEventEmitter, _queryGenerator: <T extends IDecodedMessage>(decoders: IDecoder<T>[], options?: Partial<QueryRequestParams>) => AsyncGenerator<Promise<T | undefined>[]>, options?: QueryOnConnectOptions);
    start(): void;
    stop(): void;
    /**
     * Mainly exposed for testing. Only use if you know what you are doing.
     *
     * Proceed with a query if:
     * - No successful query has happened
     * - OR, We detected that we were offline since last successful query
     * - OR, It bas been more than `forceQueryThresholdMs` than last query
     *
     * [[QueryOnConnect]] handles the listening to event to call this function.
     *
     * @param peerId A store peer id. Must be passed as we expect this to be trigger
     * upon a detected connection to a store peer.
     */
    private maybeQuery;
    private query;
    private queryTimeRange;
    private dispatchMessages;
    private setupEventListeners;
    private unsetEventListeners;
    private updateLastOfflineDate;
}
export declare function calculateTimeRange(now: number, lastSuccessfulQuery: number, maxTimeRangeQueryMs: number): {
    timeStart: Date;
    timeEnd: Date;
};
