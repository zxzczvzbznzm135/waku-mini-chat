import { TypedEventEmitter } from "@libp2p/interface";
import { HealthStatus, WakuEvent } from "@waku/interfaces";
import { Logger } from "@waku/utils";
import { PeerManagerEventNames } from "../peer_manager/peer_manager.js";
const log = new Logger("sdk:query-on-connect");
export const DEFAULT_FORCE_QUERY_THRESHOLD_MS = 5 * 60 * 1000; // 5 minutes
export const MAX_TIME_RANGE_QUERY_MS = 30 * 24 * 60 * 60 * 1000; // 30 days (queries are split)
export var QueryOnConnectEvent;
(function (QueryOnConnectEvent) {
    /**
     * A message has been retrieved.
     */
    QueryOnConnectEvent["MessagesRetrieved"] = "messages:retrieved";
})(QueryOnConnectEvent || (QueryOnConnectEvent = {}));
/**
 * Proceed with time-range store queries after connection to a store node.
 * Partial implementation of [Waku P2P Reliability](https://github.com/waku-org/specs/blob/master/standards/application/p2p-reliability.md)
 *
 * @emits <T extends IDecodedMessage> message retrieved on "messages"
 */
export class QueryOnConnect extends TypedEventEmitter {
    decoders;
    stopIfTrue;
    peerManagerEventEmitter;
    wakuEventEmitter;
    _queryGenerator;
    lastSuccessfulQuery;
    lastTimeOffline;
    forceQueryThresholdMs;
    constructor(decoders, stopIfTrue, peerManagerEventEmitter, wakuEventEmitter, _queryGenerator, options) {
        super();
        this.decoders = decoders;
        this.stopIfTrue = stopIfTrue;
        this.peerManagerEventEmitter = peerManagerEventEmitter;
        this.wakuEventEmitter = wakuEventEmitter;
        this._queryGenerator = _queryGenerator;
        this.lastSuccessfulQuery = 0;
        this.lastTimeOffline = 0;
        this.forceQueryThresholdMs =
            options?.forceQueryThresholdMs ?? DEFAULT_FORCE_QUERY_THRESHOLD_MS;
    }
    start() {
        log.info("starting query-on-connect service");
        this.setupEventListeners();
    }
    stop() {
        this.unsetEventListeners();
    }
    /**
     * Mainly exposed for testing. Only use if you know what you are doing.
     *
     * Proceed with a query if:
     * - No successful query has happened
     * - OR, We detected that we were offline since last successful query
     * - OR, It bas been more than `forceQueryThresholdMs` than last query
     *
     * [[QueryOnConnect]] handles the listening to event to call this function.
     *
     * @param peerId A store peer id. Must be passed as we expect this to be trigger
     * upon a detected connection to a store peer.
     */
    async maybeQuery(peerId) {
        const timeSinceLastQuery = Date.now() - this.lastSuccessfulQuery;
        log.info(`maybe do store query to ${peerId.toString()}`, this.lastSuccessfulQuery, this.lastTimeOffline, timeSinceLastQuery, this.forceQueryThresholdMs);
        if (this.lastSuccessfulQuery === 0 ||
            this.lastTimeOffline > this.lastSuccessfulQuery ||
            timeSinceLastQuery > this.forceQueryThresholdMs) {
            await this.query(peerId);
        }
        else {
            log.info(`no querying`);
        }
    }
    async query(peerId) {
        log.info(`perform store query to ${peerId.toString()}`);
        const { timeStart, timeEnd } = this.queryTimeRange();
        try {
            for await (const page of this._queryGenerator(this.decoders, {
                timeStart,
                timeEnd,
                peerId
            })) {
                // Await for decoding
                const messages = (await Promise.all(page)).filter((m) => m !== undefined);
                const stop = messages.some((msg) => this.stopIfTrue(msg));
                // Bundle the messages to help batch process by sds
                this.dispatchMessages(messages);
                if (stop) {
                    break;
                }
            }
            // Didn't throw, so it didn't fail
            this.lastSuccessfulQuery = Date.now();
        }
        catch (err) {
            log.warn(`store query to ${peerId.toString()} failed`, err);
        }
    }
    queryTimeRange() {
        return calculateTimeRange(Date.now(), this.lastSuccessfulQuery, MAX_TIME_RANGE_QUERY_MS);
    }
    dispatchMessages(messages) {
        log.info("dispatching messages", messages.map((m) => m.hashStr));
        this.dispatchEvent(new CustomEvent(QueryOnConnectEvent.MessagesRetrieved, {
            detail: messages
        }));
    }
    setupEventListeners() {
        this.peerManagerEventEmitter.addEventListener(PeerManagerEventNames.StoreConnect, (event) => void this.maybeQuery(event.detail).catch((err) => log.error("query-on-connect error", err)));
        this.wakuEventEmitter.addEventListener(WakuEvent.Health, this.updateLastOfflineDate.bind(this));
    }
    unsetEventListeners() {
        this.peerManagerEventEmitter.removeEventListener(PeerManagerEventNames.StoreConnect, (event) => void this.maybeQuery(event.detail).catch((err) => log.error("query-on-connect error", err)));
        this.wakuEventEmitter.removeEventListener(WakuEvent.Health, this.updateLastOfflineDate.bind(this));
    }
    updateLastOfflineDate(event) {
        if (event.detail === HealthStatus.Unhealthy) {
            this.lastTimeOffline = Date.now();
        }
    }
}
export function calculateTimeRange(now, lastSuccessfulQuery, maxTimeRangeQueryMs) {
    const timeRange = Math.min(now - lastSuccessfulQuery, maxTimeRangeQueryMs);
    const timeStart = new Date(now - timeRange);
    const timeEnd = new Date(now);
    return { timeStart, timeEnd };
}
//# sourceMappingURL=query_on_connect.js.map