{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * Similar to [AbortSignal.any](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/any_static)\n * except the returned promise has a `.clear` method that removes all event\n * listeners added to passed signals preventing memory leaks.\n *\n * At the time of writing at least, `AbortSignal.any` leaks memory in Node.js\n * and Deno environments:\n *\n * - https://github.com/nodejs/node/issues/54614\n * - https://github.com/denoland/deno/issues/24842\n *\n * @example\n *\n * ```js\n * import { anySignal } from 'any-signal'\n *\n * const userController = new AbortController()\n *\n * // Abort after 1 second\n * const timeoutSignal = AbortSignal.timeout(1000)\n *\n * const combinedSignal = anySignal([userController.signal, timeoutSignal])\n * combinedSignal.addEventListener('abort', () => console.log('Abort!'))\n *\n * try {\n *   // The user or the timeout can now abort the action\n *   await performSomeAction({ signal: combinedSignal })\n * } finally {\n *   // Clear will clean up internal event handlers\n *   combinedSignal.clear()\n * }\n * ```\n */\n\nexport interface ClearableSignal extends AbortSignal {\n  clear(): void\n}\n\n/**\n * Takes an array of AbortSignals and returns a single signal.\n * If any signals are aborted, the returned signal will be aborted.\n */\nexport function anySignal (signals: Array<AbortSignal | undefined | null>): ClearableSignal {\n  const controller = new globalThis.AbortController()\n\n  function onAbort (): void {\n    const reason = signals\n      .filter(s => s?.aborted === true)\n      .map(s => s?.reason)\n      .pop()\n\n    controller.abort(reason)\n\n    for (const signal of signals) {\n      if (signal?.removeEventListener != null) {\n        signal.removeEventListener('abort', onAbort)\n      }\n    }\n  }\n\n  for (const signal of signals) {\n    if (signal?.aborted === true) {\n      onAbort()\n      break\n    }\n\n    if (signal?.addEventListener != null) {\n      signal.addEventListener('abort', onAbort)\n    }\n  }\n\n  function clear (): void {\n    for (const signal of signals) {\n      if (signal?.removeEventListener != null) {\n        signal.removeEventListener('abort', onAbort)\n      }\n    }\n  }\n\n  const signal = controller.signal as ClearableSignal\n  signal.clear = clear\n\n  return signal\n}\n"],
  "mappings": ";6bAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,eAAAE,IA4CM,SAAUA,EAAWC,EAA8C,CACvE,IAAMC,EAAa,IAAI,WAAW,gBAElC,SAASC,GAAO,CACd,IAAMC,EAASH,EACZ,OAAOI,GAAKA,GAAG,UAAY,EAAI,EAC/B,IAAIA,GAAKA,GAAG,MAAM,EAClB,IAAG,EAENH,EAAW,MAAME,CAAM,EAEvB,QAAWE,KAAUL,EACfK,GAAQ,qBAAuB,MACjCA,EAAO,oBAAoB,QAASH,CAAO,CAGjD,CAEA,QAAWG,KAAUL,EAAS,CAC5B,GAAIK,GAAQ,UAAY,GAAM,CAC5BH,EAAO,EACP,KACF,CAEIG,GAAQ,kBAAoB,MAC9BA,EAAO,iBAAiB,QAASH,CAAO,CAE5C,CAEA,SAASI,GAAK,CACZ,QAAWD,KAAUL,EACfK,GAAQ,qBAAuB,MACjCA,EAAO,oBAAoB,QAASH,CAAO,CAGjD,CAEA,IAAMG,EAASJ,EAAW,OAC1B,OAAAI,EAAO,MAAQC,EAERD,CACT",
  "names": ["index_exports", "__export", "anySignal", "signals", "controller", "onAbort", "reason", "s", "signal", "clear"]
}
