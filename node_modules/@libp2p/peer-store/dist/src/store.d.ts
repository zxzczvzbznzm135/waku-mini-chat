import { Peer as PeerPB } from './pb/peer.js';
import type { PersistentPeerStoreComponents, PersistentPeerStoreInit } from './index.js';
import type { PeerUpdate as PeerUpdateExternal, PeerId, Peer, PeerData, PeerQuery } from '@libp2p/interface';
import type { AbortOptions } from '@multiformats/multiaddr';
import type { Mortice, Release } from 'mortice';
/**
 * Event detail emitted when peer data changes
 */
export interface PeerUpdate extends PeerUpdateExternal {
    updated: boolean;
}
export interface ExistingPeer {
    peerPB: PeerPB;
    peer: Peer;
}
export interface Lock {
    refs: number;
    lock: Mortice;
}
export declare class PersistentStore {
    #private;
    private readonly peerId;
    private readonly datastore;
    private locks;
    private readonly addressFilter?;
    private readonly log;
    private readonly maxAddressAge;
    private readonly maxPeerAge;
    constructor(components: PersistentPeerStoreComponents, init?: PersistentPeerStoreInit);
    getLock(peerId: PeerId): Lock;
    private maybeRemoveLock;
    getReadLock(peerId: PeerId, options?: AbortOptions): Promise<Release>;
    getWriteLock(peerId: PeerId, options?: AbortOptions): Promise<Release>;
    has(peerId: PeerId, options?: AbortOptions): Promise<boolean>;
    delete(peerId: PeerId, options?: AbortOptions): Promise<void>;
    load(peerId: PeerId, options?: AbortOptions): Promise<Peer>;
    save(peerId: PeerId, data: PeerData, options?: AbortOptions): Promise<PeerUpdate>;
    patch(peerId: PeerId, data: Partial<PeerData>, options?: AbortOptions): Promise<PeerUpdate>;
    merge(peerId: PeerId, data: PeerData, options?: AbortOptions): Promise<PeerUpdate>;
    all(options?: PeerQuery): AsyncGenerator<Peer, void, unknown>;
}
//# sourceMappingURL=store.d.ts.map