import { Uint8ArrayList } from 'uint8arraylist';
import type { Record, Envelope, PrivateKey, PublicKey } from '@libp2p/interface';
import type { AbortOptions } from '@multiformats/multiaddr';
export interface RecordEnvelopeInit {
    publicKey: PublicKey;
    payloadType: Uint8Array;
    payload: Uint8Array;
    signature: Uint8Array;
}
export declare class RecordEnvelope implements Envelope {
    /**
     * Unmarshal a serialized Envelope protobuf message
     */
    static createFromProtobuf: (data: Uint8Array | Uint8ArrayList) => RecordEnvelope;
    /**
     * Seal marshals the given Record, places the marshaled bytes inside an Envelope
     * and signs it with the given peerId's private key
     */
    static seal: (record: Record, privateKey: PrivateKey, options?: AbortOptions) => Promise<RecordEnvelope>;
    /**
     * Open and certify a given marshaled envelope.
     * Data is unmarshaled and the signature validated for the given domain.
     */
    static openAndCertify: (data: Uint8Array | Uint8ArrayList, domain: string, options?: AbortOptions) => Promise<RecordEnvelope>;
    publicKey: PublicKey;
    payloadType: Uint8Array;
    payload: Uint8Array;
    signature: Uint8Array;
    marshaled?: Uint8Array;
    /**
     * The Envelope is responsible for keeping an arbitrary signed record
     * by a libp2p peer.
     */
    constructor(init: RecordEnvelopeInit);
    /**
     * Marshal the envelope content
     */
    marshal(): Uint8Array;
    /**
     * Verifies if the other Envelope is identical to this one
     */
    equals(other?: Envelope): boolean;
    /**
     * Validate envelope data signature for the given domain
     */
    validate(domain: string, options?: AbortOptions): Promise<boolean>;
}
//# sourceMappingURL=index.d.ts.map