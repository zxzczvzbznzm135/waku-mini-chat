{
  "version": 3,
  "sources": ["../src/index.ts", "../src/hmac/index.browser.ts", "../src/errors.ts", "../src/webcrypto/webcrypto.browser.ts", "../src/webcrypto/index.ts", "../src/hmac/lengths.ts", "../src/keys/index.ts", "../../interface/src/errors.ts", "../../../node_modules/multiformats/src/bases/base58.ts", "../../../node_modules/multiformats/src/bytes.ts", "../../../node_modules/multiformats/src/vendor/base-x.js", "../../../node_modules/multiformats/src/bases/base.ts", "../../../node_modules/multiformats/src/bases/base32.ts", "../../../node_modules/multiformats/src/bases/base36.ts", "../../../node_modules/multiformats/src/vendor/varint.js", "../../../node_modules/multiformats/src/varint.ts", "../../../node_modules/multiformats/src/hashes/digest.ts", "../../../node_modules/multiformats/src/cid.ts", "../../../node_modules/multiformats/src/hashes/identity.ts", "../../../node_modules/uint8arrays/src/equals.ts", "../../../node_modules/uint8arrays/src/alloc.ts", "../../../node_modules/uint8arrays/src/concat.ts", "../../../node_modules/uint8arraylist/src/index.ts", "../../../node_modules/multiformats/src/bases/base10.ts", "../../../node_modules/multiformats/src/bases/base16.ts", "../../../node_modules/multiformats/src/bases/base2.ts", "../../../node_modules/multiformats/src/bases/base256emoji.ts", "../../../node_modules/multiformats/src/bases/base64.ts", "../../../node_modules/multiformats/src/bases/base8.ts", "../../../node_modules/multiformats/src/bases/identity.ts", "../../../node_modules/multiformats/src/codecs/json.ts", "../../../node_modules/multiformats/src/hashes/sha2-browser.ts", "../../../node_modules/multiformats/src/hashes/hasher.ts", "../../../node_modules/multiformats/src/basics.ts", "../../../node_modules/uint8arrays/src/util/bases.ts", "../../../node_modules/uint8arrays/src/from-string.ts", "../../../node_modules/uint8arrays/src/to-string.ts", "../src/keys/rsa/der.ts", "../src/keys/ecdsa/index.ts", "../src/keys/ecdsa/utils.ts", "../src/keys/ecdsa/ecdsa.ts", "../../../node_modules/@noble/hashes/src/utils.ts", "../../../node_modules/@noble/hashes/src/_md.ts", "../../../node_modules/@noble/hashes/src/_u64.ts", "../../../node_modules/@noble/hashes/src/sha2.ts", "../../../node_modules/@noble/curves/src/utils.ts", "../../../node_modules/@noble/curves/src/abstract/modular.ts", "../../../node_modules/@noble/curves/src/abstract/curve.ts", "../../../node_modules/@noble/curves/src/abstract/edwards.ts", "../../../node_modules/@noble/curves/src/ed25519.ts", "../src/keys/ed25519/index.browser.ts", "../src/util.ts", "../src/keys/ed25519/ed25519.ts", "../src/keys/ed25519/utils.ts", "../../../node_modules/uint8-varint/src/index.ts", "../../../node_modules/protons-runtime/src/utils/float.ts", "../../../node_modules/protons-runtime/src/utils/longbits.ts", "../../../node_modules/protons-runtime/src/utils/utf8.ts", "../../../node_modules/protons-runtime/src/utils/reader.ts", "../../../node_modules/protons-runtime/src/decode.ts", "../../../node_modules/protons-runtime/src/utils/pool.ts", "../../../node_modules/protons-runtime/src/utils/writer.ts", "../../../node_modules/protons-runtime/src/encode.ts", "../../../node_modules/protons-runtime/src/codec.ts", "../../../node_modules/protons-runtime/src/codecs/enum.ts", "../../../node_modules/protons-runtime/src/codecs/message.ts", "../src/keys/keys.ts", "../src/random-bytes.ts", "../src/keys/rsa/utils.ts", "../src/keys/rsa/rsa.ts", "../src/keys/rsa/index.browser.ts", "../../../node_modules/@noble/hashes/src/hmac.ts", "../../../node_modules/@noble/curves/src/abstract/weierstrass.ts", "../../../node_modules/@noble/curves/src/secp256k1.ts", "../src/keys/secp256k1/index.browser.ts", "../src/keys/secp256k1/secp256k1.ts", "../src/keys/secp256k1/utils.ts", "../src/keys/ecdh/index.browser.ts", "../src/keys/key-stretcher.ts", "../../../node_modules/@noble/hashes/src/legacy.ts", "../../../node_modules/@noble/hashes/src/pbkdf2.ts", "../src/pbkdf2.ts"],
  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * The `libp2p-crypto` library depends on the [Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API) in the browser. Web Crypto is available in all modern browsers, however browsers restrict its usage to [Secure Contexts](https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts).\n *\n * This means you will not be able to use some `@libp2p/crypto` functions in the browser when the page is served over HTTP.*\n *\n * To enable the Web Crypto API and allow `@libp2p/crypto` to work fully, please serve your page over HTTPS.\n */\n\nimport * as hmac from './hmac/index.js'\nimport * as keys from './keys/index.js'\nimport pbkdf2 from './pbkdf2.js'\nimport randomBytes from './random-bytes.js'\n\nexport { hmac }\nexport { keys }\nexport { randomBytes }\nexport { pbkdf2 }\n", "import webcrypto from '../webcrypto/index.js'\nimport lengths from './lengths.js'\n\nconst hashTypes = {\n  SHA1: 'SHA-1',\n  SHA256: 'SHA-256',\n  SHA512: 'SHA-512'\n}\n\nconst sign = async (key: CryptoKey, data: Uint8Array): Promise<Uint8Array> => {\n  const buf = await webcrypto.get().subtle.sign({ name: 'HMAC' }, key, data)\n  return new Uint8Array(buf, 0, buf.byteLength)\n}\n\nexport async function create (hashType: 'SHA1' | 'SHA256' | 'SHA512', secret: Uint8Array): Promise<{ digest(data: Uint8Array): Promise<Uint8Array>, length: number }> {\n  const hash = hashTypes[hashType]\n\n  const key = await webcrypto.get().subtle.importKey(\n    'raw',\n    secret,\n    {\n      name: 'HMAC',\n      hash: { name: hash }\n    },\n    false,\n    ['sign']\n  )\n\n  return {\n    async digest (data: Uint8Array) {\n      return sign(key, data)\n    },\n    length: lengths[hashType]\n  }\n}\n", "/**\n * Signing a message failed\n */\nexport class SigningError extends Error {\n  constructor (message = 'An error occurred while signing a message') {\n    super(message)\n    this.name = 'SigningError'\n  }\n}\n\n/**\n * Verifying a message signature failed\n */\nexport class VerificationError extends Error {\n  constructor (message = 'An error occurred while verifying a message') {\n    super(message)\n    this.name = 'VerificationError'\n  }\n}\n\n/**\n * WebCrypto was not available in the current context\n */\nexport class WebCryptoMissingError extends Error {\n  constructor (message = 'Missing Web Crypto API') {\n    super(message)\n    this.name = 'WebCryptoMissingError'\n  }\n}\n", "/* eslint-env browser */\n\nimport { WebCryptoMissingError } from '../errors.js'\n\n// Check native crypto exists and is enabled (In insecure context `self.crypto`\n// exists but `self.crypto.subtle` does not).\nexport default {\n  get (win = globalThis) {\n    const nativeCrypto = win.crypto\n\n    if (nativeCrypto?.subtle == null) {\n      throw new WebCryptoMissingError(\n        'Missing Web Crypto API. ' +\n        'The most likely cause of this error is that this page is being accessed ' +\n        'from an insecure context (i.e. not HTTPS). For more information and ' +\n        'possible resolutions see ' +\n        'https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api'\n      )\n    }\n\n    return nativeCrypto\n  }\n}\n", "import webcrypto from './webcrypto.js'\n\nexport default webcrypto\n", "export default {\n  SHA1: 20,\n  SHA256: 32,\n  SHA512: 64\n}\n", "/**\n * @packageDocumentation\n *\n * ## Supported Key Types\n *\n * Currently the `'RSA'`, `'ed25519'`, and `secp256k1` types are supported, although ed25519 and secp256k1 keys support only signing and verification of messages.\n *\n * For encryption / decryption support, RSA keys should be used.\n */\n\nimport { InvalidParametersError, UnsupportedKeyTypeError } from '@libp2p/interface'\nimport { ECDSAPrivateKey as ECDSAPrivateKeyClass } from './ecdsa/ecdsa.js'\nimport { ECDSA_P_256_OID, ECDSA_P_384_OID, ECDSA_P_521_OID } from './ecdsa/index.js'\nimport { generateECDSAKeyPair, pkiMessageToECDSAPrivateKey, pkiMessageToECDSAPublicKey, unmarshalECDSAPrivateKey, unmarshalECDSAPublicKey } from './ecdsa/utils.js'\nimport { privateKeyLength as ed25519PrivateKeyLength, publicKeyLength as ed25519PublicKeyLength } from './ed25519/index.js'\nimport { generateEd25519KeyPair, generateEd25519KeyPairFromSeed, unmarshalEd25519PrivateKey, unmarshalEd25519PublicKey } from './ed25519/utils.js'\nimport * as pb from './keys.js'\nimport { decodeDer } from './rsa/der.js'\nimport { RSAES_PKCS1_V1_5_OID } from './rsa/index.js'\nimport { pkcs1ToRSAPrivateKey, pkixToRSAPublicKey, generateRSAKeyPair, pkcs1MessageToRSAPrivateKey, pkixMessageToRSAPublicKey, jwkToRSAPrivateKey } from './rsa/utils.js'\nimport { privateKeyLength as secp256k1PrivateKeyLength, publicKeyLength as secp256k1PublicKeyLength } from './secp256k1/index.js'\nimport { generateSecp256k1KeyPair, unmarshalSecp256k1PrivateKey, unmarshalSecp256k1PublicKey } from './secp256k1/utils.js'\nimport type { Curve } from './ecdsa/index.js'\nimport type { PrivateKey, PublicKey, KeyType, RSAPrivateKey, Secp256k1PrivateKey, Ed25519PrivateKey, Secp256k1PublicKey, Ed25519PublicKey, ECDSAPrivateKey, ECDSAPublicKey } from '@libp2p/interface'\nimport type { MultihashDigest } from 'multiformats'\nimport type { Digest } from 'multiformats/hashes/digest'\n\nexport { generateEphemeralKeyPair } from './ecdh/index.js'\nexport type { Curve } from './ecdh/index.js'\nexport type { ECDHKey, EnhancedKey, EnhancedKeyPair, ECDHKeyPair } from './interface.js'\nexport { keyStretcher } from './key-stretcher.js'\n\n/**\n * Generates a keypair of the given type and bitsize\n */\nexport async function generateKeyPair (type: 'Ed25519'): Promise<Ed25519PrivateKey>\nexport async function generateKeyPair (type: 'secp256k1'): Promise<Secp256k1PrivateKey>\nexport async function generateKeyPair (type: 'ECDSA', curve?: Curve): Promise<ECDSAPrivateKey>\nexport async function generateKeyPair (type: 'RSA', bits?: number): Promise<RSAPrivateKey>\nexport async function generateKeyPair (type: KeyType, bits?: number): Promise<PrivateKey>\nexport async function generateKeyPair (type: KeyType, bits?: number | string): Promise<unknown> {\n  if (type === 'Ed25519') {\n    return generateEd25519KeyPair()\n  }\n\n  if (type === 'secp256k1') {\n    return generateSecp256k1KeyPair()\n  }\n\n  if (type === 'RSA') {\n    return generateRSAKeyPair(toBits(bits))\n  }\n\n  if (type === 'ECDSA') {\n    return generateECDSAKeyPair(toCurve(bits))\n  }\n\n  throw new UnsupportedKeyTypeError()\n}\n\n/**\n * Generates a keypair of the given type from the passed seed.  Currently only\n * supports Ed25519 keys.\n *\n * Seed is a 32 byte uint8array\n */\nexport async function generateKeyPairFromSeed (type: 'Ed25519', seed: Uint8Array): Promise<Ed25519PrivateKey>\nexport async function generateKeyPairFromSeed <T extends KeyType> (type: T, seed: Uint8Array, bits?: number): Promise<never>\nexport async function generateKeyPairFromSeed (type: string, seed: Uint8Array): Promise<unknown> {\n  if (type !== 'Ed25519') {\n    throw new UnsupportedKeyTypeError('Seed key derivation only supported for Ed25519 keys')\n  }\n\n  return generateEd25519KeyPairFromSeed(seed)\n}\n\n/**\n * Converts a protobuf serialized public key into its representative object.\n *\n * For RSA public keys optionally pass the multihash digest of the public key if\n * it is known. If the digest is omitted it will be calculated which can be\n * expensive.\n *\n * For other key types the digest option is ignored.\n */\nexport function publicKeyFromProtobuf (buf: Uint8Array, digest?: Digest<18, number>): PublicKey {\n  const { Type, Data } = pb.PublicKey.decode(buf)\n  const data = Data ?? new Uint8Array()\n\n  switch (Type) {\n    case pb.KeyType.RSA:\n      return pkixToRSAPublicKey(data, digest)\n    case pb.KeyType.Ed25519:\n      return unmarshalEd25519PublicKey(data)\n    case pb.KeyType.secp256k1:\n      return unmarshalSecp256k1PublicKey(data)\n    case pb.KeyType.ECDSA:\n      return unmarshalECDSAPublicKey(data)\n    default:\n      throw new UnsupportedKeyTypeError()\n  }\n}\n\n/**\n * Creates a public key from the raw key bytes\n */\nexport function publicKeyFromRaw (buf: Uint8Array): PublicKey {\n  if (buf.byteLength === ed25519PublicKeyLength) {\n    return unmarshalEd25519PublicKey(buf)\n  } else if (buf.byteLength === secp256k1PublicKeyLength) {\n    return unmarshalSecp256k1PublicKey(buf)\n  }\n\n  const message = decodeDer(buf)\n  const ecdsaOid = message[1]?.[0]\n\n  if (ecdsaOid === ECDSA_P_256_OID || ecdsaOid === ECDSA_P_384_OID || ecdsaOid === ECDSA_P_521_OID) {\n    return pkiMessageToECDSAPublicKey(message)\n  }\n\n  if (message[0]?.[0] === RSAES_PKCS1_V1_5_OID) {\n    return pkixMessageToRSAPublicKey(message, buf)\n  }\n\n  throw new InvalidParametersError('Could not extract public key from raw bytes')\n}\n\n/**\n * Creates a public key from an identity multihash which contains a protobuf\n * encoded Ed25519 or secp256k1 public key.\n *\n * RSA keys are not supported as in practice we they are not stored in identity\n * multihash since the hash would be very large.\n */\nexport function publicKeyFromMultihash (digest: MultihashDigest<0x0>): Ed25519PublicKey | Secp256k1PublicKey | ECDSAPublicKey {\n  const { Type, Data } = pb.PublicKey.decode(digest.digest)\n  const data = Data ?? new Uint8Array()\n\n  switch (Type) {\n    case pb.KeyType.Ed25519:\n      return unmarshalEd25519PublicKey(data)\n    case pb.KeyType.secp256k1:\n      return unmarshalSecp256k1PublicKey(data)\n    case pb.KeyType.ECDSA:\n      return unmarshalECDSAPublicKey(data)\n    default:\n      throw new UnsupportedKeyTypeError()\n  }\n}\n\n/**\n * Converts a public key object into a protobuf serialized public key\n */\nexport function publicKeyToProtobuf (key: PublicKey): Uint8Array {\n  return pb.PublicKey.encode({\n    Type: pb.KeyType[key.type],\n    Data: key.raw\n  })\n}\n\n/**\n * Converts a protobuf serialized private key into its representative object\n */\nexport function privateKeyFromProtobuf (buf: Uint8Array): Ed25519PrivateKey | Secp256k1PrivateKey | RSAPrivateKey | ECDSAPrivateKey {\n  const decoded = pb.PrivateKey.decode(buf)\n  const data = decoded.Data ?? new Uint8Array()\n\n  switch (decoded.Type) {\n    case pb.KeyType.RSA:\n      return pkcs1ToRSAPrivateKey(data)\n    case pb.KeyType.Ed25519:\n      return unmarshalEd25519PrivateKey(data)\n    case pb.KeyType.secp256k1:\n      return unmarshalSecp256k1PrivateKey(data)\n    case pb.KeyType.ECDSA:\n      return unmarshalECDSAPrivateKey(data)\n    default:\n      throw new UnsupportedKeyTypeError()\n  }\n}\n\n/**\n * Creates a private key from the raw key bytes. For Ed25519 keys this requires\n * the public key to be appended to the private key otherwise we can't\n * differentiate between Ed25519 and secp256k1 keys as they are the same length.\n */\nexport function privateKeyFromRaw (buf: Uint8Array): PrivateKey {\n  if (buf.byteLength === ed25519PrivateKeyLength) {\n    return unmarshalEd25519PrivateKey(buf)\n  } else if (buf.byteLength === secp256k1PrivateKeyLength) {\n    return unmarshalSecp256k1PrivateKey(buf)\n  }\n\n  const message = decodeDer(buf)\n  const ecdsaOid = message[2]?.[0]\n\n  if (ecdsaOid === ECDSA_P_256_OID || ecdsaOid === ECDSA_P_384_OID || ecdsaOid === ECDSA_P_521_OID) {\n    return pkiMessageToECDSAPrivateKey(message)\n  }\n\n  if (message.length > 8) {\n    return pkcs1MessageToRSAPrivateKey(message)\n  }\n\n  throw new InvalidParametersError('Could not extract private key from raw bytes')\n}\n\n/**\n * Converts a private key object into a protobuf serialized private key\n */\nexport function privateKeyToProtobuf (key: PrivateKey): Uint8Array {\n  return pb.PrivateKey.encode({\n    Type: pb.KeyType[key.type],\n    Data: key.raw\n  })\n}\n\nfunction toBits (bits: any): number {\n  if (bits == null) {\n    return 2048\n  }\n\n  return parseInt(bits, 10)\n}\n\nfunction toCurve (curve: any): Curve {\n  if (curve === 'P-256' || curve == null) {\n    return 'P-256'\n  }\n\n  if (curve === 'P-384') {\n    return 'P-384'\n  }\n\n  if (curve === 'P-521') {\n    return 'P-521'\n  }\n\n  throw new InvalidParametersError('Unsupported curve, should be P-256, P-384 or P-521')\n}\n\n/**\n * Convert a libp2p RSA or ECDSA private key to a WebCrypto CryptoKeyPair\n */\nexport async function privateKeyToCryptoKeyPair (privateKey: PrivateKey): Promise<CryptoKeyPair> {\n  if (privateKey.type === 'RSA') {\n    return {\n      privateKey: await crypto.subtle.importKey('jwk', privateKey.jwk, {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: { name: 'SHA-256' }\n      }, true, ['sign']),\n      publicKey: await crypto.subtle.importKey('jwk', privateKey.publicKey.jwk, {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: { name: 'SHA-256' }\n      }, true, ['verify'])\n    }\n  }\n\n  if (privateKey.type === 'ECDSA') {\n    return {\n      privateKey: await crypto.subtle.importKey('jwk', privateKey.jwk, {\n        name: 'ECDSA',\n        namedCurve: privateKey.jwk.crv ?? 'P-256'\n      }, true, ['sign']),\n      publicKey: await crypto.subtle.importKey('jwk', privateKey.publicKey.jwk, {\n        name: 'ECDSA',\n        namedCurve: privateKey.publicKey.jwk.crv ?? 'P-256'\n      }, true, ['verify'])\n    }\n  }\n\n  throw new InvalidParametersError('Only RSA and ECDSA keys are supported')\n}\n\n/**\n * Convert a RSA or ECDSA WebCrypto CryptoKeyPair to a libp2p private key\n */\nexport async function privateKeyFromCryptoKeyPair (keyPair: CryptoKeyPair): Promise<PrivateKey> {\n  if (keyPair.privateKey.algorithm.name === 'RSASSA-PKCS1-v1_5') {\n    const jwk = await crypto.subtle.exportKey('jwk', keyPair.privateKey)\n\n    return jwkToRSAPrivateKey(jwk)\n  }\n\n  if (keyPair.privateKey.algorithm.name === 'ECDSA') {\n    const jwk = await crypto.subtle.exportKey('jwk', keyPair.privateKey)\n\n    return new ECDSAPrivateKeyClass(jwk)\n  }\n\n  throw new InvalidParametersError('Only RSA and ECDSA keys are supported')\n}\n", "/**\n * When this error is thrown it means an operation was aborted,\n * usually in response to the `abort` event being emitted by an\n * AbortSignal.\n */\nexport class AbortError extends Error {\n  static name = 'AbortError'\n\n  constructor (message: string = 'The operation was aborted') {\n    super(message)\n    this.name = 'AbortError'\n  }\n}\n\n/**\n * Thrown when a remote Peer ID does not match the expected one\n */\nexport class UnexpectedPeerError extends Error {\n  static name = 'UnexpectedPeerError'\n\n  constructor (message = 'Unexpected Peer') {\n    super(message)\n    this.name = 'UnexpectedPeerError'\n  }\n}\n\n/**\n * Thrown when a crypto exchange fails\n */\nexport class InvalidCryptoExchangeError extends Error {\n  static name = 'InvalidCryptoExchangeError'\n\n  constructor (message = 'Invalid crypto exchange') {\n    super(message)\n    this.name = 'InvalidCryptoExchangeError'\n  }\n}\n\n/**\n * Thrown when invalid parameters are passed to a function or method call\n */\nexport class InvalidParametersError extends Error {\n  static name = 'InvalidParametersError'\n\n  constructor (message = 'Invalid parameters') {\n    super(message)\n    this.name = 'InvalidParametersError'\n  }\n}\n\n/**\n * Thrown when a public key is invalid\n */\nexport class InvalidPublicKeyError extends Error {\n  static name = 'InvalidPublicKeyError'\n\n  constructor (message = 'Invalid public key') {\n    super(message)\n    this.name = 'InvalidPublicKeyError'\n  }\n}\n\n/**\n * Thrown when a private key is invalid\n */\nexport class InvalidPrivateKeyError extends Error {\n  static name = 'InvalidPrivateKeyError'\n\n  constructor (message = 'Invalid private key') {\n    super(message)\n    this.name = 'InvalidPrivateKeyError'\n  }\n}\n\n/**\n * Thrown when a operation is unsupported\n */\nexport class UnsupportedOperationError extends Error {\n  static name = 'UnsupportedOperationError'\n\n  constructor (message = 'Unsupported operation') {\n    super(message)\n    this.name = 'UnsupportedOperationError'\n  }\n}\n\n/**\n * Thrown when a connection is closing\n */\nexport class ConnectionClosingError extends Error {\n  static name = 'ConnectionClosingError'\n\n  constructor (message = 'The connection is closing') {\n    super(message)\n    this.name = 'ConnectionClosingError'\n  }\n}\n\n/**\n * Thrown when a connection is closed\n */\nexport class ConnectionClosedError extends Error {\n  static name = 'ConnectionClosedError'\n\n  constructor (message = 'The connection is closed') {\n    super(message)\n    this.name = 'ConnectionClosedError'\n  }\n}\n\n/**\n * Thrown when a connection fails\n */\nexport class ConnectionFailedError extends Error {\n  static name = 'ConnectionFailedError'\n\n  constructor (message = 'Connection failed') {\n    super(message)\n    this.name = 'ConnectionFailedError'\n  }\n}\n\n/**\n * Thrown when the muxer is closed and an attempt to open a stream occurs\n */\nexport class MuxerClosedError extends Error {\n  static name = 'MuxerClosedError'\n\n  constructor (message = 'The muxer is closed') {\n    super(message)\n    this.name = 'MuxerClosedError'\n  }\n}\n\n/**\n * Thrown when a protocol stream is reset by the remote muxer\n */\nexport class StreamResetError extends Error {\n  static name = 'StreamResetError'\n\n  constructor (message = 'The stream has been reset') {\n    super(message)\n    this.name = 'StreamResetError'\n  }\n}\n\n/**\n * Thrown when a protocol stream is aborted locally\n */\nexport class StreamAbortedError extends Error {\n  static name = 'StreamAbortedError'\n\n  constructor (message = 'The stream has been aborted') {\n    super(message)\n    this.name = 'StreamAbortedError'\n  }\n}\n\n/**\n * Thrown when a stream is in an invalid state\n */\nexport class StreamStateError extends Error {\n  static name = 'StreamStateError'\n\n  constructor (message = 'The stream is in an invalid state') {\n    super(message)\n    this.name = 'StreamStateError'\n  }\n}\n\n/**\n * Thrown when a stream buffer is full\n */\nexport class StreamBufferError extends Error {\n  static name = 'StreamBufferError'\n\n  constructor (message = 'The stream buffer was full') {\n    super(message)\n    this.name = 'StreamBufferError'\n  }\n}\n\n/**\n * Thrown when a value could not be found\n */\nexport class NotFoundError extends Error {\n  static name = 'NotFoundError'\n\n  constructor (message = 'Not found') {\n    super(message)\n    this.name = 'NotFoundError'\n  }\n}\n\n/**\n * Thrown when an invalid peer ID is encountered\n */\nexport class InvalidPeerIdError extends Error {\n  static name = 'InvalidPeerIdError'\n\n  constructor (message = 'Invalid PeerID') {\n    super(message)\n    this.name = 'InvalidPeerIdError'\n  }\n}\n\n/**\n * Thrown when an invalid multiaddr is encountered\n */\nexport class InvalidMultiaddrError extends Error {\n  static name = 'InvalidMultiaddrError'\n\n  constructor (message = 'Invalid multiaddr') {\n    super(message)\n    this.name = 'InvalidMultiaddrError'\n  }\n}\n\n/**\n * Thrown when an invalid CID is encountered\n */\nexport class InvalidCIDError extends Error {\n  static name = 'InvalidCIDError'\n\n  constructor (message = 'Invalid CID') {\n    super(message)\n    this.name = 'InvalidCIDError'\n  }\n}\n\n/**\n * Thrown when an invalid multihash is encountered\n */\nexport class InvalidMultihashError extends Error {\n  static name = 'InvalidMultihashError'\n\n  constructor (message = 'Invalid Multihash') {\n    super(message)\n    this.name = 'InvalidMultihashError'\n  }\n}\n\n/**\n * Thrown when a protocol is not supported\n */\nexport class UnsupportedProtocolError extends Error {\n  static name = 'UnsupportedProtocolError'\n\n  constructor (message = 'Unsupported protocol error') {\n    super(message)\n    this.name = 'UnsupportedProtocolError'\n  }\n}\n\n/**\n * An invalid or malformed message was encountered during a protocol exchange\n */\nexport class InvalidMessageError extends Error {\n  static name = 'InvalidMessageError'\n\n  constructor (message = 'Invalid message') {\n    super(message)\n    this.name = 'InvalidMessageError'\n  }\n}\n\n/**\n * Thrown when a remote peer sends a structurally valid message that does not\n * comply with the protocol\n */\nexport class ProtocolError extends Error {\n  static name = 'ProtocolError'\n\n  constructor (message = 'Protocol error') {\n    super(message)\n    this.name = 'ProtocolError'\n  }\n}\n\n/**\n * Throw when an operation times out\n */\nexport class TimeoutError extends Error {\n  static name = 'TimeoutError'\n\n  constructor (message = 'Timed out') {\n    super(message)\n    this.name = 'TimeoutError'\n  }\n}\n\n/**\n * Thrown when a startable component is interacted with but it has not been\n * started yet\n */\nexport class NotStartedError extends Error {\n  static name = 'NotStartedError'\n\n  constructor (message = 'Not started') {\n    super(message)\n    this.name = 'NotStartedError'\n  }\n}\n\n/**\n * Thrown when a component is started that has already been started\n */\nexport class AlreadyStartedError extends Error {\n  static name = 'AlreadyStartedError'\n\n  constructor (message = 'Already started') {\n    super(message)\n    this.name = 'AlreadyStartedError'\n  }\n}\n\n/**\n * Thrown when dialing an address failed\n */\nexport class DialError extends Error {\n  static name = 'DialError'\n\n  constructor (message = 'Dial error') {\n    super(message)\n    this.name = 'DialError'\n  }\n}\n\n/**\n * Thrown when listening on an address failed\n */\nexport class ListenError extends Error {\n  static name = 'ListenError'\n\n  constructor (message = 'Listen error') {\n    super(message)\n    this.name = 'ListenError'\n  }\n}\n\n/**\n * This error is thrown when a limited connection is encountered, i.e. if the\n * user tried to open a stream on a connection for a protocol that is not\n * configured to run over limited connections.\n */\nexport class LimitedConnectionError extends Error {\n  static name = 'LimitedConnectionError'\n\n  constructor (message = 'Limited connection') {\n    super(message)\n    this.name = 'LimitedConnectionError'\n  }\n}\n\n/**\n * This error is thrown where there are too many inbound protocols streams open\n */\nexport class TooManyInboundProtocolStreamsError extends Error {\n  static name = 'TooManyInboundProtocolStreamsError'\n\n  constructor (message = 'Too many inbound protocol streams') {\n    super(message)\n    this.name = 'TooManyInboundProtocolStreamsError'\n  }\n}\n\n/**\n * This error is thrown where there are too many outbound protocols streams open\n */\nexport class TooManyOutboundProtocolStreamsError extends Error {\n  static name = 'TooManyOutboundProtocolStreamsError'\n\n  constructor (message = 'Too many outbound protocol streams') {\n    super(message)\n    this.name = 'TooManyOutboundProtocolStreamsError'\n  }\n}\n\n/**\n * Thrown when an attempt to operate on an unsupported key was made\n */\nexport class UnsupportedKeyTypeError extends Error {\n  static name = 'UnsupportedKeyTypeError'\n\n  constructor (message = 'Unsupported key type') {\n    super(message)\n    this.name = 'UnsupportedKeyTypeError'\n  }\n}\n\n/**\n * Thrown when an operation has not been implemented\n */\nexport class NotImplementedError extends Error {\n  static name = 'NotImplementedError'\n\n  constructor (message = 'Not implemented') {\n    super(message)\n    this.name = 'NotImplementedError'\n  }\n}\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "export const empty = new Uint8Array(0)\n\nexport function toHex (d: Uint8Array): string {\n  return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n}\n\nexport function fromHex (hex: string): Uint8Array {\n  const hexes = hex.match(/../g)\n  return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\nexport function equals (aa: Uint8Array, bb: Uint8Array): boolean {\n  if (aa === bb) { return true }\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function coerce (o: ArrayBufferView | ArrayBuffer | Uint8Array): Uint8Array {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') { return o }\n  if (o instanceof ArrayBuffer) { return new Uint8Array(o) }\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\nexport function isBinary (o: unknown): o is ArrayBuffer | ArrayBufferView {\n  return o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n}\n\nexport function fromString (str: string): Uint8Array {\n  return new TextEncoder().encode(str)\n}\n\nexport function toString (b: Uint8Array): string {\n  return new TextDecoder().decode(b)\n}\n", "/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  /**\n   * @param {any[] | Iterable<number>} source\n   */\n  function encode (source) {\n    // @ts-ignore\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  /**\n   * @param {string | string[]} source\n   */\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  /**\n   * @param {string | string[]} string\n   */\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "import { coerce } from '../bytes.js'\nimport basex from '../vendor/base-x.js'\nimport type { BaseCodec, BaseDecoder, BaseEncoder, CombobaseDecoder, Multibase, MultibaseCodec, MultibaseDecoder, MultibaseEncoder, UnibaseDecoder } from './interface.js'\n\ninterface EncodeFn { (bytes: Uint8Array): string }\ninterface DecodeFn { (text: string): Uint8Array }\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder<Base extends string, Prefix extends string> implements MultibaseEncoder<Prefix>, BaseEncoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  encode (bytes: Uint8Array): Multibase<Prefix> {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder<Base extends string, Prefix extends string> implements MultibaseDecoder<Prefix>, UnibaseDecoder<Prefix>, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseDecode: DecodeFn\n  private readonly prefixCodePoint: number\n\n  constructor (name: Base, prefix: Prefix, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    const prefixCodePoint = prefix.codePointAt(0)\n    /* c8 ignore next 3 */\n    if (prefixCodePoint === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    this.prefixCodePoint = prefixCodePoint\n    this.baseDecode = baseDecode\n  }\n\n  decode (text: string): Uint8Array {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  or<OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n}\n\ntype Decoders<Prefix extends string> = Record<Prefix, UnibaseDecoder<Prefix>>\n\nclass ComposedDecoder<Prefix extends string> implements MultibaseDecoder<Prefix>, CombobaseDecoder<Prefix> {\n  readonly decoders: Decoders<Prefix>\n\n  constructor (decoders: Decoders<Prefix>) {\n    this.decoders = decoders\n  }\n\n  or <OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n\n  decode (input: string): Uint8Array {\n    const prefix = input[0] as Prefix\n    const decoder = this.decoders[prefix]\n    if (decoder != null) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\nexport function or <L extends string, R extends string> (left: UnibaseDecoder<L> | CombobaseDecoder<L>, right: UnibaseDecoder<R> | CombobaseDecoder<R>): ComposedDecoder<L | R> {\n  return new ComposedDecoder({\n    ...(left.decoders ?? { [(left as UnibaseDecoder<L>).prefix]: left }),\n    ...(right.decoders ?? { [(right as UnibaseDecoder<R>).prefix]: right })\n  } as Decoders<L | R>)\n}\n\nexport class Codec<Base extends string, Prefix extends string> implements MultibaseCodec<Prefix>, MultibaseEncoder<Prefix>, MultibaseDecoder<Prefix>, BaseCodec, BaseEncoder, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n  readonly baseDecode: DecodeFn\n  readonly encoder: Encoder<Base, Prefix>\n  readonly decoder: Decoder<Base, Prefix>\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  encode (input: Uint8Array): string {\n    return this.encoder.encode(input)\n  }\n\n  decode (input: string): Uint8Array {\n    return this.decoder.decode(input)\n  }\n}\n\nexport function from <Base extends string, Prefix extends string> ({ name, prefix, encode, decode }: { name: Base, prefix: Prefix, encode: EncodeFn, decode: DecodeFn }): Codec<Base, Prefix> {\n  return new Codec(name, prefix, encode, decode)\n}\n\nexport function baseX <Base extends string, Prefix extends string> ({ name, prefix, alphabet }: { name: Base, prefix: Prefix, alphabet: string }): Codec<Base, Prefix> {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: (text: string): Uint8Array => coerce(decode(text))\n  })\n}\n\nfunction decode (string: string, alphabetIdx: Record<string, number>, bitsPerChar: number, name: string): Uint8Array {\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = alphabetIdx[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\nfunction encode (data: Uint8Array, alphabet: string, bitsPerChar: number): string {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits !== 0) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (((out.length * bitsPerChar) & 7) !== 0) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\nfunction createAlphabetIdx (alphabet: string): Record<string, number> {\n  // Build the character lookup table:\n  const alphabetIdx: Record<string, number> = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    alphabetIdx[alphabet[i]] = i\n  }\n  return alphabetIdx\n}\n\n/**\n * RFC4648 Factory\n */\nexport function rfc4648 <Base extends string, Prefix extends string> ({ name, prefix, bitsPerChar, alphabet }: { name: Base, prefix: Prefix, bitsPerChar: number, alphabet: string }): Codec<Base, Prefix> {\n  const alphabetIdx = createAlphabetIdx(alphabet)\n  return from({\n    prefix,\n    name,\n    encode (input: Uint8Array): string {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input: string): Uint8Array {\n      return decode(input, alphabetIdx, bitsPerChar, name)\n    }\n  })\n}\n", "import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n", "import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n", "/* eslint-disable */\nvar encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  // @ts-ignore\n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      // @ts-ignore\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  // @ts-ignore\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (/** @type {number} */ value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import varint from './vendor/varint.js'\n\nexport function decode (data: Uint8Array, offset = 0): [number, number] {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\nexport function encodeTo (int: number, target: Uint8Array, offset = 0): Uint8Array {\n  varint.encode(int, target, offset)\n  return target\n}\n\nexport function encodingLength (int: number): number {\n  return varint.encodingLength(int)\n}\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\nimport type { MultihashDigest } from './interface.js'\n\n/**\n * Creates a multihash digest.\n */\nexport function create <Code extends number> (code: Code, digest: Uint8Array): Digest<Code, number> {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode (multihash: Uint8Array): MultihashDigest {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\nexport function equals (a: MultihashDigest, b: unknown): b is MultihashDigest {\n  if (a === b) {\n    return true\n  } else {\n    const data = b as { code?: unknown, size?: unknown, bytes?: unknown }\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest<Code extends number, Size extends number> implements MultihashDigest {\n  readonly code: Code\n  readonly size: Size\n  readonly digest: Uint8Array\n  readonly bytes: Uint8Array\n\n  /**\n   * Creates a multihash digest.\n   */\n  constructor (code: Code, size: Size, digest: Uint8Array, bytes: Uint8Array) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n\n/**\n * Used to check that the passed multihash has the passed code\n */\nexport function hasCode <T extends number> (digest: MultihashDigest, code: T): digest is MultihashDigest<T> {\n  return digest.code === code\n}\n", "import { base32 } from './bases/base32.js'\nimport { base36 } from './bases/base36.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\nimport * as varint from './varint.js'\nimport type * as API from './link/interface.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nexport function format <T extends API.Link<unknown, number, number, API.Version>, Prefix extends string> (link: T, base?: API.MultibaseEncoder<Prefix>): API.ToString<T, Prefix> {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        base as API.MultibaseEncoder<'z'> ?? base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        (base ?? base32.encoder) as API.MultibaseEncoder<Prefix>\n      )\n  }\n}\n\nexport function toJSON <Link extends API.UnknownLink> (link: Link): API.LinkJSON<Link> {\n  return {\n    '/': format(link)\n  }\n}\n\nexport function fromJSON <Link extends API.UnknownLink> (json: API.LinkJSON<Link>): CID<unknown, number, number, API.Version> {\n  return CID.parse(json['/'])\n}\n\nconst cache = new WeakMap<API.UnknownLink, Map<string, string>>()\n\nfunction baseCache (cid: API.UnknownLink): Map<string, string> {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\nexport class CID<Data = unknown, Format extends number = number, Alg extends number = number, Version extends API.Version = API.Version> implements API.Link<Data, Format, Alg, Version> {\n  readonly code: Format\n  readonly version: Version\n  readonly multihash: API.MultihashDigest<Alg>\n  readonly bytes: Uint8Array\n  readonly '/': Uint8Array\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param multihash - (Multi)hash of the of the content.\n   */\n  constructor (version: Version, code: Format, multihash: API.MultihashDigest<Alg>, bytes: Uint8Array) {\n    this.code = code\n    this.version = version\n    this.multihash = multihash\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID (): this {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset (): number {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength (): number {\n    return this.bytes.byteLength\n  }\n\n  toV0 (): CID<Data, API.DAG_PB, API.SHA_256, 0> {\n    switch (this.version) {\n      case 0: {\n        return this as CID<Data, API.DAG_PB, API.SHA_256, 0>\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return (\n          CID.createV0(\n            multihash as API.MultihashDigest<API.SHA_256>\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  toV1 (): CID<Data, Format, Alg, 1> {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return this as CID<Data, Format, Alg, 1>\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  equals (other: unknown): other is CID<Data, Format, Alg, Version> {\n    return CID.equals(this, other)\n  }\n\n  static equals <Data, Format extends number, Alg extends number, Version extends API.Version>(self: API.Link<Data, Format, Alg, Version>, other: unknown): other is CID {\n    const unknown = other as { code?: unknown, version?: unknown, multihash?: unknown }\n    return (\n      unknown != null &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  toString (base?: API.MultibaseEncoder<string>): string {\n    return format(this, base)\n  }\n\n  toJSON (): API.LinkJSON<this> {\n    return { '/': format(this) }\n  }\n\n  link (): this {\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'CID';\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] (): string {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   */\n  static asCID <Data, Format extends number, Alg extends number, Version extends API.Version, U>(input: API.Link<Data, Format, Alg, Version> | U): CID<Data, Format, Alg, Version> | null {\n    if (input == null) {\n      return null\n    }\n\n    const value = input as any\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        multihash as API.MultihashDigest<Alg>,\n        bytes ?? encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest = Digest.decode(multihash) as API.MultihashDigest<Alg>\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param digest - (Multi)hash of the of the content.\n   */\n  static create <Data, Format extends number, Alg extends number, Version extends API.Version>(version: Version, code: Format, digest: API.MultihashDigest<Alg>): CID<Data, Format, Alg, Version> {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   */\n  static createV0 <T = unknown>(digest: API.MultihashDigest<typeof SHA_256_CODE>): CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0> {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @param code - Content encoding format code.\n   * @param digest - Multihash of the content.\n   */\n  static createV1 <Data, Code extends number, Alg extends number>(code: Code, digest: API.MultihashDigest<Alg>): CID<Data, Code, Alg, 1> {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   */\n  static decode <Data, Code extends number, Alg extends number, Version extends API.Version>(bytes: API.ByteView<API.Link<Data, Code, Alg, Version>>): CID<Data, Code, Alg, Version> {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length !== 0) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   */\n  static decodeFirst <T, C extends number, A extends number, V extends API.Version>(bytes: API.ByteView<API.Link<T, C, A, V>>): [CID<T, C, A, V>, Uint8Array] {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(digest as API.MultihashDigest<API.SHA_256>)\n        : CID.createV1(specs.codec, digest)\n    return [cid as CID<T, C, A, V>, bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   */\n  static inspectBytes <T, C extends number, A extends number, V extends API.Version>(initialBytes: API.ByteView<API.Link<T, C, A, V>>): { version: V, codec: C, multihashCode: A, digestSize: number, multihashSize: number, size: number } {\n    let offset = 0\n    const next = (): number => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = next() as V\n    let codec = DAG_PB_CODE as C\n    if (version as number === 18) {\n      // CIDv0\n      version = 0 as V\n      offset = 0\n    } else {\n      codec = next() as C\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = next() as A // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   */\n  static parse <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version>(source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): CID<Data, Code, Alg, Version> {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\nfunction parseCIDtoBytes <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): [Prefix, API.ByteView<API.Link<Data, Code, Alg, Version>>] {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base ?? base58btc\n      return [\n        base58btc.prefix as Prefix,\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base ?? base58btc\n      return [base58btc.prefix as Prefix, decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base ?? base32\n      return [base32.prefix as Prefix, decoder.decode(source)]\n    }\n    case base36.prefix: {\n      const decoder = base ?? base36\n      return [base36.prefix as Prefix, decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [source[0] as Prefix, base.decode(source)]\n    }\n  }\n}\n\nfunction toStringV0 (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<'z'>): string {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nfunction toStringV1 <Prefix extends string> (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<Prefix>): string {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\nfunction encodeCID (version: API.Version, code: number, multihash: Uint8Array): Uint8Array {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n", "import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\nimport type { DigestOptions } from './hasher.js'\n\nconst code: 0x0 = 0x0\nconst name = 'identity'\n\nconst encode: (input: Uint8Array) => Uint8Array = coerce\n\nfunction digest (input: Uint8Array, options?: DigestOptions): Digest.Digest<typeof code, number> {\n  if (options?.truncate != null && options.truncate !== input.byteLength) {\n    if (options.truncate < 0 || options.truncate > input.byteLength) {\n      throw new Error(`Invalid truncate option, must be less than or equal to ${input.byteLength}`)\n    }\n\n    input = input.subarray(0, options.truncate)\n  }\n\n  return Digest.create(code, encode(input))\n}\n\nexport const identity = { code, name, encode, digest }\n", "/**\n * Returns true if the two passed Uint8Arrays have the same content\n */\nexport function equals (a: Uint8Array, b: Uint8Array): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (a.byteLength !== b.byteLength) {\n    return false\n  }\n\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n", "/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n", "import { allocUnsafe } from '#alloc'\nimport { asUint8Array } from '#util/as-uint8array'\n\n/**\n * Returns a new Uint8Array created by concatenating the passed Uint8Arrays\n */\nexport function concat (arrays: Uint8Array[], length?: number): Uint8Array {\n  if (length == null) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0)\n  }\n\n  const output = allocUnsafe(length)\n  let offset = 0\n\n  for (const arr of arrays) {\n    output.set(arr, offset)\n    offset += arr.length\n  }\n\n  return asUint8Array(output)\n}\n", "/**\n * @packageDocumentation\n *\n * A class that lets you do operations over a list of Uint8Arrays without\n * copying them.\n *\n * ```js\n * import { Uint8ArrayList } from 'uint8arraylist'\n *\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray()\n * // -> Uint8Array([0, 1, 2, 3, 4, 5])\n *\n * list.consume(3)\n * list.subarray()\n * // -> Uint8Array([3, 4, 5])\n *\n * // you can also iterate over the list\n * for (const buf of list) {\n *   // ..do something with `buf`\n * }\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ## Converting Uint8ArrayLists to Uint8Arrays\n *\n * There are two ways to turn a `Uint8ArrayList` into a `Uint8Array` - `.slice` and `.subarray` and one way to turn a `Uint8ArrayList` into a `Uint8ArrayList` with different contents - `.sublist`.\n *\n * ### slice\n *\n * Slice follows the same semantics as [Uint8Array.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice) in that it creates a new `Uint8Array` and copies bytes into it using an optional offset & length.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.slice(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ### subarray\n *\n * Subarray attempts to follow the same semantics as [Uint8Array.subarray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray) with one important different - this is a no-copy operation, unless the requested bytes span two internal buffers in which case it is a copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0]) - no-copy\n *\n * list.subarray(2, 5)\n * // -> Uint8Array([2, 3, 4]) - copy\n * ```\n *\n * ### sublist\n *\n * Sublist creates and returns a new `Uint8ArrayList` that shares the underlying buffers with the original so is always a no-copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.sublist(0, 1)\n * // -> Uint8ArrayList([0]) - no-copy\n *\n * list.sublist(2, 5)\n * // -> Uint8ArrayList([2], [3, 4]) - no-copy\n * ```\n *\n * ## Inspiration\n *\n * Borrows liberally from [bl](https://www.npmjs.com/package/bl) but only uses native JS types.\n */\nimport { allocUnsafe, alloc } from 'uint8arrays/alloc'\nimport { concat } from 'uint8arrays/concat'\nimport { equals } from 'uint8arrays/equals'\n\nconst symbol = Symbol.for('@achingbrain/uint8arraylist')\n\nexport type Appendable = Uint8ArrayList | Uint8Array\n\nfunction findBufAndOffset (bufs: Uint8Array[], index: number): { buf: Uint8Array, index: number } {\n  if (index == null || index < 0) {\n    throw new RangeError('index is out of bounds')\n  }\n\n  let offset = 0\n\n  for (const buf of bufs) {\n    const bufEnd = offset + buf.byteLength\n\n    if (index < bufEnd) {\n      return {\n        buf,\n        index: index - offset\n      }\n    }\n\n    offset = bufEnd\n  }\n\n  throw new RangeError('index is out of bounds')\n}\n\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\nexport function isUint8ArrayList (value: any): value is Uint8ArrayList {\n  return Boolean(value?.[symbol])\n}\n\nexport class Uint8ArrayList implements Iterable<Uint8Array> {\n  private bufs: Uint8Array[]\n  public length: number\n  public readonly [symbol] = true\n\n  constructor (...data: Appendable[]) {\n    this.bufs = []\n    this.length = 0\n\n    if (data.length > 0) {\n      this.appendAll(data)\n    }\n  }\n\n  * [Symbol.iterator] (): Iterator<Uint8Array> {\n    yield * this.bufs\n  }\n\n  get byteLength (): number {\n    return this.length\n  }\n\n  /**\n   * Add one or more `bufs` to the end of this Uint8ArrayList\n   */\n  append (...bufs: Appendable[]): void {\n    this.appendAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the end of this Uint8ArrayList\n   */\n  appendAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.push(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.push(...buf.bufs)\n      } else {\n        throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Add one or more `bufs` to the start of this Uint8ArrayList\n   */\n  prepend (...bufs: Appendable[]): void {\n    this.prependAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the start of this Uint8ArrayList\n   */\n  prependAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs.reverse()) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.unshift(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.unshift(...buf.bufs)\n      } else {\n        throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Read the value at `index`\n   */\n  get (index: number): number {\n    const res = findBufAndOffset(this.bufs, index)\n\n    return res.buf[res.index]\n  }\n\n  /**\n   * Set the value at `index` to `value`\n   */\n  set (index: number, value: number): void {\n    const res = findBufAndOffset(this.bufs, index)\n\n    res.buf[res.index] = value\n  }\n\n  /**\n   * Copy bytes from `buf` to the index specified by `offset`\n   */\n  write (buf: Appendable, offset: number = 0): void {\n    if (buf instanceof Uint8Array) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf[i])\n      }\n    } else if (isUint8ArrayList(buf)) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf.get(i))\n      }\n    } else {\n      throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList')\n    }\n  }\n\n  /**\n   * Remove bytes from the front of the pool\n   */\n  consume (bytes: number): void {\n    // first, normalize the argument, in accordance with how Buffer does it\n    bytes = Math.trunc(bytes)\n\n    // do nothing if not a positive number\n    if (Number.isNaN(bytes) || bytes <= 0) {\n      return\n    }\n\n    // if consuming all bytes, skip iterating\n    if (bytes === this.byteLength) {\n      this.bufs = []\n      this.length = 0\n      return\n    }\n\n    while (this.bufs.length > 0) {\n      if (bytes >= this.bufs[0].byteLength) {\n        bytes -= this.bufs[0].byteLength\n        this.length -= this.bufs[0].byteLength\n        this.bufs.shift()\n      } else {\n        this.bufs[0] = this.bufs[0].subarray(bytes)\n        this.length -= bytes\n        break\n      }\n    }\n  }\n\n  /**\n   * Extracts a section of an array and returns a new array.\n   *\n   * This is a copy operation as it is with Uint8Arrays and Arrays\n   * - note this is different to the behaviour of Node Buffers.\n   */\n  slice (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a alloc from the given start and end element index.\n   *\n   * In the best case where the data extracted comes from a single Uint8Array\n   * internally this is a no-copy operation otherwise it is a copy operation.\n   */\n  subarray (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    if (bufs.length === 1) {\n      return bufs[0]\n    }\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a allocList from the given start and end element index.\n   *\n   * This is a no-copy operation.\n   */\n  sublist (beginInclusive?: number, endExclusive?: number): Uint8ArrayList {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    const list = new Uint8ArrayList()\n    list.length = length\n    // don't loop, just set the bufs\n    list.bufs = [...bufs]\n\n    return list\n  }\n\n  private _subList (beginInclusive?: number, endExclusive?: number): { bufs: Uint8Array[], length: number } {\n    beginInclusive = beginInclusive ?? 0\n    endExclusive = endExclusive ?? this.length\n\n    if (beginInclusive < 0) {\n      beginInclusive = this.length + beginInclusive\n    }\n\n    if (endExclusive < 0) {\n      endExclusive = this.length + endExclusive\n    }\n\n    if (beginInclusive < 0 || endExclusive > this.length) {\n      throw new RangeError('index is out of bounds')\n    }\n\n    if (beginInclusive === endExclusive) {\n      return { bufs: [], length: 0 }\n    }\n\n    if (beginInclusive === 0 && endExclusive === this.length) {\n      return { bufs: this.bufs, length: this.length }\n    }\n\n    const bufs: Uint8Array[] = []\n    let offset = 0\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      const buf = this.bufs[i]\n      const bufStart = offset\n      const bufEnd = bufStart + buf.byteLength\n\n      // for next loop\n      offset = bufEnd\n\n      if (beginInclusive >= bufEnd) {\n        // start after this buf\n        continue\n      }\n\n      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd\n      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd\n\n      if (sliceStartInBuf && sliceEndsInBuf) {\n        // slice is wholly contained within this buffer\n        if (beginInclusive === bufStart && endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        const start = beginInclusive - bufStart\n        bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)))\n        break\n      }\n\n      if (sliceStartInBuf) {\n        // slice starts in this buffer\n        if (beginInclusive === 0) {\n          // requested whole buffer\n          bufs.push(buf)\n          continue\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(beginInclusive - bufStart))\n        continue\n      }\n\n      if (sliceEndsInBuf) {\n        if (endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(0, endExclusive - bufStart))\n        break\n      }\n\n      // slice started before this buffer and ends after it\n      bufs.push(buf)\n    }\n\n    return { bufs, length: endExclusive - beginInclusive }\n  }\n\n  indexOf (search: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n      throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array')\n    }\n\n    const needle = search instanceof Uint8Array ? search : search.subarray()\n\n    offset = Number(offset ?? 0)\n\n    if (isNaN(offset)) {\n      offset = 0\n    }\n\n    if (offset < 0) {\n      offset = this.length + offset\n    }\n\n    if (offset < 0) {\n      offset = 0\n    }\n\n    if (search.length === 0) {\n      return offset > this.length ? this.length : offset\n    }\n\n    // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n    const M: number = needle.byteLength\n\n    if (M === 0) {\n      throw new TypeError('search must be at least 1 byte long')\n    }\n\n    // radix\n    const radix: number = 256\n    const rightmostPositions: Int32Array = new Int32Array(radix)\n\n    // position of the rightmost occurrence of the byte c in the pattern\n    for (let c: number = 0; c < radix; c++) {\n      // -1 for bytes not in pattern\n      rightmostPositions[c] = -1\n    }\n\n    for (let j = 0; j < M; j++) {\n      // rightmost position for bytes in pattern\n      rightmostPositions[needle[j]] = j\n    }\n\n    // Return offset of first match, -1 if no match\n    const right = rightmostPositions\n    const lastIndex = this.byteLength - needle.byteLength\n    const lastPatIndex = needle.byteLength - 1\n    let skip: number\n\n    for (let i = offset; i <= lastIndex; i += skip) {\n      skip = 0\n\n      for (let j = lastPatIndex; j >= 0; j--) {\n        const char: number = this.get(i + j)\n\n        if (needle[j] !== char) {\n          skip = Math.max(1, j - right[char])\n          break\n        }\n      }\n\n      if (skip === 0) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getInt8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt8(0)\n  }\n\n  setInt8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt16(0, littleEndian)\n  }\n\n  setInt16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt32(0, littleEndian)\n  }\n\n  setInt32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigInt64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigInt64(0, littleEndian)\n  }\n\n  setBigInt64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigInt64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint8(0)\n  }\n\n  setUint8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint16(0, littleEndian)\n  }\n\n  setUint16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint32(0, littleEndian)\n  }\n\n  setUint32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigUint64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigUint64(0, littleEndian)\n  }\n\n  setBigUint64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigUint64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat32(0, littleEndian)\n  }\n\n  setFloat32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat64 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat64(0, littleEndian)\n  }\n\n  setFloat64 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  equals (other: any): other is Uint8ArrayList {\n    if (other == null) {\n      return false\n    }\n\n    if (!(other instanceof Uint8ArrayList)) {\n      return false\n    }\n\n    if (other.bufs.length !== this.bufs.length) {\n      return false\n    }\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      if (!equals(this.bufs[i], other.bufs[i])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n   * method if you know the total size of all the Uint8Arrays ahead of time.\n   */\n  static fromUint8Arrays (bufs: Uint8Array[], length?: number): Uint8ArrayList {\n    const list = new Uint8ArrayList()\n    list.bufs = bufs\n\n    if (length == null) {\n      length = bufs.reduce((acc, curr) => acc + curr.byteLength, 0)\n    }\n\n    list.length = length\n\n    return list\n  }\n}\n\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/\n", "import { baseX } from './base.js'\n\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n})\n\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n})\n", "import { from } from './base.js'\n\nconst alphabet = Array.from('\uD83D\uDE80\uD83E\uDE90\u2604\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\u2600\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\u2764\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\u263A\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\u270C\u2728\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\u2763\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\u270B\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\u2B50\u2705\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\u2714\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\u2639\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\u261D\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\u26BD\uD83E\uDD19\u2615\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\u26A1\uD83C\uDF1E\uD83C\uDF88\u274C\u270A\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\u2708\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\u25B6\u27A1\u2753\uD83D\uDC8E\uD83D\uDCB8\u2B07\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\u26A0\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\u260E\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\u2744\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42')\nconst alphabetBytesToChars: string[] = (alphabet.reduce<string[]>((p, c, i) => { p[i] = c; return p }, ([])))\nconst alphabetCharsToBytes: number[] = (alphabet.reduce<number[]>((p, c, i) => {\n  const codePoint = c.codePointAt(0)\n  if (codePoint == null) {\n    throw new Error(`Invalid character: ${c}`)\n  }\n  p[codePoint] = i\n  return p\n}, ([])))\n\nfunction encode (data: Uint8Array): string {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c]\n    return p\n  }, '')\n}\n\nfunction decode (str: string): Uint8Array {\n  const byts = []\n  for (const char of str) {\n    const codePoint = char.codePointAt(0)\n    if (codePoint == null) {\n      throw new Error(`Invalid character: ${char}`)\n    }\n    const byt = alphabetCharsToBytes[codePoint]\n    if (byt == null) {\n      throw new Error(`Non-base256emoji character: ${char}`)\n    }\n    byts.push(byt)\n  }\n  return new Uint8Array(byts)\n}\n\nexport const base256emoji = from({\n  prefix: '\uD83D\uDE80',\n  name: 'base256emoji',\n  encode,\n  decode\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n})\n", "import { fromString, toString } from '../bytes.js'\nimport { from } from './base.js'\n\nexport const identity = from({\n  prefix: '\\x00',\n  name: 'identity',\n  encode: (buf) => toString(buf),\n  decode: (str) => fromString(str)\n})\n", "import type { ArrayBufferView, ByteView } from './interface.js'\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const name = 'json'\nexport const code = 0x0200\n\nexport function encode <T> (node: T): ByteView<T> {\n  return textEncoder.encode(JSON.stringify(node))\n}\n\nexport function decode <T> (data: ByteView<T> | ArrayBufferView<T>): T {\n  return JSON.parse(textDecoder.decode(data))\n}\n", "/* global crypto */\n\nimport { from } from './hasher.js'\n\nfunction sha (name: AlgorithmIdentifier): (data: Uint8Array) => Promise<Uint8Array> {\n  return async data => new Uint8Array(await crypto.subtle.digest(name, data))\n}\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n", "import * as Digest from './digest.js'\nimport type { MultihashHasher } from './interface.js'\n\ntype Await<T> = Promise<T> | T\n\nconst DEFAULT_MIN_DIGEST_LENGTH = 20\n\nexport interface HasherInit <Name extends string, Code extends number> {\n  name: Name\n  code: Code\n  encode(input: Uint8Array): Await<Uint8Array>\n\n  /**\n   * The minimum length a hash is allowed to be truncated to in bytes\n   *\n   * @default 20\n   */\n  minDigestLength?: number\n\n  /**\n   * The maximum length a hash is allowed to be truncated to in bytes. If not\n   * specified it will be inferred from the length of the digest.\n   */\n  maxDigestLength?: number\n}\n\nexport function from <Name extends string, Code extends number> ({ name, code, encode, minDigestLength, maxDigestLength }: HasherInit<Name, Code>): Hasher<Name, Code> {\n  return new Hasher(name, code, encode, minDigestLength, maxDigestLength)\n}\n\nexport interface DigestOptions {\n  /**\n   * Truncate the returned digest to this number of bytes.\n   *\n   * This may cause the digest method to throw/reject if the passed value is\n   * greater than the digest length or below a threshold under which the risk of\n   * hash collisions is significant.\n   *\n   * The actual value of this threshold can depend on the hashing algorithm in\n   * use.\n   */\n  truncate?: number\n}\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher<Name extends string, Code extends number> implements MultihashHasher<Code> {\n  readonly name: Name\n  readonly code: Code\n  readonly encode: (input: Uint8Array) => Await<Uint8Array>\n  readonly minDigestLength: number\n  readonly maxDigestLength?: number\n\n  constructor (name: Name, code: Code, encode: (input: Uint8Array) => Await<Uint8Array>, minDigestLength?: number, maxDigestLength?: number) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n    this.minDigestLength = minDigestLength ?? DEFAULT_MIN_DIGEST_LENGTH\n    this.maxDigestLength = maxDigestLength\n  }\n\n  digest (input: Uint8Array, options?: DigestOptions): Await<Digest.Digest<Code, number>> {\n    if (options?.truncate != null) {\n      if (options.truncate < this.minDigestLength) {\n        throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`)\n      }\n\n      if (this.maxDigestLength != null && options.truncate > this.maxDigestLength) {\n        throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)\n      }\n    }\n\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n\n      if (result instanceof Uint8Array) {\n        return createDigest(result, this.code, options?.truncate)\n      }\n\n      return result.then(digest => createDigest(digest, this.code, options?.truncate))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n\n/**\n * Create a Digest from the passed uint8array and code, optionally truncating it\n * first.\n */\nfunction createDigest <Code extends number> (digest: Uint8Array, code: Code, truncate?: number): Digest.Digest<Code, number> {\n  if (truncate != null && truncate !== digest.byteLength) {\n    if (truncate > digest.byteLength) {\n      throw new Error(`Invalid truncate option, must be less than or equal to ${digest.byteLength}`)\n    }\n\n    digest = digest.subarray(0, truncate)\n  }\n\n  return Digest.create(code, digest)\n}\n", "import * as base10 from './bases/base10.js'\nimport * as base16 from './bases/base16.js'\nimport * as base2 from './bases/base2.js'\nimport * as base256emoji from './bases/base256emoji.js'\nimport * as base32 from './bases/base32.js'\nimport * as base36 from './bases/base36.js'\nimport * as base58 from './bases/base58.js'\nimport * as base64 from './bases/base64.js'\nimport * as base8 from './bases/base8.js'\nimport * as identityBase from './bases/identity.js'\nimport * as json from './codecs/json.js'\nimport * as raw from './codecs/raw.js'\nimport * as identity from './hashes/identity.js'\nimport * as sha2 from './hashes/sha2.js'\nimport { CID, hasher, digest, varint, bytes } from './index.js'\n\nexport const bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji }\nexport const hashes = { ...sha2, ...identity }\nexport const codecs = { raw, json }\n\nexport { CID, hasher, digest, varint, bytes }\n", "import { bases } from 'multiformats/basics'\nimport type { MultibaseCodec } from 'multiformats'\nimport { allocUnsafe } from '#alloc'\n\nfunction createCodec (name: string, prefix: string, encode: (buf: Uint8Array) => string, decode: (str: string) => Uint8Array): MultibaseCodec<any> {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: {\n      decode\n    }\n  }\n}\n\nconst string = createCodec('utf8', 'u', (buf) => {\n  const decoder = new TextDecoder('utf8')\n  return 'u' + decoder.decode(buf)\n}, (str) => {\n  const encoder = new TextEncoder()\n  return encoder.encode(str.substring(1))\n})\n\nconst ascii = createCodec('ascii', 'a', (buf) => {\n  let string = 'a'\n\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i])\n  }\n  return string\n}, (str) => {\n  str = str.substring(1)\n  const buf = allocUnsafe(str.length)\n\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i)\n  }\n\n  return buf\n})\n\nexport type SupportedEncodings = 'utf8' | 'utf-8' | 'hex' | 'latin1' | 'ascii' | 'binary' | keyof typeof bases\n\nconst BASES: Record<SupportedEncodings, MultibaseCodec<any>> = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii,\n  binary: ascii,\n\n  ...bases\n}\n\nexport default BASES\n", "import bases, { type SupportedEncodings } from './util/bases.js'\n\nexport type { SupportedEncodings }\n\n/**\n * Create a `Uint8Array` from the passed string\n *\n * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function fromString (string: string, encoding: SupportedEncodings = 'utf8'): Uint8Array {\n  const base = bases[encoding]\n\n  if (base == null) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`)\n  }\n\n  // add multibase prefix\n  return base.decoder.decode(`${base.prefix}${string}`) // eslint-disable-line @typescript-eslint/restrict-template-expressions\n}\n", "import bases, { type SupportedEncodings } from './util/bases.js'\n\nexport type { SupportedEncodings }\n\n/**\n * Turns a `Uint8Array` into a string.\n *\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function toString (array: Uint8Array, encoding: SupportedEncodings = 'utf8'): string {\n  const base = bases[encoding]\n\n  if (base == null) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`)\n  }\n\n  // strip multibase prefix\n  return base.encoder.encode(array).substring(1)\n}\n", "import { Uint8ArrayList } from 'uint8arraylist'\n\ninterface Context {\n  offset: number\n}\n\nconst TAG_MASK = parseInt('11111', 2)\nconst LONG_LENGTH_MASK = parseInt('10000000', 2)\nconst LONG_LENGTH_BYTES_MASK = parseInt('01111111', 2)\n\ninterface Decoder {\n  (buf: Uint8Array, context: Context): any\n}\n\nconst decoders: Record<number, Decoder> = {\n  0x0: readSequence,\n  0x1: readSequence,\n  0x2: readInteger,\n  0x3: readBitString,\n  0x4: readOctetString,\n  0x5: readNull,\n  0x6: readObjectIdentifier,\n  0x10: readSequence,\n  0x16: readSequence,\n  0x30: readSequence\n}\n\nexport function decodeDer (buf: Uint8Array, context: Context = { offset: 0 }): any {\n  const tag = buf[context.offset] & TAG_MASK\n  context.offset++\n\n  if (decoders[tag] != null) {\n    return decoders[tag](buf, context)\n  }\n\n  throw new Error('No decoder for tag ' + tag)\n}\n\nfunction readLength (buf: Uint8Array, context: Context): number {\n  let length = 0\n\n  if ((buf[context.offset] & LONG_LENGTH_MASK) === LONG_LENGTH_MASK) {\n    // long length\n    const count = buf[context.offset] & LONG_LENGTH_BYTES_MASK\n    let str = '0x'\n    context.offset++\n\n    for (let i = 0; i < count; i++, context.offset++) {\n      str += buf[context.offset].toString(16).padStart(2, '0')\n    }\n\n    length = parseInt(str, 16)\n  } else {\n    length = buf[context.offset]\n    context.offset++\n  }\n\n  return length\n}\n\nfunction readSequence (buf: Uint8Array, context: Context): any[] {\n  readLength(buf, context)\n  const entries: any[] = []\n\n  while (true) {\n    if (context.offset >= buf.byteLength) {\n      break\n    }\n\n    const result = decodeDer(buf, context)\n\n    if (result === null) {\n      break\n    }\n\n    entries.push(result)\n  }\n\n  return entries\n}\n\nfunction readInteger (buf: Uint8Array, context: Context): Uint8Array {\n  const length = readLength(buf, context)\n  const start = context.offset\n  const end = context.offset + length\n\n  const vals: number[] = []\n\n  for (let i = start; i < end; i++) {\n    if (i === start && buf[i] === 0) {\n      continue\n    }\n\n    vals.push(buf[i])\n  }\n\n  context.offset += length\n\n  return Uint8Array.from(vals)\n}\n\nfunction readObjectIdentifier (buf: Uint8Array, context: Context): string {\n  const count = readLength(buf, context)\n  const finalOffset = context.offset + count\n\n  const byte = buf[context.offset]\n  context.offset++\n\n  let val1 = 0\n  let val2 = 0\n\n  if (byte < 40) {\n    val1 = 0\n    val2 = byte\n  } else if (byte < 80) {\n    val1 = 1\n    val2 = byte - 40\n  } else {\n    val1 = 2\n    val2 = byte - 80\n  }\n\n  let oid = `${val1}.${val2}`\n  let num: number[] = []\n\n  while (context.offset < finalOffset) {\n    const byte = buf[context.offset]\n    context.offset++\n\n    // remove msb\n    num.push(byte & 0b01111111)\n\n    if (byte < 128) {\n      num.reverse()\n\n      // reached the end of the encoding\n      let val = 0\n\n      for (let i = 0; i < num.length; i++) {\n        val += num[i] << (i * 7)\n      }\n\n      oid += `.${val}`\n      num = []\n    }\n  }\n\n  return oid\n}\n\nfunction readNull (buf: Uint8Array, context: Context): null {\n  context.offset++\n\n  return null\n}\n\nfunction readBitString (buf: Uint8Array, context: Context): any {\n  const length = readLength(buf, context)\n  const unusedBits = buf[context.offset]\n  context.offset++\n  const bytes = buf.subarray(context.offset, context.offset + length - 1)\n  context.offset += length\n\n  if (unusedBits !== 0) {\n    // need to shift all bytes along by this many bits\n    throw new Error('Unused bits in bit string is unimplemented')\n  }\n\n  return bytes\n}\n\nfunction readOctetString (buf: Uint8Array, context: Context): any {\n  const length = readLength(buf, context)\n  const bytes = buf.subarray(context.offset, context.offset + length)\n  context.offset += length\n\n  return bytes\n}\n\nfunction encodeNumber (value: number): Uint8ArrayList {\n  let number = value.toString(16)\n\n  if (number.length % 2 === 1) {\n    number = '0' + number\n  }\n\n  const array = new Uint8ArrayList()\n\n  for (let i = 0; i < number.length; i += 2) {\n    array.append(Uint8Array.from([parseInt(`${number[i]}${number[i + 1]}`, 16)]))\n  }\n\n  return array\n}\n\nfunction encodeLength (bytes: { byteLength: number }): Uint8Array | Uint8ArrayList {\n  if (bytes.byteLength < 128) {\n    return Uint8Array.from([bytes.byteLength])\n  }\n\n  // long length\n  const length = encodeNumber(bytes.byteLength)\n\n  return new Uint8ArrayList(\n    Uint8Array.from([\n      length.byteLength | LONG_LENGTH_MASK\n    ]),\n    length\n  )\n}\n\nexport function encodeInteger (value: Uint8Array | Uint8ArrayList): Uint8ArrayList {\n  const contents = new Uint8ArrayList()\n\n  const mask = 0b10000000\n  const positive = (value.subarray()[0] & mask) === mask\n\n  if (positive) {\n    contents.append(Uint8Array.from([0]))\n  }\n\n  contents.append(value)\n\n  return new Uint8ArrayList(\n    Uint8Array.from([0x02]),\n    encodeLength(contents),\n    contents\n  )\n}\n\nexport function encodeBitString (value: Uint8Array | Uint8ArrayList): Uint8ArrayList {\n  // unused bits is always 0 with full-byte-only values\n  const unusedBits = Uint8Array.from([0])\n\n  const contents = new Uint8ArrayList(\n    unusedBits,\n    value\n  )\n\n  return new Uint8ArrayList(\n    Uint8Array.from([0x03]),\n    encodeLength(contents),\n    contents\n  )\n}\n\nexport function encodeOctetString (value: Uint8Array | Uint8ArrayList): Uint8ArrayList {\n  return new Uint8ArrayList(\n    Uint8Array.from([0x04]),\n    encodeLength(value),\n    value\n  )\n}\n\nexport function encodeSequence (values: Array<Uint8Array | Uint8ArrayList>, tag = 0x30): Uint8ArrayList {\n  const output = new Uint8ArrayList()\n\n  for (const buf of values) {\n    output.append(\n      buf\n    )\n  }\n\n  return new Uint8ArrayList(\n    Uint8Array.from([tag]),\n    encodeLength(output),\n    output\n  )\n}\n", "import type { JWKKeyPair } from '../interface.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport type Curve = 'P-256' | 'P-384' | 'P-521'\n\nexport const ECDSA_P_256_OID = '1.2.840.10045.3.1.7'\nexport const ECDSA_P_384_OID = '1.3.132.0.34'\nexport const ECDSA_P_521_OID = '1.3.132.0.35'\n\nexport async function generateECDSAKey (curve: Curve = 'P-256'): Promise<JWKKeyPair> {\n  const keyPair = await crypto.subtle.generateKey({\n    name: 'ECDSA',\n    namedCurve: curve\n  }, true, ['sign', 'verify'])\n\n  return {\n    publicKey: await crypto.subtle.exportKey('jwk', keyPair.publicKey),\n    privateKey: await crypto.subtle.exportKey('jwk', keyPair.privateKey)\n  }\n}\n\nexport async function hashAndSign (key: JsonWebKey, msg: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<Uint8Array> {\n  const privateKey = await crypto.subtle.importKey('jwk', key, {\n    name: 'ECDSA',\n    namedCurve: key.crv ?? 'P-256'\n  }, false, ['sign'])\n  options?.signal?.throwIfAborted()\n\n  const signature = await crypto.subtle.sign({\n    name: 'ECDSA',\n    hash: {\n      name: 'SHA-256'\n    }\n  }, privateKey, msg.subarray())\n  options?.signal?.throwIfAborted()\n\n  return new Uint8Array(signature, 0, signature.byteLength)\n}\n\nexport async function hashAndVerify (key: JsonWebKey, sig: Uint8Array, msg: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<boolean> {\n  const publicKey = await crypto.subtle.importKey('jwk', key, {\n    name: 'ECDSA',\n    namedCurve: key.crv ?? 'P-256'\n  }, false, ['verify'])\n  options?.signal?.throwIfAborted()\n\n  const result = await crypto.subtle.verify({\n    name: 'ECDSA',\n    hash: {\n      name: 'SHA-256'\n    }\n  }, publicKey, sig, msg.subarray())\n  options?.signal?.throwIfAborted()\n\n  return result\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { decodeDer, encodeBitString, encodeInteger, encodeOctetString, encodeSequence } from '../rsa/der.js'\nimport { ECDSAPrivateKey as ECDSAPrivateKeyClass, ECDSAPublicKey as ECDSAPublicKeyClass } from './ecdsa.js'\nimport { generateECDSAKey } from './index.js'\nimport type { Curve } from '../ecdh/index.js'\nimport type { ECDSAPublicKey, ECDSAPrivateKey } from '@libp2p/interface'\n\n// 1.2.840.10045.3.1.7 prime256v1 (ANSI X9.62 named elliptic curve)\nconst OID_256 = Uint8Array.from([0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07])\n// 1.3.132.0.34 secp384r1 (SECG (Certicom) named elliptic curve)\nconst OID_384 = Uint8Array.from([0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x22])\n// 1.3.132.0.35 secp521r1 (SECG (Certicom) named elliptic curve)\nconst OID_521 = Uint8Array.from([0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x23])\n\nconst P_256_KEY_JWK = {\n  ext: true,\n  kty: 'EC',\n  crv: 'P-256'\n}\n\nconst P_384_KEY_JWK = {\n  ext: true,\n  kty: 'EC',\n  crv: 'P-384'\n}\n\nconst P_521_KEY_JWK = {\n  ext: true,\n  kty: 'EC',\n  crv: 'P-521'\n}\n\nconst P_256_KEY_LENGTH = 32\nconst P_384_KEY_LENGTH = 48\nconst P_521_KEY_LENGTH = 66\n\nexport function unmarshalECDSAPrivateKey (bytes: Uint8Array): ECDSAPrivateKey {\n  const message = decodeDer(bytes)\n\n  return pkiMessageToECDSAPrivateKey(message)\n}\n\nexport function pkiMessageToECDSAPrivateKey (message: any): ECDSAPrivateKey {\n  const privateKey = message[1]\n  const d = uint8ArrayToString(privateKey, 'base64url')\n  const coordinates: Uint8Array = message[2][1][0]\n  const offset = 1\n  let x: string\n  let y: string\n\n  if (privateKey.byteLength === P_256_KEY_LENGTH) {\n    x = uint8ArrayToString(coordinates.subarray(offset, offset + P_256_KEY_LENGTH), 'base64url')\n    y = uint8ArrayToString(coordinates.subarray(offset + P_256_KEY_LENGTH), 'base64url')\n\n    return new ECDSAPrivateKeyClass({\n      ...P_256_KEY_JWK,\n      key_ops: ['sign'],\n      d,\n      x,\n      y\n    })\n  }\n\n  if (privateKey.byteLength === P_384_KEY_LENGTH) {\n    x = uint8ArrayToString(coordinates.subarray(offset, offset + P_384_KEY_LENGTH), 'base64url')\n    y = uint8ArrayToString(coordinates.subarray(offset + P_384_KEY_LENGTH), 'base64url')\n\n    return new ECDSAPrivateKeyClass({\n      ...P_384_KEY_JWK,\n      key_ops: ['sign'],\n      d,\n      x,\n      y\n    })\n  }\n\n  if (privateKey.byteLength === P_521_KEY_LENGTH) {\n    x = uint8ArrayToString(coordinates.subarray(offset, offset + P_521_KEY_LENGTH), 'base64url')\n    y = uint8ArrayToString(coordinates.subarray(offset + P_521_KEY_LENGTH), 'base64url')\n\n    return new ECDSAPrivateKeyClass({\n      ...P_521_KEY_JWK,\n      key_ops: ['sign'],\n      d,\n      x,\n      y\n    })\n  }\n\n  throw new InvalidParametersError(`Private key length was wrong length, got ${privateKey.byteLength}, expected 32, 48 or 66`)\n}\n\nexport function unmarshalECDSAPublicKey (bytes: Uint8Array): ECDSAPublicKey {\n  const message = decodeDer(bytes)\n\n  return pkiMessageToECDSAPublicKey(message)\n}\n\nexport function pkiMessageToECDSAPublicKey (message: any): ECDSAPublicKey {\n  const coordinates = message[1][1][0]\n  const offset = 1\n  let x: string\n  let y: string\n\n  if (coordinates.byteLength === ((P_256_KEY_LENGTH * 2) + 1)) {\n    x = uint8ArrayToString(coordinates.subarray(offset, offset + P_256_KEY_LENGTH), 'base64url')\n    y = uint8ArrayToString(coordinates.subarray(offset + P_256_KEY_LENGTH), 'base64url')\n\n    return new ECDSAPublicKeyClass({\n      ...P_256_KEY_JWK,\n      key_ops: ['verify'],\n      x,\n      y\n    })\n  }\n\n  if (coordinates.byteLength === ((P_384_KEY_LENGTH * 2) + 1)) {\n    x = uint8ArrayToString(coordinates.subarray(offset, offset + P_384_KEY_LENGTH), 'base64url')\n    y = uint8ArrayToString(coordinates.subarray(offset + P_384_KEY_LENGTH), 'base64url')\n\n    return new ECDSAPublicKeyClass({\n      ...P_384_KEY_JWK,\n      key_ops: ['verify'],\n      x,\n      y\n    })\n  }\n\n  if (coordinates.byteLength === ((P_521_KEY_LENGTH * 2) + 1)) {\n    x = uint8ArrayToString(coordinates.subarray(offset, offset + P_521_KEY_LENGTH), 'base64url')\n    y = uint8ArrayToString(coordinates.subarray(offset + P_521_KEY_LENGTH), 'base64url')\n\n    return new ECDSAPublicKeyClass({\n      ...P_521_KEY_JWK,\n      key_ops: ['verify'],\n      x,\n      y\n    })\n  }\n\n  throw new InvalidParametersError(`coordinates were wrong length, got ${coordinates.byteLength}, expected 65, 97 or 133`)\n}\n\nexport function privateKeyToPKIMessage (privateKey: JsonWebKey): Uint8Array {\n  return encodeSequence([\n    encodeInteger(Uint8Array.from([1])), // header\n    encodeOctetString(uint8ArrayFromString(privateKey.d ?? '', 'base64url')), // body\n    encodeSequence([ // PKIProtection\n      getOID(privateKey.crv)\n    ], 0xA0),\n    encodeSequence([ // extraCerts\n      encodeBitString(\n        new Uint8ArrayList(\n          Uint8Array.from([0x04]),\n          uint8ArrayFromString(privateKey.x ?? '', 'base64url'),\n          uint8ArrayFromString(privateKey.y ?? '', 'base64url')\n        )\n      )\n    ], 0xA1)\n  ]).subarray()\n}\n\nexport function publicKeyToPKIMessage (publicKey: JsonWebKey): Uint8Array {\n  return encodeSequence([\n    encodeInteger(Uint8Array.from([1])), // header\n    encodeSequence([ // PKIProtection\n      getOID(publicKey.crv)\n    ], 0xA0),\n    encodeSequence([ // extraCerts\n      encodeBitString(\n        new Uint8ArrayList(\n          Uint8Array.from([0x04]),\n          uint8ArrayFromString(publicKey.x ?? '', 'base64url'),\n          uint8ArrayFromString(publicKey.y ?? '', 'base64url')\n        )\n      )\n    ], 0xA1)\n  ]).subarray()\n}\n\nfunction getOID (curve?: string): Uint8Array {\n  if (curve === 'P-256') {\n    return OID_256\n  }\n\n  if (curve === 'P-384') {\n    return OID_384\n  }\n\n  if (curve === 'P-521') {\n    return OID_521\n  }\n\n  throw new InvalidParametersError(`Invalid curve ${curve}`)\n}\n\nexport async function generateECDSAKeyPair (curve: Curve = 'P-256'): Promise<ECDSAPrivateKey> {\n  const key = await generateECDSAKey(curve)\n\n  return new ECDSAPrivateKeyClass(key.privateKey)\n}\n\nexport function ensureECDSAKey (key: Uint8Array, length: number): Uint8Array {\n  key = Uint8Array.from(key ?? [])\n  if (key.length !== length) {\n    throw new InvalidParametersError(`Key must be a Uint8Array of length ${length}, got ${key.length}`)\n  }\n  return key\n}\n", "import { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { identity } from 'multiformats/hashes/identity'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { publicKeyToProtobuf } from '../index.js'\nimport { privateKeyToPKIMessage, publicKeyToPKIMessage } from './utils.js'\nimport { hashAndVerify, hashAndSign } from './index.js'\nimport type { ECDSAPublicKey as ECDSAPublicKeyInterface, ECDSAPrivateKey as ECDSAPrivateKeyInterface, AbortOptions } from '@libp2p/interface'\nimport type { Digest } from 'multiformats/hashes/digest'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport class ECDSAPublicKey implements ECDSAPublicKeyInterface {\n  public readonly type = 'ECDSA'\n  public readonly jwk: JsonWebKey\n  private _raw?: Uint8Array\n\n  constructor (jwk: JsonWebKey) {\n    this.jwk = jwk\n  }\n\n  get raw (): Uint8Array {\n    if (this._raw == null) {\n      this._raw = publicKeyToPKIMessage(this.jwk)\n    }\n\n    return this._raw\n  }\n\n  toMultihash (): Digest<0x0, number> {\n    return identity.digest(publicKeyToProtobuf(this))\n  }\n\n  toCID (): CID<unknown, 114, 0x0, 1> {\n    return CID.createV1(114, this.toMultihash())\n  }\n\n  toString (): string {\n    return base58btc.encode(this.toMultihash().bytes).substring(1)\n  }\n\n  equals (key?: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  async verify (data: Uint8Array | Uint8ArrayList, sig: Uint8Array, options?: AbortOptions): Promise<boolean> {\n    return hashAndVerify(this.jwk, sig, data, options)\n  }\n}\n\nexport class ECDSAPrivateKey implements ECDSAPrivateKeyInterface {\n  public readonly type = 'ECDSA'\n  public readonly jwk: JsonWebKey\n  public readonly publicKey: ECDSAPublicKey\n  private _raw?: Uint8Array\n\n  constructor (jwk: JsonWebKey) {\n    this.jwk = jwk\n    this.publicKey = new ECDSAPublicKey({\n      crv: jwk.crv,\n      ext: jwk.ext,\n      key_ops: ['verify'],\n      kty: 'EC',\n      x: jwk.x,\n      y: jwk.y\n    })\n  }\n\n  get raw (): Uint8Array {\n    if (this._raw == null) {\n      this._raw = privateKeyToPKIMessage(this.jwk)\n    }\n\n    return this._raw\n  }\n\n  equals (key?: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  async sign (message: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<Uint8Array> {\n    return hashAndSign(this.jwk, message, options)\n  }\n}\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number, title: string = ''): void {\n  if (!Number.isSafeInteger(n) || n < 0) {\n    const prefix = title && `\"${title}\" `;\n    throw new Error(`${prefix}expected integer >= 0, got ${n}`);\n  }\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(value: Uint8Array, length?: number, title: string = ''): Uint8Array {\n  const bytes = isBytes(value);\n  const len = value?.length;\n  const needsLen = length !== undefined;\n  if (!bytes || (needsLen && len !== length)) {\n    const prefix = title && `\"${title}\" `;\n    const ofLen = needsLen ? ` of length ${length}` : '';\n    const got = bytes ? `length=${len}` : `type=${typeof value}`;\n    throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n  }\n  return value;\n}\n\n/** Asserts something is hash */\nexport function ahash(h: CHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash must wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out, undefined, 'digestInto() output');\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('\"digestInto() output\" expected to be of length >=' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * Built-in doesn't validate input to be string: we do the check.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput, errorTitle = ''): Uint8Array {\n  if (typeof data === 'string') return utf8ToBytes(data);\n  return abytes(data, undefined, errorTitle);\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\n/** Merges default options and passed options. */\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options must be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Common interface for all hashes. */\nexport interface Hash<T> {\n  blockLen: number; // Bytes per block\n  outputLen: number; // Bytes in output\n  update(buf: Uint8Array): this;\n  digestInto(buf: Uint8Array): void;\n  digest(): Uint8Array;\n  destroy(): void;\n  _cloneInto(to?: T): T;\n  clone(): T;\n}\n\n/** PseudoRandom (number) Generator */\nexport interface PRG {\n  addEntropy(seed: Uint8Array): void;\n  randomBytes(length: number): Uint8Array;\n  clean(): void;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash constructor */\nexport type HasherCons<T, Opts = undefined> = Opts extends undefined ? () => T : (opts?: Opts) => T;\n/** Optional hash params. */\nexport type HashInfo = {\n  oid?: Uint8Array; // DER encoded OID in bytes\n};\n/** Hash function */\nexport type CHash<T extends Hash<T> = Hash<any>, Opts = undefined> = {\n  outputLen: number;\n  blockLen: number;\n} & HashInfo &\n  (Opts extends undefined\n    ? {\n        (msg: Uint8Array): Uint8Array;\n        create(): T;\n      }\n    : {\n        (msg: Uint8Array, opts?: Opts): Uint8Array;\n        create(opts?: Opts): T;\n      });\n/** XOF with output */\nexport type CHashXOF<T extends HashXOF<T> = HashXOF<any>, Opts = undefined> = CHash<T, Opts>;\n\n/** Creates function with outputLen, blockLen, create properties from a class constructor. */\nexport function createHasher<T extends Hash<T>, Opts = undefined>(\n  hashCons: HasherCons<T, Opts>,\n  info: HashInfo = {}\n): CHash<T, Opts> {\n  const hashC: any = (msg: Uint8Array, opts?: Opts) => hashCons(opts).update(msg).digest();\n  const tmp = hashCons(undefined);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: Opts) => hashCons(opts);\n  Object.assign(hashC, info);\n  return Object.freeze(hashC);\n}\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  const cr = typeof globalThis === 'object' ? (globalThis as any).crypto : null;\n  if (typeof cr?.getRandomValues !== 'function')\n    throw new Error('crypto.getRandomValues must be defined');\n  return cr.getRandomValues(new Uint8Array(bytesLength));\n}\n\n/** Creates OID opts for NIST hashes, with prefix 06 09 60 86 48 01 65 03 04 02. */\nexport const oidNist = (suffix: number): Required<HashInfo> => ({\n  oid: Uint8Array.from([0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, suffix]),\n});\n", "/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { abytes, aexists, aoutput, clean, createView, type Hash } from './utils.ts';\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> implements Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Uint8Array): this {\n    aexists(this);\n    abytes(data);\n    const { view, buffer, blockLen } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    clean(this.buffer.subarray(pos));\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which must be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen must be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to as unknown as any;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n  0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n", "/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0; i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://www.rfc-editor.org/rfc/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\nimport { type CHash, clean, createHasher, oidNist, rotr } from './utils.ts';\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\n\n/** Internal 32-byte base SHA2 hash class. */\nabstract class SHA2_32B<T extends SHA2_32B<T>> extends HashMD<T> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected abstract A: number;\n  protected abstract B: number;\n  protected abstract C: number;\n  protected abstract D: number;\n  protected abstract E: number;\n  protected abstract F: number;\n  protected abstract G: number;\n  protected abstract H: number;\n\n  constructor(outputLen: number) {\n    super(64, outputLen, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    clean(SHA256_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\n/** Internal SHA2-256 hash class. */\nexport class _SHA256 extends SHA2_32B<_SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n  constructor() {\n    super(32);\n  }\n}\n\n/** Internal SHA2-224 hash class. */\nexport class _SHA224 extends SHA2_32B<_SHA224> {\n  protected A: number = SHA224_IV[0] | 0;\n  protected B: number = SHA224_IV[1] | 0;\n  protected C: number = SHA224_IV[2] | 0;\n  protected D: number = SHA224_IV[3] | 0;\n  protected E: number = SHA224_IV[4] | 0;\n  protected F: number = SHA224_IV[5] | 0;\n  protected G: number = SHA224_IV[6] | 0;\n  protected H: number = SHA224_IV[7] | 0;\n  constructor() {\n    super(28);\n  }\n}\n\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n\n/** Internal 64-byte base SHA2 hash class. */\nabstract class SHA2_64B<T extends SHA2_64B<T>> extends HashMD<T> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  // h -- high 32 bits, l -- low 32 bits\n  protected abstract Ah: number;\n  protected abstract Al: number;\n  protected abstract Bh: number;\n  protected abstract Bl: number;\n  protected abstract Ch: number;\n  protected abstract Cl: number;\n  protected abstract Dh: number;\n  protected abstract Dl: number;\n  protected abstract Eh: number;\n  protected abstract El: number;\n  protected abstract Fh: number;\n  protected abstract Fl: number;\n  protected abstract Gh: number;\n  protected abstract Gl: number;\n  protected abstract Hh: number;\n  protected abstract Hl: number;\n\n  constructor(outputLen: number) {\n    super(128, outputLen, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ): void {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean(): void {\n    clean(SHA512_W_H, SHA512_W_L);\n  }\n  destroy(): void {\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\n/** Internal SHA2-512 hash class. */\nexport class _SHA512 extends SHA2_64B<_SHA512> {\n  protected Ah: number = SHA512_IV[0] | 0;\n  protected Al: number = SHA512_IV[1] | 0;\n  protected Bh: number = SHA512_IV[2] | 0;\n  protected Bl: number = SHA512_IV[3] | 0;\n  protected Ch: number = SHA512_IV[4] | 0;\n  protected Cl: number = SHA512_IV[5] | 0;\n  protected Dh: number = SHA512_IV[6] | 0;\n  protected Dl: number = SHA512_IV[7] | 0;\n  protected Eh: number = SHA512_IV[8] | 0;\n  protected El: number = SHA512_IV[9] | 0;\n  protected Fh: number = SHA512_IV[10] | 0;\n  protected Fl: number = SHA512_IV[11] | 0;\n  protected Gh: number = SHA512_IV[12] | 0;\n  protected Gl: number = SHA512_IV[13] | 0;\n  protected Hh: number = SHA512_IV[14] | 0;\n  protected Hl: number = SHA512_IV[15] | 0;\n\n  constructor() {\n    super(64);\n  }\n}\n\n/** Internal SHA2-384 hash class. */\nexport class _SHA384 extends SHA2_64B<_SHA384> {\n  protected Ah: number = SHA384_IV[0] | 0;\n  protected Al: number = SHA384_IV[1] | 0;\n  protected Bh: number = SHA384_IV[2] | 0;\n  protected Bl: number = SHA384_IV[3] | 0;\n  protected Ch: number = SHA384_IV[4] | 0;\n  protected Cl: number = SHA384_IV[5] | 0;\n  protected Dh: number = SHA384_IV[6] | 0;\n  protected Dl: number = SHA384_IV[7] | 0;\n  protected Eh: number = SHA384_IV[8] | 0;\n  protected El: number = SHA384_IV[9] | 0;\n  protected Fh: number = SHA384_IV[10] | 0;\n  protected Fl: number = SHA384_IV[11] | 0;\n  protected Gh: number = SHA384_IV[12] | 0;\n  protected Gl: number = SHA384_IV[13] | 0;\n  protected Hh: number = SHA384_IV[14] | 0;\n  protected Hl: number = SHA384_IV[15] | 0;\n\n  constructor() {\n    super(48);\n  }\n}\n\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n  0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n  0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n  0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n  0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n\n/** Internal SHA2-512/224 hash class. */\nexport class _SHA512_224 extends SHA2_64B<_SHA512_224> {\n  protected Ah: number = T224_IV[0] | 0;\n  protected Al: number = T224_IV[1] | 0;\n  protected Bh: number = T224_IV[2] | 0;\n  protected Bl: number = T224_IV[3] | 0;\n  protected Ch: number = T224_IV[4] | 0;\n  protected Cl: number = T224_IV[5] | 0;\n  protected Dh: number = T224_IV[6] | 0;\n  protected Dl: number = T224_IV[7] | 0;\n  protected Eh: number = T224_IV[8] | 0;\n  protected El: number = T224_IV[9] | 0;\n  protected Fh: number = T224_IV[10] | 0;\n  protected Fl: number = T224_IV[11] | 0;\n  protected Gh: number = T224_IV[12] | 0;\n  protected Gl: number = T224_IV[13] | 0;\n  protected Hh: number = T224_IV[14] | 0;\n  protected Hl: number = T224_IV[15] | 0;\n\n  constructor() {\n    super(28);\n  }\n}\n\n/** Internal SHA2-512/256 hash class. */\nexport class _SHA512_256 extends SHA2_64B<_SHA512_256> {\n  protected Ah: number = T256_IV[0] | 0;\n  protected Al: number = T256_IV[1] | 0;\n  protected Bh: number = T256_IV[2] | 0;\n  protected Bl: number = T256_IV[3] | 0;\n  protected Ch: number = T256_IV[4] | 0;\n  protected Cl: number = T256_IV[5] | 0;\n  protected Dh: number = T256_IV[6] | 0;\n  protected Dl: number = T256_IV[7] | 0;\n  protected Eh: number = T256_IV[8] | 0;\n  protected El: number = T256_IV[9] | 0;\n  protected Fh: number = T256_IV[10] | 0;\n  protected Fl: number = T256_IV[11] | 0;\n  protected Gh: number = T256_IV[12] | 0;\n  protected Gl: number = T256_IV[13] | 0;\n  protected Hh: number = T256_IV[14] | 0;\n  protected Hl: number = T256_IV[15] | 0;\n\n  constructor() {\n    super(32);\n  }\n}\n\n/**\n * SHA2-256 hash function from RFC 4634. In JS it's the fastest: even faster than Blake3. Some info:\n *\n * - Trying 2^128 hashes would get 50% chance of collision, using birthday attack.\n * - BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n * - Each sha256 hash is executing 2^18 bit operations.\n * - Good 2024 ASICs can do 200Th/sec with 3500 watts of power, corresponding to 2^36 hashes/joule.\n */\nexport const sha256: CHash<_SHA256> = /* @__PURE__ */ createHasher(\n  () => new _SHA256(),\n  /* @__PURE__ */ oidNist(0x01)\n);\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224: CHash<_SHA224> = /* @__PURE__ */ createHasher(\n  () => new _SHA224(),\n  /* @__PURE__ */ oidNist(0x04)\n);\n\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512: CHash<_SHA512> = /* @__PURE__ */ createHasher(\n  () => new _SHA512(),\n  /* @__PURE__ */ oidNist(0x03)\n);\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384: CHash<_SHA384> = /* @__PURE__ */ createHasher(\n  () => new _SHA384(),\n  /* @__PURE__ */ oidNist(0x02)\n);\n\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256: CHash<_SHA512_256> = /* @__PURE__ */ createHasher(\n  () => new _SHA512_256(),\n  /* @__PURE__ */ oidNist(0x06)\n);\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224: CHash<_SHA512_224> = /* @__PURE__ */ createHasher(\n  () => new _SHA512_224(),\n  /* @__PURE__ */ oidNist(0x05)\n);\n", "/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  abytes as abytes_,\n  anumber,\n  bytesToHex as bytesToHex_,\n  concatBytes as concatBytes_,\n  hexToBytes as hexToBytes_,\n} from '@noble/hashes/utils.js';\nexport {\n  abytes,\n  anumber,\n  bytesToHex,\n  concatBytes,\n  hexToBytes,\n  isBytes,\n  randomBytes,\n} from '@noble/hashes/utils.js';\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\n\nexport type CHash = {\n  (message: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array) => Uint8Array;\nexport function abool(value: boolean, title: string = ''): boolean {\n  if (typeof value !== 'boolean') {\n    const prefix = title && `\"${title}\" `;\n    throw new Error(prefix + 'expected boolean, got type=' + typeof value);\n  }\n  return value;\n}\n\n// Used in weierstrass, der\nfunction abignumber(n: number | bigint) {\n  if (typeof n === 'bigint') {\n    if (!isPosBig(n)) throw new Error('positive bigint expected, got ' + n);\n  } else anumber(n);\n  return n;\n}\n\nexport function asafenumber(value: number, title: string = ''): void {\n  if (!Number.isSafeInteger(value)) {\n    const prefix = title && `\"${title}\" `;\n    throw new Error(prefix + 'expected safe integer, got type=' + typeof value);\n  }\n}\n\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = abignumber(num).toString(16);\n  return hex.length & 1 ? '0' + hex : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex_(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex_(copyBytes(abytes_(bytes)).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  anumber(len);\n  n = abignumber(n);\n  const res = hexToBytes_(n.toString(16).padStart(len * 2, '0'));\n  if (res.length !== len) throw new Error('number too large');\n  return res;\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes_(numberToHexUnpadded(abignumber(n)));\n}\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n/**\n * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,\n * and Buffer#slice creates mutable copy. Never use Buffers!\n */\nexport function copyBytes(bytes: Uint8Array): Uint8Array {\n  return Uint8Array.from(bytes);\n}\n\n/**\n * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols\n * Should be safe to use for things expected to be ASCII.\n * Returns exact same result as `TextEncoder` for ASCII or throws.\n */\nexport function asciiToBytes(ascii: string): Uint8Array {\n  return Uint8Array.from(ascii, (c, i) => {\n    const charCode = c.charCodeAt(0);\n    if (c.length !== 1 || charCode > 127) {\n      throw new Error(\n        `string contains non-ASCII character \"${ascii[i]}\" with code ${charCode} at position ${i}`\n      );\n    }\n    return charCode;\n  });\n}\n\n// Is positive bigint\nconst isPosBig = (n: bigint) => typeof n === 'bigint' && _0n <= n;\n\nexport function inRange(n: bigint, min: bigint, max: bigint): boolean {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title: string, n: bigint, min: bigint, max: bigint): void {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max))\n    throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n: bigint): number {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number): bigint {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n: bigint, pos: number, value: boolean): bigint {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number): bigint => (_1n << BigInt(n)) - _1n;\n\n// DRBG\n\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, message: Uint8Array) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  anumber(hashLen, 'hashLen');\n  anumber(qByteLen, 'qByteLen');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  const u8n = (len: number): Uint8Array => new Uint8Array(len); // creates Uint8Array\n  const NULL = Uint8Array.of();\n  const byte0 = Uint8Array.of(0x00);\n  const byte1 = Uint8Array.of(0x01);\n  const _maxDrbgIters = 1000;\n\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...msgs: Uint8Array[]) => hmacFn(k, concatBytes_(v, ...msgs)); // hmac(k)(v, ...values)\n  const reseed = (seed: Uint8Array = NULL) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(byte0, seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(byte1, seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= _maxDrbgIters) throw new Error('drbg: tried max amount of iterations');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes_(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\nexport function validateObject(\n  object: Record<string, any>,\n  fields: Record<string, string> = {},\n  optFields: Record<string, string> = {}\n): void {\n  if (!object || typeof object !== 'object') throw new Error('expected valid options object');\n  type Item = keyof typeof object;\n  function checkField(fieldName: Item, expectedType: string, isOpt: boolean) {\n    const val = object[fieldName];\n    if (isOpt && val === undefined) return;\n    const current = typeof val;\n    if (current !== expectedType || val === null)\n      throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n  }\n  const iter = (f: typeof fields, isOpt: boolean) =>\n    Object.entries(f).forEach(([k, v]) => checkField(k, v, isOpt));\n  iter(fields, false);\n  iter(optFields, true);\n}\n\n/**\n * throws not implemented error\n */\nexport const notImplemented = (): never => {\n  throw new Error('not implemented');\n};\n\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized<T extends object, R, O extends any[]>(\n  fn: (arg: T, ...args: O) => R\n): (arg: T, ...args: O) => R {\n  const map = new WeakMap<T, R>();\n  return (arg: T, ...args: O): R => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}\n\nexport interface CryptoKeys {\n  lengths: { seed?: number; public?: number; secret?: number };\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n  getPublicKey: (secretKey: Uint8Array) => Uint8Array;\n}\n\n/** Generic interface for signatures. Has keygen, sign and verify. */\nexport interface Signer extends CryptoKeys {\n  // Interfaces are fun. We cannot just add new fields without copying old ones.\n  lengths: {\n    seed?: number;\n    public?: number;\n    secret?: number;\n    signRand?: number;\n    signature?: number;\n  };\n  sign: (msg: Uint8Array, secretKey: Uint8Array) => Uint8Array;\n  verify: (sig: Uint8Array, msg: Uint8Array, publicKey: Uint8Array) => boolean;\n}\n", "/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  abytes,\n  anumber,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  numberToBytesBE,\n  numberToBytesLE,\n  validateObject,\n} from '../utils.ts';\n\n// Numbers aren't used in x25519 / x448 builds\n// prettier-ignore\nconst _0n = /* @__PURE__ */ BigInt(0), _1n = /* @__PURE__ */ BigInt(1), _2n = /* @__PURE__ */ BigInt(2);\n// prettier-ignore\nconst _3n = /* @__PURE__ */ BigInt(3), _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5);\n// prettier-ignore\nconst _7n = /* @__PURE__ */ BigInt(7), _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9);\nconst _16n = /* @__PURE__ */ BigInt(16);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  return FpPow(Field(modulo), num, power);\n}\n\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n) throw new Error('invert: expected non-zero number');\n  if (modulo <= _0n) throw new Error('invert: expected positive modulus, got ' + modulo);\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\nfunction assertIsSquare<T>(Fp: IField<T>, root: T, n: T): void {\n  if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n}\n\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4<T>(Fp: IField<T>, n: T) {\n  const p1div4 = (Fp.ORDER + _1n) / _4n;\n  const root = Fp.pow(n, p1div4);\n  assertIsSquare(Fp, root, n);\n  return root;\n}\n\nfunction sqrt5mod8<T>(Fp: IField<T>, n: T) {\n  const p5div8 = (Fp.ORDER - _5n) / _8n;\n  const n2 = Fp.mul(n, _2n);\n  const v = Fp.pow(n2, p5div8);\n  const nv = Fp.mul(n, v);\n  const i = Fp.mul(Fp.mul(nv, _2n), v);\n  const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n  assertIsSquare(Fp, root, n);\n  return root;\n}\n\n// Based on RFC9380, Kong algorithm\n// prettier-ignore\nfunction sqrt9mod16(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  const Fp_ = Field(P);\n  const tn = tonelliShanks(P);\n  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));//  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n  const c2 = tn(Fp_, c1);              //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n  const c3 = tn(Fp_, Fp_.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n  const c4 = (P + _7n) / _16n;         //  4. c4 = (q + 7) / 16        # Integer arithmetic\n  return <T>(Fp: IField<T>, n: T) => {\n    let tv1 = Fp.pow(n, c4);           //  1. tv1 = x^c4\n    let tv2 = Fp.mul(tv1, c1);         //  2. tv2 = c1 * tv1\n    const tv3 = Fp.mul(tv1, c2);       //  3. tv3 = c2 * tv1\n    const tv4 = Fp.mul(tv1, c3);       //  4. tv4 = c3 * tv1\n    const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x\n    const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x\n    tv1 = Fp.cmov(tv1, tv2, e1);       //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    tv2 = Fp.cmov(tv4, tv3, e2);       //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x\n    const root = Fp.cmov(tv1, tv2, e3);// 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2\n    assertIsSquare(Fp, root, n);\n    return root;\n  };\n}\n\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // Initialization (precomputation).\n  // Caching initialization could boost perf by 7%.\n  if (P < _3n) throw new Error('sqrt is not defined for small field');\n  // Factor P - 1 = Q * 2^S, where Q is odd\n  let Q = P - _1n;\n  let S = 0;\n  while (Q % _2n === _0n) {\n    Q /= _2n;\n    S++;\n  }\n\n  // Find the first quadratic non-residue Z >= 2\n  let Z = _2n;\n  const _Fp = Field(P);\n  while (FpLegendre(_Fp, Z) === 1) {\n    // Basic primality test for P. After x iterations, chance of\n    // not finding quadratic non-residue is 2^x, so 2^1000.\n    if (Z++ > 1000) throw new Error('Cannot find square root: probably non-prime P');\n  }\n  // Fast-path; usually done before Z, but we do \"primality test\".\n  if (S === 1) return sqrt3mod4;\n\n  // Slow-path\n  // TODO: test on Fp2 and others\n  let cc = _Fp.pow(Z, Q); // c = z^Q\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    if (Fp.is0(n)) return n;\n    // Check if n is a quadratic residue using Legendre symbol\n    if (FpLegendre(Fp, n) !== 1) throw new Error('Cannot find square root');\n\n    // Initialize variables for the main loop\n    let M = S;\n    let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n    let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n    let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n\n    // Main loop\n    // while t != 1\n    while (!Fp.eql(t, Fp.ONE)) {\n      if (Fp.is0(t)) return Fp.ZERO; // if t=0 return R=0\n      let i = 1;\n\n      // Find the smallest i >= 1 such that t^(2^i) \u2261 1 (mod P)\n      let t_tmp = Fp.sqr(t); // t^(2^1)\n      while (!Fp.eql(t_tmp, Fp.ONE)) {\n        i++;\n        t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n        if (i === M) throw new Error('Cannot find square root');\n      }\n\n      // Calculate the exponent for b: 2^(M - i - 1)\n      const exponent = _1n << BigInt(M - i - 1); // bigint is important\n      const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n\n      // Update variables\n      M = i;\n      c = Fp.sqr(b); // c = b^2\n      t = Fp.mul(t, c); // t = (t * b^2)\n      R = Fp.mul(R, b); // R = R*b\n    }\n    return R;\n  };\n}\n\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P \u2261 3 (mod 4)\n * 2. P \u2261 5 (mod 8)\n * 3. P \u2261 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // P \u2261 3 (mod 4) => \u221An = n^((P+1)/4)\n  if (P % _4n === _3n) return sqrt3mod4;\n  // P \u2261 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n  if (P % _8n === _5n) return sqrt5mod8;\n  // P \u2261 9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)\n  if (P % _16n === _9n) return sqrt9mod16(P);\n  // Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint): boolean =>\n  (mod(num, modulo) & _1n) === _1n;\n\n/** Field is not always over prime: for example, Fp2 has ORDER(q)=p^m. */\nexport interface IField<T> {\n  ORDER: bigint;\n  BYTES: number;\n  BITS: number;\n  isLE: boolean;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  isValidNot0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  // legendre?(num: T): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array, skipValidation?: boolean): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>): IField<T> {\n  const initial = {\n    ORDER: 'bigint',\n    BYTES: 'number',\n    BITS: 'number',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  validateObject(field, opts);\n  // const max = 16384;\n  // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n  // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n  return field;\n}\n\n// Generic field functions\n\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow<T>(Fp: IField<T>, num: T, power: bigint): T {\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (power === _0n) return Fp.ONE;\n  if (power === _1n) return num;\n  let p = Fp.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = Fp.mul(p, d);\n    d = Fp.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nexport function FpInvertBatch<T>(Fp: IField<T>, nums: T[], passZero = false): T[] {\n  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n  // Walk from first to last, multiply them by each other MOD p\n  const multipliedAcc = nums.reduce((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = acc;\n    return Fp.mul(acc, num);\n  }, Fp.ONE);\n  // Invert last element\n  const invertedAcc = Fp.inv(multipliedAcc);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = Fp.mul(acc, inverted[i]);\n    return Fp.mul(acc, num);\n  }, invertedAcc);\n  return inverted;\n}\n\n// TODO: remove\nexport function FpDiv<T>(Fp: IField<T>, lhs: T, rhs: T | bigint): T {\n  return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p) \u2261 1    if a is a square (mod p), quadratic residue\n * * (a | p) \u2261 -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) \u2261 0    if a \u2261 0 (mod p)\n */\nexport function FpLegendre<T>(Fp: IField<T>, n: T): -1 | 0 | 1 {\n  // We can use 3rd argument as optional cache of this value\n  // but seems unneeded for now. The operation is very fast.\n  const p1mod2 = (Fp.ORDER - _1n) / _2n;\n  const powered = Fp.pow(n, p1mod2);\n  const yes = Fp.eql(powered, Fp.ONE);\n  const zero = Fp.eql(powered, Fp.ZERO);\n  const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n  if (!yes && !zero && !no) throw new Error('invalid Legendre symbol result');\n  return yes ? 1 : zero ? 0 : -1;\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(Fp: IField<T>, n: T): boolean {\n  const l = FpLegendre(Fp, n);\n  return l === 1;\n}\n\nexport type NLength = { nByteLength: number; nBitLength: number };\n// CURVE.n lengths\nexport function nLength(n: bigint, nBitLength?: number): NLength {\n  // Bit size, byte size of CURVE.n\n  if (nBitLength !== undefined) anumber(nBitLength);\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\ntype SqrtFn = (n: bigint) => bigint;\ntype FieldOpts = Partial<{\n  isLE: boolean;\n  BITS: number;\n  sqrt: SqrtFn;\n  allowedLengths?: readonly number[]; // for P521 (adds padding for smaller sizes)\n  modFromBytes: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\n}>;\nclass _Field implements IField<bigint> {\n  readonly ORDER: bigint;\n  readonly BITS: number;\n  readonly BYTES: number;\n  readonly isLE: boolean;\n  readonly ZERO = _0n;\n  readonly ONE = _1n;\n  readonly _lengths?: number[];\n  private _sqrt: ReturnType<typeof FpSqrt> | undefined; // cached sqrt\n  private readonly _mod?: boolean;\n  constructor(ORDER: bigint, opts: FieldOpts = {}) {\n    if (ORDER <= _0n) throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    let _nbitLength: number | undefined = undefined;\n    this.isLE = false;\n    if (opts != null && typeof opts === 'object') {\n      if (typeof opts.BITS === 'number') _nbitLength = opts.BITS;\n      if (typeof opts.sqrt === 'function') this.sqrt = opts.sqrt;\n      if (typeof opts.isLE === 'boolean') this.isLE = opts.isLE;\n      if (opts.allowedLengths) this._lengths = opts.allowedLengths?.slice();\n      if (typeof opts.modFromBytes === 'boolean') this._mod = opts.modFromBytes;\n    }\n    const { nBitLength, nByteLength } = nLength(ORDER, _nbitLength);\n    if (nByteLength > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    this.ORDER = ORDER;\n    this.BITS = nBitLength;\n    this.BYTES = nByteLength;\n    this._sqrt = undefined;\n    Object.preventExtensions(this);\n  }\n\n  create(num: bigint) {\n    return mod(num, this.ORDER);\n  }\n  isValid(num: bigint) {\n    if (typeof num !== 'bigint')\n      throw new Error('invalid field element: expected bigint, got ' + typeof num);\n    return _0n <= num && num < this.ORDER; // 0 is valid element, but it's not invertible\n  }\n  is0(num: bigint) {\n    return num === _0n;\n  }\n  // is valid and invertible\n  isValidNot0(num: bigint) {\n    return !this.is0(num) && this.isValid(num);\n  }\n  isOdd(num: bigint) {\n    return (num & _1n) === _1n;\n  }\n  neg(num: bigint) {\n    return mod(-num, this.ORDER);\n  }\n  eql(lhs: bigint, rhs: bigint) {\n    return lhs === rhs;\n  }\n\n  sqr(num: bigint) {\n    return mod(num * num, this.ORDER);\n  }\n  add(lhs: bigint, rhs: bigint) {\n    return mod(lhs + rhs, this.ORDER);\n  }\n  sub(lhs: bigint, rhs: bigint) {\n    return mod(lhs - rhs, this.ORDER);\n  }\n  mul(lhs: bigint, rhs: bigint) {\n    return mod(lhs * rhs, this.ORDER);\n  }\n  pow(num: bigint, power: bigint): bigint {\n    return FpPow(this, num, power);\n  }\n  div(lhs: bigint, rhs: bigint) {\n    return mod(lhs * invert(rhs, this.ORDER), this.ORDER);\n  }\n\n  // Same as above, but doesn't normalize\n  sqrN(num: bigint) {\n    return num * num;\n  }\n  addN(lhs: bigint, rhs: bigint) {\n    return lhs + rhs;\n  }\n  subN(lhs: bigint, rhs: bigint) {\n    return lhs - rhs;\n  }\n  mulN(lhs: bigint, rhs: bigint) {\n    return lhs * rhs;\n  }\n\n  inv(num: bigint) {\n    return invert(num, this.ORDER);\n  }\n  sqrt(num: bigint): bigint {\n    // Caching _sqrt speeds up sqrt9mod16 by 5x and tonneli-shanks by 10%\n    if (!this._sqrt) this._sqrt = FpSqrt(this.ORDER);\n    return this._sqrt(this, num);\n  }\n  toBytes(num: bigint) {\n    return this.isLE ? numberToBytesLE(num, this.BYTES) : numberToBytesBE(num, this.BYTES);\n  }\n  fromBytes(bytes: Uint8Array, skipValidation = false) {\n    abytes(bytes);\n    const { _lengths: allowedLengths, BYTES, isLE, ORDER, _mod: modFromBytes } = this;\n    if (allowedLengths) {\n      if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n        throw new Error(\n          'Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length\n        );\n      }\n      const padded = new Uint8Array(BYTES);\n      // isLE add 0 to right, !isLE to the left.\n      padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n      bytes = padded;\n    }\n    if (bytes.length !== BYTES)\n      throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n    let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n    if (modFromBytes) scalar = mod(scalar, ORDER);\n    if (!skipValidation)\n      if (!this.isValid(scalar))\n        throw new Error('invalid field element: outside of range 0..ORDER');\n    // NOTE: we don't validate scalar here, please use isValid. This done such way because some\n    // protocol may allow non-reduced scalar that reduced later or changed some other way.\n    return scalar;\n  }\n  // TODO: we don't need it here, move out to separate fn\n  invertBatch(lst: bigint[]): bigint[] {\n    return FpInvertBatch(this, lst);\n  }\n  // We can't move this out because Fp6, Fp12 implement it\n  // and it's unclear what to return in there.\n  cmov(a: bigint, b: bigint, condition: boolean) {\n    return condition ? b : a;\n  }\n}\n\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER: bigint, opts: FieldOpts = {}): Readonly<FpField> {\n  return new _Field(ORDER, opts);\n}\n\n// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?\n// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).\n// which mean we cannot force this via opts.\n// Not sure what to do with randomBytes, we can accept it inside opts if wanted.\n// Probably need to export getMinHashLength somewhere?\n// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {\n//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;\n//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?\n//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;\n//   return reduced;\n// },\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder: bigint): number {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder: bigint): number {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.Point.Fn.ORDER)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\n  abytes(key);\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024)\n    throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n  const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n", "/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { bitLen, bitMask, type Signer } from '../utils.ts';\nimport { Field, FpInvertBatch, validateField, type IField } from './modular.ts';\n\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\n\nexport type AffinePoint<T> = {\n  x: T;\n  y: T;\n} & { Z?: never };\n\n// We can't \"abstract out\" coordinates (X, Y, Z; and T in Edwards): argument names of constructor\n// are not accessible. See Typescript gh-56093, gh-41594.\n//\n// We have to use recursive types, so it will return actual point, not constained `CurvePoint`.\n// If, at any point, P is `any`, it will erase all types and replace it\n// with `any`, because of recursion, `any implements CurvePoint`,\n// but we lose all constrains on methods.\n\n/** Base interface for all elliptic curve Points. */\nexport interface CurvePoint<F, P extends CurvePoint<F, P>> {\n  /** Affine x coordinate. Different from projective / extended X coordinate. */\n  x: F;\n  /** Affine y coordinate. Different from projective / extended Y coordinate. */\n  y: F;\n  Z?: F;\n  double(): P;\n  negate(): P;\n  add(other: P): P;\n  subtract(other: P): P;\n  equals(other: P): boolean;\n  multiply(scalar: bigint): P;\n  assertValidity(): void;\n  clearCofactor(): P;\n  is0(): boolean;\n  isTorsionFree(): boolean;\n  isSmallOrder(): boolean;\n  multiplyUnsafe(scalar: bigint): P;\n  /**\n   * Massively speeds up `p.multiply(n)` by using precompute tables (caching). See {@link wNAF}.\n   * @param isLazy calculate cache now. Default (true) ensures it's deferred to first `multiply()`\n   */\n  precompute(windowSize?: number, isLazy?: boolean): P;\n  /** Converts point to 2D xy affine coordinates */\n  toAffine(invertedZ?: F): AffinePoint<F>;\n  toBytes(): Uint8Array;\n  toHex(): string;\n}\n\n/** Base interface for all elliptic curve Point constructors. */\nexport interface CurvePointCons<P extends CurvePoint<any, P>> {\n  [Symbol.hasInstance]: (item: unknown) => boolean;\n  BASE: P;\n  ZERO: P;\n  /** Field for basic curve math */\n  Fp: IField<P_F<P>>;\n  /** Scalar field, for scalars in multiply and others */\n  Fn: IField<bigint>;\n  /** Creates point from x, y. Does NOT validate if the point is valid. Use `.assertValidity()`. */\n  fromAffine(p: AffinePoint<P_F<P>>): P;\n  fromBytes(bytes: Uint8Array): P;\n  fromHex(hex: string): P;\n}\n\n// Type inference helpers: PC - PointConstructor, P - Point, Fp - Field element\n// Short names, because we use them a lot in result types:\n// * we can't do 'P = GetCurvePoint<PC>': this is default value and doesn't constrain anything\n// * we can't do 'type X = GetCurvePoint<PC>': it won't be accesible for arguments/return types\n// * `CurvePointCons<P extends CurvePoint<any, P>>` constraints from interface definition\n//   won't propagate, if `PC extends CurvePointCons<any>`: the P would be 'any', which is incorrect\n// * PC could be super specific with super specific P, which implements CurvePoint<any, P>.\n//   this means we need to do stuff like\n//   `function test<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(`\n//   if we want type safety around P, otherwise PC_P<PC> will be any\n\n/** Returns Fp type from Point (P_F<P> == P.F) */\nexport type P_F<P extends CurvePoint<any, P>> = P extends CurvePoint<infer F, P> ? F : never;\n/** Returns Fp type from PointCons (PC_F<PC> == PC.P.F) */\nexport type PC_F<PC extends CurvePointCons<CurvePoint<any, any>>> = PC['Fp']['ZERO'];\n/** Returns Point type from PointCons (PC_P<PC> == PC.P) */\nexport type PC_P<PC extends CurvePointCons<CurvePoint<any, any>>> = PC['ZERO'];\n\n// Ugly hack to get proper type inference, because in typescript fails to infer resursively.\n// The hack allows to do up to 10 chained operations without applying type erasure.\n//\n// Types which won't work:\n// * `CurvePointCons<CurvePoint<any, any>>`, will return `any` after 1 operation\n// * `CurvePointCons<any>: WeierstrassPointCons<bigint> extends CurvePointCons<any> = false`\n// * `P extends CurvePoint, PC extends CurvePointCons<P>`\n//     * It can't infer P from PC alone\n//     * Too many relations between F, P & PC\n//     * It will infer P/F if `arg: CurvePointCons<F, P>`, but will fail if PC is generic\n//     * It will work correctly if there is an additional argument of type P\n//     * But generally, we don't want to parametrize `CurvePointCons` over `F`: it will complicate\n//       types, making them un-inferable\n// prettier-ignore\nexport type PC_ANY = CurvePointCons<\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any, any>\n  >>>>>>>>>\n>;\n\nexport interface CurveLengths {\n  secretKey?: number;\n  publicKey?: number;\n  publicKeyUncompressed?: number;\n  publicKeyHasPrefix?: boolean;\n  signature?: number;\n  seed?: number;\n}\n\nexport type Mapper<T> = (i: T[]) => T[];\n\nexport function negateCt<T extends { negate: () => T }>(condition: boolean, item: T): T {\n  const neg = item.negate();\n  return condition ? neg : item;\n}\n\n/**\n * Takes a bunch of Projective Points but executes only one\n * inversion on all of them. Inversion is very slow operation,\n * so this improves performance massively.\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\n */\nexport function normalizeZ<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  c: PC,\n  points: P[]\n): P[] {\n  const invertedZs = FpInvertBatch(\n    c.Fp,\n    points.map((p) => p.Z!)\n  );\n  return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));\n}\n\nfunction validateW(W: number, bits: number) {\n  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n    throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\n\n/** Internal wNAF opts for specific W and scalarBits */\ntype WOpts = {\n  windows: number;\n  windowSize: number;\n  mask: bigint;\n  maxNumber: number;\n  shiftBy: bigint;\n};\n\nfunction calcWOpts(W: number, scalarBits: number): WOpts {\n  validateW(W, scalarBits);\n  const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n  const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n  const maxNumber = 2 ** W; // W=8 256\n  const mask = bitMask(W); // W=8 255 == mask 0b11111111\n  const shiftBy = BigInt(W); // W=8 8\n  return { windows, windowSize, mask, maxNumber, shiftBy };\n}\n\nfunction calcOffsets(n: bigint, window: number, wOpts: WOpts) {\n  const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n  let wbits = Number(n & mask); // extract W bits.\n  let nextN = n >> shiftBy; // shift number by W bits.\n\n  // What actually happens here:\n  // const highestBit = Number(mask ^ (mask >> 1n));\n  // let wbits2 = wbits - 1; // skip zero\n  // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n\n  // split if bits > max: +224 => 256-32\n  if (wbits > windowSize) {\n    // we skip zero, which means instead of `>= size-1`, we do `> size`\n    wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n    nextN += _1n; // +256 (carry)\n  }\n  const offsetStart = window * windowSize;\n  const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n  const isZero = wbits === 0; // is current window slice a 0?\n  const isNeg = wbits < 0; // is current window slice negative?\n  const isNegF = window % 2 !== 0; // fake random statement for noise\n  const offsetF = offsetStart; // fake offset for noise\n  return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\n\nfunction validateMSMPoints(points: any[], c: any) {\n  if (!Array.isArray(points)) throw new Error('array expected');\n  points.forEach((p, i) => {\n    if (!(p instanceof c)) throw new Error('invalid point at index ' + i);\n  });\n}\nfunction validateMSMScalars(scalars: any[], field: any) {\n  if (!Array.isArray(scalars)) throw new Error('array of scalars expected');\n  scalars.forEach((s, i) => {\n    if (!field.isValid(s)) throw new Error('invalid scalar at index ' + i);\n  });\n}\n\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap<any, any[]>();\nconst pointWindowSizes = new WeakMap<any, number>();\n\nfunction getW(P: any): number {\n  // To disable precomputes:\n  // return 1;\n  return pointWindowSizes.get(P) || 1;\n}\n\nfunction assert0(n: bigint): void {\n  if (n !== _0n) throw new Error('invalid wNAF');\n}\n\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Table generation takes **30MB of ram and 10ms on high-end CPU**,\n * but may take much longer on slow devices. Actual generation will happen on\n * first call of `multiply()`. By default, `BASE` point is precomputed.\n *\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / \uD835\uDC4A) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport class wNAF<PC extends PC_ANY> {\n  private readonly BASE: PC_P<PC>;\n  private readonly ZERO: PC_P<PC>;\n  private readonly Fn: PC['Fn'];\n  readonly bits: number;\n\n  // Parametrized with a given Point class (not individual point)\n  constructor(Point: PC, bits: number) {\n    this.BASE = Point.BASE;\n    this.ZERO = Point.ZERO;\n    this.Fn = Point.Fn;\n    this.bits = bits;\n  }\n\n  // non-const time multiplication ladder\n  _unsafeLadder(elm: PC_P<PC>, n: bigint, p: PC_P<PC> = this.ZERO): PC_P<PC> {\n    let d: PC_P<PC> = elm;\n    while (n > _0n) {\n      if (n & _1n) p = p.add(d);\n      d = d.double();\n      n >>= _1n;\n    }\n    return p;\n  }\n\n  /**\n   * Creates a wNAF precomputation window. Used for caching.\n   * Default window size is set by `utils.precompute()` and is equal to 8.\n   * Number of precomputed points depends on the curve size:\n   * 2^(\uD835\uDC4A\u22121) * (Math.ceil(\uD835\uDC5B / \uD835\uDC4A) + 1), where:\n   * - \uD835\uDC4A is the window size\n   * - \uD835\uDC5B is the bitlength of the curve order.\n   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n   * @param point Point instance\n   * @param W window size\n   * @returns precomputed point tables flattened to a single array\n   */\n  private precomputeWindow(point: PC_P<PC>, W: number): PC_P<PC>[] {\n    const { windows, windowSize } = calcWOpts(W, this.bits);\n    const points: PC_P<PC>[] = [];\n    let p: PC_P<PC> = point;\n    let base = p;\n    for (let window = 0; window < windows; window++) {\n      base = p;\n      points.push(base);\n      // i=1, bc we skip 0\n      for (let i = 1; i < windowSize; i++) {\n        base = base.add(p);\n        points.push(base);\n      }\n      p = base.double();\n    }\n    return points;\n  }\n\n  /**\n   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n   * More compact implementation:\n   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n   * @returns real and fake (for const-time) points\n   */\n  private wNAF(W: number, precomputes: PC_P<PC>[], n: bigint): { p: PC_P<PC>; f: PC_P<PC> } {\n    // Scalar should be smaller than field order\n    if (!this.Fn.isValid(n)) throw new Error('invalid scalar');\n    // Accumulators\n    let p = this.ZERO;\n    let f = this.BASE;\n    // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n    // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n    // there is negate now: it is possible that negated element from low value\n    // would be the same as high element, which will create carry into next window.\n    // It's not obvious how this can fail, but still worth investigating later.\n    const wo = calcWOpts(W, this.bits);\n    for (let window = 0; window < wo.windows; window++) {\n      // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n      const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n      n = nextN;\n      if (isZero) {\n        // bits are 0: add garbage to fake point\n        // Important part for const-time getPublicKey: add random \"noise\" point to f.\n        f = f.add(negateCt(isNegF, precomputes[offsetF]));\n      } else {\n        // bits are 1: add to result point\n        p = p.add(negateCt(isNeg, precomputes[offset]));\n      }\n    }\n    assert0(n);\n    // Return both real and fake points: JIT won't eliminate f.\n    // At this point there is a way to F be infinity-point even if p is not,\n    // which makes it less const-time: around 1 bigint multiply.\n    return { p, f };\n  }\n\n  /**\n   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n   * @param acc accumulator point to add result of multiplication\n   * @returns point\n   */\n  private wNAFUnsafe(\n    W: number,\n    precomputes: PC_P<PC>[],\n    n: bigint,\n    acc: PC_P<PC> = this.ZERO\n  ): PC_P<PC> {\n    const wo = calcWOpts(W, this.bits);\n    for (let window = 0; window < wo.windows; window++) {\n      if (n === _0n) break; // Early-exit, skip 0 value\n      const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n      n = nextN;\n      if (isZero) {\n        // Window bits are 0: skip processing.\n        // Move to next window.\n        continue;\n      } else {\n        const item = precomputes[offset];\n        acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n      }\n    }\n    assert0(n);\n    return acc;\n  }\n\n  private getPrecomputes(W: number, point: PC_P<PC>, transform?: Mapper<PC_P<PC>>): PC_P<PC>[] {\n    // Calculate precomputes on a first run, reuse them after\n    let comp = pointPrecomputes.get(point);\n    if (!comp) {\n      comp = this.precomputeWindow(point, W) as PC_P<PC>[];\n      if (W !== 1) {\n        // Doing transform outside of if brings 15% perf hit\n        if (typeof transform === 'function') comp = transform(comp);\n        pointPrecomputes.set(point, comp);\n      }\n    }\n    return comp;\n  }\n\n  cached(\n    point: PC_P<PC>,\n    scalar: bigint,\n    transform?: Mapper<PC_P<PC>>\n  ): { p: PC_P<PC>; f: PC_P<PC> } {\n    const W = getW(point);\n    return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);\n  }\n\n  unsafe(point: PC_P<PC>, scalar: bigint, transform?: Mapper<PC_P<PC>>, prev?: PC_P<PC>): PC_P<PC> {\n    const W = getW(point);\n    if (W === 1) return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster\n    return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);\n  }\n\n  // We calculate precomputes for elliptic curve point multiplication\n  // using windowed method. This specifies window size and\n  // stores precomputed values. Usually only base point would be precomputed.\n  createCache(P: PC_P<PC>, W: number): void {\n    validateW(W, this.bits);\n    pointWindowSizes.set(P, W);\n    pointPrecomputes.delete(P);\n  }\n\n  hasCache(elm: PC_P<PC>): boolean {\n    return getW(elm) !== 1;\n  }\n}\n\n/**\n * Endomorphism-specific multiplication for Koblitz curves.\n * Cost: 128 dbl, 0-256 adds.\n */\nexport function mulEndoUnsafe<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  Point: PC,\n  point: P,\n  k1: bigint,\n  k2: bigint\n): { p1: P; p2: P } {\n  let acc = point;\n  let p1 = Point.ZERO;\n  let p2 = Point.ZERO;\n  while (k1 > _0n || k2 > _0n) {\n    if (k1 & _1n) p1 = p1.add(acc);\n    if (k2 & _1n) p2 = p2.add(acc);\n    acc = acc.double();\n    k1 >>= _1n;\n    k2 >>= _1n;\n  }\n  return { p1, p2 };\n}\n\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka secret keys / bigints)\n */\nexport function pippenger<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  c: PC,\n  points: P[],\n  scalars: bigint[]\n): P {\n  // If we split scalars by some window (let's say 8 bits), every chunk will only\n  // take 256 buckets even if there are 4096 scalars, also re-uses double.\n  // TODO:\n  // - https://eprint.iacr.org/2024/750.pdf\n  // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n  // 0 is accepted in scalars\n  const fieldN = c.Fn;\n  validateMSMPoints(points, c);\n  validateMSMScalars(scalars, fieldN);\n  const plength = points.length;\n  const slength = scalars.length;\n  if (plength !== slength) throw new Error('arrays of points and scalars must have equal length');\n  // if (plength === 0) throw new Error('array must be of length >= 2');\n  const zero = c.ZERO;\n  const wbits = bitLen(BigInt(plength));\n  let windowSize = 1; // bits\n  if (wbits > 12) windowSize = wbits - 3;\n  else if (wbits > 4) windowSize = wbits - 2;\n  else if (wbits > 0) windowSize = 2;\n  const MASK = bitMask(windowSize);\n  const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n  let sum = zero;\n  for (let i = lastBits; i >= 0; i -= windowSize) {\n    buckets.fill(zero);\n    for (let j = 0; j < slength; j++) {\n      const scalar = scalars[j];\n      const wbits = Number((scalar >> BigInt(i)) & MASK);\n      buckets[wbits] = buckets[wbits].add(points[j]);\n    }\n    let resI = zero; // not using this will do small speed-up, but will lose ct\n    // Skip first bucket, because it is zero\n    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n      sumI = sumI.add(buckets[j]);\n      resI = resI.add(sumI);\n    }\n    sum = sum.add(resI);\n    if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();\n  }\n  return sum as P;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  c: PC,\n  points: P[],\n  windowSize: number\n): (scalars: bigint[]) => P {\n  /**\n   * Performance Analysis of Window-based Precomputation\n   *\n   * Base Case (256-bit scalar, 8-bit window):\n   * - Standard precomputation requires:\n   *   - 31 additions per scalar \u00D7 256 scalars = 7,936 ops\n   *   - Plus 255 summary additions = 8,191 total ops\n   *   Note: Summary additions can be optimized via accumulator\n   *\n   * Chunked Precomputation Analysis:\n   * - Using 32 chunks requires:\n   *   - 255 additions per chunk\n   *   - 256 doublings\n   *   - Total: (255 \u00D7 32) + 256 = 8,416 ops\n   *\n   * Memory Usage Comparison:\n   * Window Size | Standard Points | Chunked Points\n   * ------------|-----------------|---------------\n   *     4-bit   |     520         |      15\n   *     8-bit   |    4,224        |     255\n   *    10-bit   |   13,824        |   1,023\n   *    16-bit   |  557,056        |  65,535\n   *\n   * Key Advantages:\n   * 1. Enables larger window sizes due to reduced memory overhead\n   * 2. More efficient for smaller scalar counts:\n   *    - 16 chunks: (16 \u00D7 255) + 256 = 4,336 ops\n   *    - ~2x faster than standard 8,191 ops\n   *\n   * Limitations:\n   * - Not suitable for plain precomputes (requires 256 constant doublings)\n   * - Performance degrades with larger scalar counts:\n   *   - Optimal for ~256 scalars\n   *   - Less efficient for 4096+ scalars (Pippenger preferred)\n   */\n  const fieldN = c.Fn;\n  validateW(windowSize, fieldN.BITS);\n  validateMSMPoints(points, c);\n  const zero = c.ZERO;\n  const tableSize = 2 ** windowSize - 1; // table size (without zero)\n  const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n  const MASK = bitMask(windowSize);\n  const tables = points.map((p: P) => {\n    const res = [];\n    for (let i = 0, acc = p; i < tableSize; i++) {\n      res.push(acc);\n      acc = acc.add(p);\n    }\n    return res;\n  });\n  return (scalars: bigint[]): P => {\n    validateMSMScalars(scalars, fieldN);\n    if (scalars.length > points.length)\n      throw new Error('array of scalars must be smaller than array of points');\n    let res = zero;\n    for (let i = 0; i < chunks; i++) {\n      // No need to double if accumulator is still zero.\n      if (res !== zero) for (let j = 0; j < windowSize; j++) res = res.double();\n      const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n      for (let j = 0; j < scalars.length; j++) {\n        const n = scalars[j];\n        const curr = Number((n >> shiftBy) & MASK);\n        if (!curr) continue; // skip zero scalars chunks\n        res = res.add(tables[j][curr - 1]);\n      }\n    }\n    return res;\n  };\n}\n\nexport type ValidCurveParams<T> = {\n  p: bigint;\n  n: bigint;\n  h: bigint;\n  a: T;\n  b?: T;\n  d?: T;\n  Gx: T;\n  Gy: T;\n};\n\nfunction createField<T>(order: bigint, field?: IField<T>, isLE?: boolean): IField<T> {\n  if (field) {\n    if (field.ORDER !== order) throw new Error('Field.ORDER must match order: Fp == p, Fn == n');\n    validateField(field);\n    return field;\n  } else {\n    return Field(order, { isLE }) as unknown as IField<T>;\n  }\n}\nexport type FpFn<T> = { Fp: IField<T>; Fn: IField<bigint> };\n\n/** Validates CURVE opts and creates fields */\nexport function createCurveFields<T>(\n  type: 'weierstrass' | 'edwards',\n  CURVE: ValidCurveParams<T>,\n  curveOpts: Partial<FpFn<T>> = {},\n  FpFnLE?: boolean\n): FpFn<T> & { CURVE: ValidCurveParams<T> } {\n  if (FpFnLE === undefined) FpFnLE = type === 'edwards';\n  if (!CURVE || typeof CURVE !== 'object') throw new Error(`expected valid ${type} CURVE object`);\n  for (const p of ['p', 'n', 'h'] as const) {\n    const val = CURVE[p];\n    if (!(typeof val === 'bigint' && val > _0n))\n      throw new Error(`CURVE.${p} must be positive bigint`);\n  }\n  const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);\n  const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);\n  const _b: 'b' | 'd' = type === 'weierstrass' ? 'b' : 'd';\n  const params = ['Gx', 'Gy', 'a', _b] as const;\n  for (const p of params) {\n    // @ts-ignore\n    if (!Fp.isValid(CURVE[p]))\n      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n  }\n  CURVE = Object.freeze(Object.assign({}, CURVE));\n  return { CURVE, Fp, Fn };\n}\n\ntype KeygenFn = (\n  seed?: Uint8Array,\n  isCompressed?: boolean\n) => { secretKey: Uint8Array; publicKey: Uint8Array };\nexport function createKeygen(\n  randomSecretKey: Function,\n  getPublicKey: Signer['getPublicKey']\n): KeygenFn {\n  return function keygen(seed?: Uint8Array) {\n    const secretKey = randomSecretKey(seed);\n    return { secretKey, publicKey: getPublicKey(secretKey) };\n  };\n}\n", "/**\n * Twisted Edwards curve. The formula is: ax\u00B2 + y\u00B2 = 1 + dx\u00B2y\u00B2.\n * For design rationale of types / exports, see weierstrass module documentation.\n * Untwisted Edwards curves exist, but they aren't used in real-world protocols.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  abool,\n  abytes,\n  aInRange,\n  bytesToHex,\n  bytesToNumberLE,\n  concatBytes,\n  copyBytes,\n  hexToBytes,\n  isBytes,\n  memoized,\n  notImplemented,\n  validateObject,\n  randomBytes as wcRandomBytes,\n  type FHash,\n  type Signer,\n} from '../utils.ts';\nimport {\n  createCurveFields,\n  createKeygen,\n  normalizeZ,\n  wNAF,\n  type AffinePoint,\n  type CurveLengths,\n  type CurvePoint,\n  type CurvePointCons,\n} from './curve.ts';\nimport { type IField } from './modular.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n\n/** Instance of Extended Point with coordinates in X, Y, Z, T. */\nexport interface EdwardsPoint extends CurvePoint<bigint, EdwardsPoint> {\n  /** extended X coordinate. Different from affine x. */\n  readonly X: bigint;\n  /** extended Y coordinate. Different from affine y. */\n  readonly Y: bigint;\n  /** extended Z coordinate */\n  readonly Z: bigint;\n  /** extended T coordinate */\n  readonly T: bigint;\n}\n/** Static methods of Extended Point with coordinates in X, Y, Z, T. */\nexport interface EdwardsPointCons extends CurvePointCons<EdwardsPoint> {\n  new (X: bigint, Y: bigint, Z: bigint, T: bigint): EdwardsPoint;\n  CURVE(): EdwardsOpts;\n  fromBytes(bytes: Uint8Array, zip215?: boolean): EdwardsPoint;\n  fromHex(hex: string, zip215?: boolean): EdwardsPoint;\n}\n\n/**\n * Twisted Edwards curve options.\n *\n * * a: formula param\n * * d: formula param\n * * p: prime characteristic (order) of finite field, in which arithmetics is done\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * h: cofactor. h*n is group order; n is subgroup order\n * * Gx: x coordinate of generator point a.k.a. base point\n * * Gy: y coordinate of generator point\n */\nexport type EdwardsOpts = Readonly<{\n  p: bigint;\n  n: bigint;\n  h: bigint;\n  a: bigint;\n  d: bigint;\n  Gx: bigint;\n  Gy: bigint;\n}>;\n\n/**\n * Extra curve options for Twisted Edwards.\n *\n * * Fp: redefined Field over curve.p\n * * Fn: redefined Field over curve.n\n * * uvRatio: helper function for decompression, calculating \u221A(u/v)\n */\nexport type EdwardsExtraOpts = Partial<{\n  Fp: IField<bigint>;\n  Fn: IField<bigint>;\n  FpFnLE: boolean;\n  uvRatio: (u: bigint, v: bigint) => { isValid: boolean; value: bigint };\n}>;\n\n/**\n * EdDSA (Edwards Digital Signature algorithm) options.\n *\n * * hash: hash function used to hash secret keys and messages\n * * adjustScalarBytes: clears bits to get valid field element\n * * domain: Used for hashing\n * * mapToCurve: for hash-to-curve standard\n * * prehash: RFC 8032 pre-hashing of messages to sign() / verify()\n * * randomBytes: function generating random bytes, used for randomSecretKey\n */\nexport type EdDSAOpts = Partial<{\n  adjustScalarBytes: (bytes: Uint8Array) => Uint8Array;\n  domain: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array;\n  mapToCurve: (scalar: bigint[]) => AffinePoint<bigint>;\n  prehash: FHash;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n}>;\n\n/**\n * EdDSA (Edwards Digital Signature algorithm) interface.\n *\n * Allows to create and verify signatures, create public and secret keys.\n */\nexport interface EdDSA {\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n  getPublicKey: (secretKey: Uint8Array) => Uint8Array;\n  sign: (\n    message: Uint8Array,\n    secretKey: Uint8Array,\n    options?: { context?: Uint8Array }\n  ) => Uint8Array;\n  verify: (\n    sig: Uint8Array,\n    message: Uint8Array,\n    publicKey: Uint8Array,\n    options?: { context?: Uint8Array; zip215: boolean }\n  ) => boolean;\n  Point: EdwardsPointCons;\n  utils: {\n    randomSecretKey: (seed?: Uint8Array) => Uint8Array;\n    isValidSecretKey: (secretKey: Uint8Array) => boolean;\n    isValidPublicKey: (publicKey: Uint8Array, zip215?: boolean) => boolean;\n\n    /**\n     * Converts ed public key to x public key.\n     *\n     * There is NO `fromMontgomery`:\n     * - There are 2 valid ed25519 points for every x25519, with flipped coordinate\n     * - Sometimes there are 0 valid ed25519 points, because x25519 *additionally*\n     *   accepts inputs on the quadratic twist, which can't be moved to ed25519\n     *\n     * @example\n     * ```js\n     * const someonesPub_ed = ed25519.getPublicKey(ed25519.utils.randomSecretKey());\n     * const someonesPub = ed25519.utils.toMontgomery(someonesPub);\n     * const aPriv = x25519.utils.randomSecretKey();\n     * const shared = x25519.getSharedSecret(aPriv, someonesPub)\n     * ```\n     */\n    toMontgomery: (publicKey: Uint8Array) => Uint8Array;\n    /**\n     * Converts ed secret key to x secret key.\n     * @example\n     * ```js\n     * const someonesPub = x25519.getPublicKey(x25519.utils.randomSecretKey());\n     * const aPriv_ed = ed25519.utils.randomSecretKey();\n     * const aPriv = ed25519.utils.toMontgomerySecret(aPriv_ed);\n     * const shared = x25519.getSharedSecret(aPriv, someonesPub)\n     * ```\n     */\n    toMontgomerySecret: (secretKey: Uint8Array) => Uint8Array;\n    getExtendedPublicKey: (key: Uint8Array) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: EdwardsPoint;\n      pointBytes: Uint8Array;\n    };\n  };\n  lengths: CurveLengths;\n}\n\nfunction isEdValidXY(Fp: IField<bigint>, CURVE: EdwardsOpts, x: bigint, y: bigint): boolean {\n  const x2 = Fp.sqr(x);\n  const y2 = Fp.sqr(y);\n  const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n  const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n  return Fp.eql(left, right);\n}\n\nexport function edwards(params: EdwardsOpts, extraOpts: EdwardsExtraOpts = {}): EdwardsPointCons {\n  const validated = createCurveFields('edwards', params, extraOpts, extraOpts.FpFnLE);\n  const { Fp, Fn } = validated;\n  let CURVE = validated.CURVE as EdwardsOpts;\n  const { h: cofactor } = CURVE;\n  validateObject(extraOpts, {}, { uvRatio: 'function' });\n\n  // Important:\n  // There are some places where Fp.BYTES is used instead of nByteLength.\n  // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n  // TODO: test and find curves which behave otherwise.\n  const MASK = _2n << (BigInt(Fn.BYTES * 8) - _1n);\n  const modP = (n: bigint) => Fp.create(n); // Function overrides\n\n  // sqrt(u/v)\n  const uvRatio =\n    extraOpts.uvRatio ||\n    ((u: bigint, v: bigint) => {\n      try {\n        return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };\n      } catch (e) {\n        return { isValid: false, value: _0n };\n      }\n    });\n\n  // Validate whether the passed curve params are valid.\n  // equation ax\u00B2 + y\u00B2 = 1 + dx\u00B2y\u00B2 should work for generator point.\n  if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))\n    throw new Error('bad curve params: generator point');\n\n  /**\n   * Asserts coordinate is valid: 0 <= n < MASK.\n   * Coordinates >= Fp.ORDER are allowed for zip215.\n   */\n  function acoord(title: string, n: bigint, banZero = false) {\n    const min = banZero ? _1n : _0n;\n    aInRange('coordinate ' + title, n, min, MASK);\n    return n;\n  }\n\n  function aedpoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('EdwardsPoint expected');\n  }\n  // Converts Extended point to default (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  const toAffineMemo = memoized((p: Point, iz?: bigint): AffinePoint<bigint> => {\n    const { X, Y, Z } = p;\n    const is0 = p.is0();\n    if (iz == null) iz = is0 ? _8n : (Fp.inv(Z) as bigint); // 8 was chosen arbitrarily\n    const x = modP(X * iz);\n    const y = modP(Y * iz);\n    const zz = Fp.mul(Z, iz);\n    if (is0) return { x: _0n, y: _1n };\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return { x, y };\n  });\n  const assertValidMemo = memoized((p: Point) => {\n    const { a, d } = CURVE;\n    if (p.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n    // Equation in affine coordinates: ax\u00B2 + y\u00B2 = 1 + dx\u00B2y\u00B2\n    // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX\u00B2 + Y\u00B2)Z\u00B2 = Z\u2074 + dX\u00B2Y\u00B2\n    const { X, Y, Z, T } = p;\n    const X2 = modP(X * X); // X\u00B2\n    const Y2 = modP(Y * Y); // Y\u00B2\n    const Z2 = modP(Z * Z); // Z\u00B2\n    const Z4 = modP(Z2 * Z2); // Z\u2074\n    const aX2 = modP(X2 * a); // aX\u00B2\n    const left = modP(Z2 * modP(aX2 + Y2)); // (aX\u00B2 + Y\u00B2)Z\u00B2\n    const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z\u2074 + dX\u00B2Y\u00B2\n    if (left !== right) throw new Error('bad point: equation left != right (1)');\n    // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n    const XY = modP(X * Y);\n    const ZT = modP(Z * T);\n    if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    return true;\n  });\n\n  // Extended Point works in extended coordinates: (X, Y, Z, T) \u220B (x=X/Z, y=Y/Z, T=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point implements EdwardsPoint {\n    // base / generator point\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    // zero / infinity / identity point\n    static readonly ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    // math field\n    static readonly Fp = Fp;\n    // scalar field\n    static readonly Fn = Fn;\n\n    readonly X: bigint;\n    readonly Y: bigint;\n    readonly Z: bigint;\n    readonly T: bigint;\n\n    constructor(X: bigint, Y: bigint, Z: bigint, T: bigint) {\n      this.X = acoord('x', X);\n      this.Y = acoord('y', Y);\n      this.Z = acoord('z', Z, true);\n      this.T = acoord('t', T);\n      Object.freeze(this);\n    }\n\n    static CURVE(): EdwardsOpts {\n      return CURVE;\n    }\n\n    static fromAffine(p: AffinePoint<bigint>): Point {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const { x, y } = p || {};\n      acoord('x', x);\n      acoord('y', y);\n      return new Point(x, y, _1n, modP(x * y));\n    }\n\n    // Uses algo from RFC8032 5.1.3.\n    static fromBytes(bytes: Uint8Array, zip215 = false): Point {\n      const len = Fp.BYTES;\n      const { a, d } = CURVE;\n      bytes = copyBytes(abytes(bytes, len, 'point'));\n      abool(zip215, 'zip215');\n      const normed = copyBytes(bytes); // copy again, we'll manipulate it\n      const lastByte = bytes[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = bytesToNumberLE(normed);\n\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // RFC8032 prohibits >= p, but ZIP215 doesn't\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      const max = zip215 ? MASK : Fp.ORDER;\n      aInRange('point.y', y, _0n, max);\n\n      // Ed25519: x\u00B2 = (y\u00B2-1)/(dy\u00B2+1) mod p. Ed448: x\u00B2 = (y\u00B2-1)/(dy\u00B2-1) mod p. Generic case:\n      // ax\u00B2+y\u00B2=1+dx\u00B2y\u00B2 => y\u00B2-1=dx\u00B2y\u00B2-ax\u00B2 => y\u00B2-1=x\u00B2(dy\u00B2-a) => x\u00B2=(y\u00B2-1)/(dy\u00B2-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y\u00B2 - 1\n      const v = modP(d * y2 - a); // v = d y\u00B2 + 1.\n      let { isValid, value: x } = uvRatio(u, v); // \u221A(u/v)\n      if (!isValid) throw new Error('bad point: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('bad point: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({ x, y });\n    }\n\n    static fromHex(hex: string, zip215 = false): Point {\n      return Point.fromBytes(hexToBytes(hex), zip215);\n    }\n\n    get x(): bigint {\n      return this.toAffine().x;\n    }\n    get y(): bigint {\n      return this.toAffine().y;\n    }\n\n    precompute(windowSize: number = 8, isLazy = true) {\n      wnaf.createCache(this, windowSize);\n      if (!isLazy) this.multiply(_2n); // random number\n      return this;\n    }\n\n    // Useful in fromAffine() - not for fromBytes(), which always created valid points.\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    // Compare one point to another.\n    equals(other: Point): boolean {\n      aedpoint(other);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const { X: X2, Y: Y2, Z: Z2 } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n\n    is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    negate(): Point {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));\n    }\n\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double(): Point {\n      const { a } = CURVE;\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other: Point) {\n      aedpoint(other);\n      const { a, d } = CURVE;\n      const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;\n      const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    subtract(other: Point): Point {\n      return this.add(other.negate());\n    }\n\n    // Constant-time multiplication.\n    multiply(scalar: bigint): Point {\n      // 1 <= scalar < L\n      if (!Fn.isValidNot0(scalar)) throw new Error('invalid scalar: expected 1 <= sc < curve.n');\n      const { p, f } = wnaf.cached(this, scalar, (p) => normalizeZ(Point, p));\n      return normalizeZ(Point, [p, f])[0];\n    }\n\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n    multiplyUnsafe(scalar: bigint, acc = Point.ZERO): Point {\n      // 0 <= scalar < L\n      if (!Fn.isValid(scalar)) throw new Error('invalid scalar: expected 0 <= sc < curve.n');\n      if (scalar === _0n) return Point.ZERO;\n      if (this.is0() || scalar === _1n) return this;\n      return wnaf.unsafe(this, scalar, (p) => normalizeZ(Point, p), acc);\n    }\n\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder(): boolean {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree(): boolean {\n      return wnaf.unsafe(this, CURVE.n).is0();\n    }\n\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(invertedZ?: bigint): AffinePoint<bigint> {\n      return toAffineMemo(this, invertedZ);\n    }\n\n    clearCofactor(): Point {\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    toBytes(): Uint8Array {\n      const { x, y } = this.toAffine();\n      // Fp.toBytes() allows non-canonical encoding of y (>= p).\n      const bytes = Fp.toBytes(y);\n      // Each y has 2 valid points: (x, y), (x,-y).\n      // When compressing, it's enough to store y and use the last byte to encode sign of x\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0;\n      return bytes;\n    }\n    toHex(): string {\n      return bytesToHex(this.toBytes());\n    }\n\n    toString() {\n      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n    }\n  }\n  const wnaf = new wNAF(Point, Fn.BITS);\n  Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n  return Point;\n}\n\n/**\n * Base class for prime-order points like Ristretto255 and Decaf448.\n * These points eliminate cofactor issues by representing equivalence classes\n * of Edwards curve points.\n */\nexport abstract class PrimeEdwardsPoint<T extends PrimeEdwardsPoint<T>>\n  implements CurvePoint<bigint, T>\n{\n  static BASE: PrimeEdwardsPoint<any>;\n  static ZERO: PrimeEdwardsPoint<any>;\n  static Fp: IField<bigint>;\n  static Fn: IField<bigint>;\n\n  protected readonly ep: EdwardsPoint;\n\n  constructor(ep: EdwardsPoint) {\n    this.ep = ep;\n  }\n\n  // Abstract methods that must be implemented by subclasses\n  abstract toBytes(): Uint8Array;\n  abstract equals(other: T): boolean;\n\n  // Static methods that must be implemented by subclasses\n  static fromBytes(_bytes: Uint8Array): any {\n    notImplemented();\n  }\n\n  static fromHex(_hex: string): any {\n    notImplemented();\n  }\n\n  get x(): bigint {\n    return this.toAffine().x;\n  }\n  get y(): bigint {\n    return this.toAffine().y;\n  }\n\n  // Common implementations\n  clearCofactor(): T {\n    // no-op for prime-order groups\n    return this as any;\n  }\n\n  assertValidity(): void {\n    this.ep.assertValidity();\n  }\n\n  toAffine(invertedZ?: bigint): AffinePoint<bigint> {\n    return this.ep.toAffine(invertedZ);\n  }\n\n  toHex(): string {\n    return bytesToHex(this.toBytes());\n  }\n\n  toString(): string {\n    return this.toHex();\n  }\n\n  isTorsionFree(): boolean {\n    return true;\n  }\n\n  isSmallOrder(): boolean {\n    return false;\n  }\n\n  add(other: T): T {\n    this.assertSame(other);\n    return this.init(this.ep.add(other.ep));\n  }\n\n  subtract(other: T): T {\n    this.assertSame(other);\n    return this.init(this.ep.subtract(other.ep));\n  }\n\n  multiply(scalar: bigint): T {\n    return this.init(this.ep.multiply(scalar));\n  }\n\n  multiplyUnsafe(scalar: bigint): T {\n    return this.init(this.ep.multiplyUnsafe(scalar));\n  }\n\n  double(): T {\n    return this.init(this.ep.double());\n  }\n\n  negate(): T {\n    return this.init(this.ep.negate());\n  }\n\n  precompute(windowSize?: number, isLazy?: boolean): T {\n    return this.init(this.ep.precompute(windowSize, isLazy));\n  }\n\n  // Helper methods\n  abstract is0(): boolean;\n  protected abstract assertSame(other: T): void;\n  protected abstract init(ep: EdwardsPoint): T;\n}\n\n/**\n * Initializes EdDSA signatures over given Edwards curve.\n */\nexport function eddsa(Point: EdwardsPointCons, cHash: FHash, eddsaOpts: EdDSAOpts = {}): EdDSA {\n  if (typeof cHash !== 'function') throw new Error('\"hash\" function param is required');\n  validateObject(\n    eddsaOpts,\n    {},\n    {\n      adjustScalarBytes: 'function',\n      randomBytes: 'function',\n      domain: 'function',\n      prehash: 'function',\n      mapToCurve: 'function',\n    }\n  );\n\n  const { prehash } = eddsaOpts;\n  const { BASE, Fp, Fn } = Point;\n\n  const randomBytes = eddsaOpts.randomBytes || wcRandomBytes;\n  const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes: Uint8Array) => bytes);\n  const domain =\n    eddsaOpts.domain ||\n    ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => {\n      abool(phflag, 'phflag');\n      if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n      return data;\n    }); // NOOP\n\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash: Uint8Array): bigint {\n    return Fn.create(bytesToNumberLE(hash)); // Not Fn.fromBytes: it has length limit\n  }\n\n  // Get the hashed private scalar per RFC8032 5.1.5\n  function getPrivateScalar(key: Uint8Array) {\n    const len = lengths.secretKey;\n    abytes(key, lengths.secretKey, 'secretKey');\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = abytes(cHash(key), 2 * len, 'hashedSecretKey');\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    return { head, prefix, scalar };\n  }\n\n  /** Convenience method that creates public key from scalar. RFC8032 5.1.5 */\n  function getExtendedPublicKey(secretKey: Uint8Array) {\n    const { head, prefix, scalar } = getPrivateScalar(secretKey);\n    const point = BASE.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toBytes();\n    return { head, prefix, scalar, point, pointBytes };\n  }\n\n  /** Calculates EdDSA pub key. RFC8032 5.1.5. */\n  function getPublicKey(secretKey: Uint8Array): Uint8Array {\n    return getExtendedPublicKey(secretKey).pointBytes;\n  }\n\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context: Uint8Array = Uint8Array.of(), ...msgs: Uint8Array[]) {\n    const msg = concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, abytes(context, undefined, 'context'), !!prehash)));\n  }\n\n  /** Signs message with secret key. RFC8032 5.1.6 */\n  function sign(\n    msg: Uint8Array,\n    secretKey: Uint8Array,\n    options: { context?: Uint8Array } = {}\n  ): Uint8Array {\n    msg = abytes(msg, undefined, 'message');\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = BASE.multiply(r).toBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = Fn.create(r + k * scalar); // S = (r + k * s) mod L\n    if (!Fn.isValid(s)) throw new Error('sign failed: invalid s'); // 0 <= s < L\n    const rs = concatBytes(R, Fn.toBytes(s));\n    return abytes(rs, lengths.signature, 'result');\n  }\n\n  // verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\n  const verifyOpts: { context?: Uint8Array; zip215?: boolean } = { zip215: true };\n\n  /**\n   * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n   * An extended group equation is checked.\n   */\n  function verify(\n    sig: Uint8Array,\n    msg: Uint8Array,\n    publicKey: Uint8Array,\n    options = verifyOpts\n  ): boolean {\n    const { context, zip215 } = options;\n    const len = lengths.signature;\n    sig = abytes(sig, len, 'signature');\n    msg = abytes(msg, undefined, 'message');\n    publicKey = abytes(publicKey, lengths.publicKey, 'publicKey');\n    if (zip215 !== undefined) abool(zip215, 'zip215');\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n\n    const mid = len / 2;\n    const r = sig.subarray(0, mid);\n    const s = bytesToNumberLE(sig.subarray(mid, len));\n    let A, R, SB;\n    try {\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      A = Point.fromBytes(publicKey, zip215);\n      R = Point.fromBytes(r, zip215);\n      SB = BASE.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false; // zip215 allows public keys of small order\n\n    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // Extended group equation\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().is0();\n  }\n\n  const _size = Fp.BYTES; // 32 for ed25519, 57 for ed448\n  const lengths = {\n    secretKey: _size,\n    publicKey: _size,\n    signature: 2 * _size,\n    seed: _size,\n  };\n  function randomSecretKey(seed = randomBytes(lengths.seed)): Uint8Array {\n    return abytes(seed, lengths.seed, 'seed');\n  }\n\n  function isValidSecretKey(key: Uint8Array): boolean {\n    return isBytes(key) && key.length === Fn.BYTES;\n  }\n\n  function isValidPublicKey(key: Uint8Array, zip215?: boolean): boolean {\n    try {\n      return !!Point.fromBytes(key, zip215);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  const utils = {\n    getExtendedPublicKey,\n    randomSecretKey,\n    isValidSecretKey,\n    isValidPublicKey,\n    /**\n     * Converts ed public key to x public key. Uses formula:\n     * - ed25519:\n     *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n     *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n     * - ed448:\n     *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`\n     *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`\n     */\n    toMontgomery(publicKey: Uint8Array): Uint8Array {\n      const { y } = Point.fromBytes(publicKey);\n      const size = lengths.publicKey;\n      const is25519 = size === 32;\n      if (!is25519 && size !== 57) throw new Error('only defined for 25519 and 448');\n      const u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);\n      return Fp.toBytes(u);\n    },\n    toMontgomerySecret(secretKey: Uint8Array): Uint8Array {\n      const size = lengths.secretKey;\n      abytes(secretKey, size);\n      const hashed = cHash(secretKey.subarray(0, size));\n      return adjustScalarBytes(hashed).subarray(0, size);\n    },\n  };\n\n  return Object.freeze({\n    keygen: createKeygen(randomSecretKey, getPublicKey),\n    getPublicKey,\n    sign,\n    verify,\n    utils,\n    Point,\n    lengths,\n  }) satisfies Signer;\n}\n", "/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha2.js';\nimport { abytes, concatBytes, hexToBytes } from '@noble/hashes/utils.js';\nimport { type AffinePoint } from './abstract/curve.ts';\nimport {\n  eddsa,\n  edwards,\n  PrimeEdwardsPoint,\n  type EdDSA,\n  type EdDSAOpts,\n  type EdwardsOpts,\n  type EdwardsPoint,\n  type EdwardsPointCons,\n} from './abstract/edwards.ts';\nimport {\n  _DST_scalar,\n  createHasher,\n  expand_message_xmd,\n  type H2CDSTOpts,\n  type H2CHasher,\n  type H2CHasherBase,\n} from './abstract/hash-to-curve.ts';\nimport {\n  FpInvertBatch,\n  FpSqrtEven,\n  isNegativeLE,\n  mod,\n  pow2,\n  type IField,\n} from './abstract/modular.ts';\nimport { montgomery, type MontgomeryECDH } from './abstract/montgomery.ts';\nimport { createORPF, type OPRF } from './abstract/oprf.ts';\nimport { asciiToBytes, bytesToNumberLE, equalBytes } from './utils.ts';\n\n// prettier-ignore\nconst _0n = /* @__PURE__ */ BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\n\n// P = 2n**255n - 19n\nconst ed25519_CURVE_p = BigInt(\n  '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed'\n);\n// N = 2n**252n + 27742317777372353535851937790883648493n\n// a = Fp.create(BigInt(-1))\n// d = -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))\nconst ed25519_CURVE: EdwardsOpts = /* @__PURE__ */ (() => ({\n  p: ed25519_CURVE_p,\n  n: BigInt('0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed'),\n  h: _8n,\n  a: BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec'),\n  d: BigInt('0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3'),\n  Gx: BigInt('0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a'),\n  Gy: BigInt('0x6666666666666666666666666666666666666666666666666666666666666658'),\n}))();\n\nfunction ed25519_pow_2_252_3(x: bigint) {\n  // prettier-ignore\n  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n  const P = ed25519_CURVE_p;\n  const x2 = (x * x) % P;\n  const b2 = (x2 * x) % P; // x^3, 11\n  const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n  const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n  const b10 = (pow2(b5, _5n, P) * b5) % P;\n  const b20 = (pow2(b10, _10n, P) * b10) % P;\n  const b40 = (pow2(b20, _20n, P) * b20) % P;\n  const b80 = (pow2(b40, _40n, P) * b40) % P;\n  const b160 = (pow2(b80, _80n, P) * b80) % P;\n  const b240 = (pow2(b160, _80n, P) * b80) % P;\n  const b250 = (pow2(b240, _10n, P) * b10) % P;\n  const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n  // ^ To pow to (p+3)/8, multiply it by x.\n  return { pow_p_5_8, b2 };\n}\n\nfunction adjustScalarBytes(bytes: Uint8Array): Uint8Array {\n  // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n  // set the three least significant bits of the first byte\n  bytes[0] &= 248; // 0b1111_1000\n  // and the most significant bit of the last to zero,\n  bytes[31] &= 127; // 0b0111_1111\n  // set the second most significant bit of the last byte to 1\n  bytes[31] |= 64; // 0b0100_0000\n  return bytes;\n}\n\n// \u221A(-1) aka \u221A(a) aka 2^((p-1)/4)\n// Fp.sqrt(Fp.neg(1))\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt(\n  '19681161376707505956807079304988542015446066515923890162744021073123829784752'\n);\n// sqrt(u/v)\nfunction uvRatio(u: bigint, v: bigint): { isValid: boolean; value: bigint } {\n  const P = ed25519_CURVE_p;\n  const v3 = mod(v * v * v, P); // v\u00B3\n  const v7 = mod(v3 * v3 * v, P); // v\u2077\n  // (p+3)/8 and (p-5)/8\n  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n  let x = mod(u * v3 * pow, P); // (uv\u00B3)(uv\u2077)^(p-5)/8\n  const vx2 = mod(v * x * x, P); // vx\u00B2\n  const root1 = x; // First root candidate\n  const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n  const useRoot1 = vx2 === u; // If vx\u00B2 = u (mod p), x is a square root\n  const useRoot2 = vx2 === mod(-u, P); // If vx\u00B2 = -u, set x <-- x * 2^((p-1)/4)\n  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx\u00B2 = -u\u221A(-1)\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n  if (isNegativeLE(x, P)) x = mod(-x, P);\n  return { isValid: useRoot1 || useRoot2, value: x };\n}\n\nconst ed25519_Point = /* @__PURE__ */ edwards(ed25519_CURVE, { uvRatio });\nconst Fp = /* @__PURE__ */ (() => ed25519_Point.Fp)();\nconst Fn = /* @__PURE__ */ (() => ed25519_Point.Fn)();\n\nfunction ed25519_domain(data: Uint8Array, ctx: Uint8Array, phflag: boolean) {\n  if (ctx.length > 255) throw new Error('Context is too big');\n  return concatBytes(\n    asciiToBytes('SigEd25519 no Ed25519 collisions'),\n    new Uint8Array([phflag ? 1 : 0, ctx.length]),\n    ctx,\n    data\n  );\n}\n\nfunction ed(opts: EdDSAOpts) {\n  return eddsa(ed25519_Point, sha512, Object.assign({ adjustScalarBytes }, opts));\n}\n\n/**\n * ed25519 curve with EdDSA signatures.\n * @example\n * ```js\n * import { ed25519 } from '@noble/curves/ed25519.js';\n * const { secretKey, publicKey } = ed25519.keygen();\n * // const publicKey = ed25519.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello noble');\n * const sig = ed25519.sign(msg, secretKey);\n * const isValid = ed25519.verify(sig, msg, pub); // ZIP215\n * // RFC8032 / FIPS 186-5\n * const isValid2 = ed25519.verify(sig, msg, pub, { zip215: false });\n * ```\n */\nexport const ed25519: EdDSA = /* @__PURE__ */ ed({});\n/** Context version of ed25519 (ctx for domain separation). See {@link ed25519} */\nexport const ed25519ctx: EdDSA = /* @__PURE__ */ ed({ domain: ed25519_domain });\n/** Prehashed version of ed25519. See {@link ed25519} */\nexport const ed25519ph: EdDSA = /* @__PURE__ */ ed({ domain: ed25519_domain, prehash: sha512 });\n\n/**\n * ECDH using curve25519 aka x25519.\n * @example\n * ```js\n * import { x25519 } from '@noble/curves/ed25519.js';\n * const alice = x25519.keygen();\n * const bob = x25519.keygen();\n * const shared = x25519.getSharedSecret(alice.secretKey, bob.publicKey);\n * ```\n */\nexport const x25519: MontgomeryECDH = /* @__PURE__ */ (() => {\n  const P = ed25519_CURVE_p;\n  return montgomery({\n    P,\n    type: 'x25519',\n    powPminus2: (x: bigint): bigint => {\n      // x^(p-2) aka x^(2^255-21)\n      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n      return mod(pow2(pow_p_5_8, _3n, P) * b2, P);\n    },\n    adjustScalarBytes,\n  });\n})();\n\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = /* @__PURE__ */ (() => (ed25519_CURVE_p + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n\n/**\n * RFC 9380 method `map_to_curve_elligator2_curve25519`. Experimental name: may be renamed later.\n * @private\n */\n// prettier-ignore\nexport function _map_to_curve_elligator2_curve25519(u: bigint): {\n  xMn: bigint, xMd: bigint, yMn: bigint, yMd: bigint\n} {\n  const ELL2_C4 = (ed25519_CURVE_p - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n  const ELL2_J = BigInt(486662);\n\n  let tv1 = Fp.sqr(u);          //  1.  tv1 = u^2\n  tv1 = Fp.mul(tv1, _2n);       //  2.  tv1 = 2 * tv1\n  let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n  let x1n = Fp.neg(ELL2_J);     //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n  let tv2 = Fp.sqr(xd);         //  5.  tv2 = xd^2\n  let gxd = Fp.mul(tv2, xd);    //  6.  gxd = tv2 * xd        # gxd = xd^3\n  let gx1 = Fp.mul(tv1, ELL2_J);//  7.  gx1 = J * tv1         # x1n + J * xd\n  gx1 = Fp.mul(gx1, x1n);       //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n  gx1 = Fp.add(gx1, tv2);       //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n  gx1 = Fp.mul(gx1, x1n);       //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n  let tv3 = Fp.sqr(gxd);        //  11. tv3 = gxd^2\n  tv2 = Fp.sqr(tv3);            //  12. tv2 = tv3^2           # gxd^4\n  tv3 = Fp.mul(tv3, gxd);       //  13. tv3 = tv3 * gxd       # gxd^3\n  tv3 = Fp.mul(tv3, gx1);       //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n  tv2 = Fp.mul(tv2, tv3);       //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n  let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n  y11 = Fp.mul(y11, tv3);       //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n  let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n  tv2 = Fp.sqr(y11);            //  19. tv2 = y11^2\n  tv2 = Fp.mul(tv2, gxd);       //  20. tv2 = tv2 * gxd\n  let e1 = Fp.eql(tv2, gx1);    //  21.  e1 = tv2 == gx1\n  let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n  let x2n = Fp.mul(x1n, tv1);   //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n  let y21 = Fp.mul(y11, u);     //  24. y21 = y11 * u\n  y21 = Fp.mul(y21, ELL2_C2);   //  25. y21 = y21 * c2\n  let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n  let gx2 = Fp.mul(gx1, tv1);   //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n  tv2 = Fp.sqr(y21);            //  28. tv2 = y21^2\n  tv2 = Fp.mul(tv2, gxd);       //  29. tv2 = tv2 * gxd\n  let e2 = Fp.eql(tv2, gx2);    //  30.  e2 = tv2 == gx2\n  let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n  tv2 = Fp.sqr(y1);             //  32. tv2 = y1^2\n  tv2 = Fp.mul(tv2, gxd);       //  33. tv2 = tv2 * gxd\n  let e3 = Fp.eql(tv2, gx1);    //  34.  e3 = tv2 == gx1\n  let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n  let y = Fp.cmov(y2, y1, e3);  //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n  let e4 = Fp.isOdd!(y);         //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n  y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\n\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u: bigint) {\n  const { xMn, xMd, yMn, yMd } = _map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n  // map_to_curve_elligator2_curve25519(u)\n  let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n  xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n  let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n  let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n  let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n  let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n  let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n  xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n  xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n  yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n  yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n  const [xd_inv, yd_inv] = FpInvertBatch(Fp, [xd, yd], true); // batch division\n  return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) }; //  13. return (xn, xd, yn, yd)\n}\n\n/** Hashing to ed25519 points / field. RFC 9380 methods. */\nexport const ed25519_hasher: H2CHasher<EdwardsPointCons> = /* @__PURE__ */ (() =>\n  createHasher(\n    ed25519_Point,\n    (scalars: bigint[]) => map_to_curve_elligator2_edwards25519(scalars[0]),\n    {\n      DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n      encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n      p: ed25519_CURVE_p,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha512,\n    }\n  ))();\n\n// \u221A(-1) aka \u221A(a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// \u221A(ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt(\n  '25063068953384623474111414158702152701244531502492656460079210482610430750235'\n);\n// 1 / \u221A(a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt(\n  '54469307008909316920995813868745141605393597292927456921205312896311721017578'\n);\n// 1-d\u00B2\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt(\n  '1159843021668779879193775521855586647937357759715417654439879720876111806838'\n);\n// (d-1)\u00B2\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt(\n  '40440834346308536858101042469323190826248399146238708352240133220865137265952'\n);\n// Calculates 1/\u221A(number)\nconst invertSqrt = (number: bigint) => uvRatio(_1n, number);\n\nconst MAX_255B = /* @__PURE__ */ BigInt(\n  '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n);\nconst bytes255ToNumberLE = (bytes: Uint8Array) => Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n\n/**\n * Computes Elligator map for Ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n * the [website](https://ristretto.group/formulas/elligator.html).\n */\nfunction calcElligatorRistrettoMap(r0: bigint): EdwardsPoint {\n  const { d } = ed25519_CURVE;\n  const P = ed25519_CURVE_p;\n  const mod = (n: bigint) => Fp.create(n);\n  const r = mod(SQRT_M1 * r0 * r0); // 1\n  const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n  let c = BigInt(-1); // 3\n  const D = mod((c - d * r) * mod(r + d)); // 4\n  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n  let s_ = mod(s * r0); // 6\n  if (!isNegativeLE(s_, P)) s_ = mod(-s_);\n  if (!Ns_D_is_sq) s = s_; // 7\n  if (!Ns_D_is_sq) c = r; // 8\n  const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n  const s2 = s * s;\n  const W0 = mod((s + s) * D); // 10\n  const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n  const W2 = mod(_1n - s2); // 12\n  const W3 = mod(_1n + s2); // 13\n  return new ed25519_Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n\n/**\n * Wrapper over Edwards Point for ristretto255.\n *\n * Each ed25519/EdwardsPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like EdwardsPoint,\n * but it should work in its own namespace: do not combine those two.\n * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */\nclass _RistrettoPoint extends PrimeEdwardsPoint<_RistrettoPoint> {\n  // Do NOT change syntax: the following gymnastics is done,\n  // because typescript strips comments, which makes bundlers disable tree-shaking.\n  // prettier-ignore\n  static BASE: _RistrettoPoint =\n    /* @__PURE__ */ (() => new _RistrettoPoint(ed25519_Point.BASE))();\n  // prettier-ignore\n  static ZERO: _RistrettoPoint =\n    /* @__PURE__ */ (() => new _RistrettoPoint(ed25519_Point.ZERO))();\n  // prettier-ignore\n  static Fp: IField<bigint> =\n    /* @__PURE__ */ (() => Fp)();\n  // prettier-ignore\n  static Fn: IField<bigint> =\n    /* @__PURE__ */ (() => Fn)();\n\n  constructor(ep: EdwardsPoint) {\n    super(ep);\n  }\n\n  static fromAffine(ap: AffinePoint<bigint>): _RistrettoPoint {\n    return new _RistrettoPoint(ed25519_Point.fromAffine(ap));\n  }\n\n  protected assertSame(other: _RistrettoPoint): void {\n    if (!(other instanceof _RistrettoPoint)) throw new Error('RistrettoPoint expected');\n  }\n\n  protected init(ep: EdwardsPoint): _RistrettoPoint {\n    return new _RistrettoPoint(ep);\n  }\n\n  static fromBytes(bytes: Uint8Array): _RistrettoPoint {\n    abytes(bytes, 32);\n    const { a, d } = ed25519_CURVE;\n    const P = ed25519_CURVE_p;\n    const mod = (n: bigint) => Fp.create(n);\n    const s = bytes255ToNumberLE(bytes);\n    // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n    // 3. Check that s is non-negative, or else abort\n    if (!equalBytes(Fp.toBytes(s), bytes) || isNegativeLE(s, P))\n      throw new Error('invalid ristretto255 encoding 1');\n    const s2 = mod(s * s);\n    const u1 = mod(_1n + a * s2); // 4 (a is -1)\n    const u2 = mod(_1n - a * s2); // 5\n    const u1_2 = mod(u1 * u1);\n    const u2_2 = mod(u2 * u2);\n    const v = mod(a * d * u1_2 - u2_2); // 6\n    const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n    const Dx = mod(I * u2); // 8\n    const Dy = mod(I * Dx * v); // 9\n    let x = mod((s + s) * Dx); // 10\n    if (isNegativeLE(x, P)) x = mod(-x); // 10\n    const y = mod(u1 * Dy); // 11\n    const t = mod(x * y); // 12\n    if (!isValid || isNegativeLE(t, P) || y === _0n)\n      throw new Error('invalid ristretto255 encoding 2');\n    return new _RistrettoPoint(new ed25519_Point(x, y, _1n, t));\n  }\n\n  /**\n   * Converts ristretto-encoded string to ristretto point.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).\n   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n   */\n  static fromHex(hex: string): _RistrettoPoint {\n    return _RistrettoPoint.fromBytes(hexToBytes(hex));\n  }\n\n  /**\n   * Encodes ristretto point to Uint8Array.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).\n   */\n  toBytes(): Uint8Array {\n    let { X, Y, Z, T } = this.ep;\n    const P = ed25519_CURVE_p;\n    const mod = (n: bigint) => Fp.create(n);\n    const u1 = mod(mod(Z + Y) * mod(Z - Y)); // 1\n    const u2 = mod(X * Y); // 2\n    // Square root always exists\n    const u2sq = mod(u2 * u2);\n    const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n    const D1 = mod(invsqrt * u1); // 4\n    const D2 = mod(invsqrt * u2); // 5\n    const zInv = mod(D1 * D2 * T); // 6\n    let D: bigint; // 7\n    if (isNegativeLE(T * zInv, P)) {\n      let _x = mod(Y * SQRT_M1);\n      let _y = mod(X * SQRT_M1);\n      X = _x;\n      Y = _y;\n      D = mod(D1 * INVSQRT_A_MINUS_D);\n    } else {\n      D = D2; // 8\n    }\n    if (isNegativeLE(X * zInv, P)) Y = mod(-Y); // 9\n    let s = mod((Z - Y) * D); // 10 (check footer's note, no sqrt(-a))\n    if (isNegativeLE(s, P)) s = mod(-s);\n    return Fp.toBytes(s); // 11\n  }\n\n  /**\n   * Compares two Ristretto points.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).\n   */\n  equals(other: _RistrettoPoint): boolean {\n    this.assertSame(other);\n    const { X: X1, Y: Y1 } = this.ep;\n    const { X: X2, Y: Y2 } = other.ep;\n    const mod = (n: bigint) => Fp.create(n);\n    // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n    const one = mod(X1 * Y2) === mod(Y1 * X2);\n    const two = mod(Y1 * Y2) === mod(X1 * X2);\n    return one || two;\n  }\n\n  is0(): boolean {\n    return this.equals(_RistrettoPoint.ZERO);\n  }\n}\n\nexport const ristretto255: {\n  Point: typeof _RistrettoPoint;\n} = { Point: _RistrettoPoint };\n\n/** Hashing to ristretto255 points / field. RFC 9380 methods. */\nexport const ristretto255_hasher: H2CHasherBase<typeof _RistrettoPoint> = {\n  Point: _RistrettoPoint,\n  /**\n  * Spec: https://www.rfc-editor.org/rfc/rfc9380.html#name-hashing-to-ristretto255. Caveats:\n  * * There are no test vectors\n  * * encodeToCurve / mapToCurve is undefined\n  * * mapToCurve would be `calcElligatorRistrettoMap(scalars[0])`, not ristretto255_map!\n  * * hashToScalar is undefined too, so we just use OPRF implementation\n  * * We cannot re-use 'createHasher', because ristretto255_map is different algorithm/RFC\n    (os2ip -> bytes255ToNumberLE)\n  * * mapToCurve == calcElligatorRistrettoMap, hashToCurve == ristretto255_map\n  * * hashToScalar is undefined in RFC9380 for ristretto, we are using version from OPRF here, using bytes255ToNumblerLE will create different result if we use bytes255ToNumberLE as os2ip\n  * * current version is closest to spec.\n  */\n  hashToCurve(msg: Uint8Array, options?: H2CDSTOpts): _RistrettoPoint {\n    // == 'hash_to_ristretto255'\n    const DST = options?.DST || 'ristretto255_XMD:SHA-512_R255MAP_RO_';\n    const xmd = expand_message_xmd(msg, DST, 64, sha512);\n    // NOTE: RFC 9380 incorrectly calls this function 'ristretto255_map', in RFC 9496 map was function inside (per point)\n    // That also lead to confustion that ristretto255_map is mapToCurve (it is not! it is old hashToCurve)\n    return ristretto255_hasher.deriveToCurve!(xmd);\n  },\n  hashToScalar(msg: Uint8Array, options: H2CDSTOpts = { DST: _DST_scalar }) {\n    const xmd = expand_message_xmd(msg, options.DST, 64, sha512);\n    return Fn.create(bytesToNumberLE(xmd));\n  },\n  /**\n   * HashToCurve-like construction based on RFC 9496 (Element Derivation).\n   * Converts 64 uniform random bytes into a curve point.\n   *\n   * WARNING: This represents an older hash-to-curve construction, preceding the finalization of RFC 9380.\n   * It was later reused as a component in the newer `hash_to_ristretto255` function defined in RFC 9380.\n   */\n  deriveToCurve(bytes: Uint8Array): _RistrettoPoint {\n    // https://www.rfc-editor.org/rfc/rfc9496.html#name-element-derivation\n    abytes(bytes, 64);\n    const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));\n    const R1 = calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));\n    const R2 = calcElligatorRistrettoMap(r2);\n    return new _RistrettoPoint(R1.add(R2));\n  },\n};\n\n/** ristretto255 OPRF, defined in RFC 9497. */\nexport const ristretto255_oprf: OPRF = /* @__PURE__ */ (() =>\n  createORPF({\n    name: 'ristretto255-SHA512',\n    Point: _RistrettoPoint,\n    hash: sha512,\n    hashToGroup: ristretto255_hasher.hashToCurve,\n    hashToScalar: ristretto255_hasher.hashToScalar,\n  }))();\n\n/**\n * Weird / bogus points, useful for debugging.\n * All 8 ed25519 points of 8-torsion subgroup can be generated from the point\n * T = `26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05`.\n * \u27E8T\u27E9 = { O, T, 2T, 3T, 4T, 5T, 6T, 7T }\n */\nexport const ED25519_TORSION_SUBGROUP: string[] = [\n  '0100000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n  '0000000000000000000000000000000000000000000000000000000000000080',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n  'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\n", "import { ed25519 as ed } from '@noble/curves/ed25519.js'\nimport { toString as uint8arrayToString } from 'uint8arrays/to-string'\nimport crypto from '../../webcrypto/index.js'\nimport type { Uint8ArrayKeyPair } from '../interface.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst PUBLIC_KEY_BYTE_LENGTH = 32\nconst PRIVATE_KEY_BYTE_LENGTH = 64 // private key is actually 32 bytes but for historical reasons we concat private and public keys\nconst KEYS_BYTE_LENGTH = 32\n\nexport { PUBLIC_KEY_BYTE_LENGTH as publicKeyLength }\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength }\n\n// memoize support result to skip additional awaits every time we use an ed key\nlet ed25519Supported: boolean | undefined\nconst webCryptoEd25519SupportedPromise = (async () => {\n  try {\n    await crypto.get().subtle.generateKey({ name: 'Ed25519' }, true, ['sign', 'verify'])\n    return true\n  } catch {\n    return false\n  }\n})()\n\nexport function generateKey (): Uint8ArrayKeyPair {\n  // the actual private key (32 bytes)\n  const privateKeyRaw = ed.utils.randomSecretKey()\n  const publicKey = ed.getPublicKey(privateKeyRaw)\n\n  // concatenated the public key to the private key\n  const privateKey = concatKeys(privateKeyRaw, publicKey)\n\n  return {\n    privateKey,\n    publicKey\n  }\n}\n\nexport function generateKeyFromSeed (seed: Uint8Array): Uint8ArrayKeyPair {\n  if (seed.length !== KEYS_BYTE_LENGTH) {\n    throw new TypeError('\"seed\" must be 32 bytes in length.')\n  } else if (!(seed instanceof Uint8Array)) {\n    throw new TypeError('\"seed\" must be a node.js Buffer, or Uint8Array.')\n  }\n\n  // based on node forges algorithm, the seed is used directly as private key\n  const privateKeyRaw = seed\n  const publicKey = ed.getPublicKey(privateKeyRaw)\n\n  const privateKey = concatKeys(privateKeyRaw, publicKey)\n\n  return {\n    privateKey,\n    publicKey\n  }\n}\n\nasync function hashAndSignWebCrypto (privateKey: Uint8Array, msg: Uint8Array | Uint8ArrayList): Promise<Uint8Array> {\n  let privateKeyRaw: Uint8Array\n  if (privateKey.length === PRIVATE_KEY_BYTE_LENGTH) {\n    privateKeyRaw = privateKey.subarray(0, 32)\n  } else {\n    privateKeyRaw = privateKey\n  }\n\n  const jwk: JsonWebKey = {\n    crv: 'Ed25519',\n    kty: 'OKP',\n    x: uint8arrayToString(privateKey.subarray(32), 'base64url'),\n    d: uint8arrayToString(privateKeyRaw, 'base64url'),\n    ext: true,\n    key_ops: ['sign']\n  }\n\n  const key = await crypto.get().subtle.importKey('jwk', jwk, { name: 'Ed25519' }, true, ['sign'])\n  const sig = await crypto.get().subtle.sign({ name: 'Ed25519' }, key, msg instanceof Uint8Array ? msg : msg.subarray())\n\n  return new Uint8Array(sig, 0, sig.byteLength)\n}\n\nexport function hashAndSignNoble (privateKey: Uint8Array, msg: Uint8Array | Uint8ArrayList): Uint8Array {\n  const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH)\n\n  return ed.sign(msg instanceof Uint8Array ? msg : msg.subarray(), privateKeyRaw)\n}\n\nexport async function hashAndSign (privateKey: Uint8Array, msg: Uint8Array | Uint8ArrayList): Promise<Uint8Array> {\n  if (ed25519Supported == null) {\n    ed25519Supported = await webCryptoEd25519SupportedPromise\n  }\n\n  if (ed25519Supported) {\n    return hashAndSignWebCrypto(privateKey, msg)\n  }\n\n  return hashAndSignNoble(privateKey, msg)\n}\n\nasync function hashAndVerifyWebCrypto (publicKey: Uint8Array, sig: Uint8Array, msg: Uint8Array | Uint8ArrayList): Promise<boolean> {\n  if (publicKey.buffer instanceof ArrayBuffer) {\n    const key = await crypto.get().subtle.importKey('raw', publicKey.buffer, { name: 'Ed25519' }, false, ['verify'])\n    const isValid = await crypto.get().subtle.verify({ name: 'Ed25519' }, key, sig, msg instanceof Uint8Array ? msg : msg.subarray())\n    return isValid\n  }\n\n  throw new TypeError('WebCrypto does not support SharedArrayBuffer for Ed25519 keys')\n}\n\nexport function hashAndVerifyNoble (publicKey: Uint8Array, sig: Uint8Array, msg: Uint8Array | Uint8ArrayList): boolean {\n  return ed.verify(sig, msg instanceof Uint8Array ? msg : msg.subarray(), publicKey)\n}\n\nexport async function hashAndVerify (publicKey: Uint8Array, sig: Uint8Array, msg: Uint8Array | Uint8ArrayList): Promise<boolean> {\n  if (ed25519Supported == null) {\n    ed25519Supported = await webCryptoEd25519SupportedPromise\n  }\n\n  if (ed25519Supported) {\n    return hashAndVerifyWebCrypto(publicKey, sig, msg)\n  }\n\n  return hashAndVerifyNoble(publicKey, sig, msg)\n}\n\nfunction concatKeys (privateKeyRaw: Uint8Array, publicKey: Uint8Array): Uint8Array {\n  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH)\n  for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {\n    privateKey[i] = privateKeyRaw[i]\n    privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i]\n  }\n  return privateKey\n}\n", "import { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\n\nexport function base64urlToBuffer (str: string, len?: number): Uint8Array {\n  let buf = uint8ArrayFromString(str, 'base64urlpad')\n\n  if (len != null) {\n    if (buf.length > len) {\n      throw new Error('byte array longer than desired length')\n    }\n\n    buf = uint8ArrayConcat([new Uint8Array(len - buf.length), buf])\n  }\n\n  return buf\n}\n\nexport function isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  if (thing == null) {\n    return false\n  }\n\n  return typeof thing.then === 'function' &&\n    typeof thing.catch === 'function' &&\n    typeof thing.finally === 'function'\n}\n", "import { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { identity } from 'multiformats/hashes/identity'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { isPromise } from '../../util.ts'\nimport { publicKeyToProtobuf } from '../index.js'\nimport { ensureEd25519Key } from './utils.js'\nimport * as crypto from './index.js'\nimport type { Ed25519PublicKey as Ed25519PublicKeyInterface, Ed25519PrivateKey as Ed25519PrivateKeyInterface, AbortOptions } from '@libp2p/interface'\nimport type { Digest } from 'multiformats/hashes/digest'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport class Ed25519PublicKey implements Ed25519PublicKeyInterface {\n  public readonly type = 'Ed25519'\n  public readonly raw: Uint8Array\n\n  constructor (key: Uint8Array) {\n    this.raw = ensureEd25519Key(key, crypto.publicKeyLength)\n  }\n\n  toMultihash (): Digest<0x0, number> {\n    return identity.digest(publicKeyToProtobuf(this))\n  }\n\n  toCID (): CID<unknown, 114, 0x0, 1> {\n    return CID.createV1(114, this.toMultihash())\n  }\n\n  toString (): string {\n    return base58btc.encode(this.toMultihash().bytes).substring(1)\n  }\n\n  equals (key?: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  verify (data: Uint8Array | Uint8ArrayList, sig: Uint8Array, options?: AbortOptions): boolean | Promise<boolean> {\n    options?.signal?.throwIfAborted()\n    const result = crypto.hashAndVerify(this.raw, sig, data)\n\n    if (isPromise<boolean>(result)) {\n      return result.then(res => {\n        options?.signal?.throwIfAborted()\n        return res\n      })\n    }\n\n    return result\n  }\n}\n\nexport class Ed25519PrivateKey implements Ed25519PrivateKeyInterface {\n  public readonly type = 'Ed25519'\n  public readonly raw: Uint8Array\n  public readonly publicKey: Ed25519PublicKey\n\n  // key       - 64 byte Uint8Array containing private key\n  // publicKey - 32 byte Uint8Array containing public key\n  constructor (key: Uint8Array, publicKey: Uint8Array) {\n    this.raw = ensureEd25519Key(key, crypto.privateKeyLength)\n    this.publicKey = new Ed25519PublicKey(publicKey)\n  }\n\n  equals (key?: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  sign (message: Uint8Array | Uint8ArrayList, options?: AbortOptions): Uint8Array | Promise<Uint8Array> {\n    options?.signal?.throwIfAborted()\n    const sig = crypto.hashAndSign(this.raw, message)\n\n    if (isPromise<Uint8Array>(sig)) {\n      return sig.then(res => {\n        options?.signal?.throwIfAborted()\n        return res\n      })\n    }\n\n    options?.signal?.throwIfAborted()\n    return sig\n  }\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { Ed25519PublicKey as Ed25519PublicKeyClass, Ed25519PrivateKey as Ed25519PrivateKeyClass } from './ed25519.js'\nimport * as crypto from './index.js'\nimport type { Ed25519PublicKey, Ed25519PrivateKey } from '@libp2p/interface'\n\nexport function unmarshalEd25519PrivateKey (bytes: Uint8Array): Ed25519PrivateKey {\n  // Try the old, redundant public key version\n  if (bytes.length > crypto.privateKeyLength) {\n    bytes = ensureEd25519Key(bytes, crypto.privateKeyLength + crypto.publicKeyLength)\n    const privateKeyBytes = bytes.subarray(0, crypto.privateKeyLength)\n    const publicKeyBytes = bytes.subarray(crypto.privateKeyLength, bytes.length)\n    return new Ed25519PrivateKeyClass(privateKeyBytes, publicKeyBytes)\n  }\n\n  bytes = ensureEd25519Key(bytes, crypto.privateKeyLength)\n  const privateKeyBytes = bytes.subarray(0, crypto.privateKeyLength)\n  const publicKeyBytes = bytes.subarray(crypto.publicKeyLength)\n  return new Ed25519PrivateKeyClass(privateKeyBytes, publicKeyBytes)\n}\n\nexport function unmarshalEd25519PublicKey (bytes: Uint8Array): Ed25519PublicKey {\n  bytes = ensureEd25519Key(bytes, crypto.publicKeyLength)\n  return new Ed25519PublicKeyClass(bytes)\n}\n\nexport async function generateEd25519KeyPair (): Promise<Ed25519PrivateKey> {\n  const { privateKey, publicKey } = crypto.generateKey()\n  return new Ed25519PrivateKeyClass(privateKey, publicKey)\n}\n\nexport async function generateEd25519KeyPairFromSeed (seed: Uint8Array): Promise<Ed25519PrivateKey> {\n  const { privateKey, publicKey } = crypto.generateKeyFromSeed(seed)\n  return new Ed25519PrivateKeyClass(privateKey, publicKey)\n}\n\nexport function ensureEd25519Key (key: Uint8Array, length: number): Uint8Array {\n  key = Uint8Array.from(key ?? [])\n  if (key.length !== length) {\n    throw new InvalidParametersError(`Key must be a Uint8Array of length ${length}, got ${key.length}`)\n  }\n  return key\n}\n", "/* eslint-disable no-fallthrough */\nimport { allocUnsafe } from 'uint8arrays/alloc'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst N1 = Math.pow(2, 7)\nconst N2 = Math.pow(2, 14)\nconst N3 = Math.pow(2, 21)\nconst N4 = Math.pow(2, 28)\nconst N5 = Math.pow(2, 35)\nconst N6 = Math.pow(2, 42)\nconst N7 = Math.pow(2, 49)\n\n/** Most significant bit of a byte */\nconst MSB = 0x80\n/** Rest of the bits in a byte */\nconst REST = 0x7f\n\nexport function encodingLength (value: number): number {\n  if (value < N1) {\n    return 1\n  }\n\n  if (value < N2) {\n    return 2\n  }\n\n  if (value < N3) {\n    return 3\n  }\n\n  if (value < N4) {\n    return 4\n  }\n\n  if (value < N5) {\n    return 5\n  }\n\n  if (value < N6) {\n    return 6\n  }\n\n  if (value < N7) {\n    return 7\n  }\n\n  if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('Could not encode varint')\n  }\n\n  return 8\n}\n\nexport function encodeUint8Array (value: number, buf: Uint8Array, offset: number = 0): Uint8Array {\n  switch (encodingLength(value)) {\n    case 8: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 7: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 6: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 5: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 4: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 3: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 2: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 1: {\n      buf[offset++] = (value & 0xFF)\n      value >>>= 7\n      break\n    }\n    default: throw new Error('unreachable')\n  }\n  return buf\n}\n\nexport function encodeUint8ArrayList (value: number, buf: Uint8ArrayList, offset: number = 0): Uint8ArrayList {\n  switch (encodingLength(value)) {\n    case 8: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 7: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 6: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 5: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 4: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 3: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 2: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 1: {\n      buf.set(offset++, (value & 0xFF))\n      value >>>= 7\n      break\n    }\n    default: throw new Error('unreachable')\n  }\n  return buf\n}\n\nexport function decodeUint8Array (buf: Uint8Array, offset: number): number {\n  let b = buf[offset]\n  let res = 0\n\n  res += b & REST\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 1]\n  res += (b & REST) << 7\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 2]\n  res += (b & REST) << 14\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 3]\n  res += (b & REST) << 21\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 4]\n  res += (b & REST) * N4\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 5]\n  res += (b & REST) * N5\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 6]\n  res += (b & REST) * N6\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 7]\n  res += (b & REST) * N7\n  if (b < MSB) {\n    return res\n  }\n\n  throw new RangeError('Could not decode varint')\n}\n\nexport function decodeUint8ArrayList (buf: Uint8ArrayList, offset: number): number {\n  let b = buf.get(offset)\n  let res = 0\n\n  res += b & REST\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 1)\n  res += (b & REST) << 7\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 2)\n  res += (b & REST) << 14\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 3)\n  res += (b & REST) << 21\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 4)\n  res += (b & REST) * N4\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 5)\n  res += (b & REST) * N5\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 6)\n  res += (b & REST) * N6\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 7)\n  res += (b & REST) * N7\n  if (b < MSB) {\n    return res\n  }\n\n  throw new RangeError('Could not decode varint')\n}\n\nexport function encode (value: number): Uint8Array\nexport function encode (value: number, buf: Uint8Array, offset?: number): Uint8Array\nexport function encode (value: number, buf: Uint8ArrayList, offset?: number): Uint8ArrayList\nexport function encode <T extends Uint8Array | Uint8ArrayList = Uint8Array> (value: number, buf?: T, offset: number = 0): T {\n  if (buf == null) {\n    buf = allocUnsafe(encodingLength(value)) as T\n  }\n  if (buf instanceof Uint8Array) {\n    return encodeUint8Array(value, buf, offset) as T\n  } else {\n    return encodeUint8ArrayList(value, buf, offset) as T\n  }\n}\n\nexport function decode (buf: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n  if (buf instanceof Uint8Array) {\n    return decodeUint8Array(buf, offset)\n  } else {\n    return decodeUint8ArrayList(buf, offset)\n  }\n}\n", "const f32 = new Float32Array([-0])\nconst f8b = new Uint8Array(f32.buffer)\n\n/**\n * Writes a 32 bit float to a buffer using little endian byte order\n */\nexport function writeFloatLE (val: number, buf: Uint8Array, pos: number): void {\n  f32[0] = val\n  buf[pos] = f8b[0]\n  buf[pos + 1] = f8b[1]\n  buf[pos + 2] = f8b[2]\n  buf[pos + 3] = f8b[3]\n}\n\n/**\n * Writes a 32 bit float to a buffer using big endian byte order\n */\nexport function writeFloatBE (val: number, buf: Uint8Array, pos: number): void {\n  f32[0] = val\n  buf[pos] = f8b[3]\n  buf[pos + 1] = f8b[2]\n  buf[pos + 2] = f8b[1]\n  buf[pos + 3] = f8b[0]\n}\n\n/**\n * Reads a 32 bit float from a buffer using little endian byte order\n */\nexport function readFloatLE (buf: Uint8Array, pos: number): number {\n  f8b[0] = buf[pos]\n  f8b[1] = buf[pos + 1]\n  f8b[2] = buf[pos + 2]\n  f8b[3] = buf[pos + 3]\n  return f32[0]\n}\n\n/**\n * Reads a 32 bit float from a buffer using big endian byte order\n */\nexport function readFloatBE (buf: Uint8Array, pos: number): number {\n  f8b[3] = buf[pos]\n  f8b[2] = buf[pos + 1]\n  f8b[1] = buf[pos + 2]\n  f8b[0] = buf[pos + 3]\n  return f32[0]\n}\n\nconst f64 = new Float64Array([-0])\nconst d8b = new Uint8Array(f64.buffer)\n\n/**\n * Writes a 64 bit double to a buffer using little endian byte order\n */\nexport function writeDoubleLE (val: number, buf: Uint8Array, pos: number): void {\n  f64[0] = val\n  buf[pos] = d8b[0]\n  buf[pos + 1] = d8b[1]\n  buf[pos + 2] = d8b[2]\n  buf[pos + 3] = d8b[3]\n  buf[pos + 4] = d8b[4]\n  buf[pos + 5] = d8b[5]\n  buf[pos + 6] = d8b[6]\n  buf[pos + 7] = d8b[7]\n}\n\n/**\n * Writes a 64 bit double to a buffer using big endian byte order\n */\nexport function writeDoubleBE (val: number, buf: Uint8Array, pos: number): void {\n  f64[0] = val\n  buf[pos] = d8b[7]\n  buf[pos + 1] = d8b[6]\n  buf[pos + 2] = d8b[5]\n  buf[pos + 3] = d8b[4]\n  buf[pos + 4] = d8b[3]\n  buf[pos + 5] = d8b[2]\n  buf[pos + 6] = d8b[1]\n  buf[pos + 7] = d8b[0]\n}\n\n/**\n * Reads a 64 bit double from a buffer using little endian byte order\n */\nexport function readDoubleLE (buf: Uint8Array, pos: number): number {\n  d8b[0] = buf[pos]\n  d8b[1] = buf[pos + 1]\n  d8b[2] = buf[pos + 2]\n  d8b[3] = buf[pos + 3]\n  d8b[4] = buf[pos + 4]\n  d8b[5] = buf[pos + 5]\n  d8b[6] = buf[pos + 6]\n  d8b[7] = buf[pos + 7]\n  return f64[0]\n}\n\n/**\n * Reads a 64 bit double from a buffer using big endian byte order\n */\nexport function readDoubleBE (buf: Uint8Array, pos: number): number {\n  d8b[7] = buf[pos]\n  d8b[6] = buf[pos + 1]\n  d8b[5] = buf[pos + 2]\n  d8b[4] = buf[pos + 3]\n  d8b[3] = buf[pos + 4]\n  d8b[2] = buf[pos + 5]\n  d8b[1] = buf[pos + 6]\n  d8b[0] = buf[pos + 7]\n  return f64[0]\n}\n", "// the largest BigInt we can safely downcast to a Number\nconst MAX_SAFE_NUMBER_INTEGER = BigInt(Number.MAX_SAFE_INTEGER)\nconst MIN_SAFE_NUMBER_INTEGER = BigInt(Number.MIN_SAFE_INTEGER)\n\n/**\n * Constructs new long bits.\n *\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @function Object() { [native code] }\n * @param {number} lo - Low 32 bits, unsigned\n * @param {number} hi - High 32 bits, unsigned\n */\nexport class LongBits {\n  public lo: number\n  public hi: number\n\n  constructor (lo: number, hi: number) {\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits\n     */\n    this.lo = lo | 0\n\n    /**\n     * High bits\n     */\n    this.hi = hi | 0\n  }\n\n  /**\n   * Converts this long bits to a possibly unsafe JavaScript number\n   */\n  toNumber (unsigned: boolean = false): number {\n    if (!unsigned && (this.hi >>> 31) > 0) {\n      const lo = ~this.lo + 1 >>> 0\n      let hi = ~this.hi >>> 0\n      if (lo === 0) {\n        hi = hi + 1 >>> 0\n      }\n      return -(lo + hi * 4294967296)\n    }\n    return this.lo + this.hi * 4294967296\n  }\n\n  /**\n   * Converts this long bits to a bigint\n   */\n  toBigInt (unsigned: boolean = false): bigint {\n    if (unsigned) {\n      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n)\n    }\n\n    if ((this.hi >>> 31) !== 0) {\n      const lo = ~this.lo + 1 >>> 0\n      let hi = ~this.hi >>> 0\n      if (lo === 0) {\n        hi = hi + 1 >>> 0\n      }\n      return -(BigInt(lo) + (BigInt(hi) << 32n))\n    }\n\n    return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n)\n  }\n\n  /**\n   * Converts this long bits to a string\n   */\n  toString (unsigned: boolean = false): string {\n    return this.toBigInt(unsigned).toString()\n  }\n\n  /**\n   * Zig-zag encodes this long bits\n   */\n  zzEncode (): this {\n    const mask = this.hi >> 31\n    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0\n    this.lo = (this.lo << 1 ^ mask) >>> 0\n    return this\n  }\n\n  /**\n   * Zig-zag decodes this long bits\n   */\n  zzDecode (): this {\n    const mask = -(this.lo & 1)\n    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0\n    this.hi = (this.hi >>> 1 ^ mask) >>> 0\n    return this\n  }\n\n  /**\n   * Calculates the length of this longbits when encoded as a varint.\n   */\n  length (): number {\n    const part0 = this.lo\n    const part1 = (this.lo >>> 28 | this.hi << 4) >>> 0\n    const part2 = this.hi >>> 24\n    return part2 === 0\n      ? part1 === 0\n        ? part0 < 16384\n          ? part0 < 128 ? 1 : 2\n          : part0 < 2097152 ? 3 : 4\n        : part1 < 16384\n          ? part1 < 128 ? 5 : 6\n          : part1 < 2097152 ? 7 : 8\n      : part2 < 128 ? 9 : 10\n  }\n\n  /**\n   * Constructs new long bits from the specified number\n   */\n  static fromBigInt (value: bigint): LongBits {\n    if (value === 0n) {\n      return zero\n    }\n\n    if (value < MAX_SAFE_NUMBER_INTEGER && value > MIN_SAFE_NUMBER_INTEGER) {\n      return this.fromNumber(Number(value))\n    }\n\n    const negative = value < 0n\n\n    if (negative) {\n      value = -value\n    }\n\n    let hi = value >> 32n\n    let lo = value - (hi << 32n)\n\n    if (negative) {\n      hi = ~hi | 0n\n      lo = ~lo | 0n\n\n      if (++lo > TWO_32) {\n        lo = 0n\n        if (++hi > TWO_32) { hi = 0n }\n      }\n    }\n\n    return new LongBits(Number(lo), Number(hi))\n  }\n\n  /**\n   * Constructs new long bits from the specified number\n   */\n  static fromNumber (value: number): LongBits {\n    if (value === 0) { return zero }\n    const sign = value < 0\n    if (sign) { value = -value }\n    let lo = value >>> 0\n    let hi = (value - lo) / 4294967296 >>> 0\n    if (sign) {\n      hi = ~hi >>> 0\n      lo = ~lo >>> 0\n      if (++lo > 4294967295) {\n        lo = 0\n        if (++hi > 4294967295) { hi = 0 }\n      }\n    }\n    return new LongBits(lo, hi)\n  }\n\n  /**\n   * Constructs new long bits from a number, long or string\n   */\n  static from (value: bigint | number | string | { low: number, high: number }): LongBits {\n    if (typeof value === 'number') {\n      return LongBits.fromNumber(value)\n    }\n    if (typeof value === 'bigint') {\n      return LongBits.fromBigInt(value)\n    }\n    if (typeof value === 'string') {\n      return LongBits.fromBigInt(BigInt(value))\n    }\n    return value.low != null || value.high != null ? new LongBits(value.low >>> 0, value.high >>> 0) : zero\n  }\n}\n\nconst zero = new LongBits(0, 0)\nzero.toBigInt = function () { return 0n }\nzero.zzEncode = zero.zzDecode = function () { return this }\nzero.length = function () { return 1 }\n\nconst TWO_32 = 4294967296n\n", "/**\n * Calculates the UTF8 byte length of a string\n */\nexport function length (string: string): number {\n  let len = 0\n  let c = 0\n  for (let i = 0; i < string.length; ++i) {\n    c = string.charCodeAt(i)\n\n    if (c < 128) {\n      len += 1\n    } else if (c < 2048) {\n      len += 2\n    } else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\n      ++i\n      len += 4\n    } else {\n      len += 3\n    }\n  }\n\n  return len\n}\n\n/**\n * Reads UTF8 bytes as a string\n */\nexport function read (buffer: Uint8Array, start: number, end: number): string {\n  const len = end - start\n\n  if (len < 1) {\n    return ''\n  }\n\n  let parts: string[] | undefined\n  const chunk: number[] = []\n  let i = 0 // char offset\n  let t: number // temporary\n\n  while (start < end) {\n    t = buffer[start++]\n\n    if (t < 128) {\n      chunk[i++] = t\n    } else if (t > 191 && t < 224) {\n      chunk[i++] = (t & 31) << 6 | buffer[start++] & 63\n    } else if (t > 239 && t < 365) {\n      t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000\n      chunk[i++] = 0xD800 + (t >> 10)\n      chunk[i++] = 0xDC00 + (t & 1023)\n    } else {\n      chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63\n    }\n\n    if (i > 8191) {\n      (parts ?? (parts = [])).push(String.fromCharCode.apply(String, chunk))\n      i = 0\n    }\n  }\n\n  if (parts != null) {\n    if (i > 0) {\n      parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)))\n    }\n\n    return parts.join('')\n  }\n\n  return String.fromCharCode.apply(String, chunk.slice(0, i))\n}\n\n/**\n * Writes a string as UTF8 bytes\n */\nexport function write (string: string, buffer: Uint8Array, offset: number): number {\n  const start = offset\n  let c1 // character 1\n  let c2 // character 2\n\n  for (let i = 0; i < string.length; ++i) {\n    c1 = string.charCodeAt(i)\n\n    if (c1 < 128) {\n      buffer[offset++] = c1\n    } else if (c1 < 2048) {\n      buffer[offset++] = c1 >> 6 | 192\n      buffer[offset++] = c1 & 63 | 128\n    } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\n      c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF)\n      ++i\n      buffer[offset++] = c1 >> 18 | 240\n      buffer[offset++] = c1 >> 12 & 63 | 128\n      buffer[offset++] = c1 >> 6 & 63 | 128\n      buffer[offset++] = c1 & 63 | 128\n    } else {\n      buffer[offset++] = c1 >> 12 | 224\n      buffer[offset++] = c1 >> 6 & 63 | 128\n      buffer[offset++] = c1 & 63 | 128\n    }\n  }\n\n  return offset - start\n}\n", "import { decodeUint8Array, encodingLength } from 'uint8-varint'\nimport { readFloatLE, readDoubleLE } from './float.js'\nimport { LongBits } from './longbits.js'\nimport * as utf8 from './utf8.js'\nimport type { Reader } from '../index.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\n/* istanbul ignore next */\nfunction indexOutOfRange (reader: Reader, writeLength?: number): RangeError {\n  return RangeError(`index out of range: ${reader.pos} + ${writeLength ?? 1} > ${reader.len}`)\n}\n\nfunction readFixed32End (buf: Uint8Array, end: number): number { // note that this uses `end`, not `pos`\n  return (buf[end - 4] |\n        buf[end - 3] << 8 |\n        buf[end - 2] << 16 |\n        buf[end - 1] << 24) >>> 0\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n */\nexport class Uint8ArrayReader implements Reader {\n  public buf: Uint8Array\n  public pos: number\n  public len: number\n\n  public _slice = Uint8Array.prototype.subarray\n\n  constructor (buffer: Uint8Array) {\n    /**\n     * Read buffer\n     */\n    this.buf = buffer\n\n    /**\n     * Read buffer position\n     */\n    this.pos = 0\n\n    /**\n     * Read buffer length\n     */\n    this.len = buffer.length\n  }\n\n  /**\n   * Reads a varint as an unsigned 32 bit value\n   */\n  uint32 (): number {\n    let value = 4294967295\n\n    value = (this.buf[this.pos] & 127) >>> 0; if (this.buf[this.pos++] < 128) { return value }\n    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0; if (this.buf[this.pos++] < 128) { return value }\n    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) { return value }\n    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) { return value }\n    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0; if (this.buf[this.pos++] < 128) { return value }\n\n    if ((this.pos += 5) > this.len) {\n      this.pos = this.len\n      throw indexOutOfRange(this, 10)\n    }\n\n    return value\n  }\n\n  /**\n   * Reads a varint as a signed 32 bit value\n   */\n  int32 (): number {\n    return this.uint32() | 0\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 32 bit value\n   */\n  sint32 (): number {\n    const value = this.uint32()\n    return value >>> 1 ^ -(value & 1) | 0\n  }\n\n  /**\n   * Reads a varint as a boolean\n   */\n  bool (): boolean {\n    return this.uint32() !== 0\n  }\n\n  /**\n   * Reads fixed 32 bits as an unsigned 32 bit integer\n   */\n  fixed32 (): number {\n    if (this.pos + 4 > this.len) { throw indexOutOfRange(this, 4) }\n\n    const res = readFixed32End(this.buf, this.pos += 4)\n\n    return res\n  }\n\n  /**\n   * Reads fixed 32 bits as a signed 32 bit integer\n   */\n  sfixed32 (): number {\n    if (this.pos + 4 > this.len) {\n      throw indexOutOfRange(this, 4)\n    }\n\n    const res = readFixed32End(this.buf, this.pos += 4) | 0\n\n    return res\n  }\n\n  /**\n   * Reads a float (32 bit) as a number\n   */\n  float (): number {\n    if (this.pos + 4 > this.len) {\n      throw indexOutOfRange(this, 4)\n    }\n\n    const value = readFloatLE(this.buf, this.pos)\n    this.pos += 4\n    return value\n  }\n\n  /**\n   * Reads a double (64 bit float) as a number\n   */\n  double (): number {\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len) { throw indexOutOfRange(this, 4) }\n\n    const value = readDoubleLE(this.buf, this.pos)\n    this.pos += 8\n    return value\n  }\n\n  /**\n   * Reads a sequence of bytes preceded by its length as a varint\n   */\n  bytes (): Uint8Array {\n    const length = this.uint32()\n    const start = this.pos\n    const end = this.pos + length\n\n    /* istanbul ignore if */\n    if (end > this.len) {\n      throw indexOutOfRange(this, length)\n    }\n\n    this.pos += length\n\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n      ? new Uint8Array(0)\n      : this.buf.subarray(start, end)\n  }\n\n  /**\n   * Reads a string preceded by its byte length as a varint\n   */\n  string (): string {\n    const bytes = this.bytes()\n    return utf8.read(bytes, 0, bytes.length)\n  }\n\n  /**\n   * Skips the specified number of bytes if specified, otherwise skips a varint\n   */\n  skip (length?: number): this {\n    if (typeof length === 'number') {\n      /* istanbul ignore if */\n      if (this.pos + length > this.len) { throw indexOutOfRange(this, length) }\n      this.pos += length\n    } else {\n      do {\n        /* istanbul ignore if */\n        if (this.pos >= this.len) {\n          throw indexOutOfRange(this)\n        }\n      } while ((this.buf[this.pos++] & 128) !== 0)\n    }\n    return this\n  }\n\n  /**\n   * Skips the next element of the specified wire type\n   */\n  skipType (wireType: number): this {\n    switch (wireType) {\n      case 0:\n        this.skip()\n        break\n      case 1:\n        this.skip(8)\n        break\n      case 2:\n        this.skip(this.uint32())\n        break\n      case 3:\n        while ((wireType = this.uint32() & 7) !== 4) {\n          this.skipType(wireType)\n        }\n        break\n      case 5:\n        this.skip(4)\n        break\n\n        /* istanbul ignore next */\n      default:\n        throw Error(`invalid wire type ${wireType} at offset ${this.pos}`)\n    }\n    return this\n  }\n\n  private readLongVarint (): LongBits {\n    // tends to deopt with local vars for octet etc.\n    const bits = new LongBits(0, 0)\n    let i = 0\n    if (this.len - this.pos > 4) { // fast route (lo)\n      for (; i < 4; ++i) {\n        // 1st..4th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n      // 5th\n      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0\n      bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0\n      if (this.buf[this.pos++] < 128) { return bits }\n      i = 0\n    } else {\n      for (; i < 3; ++i) {\n        /* istanbul ignore if */\n        if (this.pos >= this.len) { throw indexOutOfRange(this) }\n        // 1st..3th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n      // 4th\n      bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0\n      return bits\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n      for (; i < 5; ++i) {\n        // 6th..10th\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n    } else {\n      for (; i < 5; ++i) {\n        if (this.pos >= this.len) {\n          throw indexOutOfRange(this)\n        }\n\n        // 6th..10th\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n    }\n\n    throw Error('invalid varint encoding')\n  }\n\n  private readFixed64 (): LongBits {\n    if (this.pos + 8 > this.len) {\n      throw indexOutOfRange(this, 8)\n    }\n\n    const lo = readFixed32End(this.buf, this.pos += 4)\n    const hi = readFixed32End(this.buf, this.pos += 4)\n\n    return new LongBits(lo, hi)\n  }\n\n  /**\n   * Reads a varint as a signed 64 bit value\n   */\n  int64 (): bigint {\n    return this.readLongVarint().toBigInt()\n  }\n\n  /**\n   * Reads a varint as a signed 64 bit value returned as a possibly unsafe\n   * JavaScript number\n   */\n  int64Number (): number {\n    return this.readLongVarint().toNumber()\n  }\n\n  /**\n   * Reads a varint as a signed 64 bit value returned as a string\n   */\n  int64String (): string {\n    return this.readLongVarint().toString()\n  }\n\n  /**\n   * Reads a varint as an unsigned 64 bit value\n   */\n  uint64 (): bigint {\n    return this.readLongVarint().toBigInt(true)\n  }\n\n  /**\n   * Reads a varint as an unsigned 64 bit value returned as a possibly unsafe\n   * JavaScript number\n   */\n  uint64Number (): number {\n    const value = decodeUint8Array(this.buf, this.pos)\n    this.pos += encodingLength(value)\n    return value\n  }\n\n  /**\n   * Reads a varint as an unsigned 64 bit value returned as a string\n   */\n  uint64String (): string {\n    return this.readLongVarint().toString(true)\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value\n   */\n  sint64 (): bigint {\n    return this.readLongVarint().zzDecode().toBigInt()\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a\n   * possibly unsafe JavaScript number\n   */\n  sint64Number (): number {\n    return this.readLongVarint().zzDecode().toNumber()\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a\n   * string\n   */\n  sint64String (): string {\n    return this.readLongVarint().zzDecode().toString()\n  }\n\n  /**\n   * Reads fixed 64 bits\n   */\n  fixed64 (): bigint {\n    return this.readFixed64().toBigInt()\n  }\n\n  /**\n   * Reads fixed 64 bits returned as a possibly unsafe JavaScript number\n   */\n  fixed64Number (): number {\n    return this.readFixed64().toNumber()\n  }\n\n  /**\n   * Reads fixed 64 bits returned as a string\n   */\n  fixed64String (): string {\n    return this.readFixed64().toString()\n  }\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits\n   */\n  sfixed64 (): bigint {\n    return this.readFixed64().toBigInt()\n  }\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits returned as a possibly unsafe\n   * JavaScript number\n   */\n  sfixed64Number (): number {\n    return this.readFixed64().toNumber()\n  }\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits returned as a string\n   */\n  sfixed64String (): string {\n    return this.readFixed64().toString()\n  }\n}\n\nexport function createReader (buf: Uint8Array | Uint8ArrayList): Reader {\n  return new Uint8ArrayReader(buf instanceof Uint8Array ? buf : buf.subarray())\n}\n", "import { createReader } from './utils/reader.js'\nimport type { Codec, DecodeOptions } from './codec.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport function decodeMessage <T> (buf: Uint8Array | Uint8ArrayList, codec: Pick<Codec<T>, 'decode'>, opts?: DecodeOptions<T>): T {\n  const reader = createReader(buf)\n\n  return codec.decode(reader, undefined, opts)\n}\n", "import { allocUnsafe } from 'uint8arrays/alloc'\n\n/**\n * A general purpose buffer pool\n */\nexport default function pool (size?: number): (size: number) => Uint8Array {\n  const SIZE = size ?? 8192\n  const MAX = SIZE >>> 1\n  let slab: Uint8Array\n  let offset = SIZE\n  return function poolAlloc (size: number) {\n    if (size < 1 || size > MAX) {\n      return allocUnsafe(size)\n    }\n\n    if (offset + size > SIZE) {\n      slab = allocUnsafe(SIZE)\n      offset = 0\n    }\n\n    const buf = slab.subarray(offset, offset += size)\n\n    if ((offset & 7) !== 0) {\n      // align to 32 bit\n      offset = (offset | 7) + 1\n    }\n\n    return buf\n  }\n}\n", "import { encodeUint8Array, encodingLength } from 'uint8-varint'\nimport { allocUnsafe } from 'uint8arrays/alloc'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { writeFloatLE, writeDoubleLE } from './float.js'\nimport { LongBits } from './longbits.js'\nimport pool from './pool.js'\nimport * as utf8 from './utf8.js'\nimport type { Writer } from '../index.js'\n\ninterface WriterOperation<T> {\n  (val: T, buf: Uint8Array, pos: number): any\n}\n\n/**\n * Constructs a new writer operation instance.\n *\n * @classdesc Scheduled writer operation\n */\nclass Op<T> {\n  /**\n   * Function to call\n   */\n  public fn: WriterOperation<T>\n\n  /**\n   * Value byte length\n   */\n  public len: number\n\n  /**\n   * Next operation\n   */\n  public next?: Op<any>\n\n  /**\n   * Value to write\n   */\n  public val: T\n\n  constructor (fn: WriterOperation<T>, len: number, val: T) {\n    this.fn = fn\n    this.len = len\n    this.next = undefined\n    this.val = val // type varies\n  }\n}\n\n/* istanbul ignore next */\nfunction noop (): void {}\n\n/**\n * Constructs a new writer state instance\n */\nclass State {\n  /**\n   * Current head\n   */\n  public head: Op<any>\n\n  /**\n   * Current tail\n   */\n  public tail: Op<any>\n\n  /**\n   * Current buffer length\n   */\n  public len: number\n\n  /**\n   * Next state\n   */\n  public next?: State\n\n  constructor (writer: Uint8ArrayWriter) {\n    this.head = writer.head\n    this.tail = writer.tail\n    this.len = writer.len\n    this.next = writer.states\n  }\n}\n\nconst bufferPool = pool()\n\n/**\n * Allocates a buffer of the specified size\n */\nfunction alloc (size: number): Uint8Array {\n  if (globalThis.Buffer != null) {\n    return allocUnsafe(size)\n  }\n\n  return bufferPool(size)\n}\n\n/**\n * When a value is written, the writer calculates its byte length and puts it into a linked\n * list of operations to perform when finish() is called. This both allows us to allocate\n * buffers of the exact required size and reduces the amount of work we have to do compared\n * to first calculating over objects and then encoding over objects. In our case, the encoding\n * part is just a linked list walk calling operations with already prepared values.\n */\nclass Uint8ArrayWriter implements Writer {\n  /**\n   * Current length\n   */\n  public len: number\n\n  /**\n   * Operations head\n   */\n  public head: Op<any>\n\n  /**\n   * Operations tail\n   */\n  public tail: Op<any>\n\n  /**\n   * Linked forked states\n   */\n  public states?: any\n\n  constructor () {\n    this.len = 0\n    this.head = new Op(noop, 0, 0)\n    this.tail = this.head\n    this.states = null\n  }\n\n  /**\n   * Pushes a new operation to the queue\n   */\n  _push (fn: WriterOperation<any>, len: number, val: any): this {\n    this.tail = this.tail.next = new Op(fn, len, val)\n    this.len += len\n\n    return this\n  }\n\n  /**\n   * Writes an unsigned 32 bit value as a varint\n   */\n  uint32 (value: number): this {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n      (value = value >>> 0) <\n                128\n        ? 1\n        : value < 16384\n          ? 2\n          : value < 2097152\n            ? 3\n            : value < 268435456\n              ? 4\n              : 5,\n      value)).len\n    return this\n  }\n\n  /**\n   * Writes a signed 32 bit value as a varint`\n   */\n  int32 (value: number): this {\n    return value < 0\n      ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n      : this.uint32(value)\n  }\n\n  /**\n   * Writes a 32 bit value as a varint, zig-zag encoded\n   */\n  sint32 (value: number): this {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64 (value: bigint): this {\n    const bits = LongBits.fromBigInt(value)\n    return this._push(writeVarint64, bits.length(), bits)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64Number (value: number): this {\n    return this._push(encodeUint8Array, encodingLength(value), value)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64String (value: string): this {\n    return this.uint64(BigInt(value))\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64 (value: bigint): this {\n    return this.uint64(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64Number (value: number): this {\n    return this.uint64Number(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64String (value: string): this {\n    return this.uint64String(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64 (value: bigint): this {\n    const bits = LongBits.fromBigInt(value).zzEncode()\n    return this._push(writeVarint64, bits.length(), bits)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64Number (value: number): this {\n    const bits = LongBits.fromNumber(value).zzEncode()\n    return this._push(writeVarint64, bits.length(), bits)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64String (value: string): this {\n    return this.sint64(BigInt(value))\n  }\n\n  /**\n   * Writes a boolish value as a varint\n   */\n  bool (value: boolean): this {\n    return this._push(writeByte, 1, value ? 1 : 0)\n  }\n\n  /**\n   * Writes an unsigned 32 bit value as fixed 32 bits\n   */\n  fixed32 (value: number): this {\n    return this._push(writeFixed32, 4, value >>> 0)\n  }\n\n  /**\n   * Writes a signed 32 bit value as fixed 32 bits\n   */\n  sfixed32 (value: number): this {\n    return this.fixed32(value)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64 (value: bigint): this {\n    const bits = LongBits.fromBigInt(value)\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64Number (value: number): this {\n    const bits = LongBits.fromNumber(value)\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64String (value: string): this {\n    return this.fixed64(BigInt(value))\n  }\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64 (value: bigint): this {\n    return this.fixed64(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64Number (value: number): this {\n    return this.fixed64Number(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64String (value: string): this {\n    return this.fixed64String(value)\n  }\n\n  /**\n   * Writes a float (32 bit)\n   */\n  float (value: number): this {\n    return this._push(writeFloatLE, 4, value)\n  }\n\n  /**\n   * Writes a double (64 bit float).\n   *\n   * @function\n   * @param {number} value - Value to write\n   * @returns {Writer} `this`\n   */\n  double (value: number): this {\n    return this._push(writeDoubleLE, 8, value)\n  }\n\n  /**\n   * Writes a sequence of bytes\n   */\n  bytes (value: Uint8Array): this {\n    const len = value.length >>> 0\n\n    if (len === 0) {\n      return this._push(writeByte, 1, 0)\n    }\n\n    return this.uint32(len)._push(writeBytes, len, value)\n  }\n\n  /**\n   * Writes a string\n   */\n  string (value: string): this {\n    const len = utf8.length(value)\n    return len !== 0\n      ? this.uint32(len)._push(utf8.write, len, value)\n      : this._push(writeByte, 1, 0)\n  }\n\n  /**\n   * Forks this writer's state by pushing it to a stack.\n   * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n   */\n  fork (): this {\n    this.states = new State(this)\n    this.head = this.tail = new Op(noop, 0, 0)\n    this.len = 0\n    return this\n  }\n\n  /**\n   * Resets this instance to the last state\n   */\n  reset (): this {\n    if (this.states != null) {\n      this.head = this.states.head\n      this.tail = this.states.tail\n      this.len = this.states.len\n      this.states = this.states.next\n    } else {\n      this.head = this.tail = new Op(noop, 0, 0)\n      this.len = 0\n    }\n    return this\n  }\n\n  /**\n   * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n   */\n  ldelim (): this {\n    const head = this.head\n    const tail = this.tail\n    const len = this.len\n    this.reset().uint32(len)\n    if (len !== 0) {\n      this.tail.next = head.next // skip noop\n      this.tail = tail\n      this.len += len\n    }\n    return this\n  }\n\n  /**\n   * Finishes the write operation\n   */\n  finish (): Uint8Array {\n    let head = this.head.next // skip noop\n    const buf = alloc(this.len)\n    let pos = 0\n    while (head != null) {\n      head.fn(head.val, buf, pos)\n      pos += head.len\n      head = head.next\n    }\n    // this.head = this.tail = null;\n    return buf\n  }\n}\n\nfunction writeByte (val: number, buf: Uint8Array, pos: number): void {\n  buf[pos] = val & 255\n}\n\nfunction writeVarint32 (val: number, buf: Uint8Array, pos: number): void {\n  while (val > 127) {\n    buf[pos++] = val & 127 | 128\n    val >>>= 7\n  }\n  buf[pos] = val\n}\n\n/**\n * Constructs a new varint writer operation instance.\n *\n * @classdesc Scheduled varint writer operation\n */\nclass VarintOp extends Op<number> {\n  public next?: Op<any>\n\n  constructor (len: number, val: number) {\n    super(writeVarint32, len, val)\n    this.next = undefined\n  }\n}\n\nfunction writeVarint64 (val: LongBits, buf: Uint8Array, pos: number): void {\n  while (val.hi !== 0) {\n    buf[pos++] = val.lo & 127 | 128\n    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0\n    val.hi >>>= 7\n  }\n  while (val.lo > 127) {\n    buf[pos++] = val.lo & 127 | 128\n    val.lo = val.lo >>> 7\n  }\n  buf[pos++] = val.lo\n}\n\nfunction writeFixed32 (val: number, buf: Uint8Array, pos: number): void {\n  buf[pos] = val & 255\n  buf[pos + 1] = val >>> 8 & 255\n  buf[pos + 2] = val >>> 16 & 255\n  buf[pos + 3] = val >>> 24\n}\n\nfunction writeBytes (val: Uint8Array, buf: Uint8Array, pos: number): void {\n  buf.set(val, pos)\n}\n\nif (globalThis.Buffer != null) {\n  Uint8ArrayWriter.prototype.bytes = function (value: Uint8Array) {\n    const len = value.length >>> 0\n\n    this.uint32(len)\n\n    if (len > 0) {\n      this._push(writeBytesBuffer, len, value)\n    }\n\n    return this\n  }\n\n  Uint8ArrayWriter.prototype.string = function (value: string) {\n    const len = globalThis.Buffer.byteLength(value)\n\n    this.uint32(len)\n\n    if (len > 0) {\n      this._push(writeStringBuffer, len, value)\n    }\n\n    return this\n  }\n}\n\nfunction writeBytesBuffer (val: Uint8Array, buf: Uint8Array, pos: number): void {\n  buf.set(val, pos) // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n  // also works for plain array values\n}\n\nfunction writeStringBuffer (val: string, buf: Uint8Array, pos: number): void {\n  if (val.length < 40) {\n    // plain js is faster for short strings (probably due to redundant assertions)\n    utf8.write(val, buf, pos)\n    // @ts-expect-error buf isn't a Uint8Array?\n  } else if (buf.utf8Write != null) {\n    // @ts-expect-error buf isn't a Uint8Array?\n    buf.utf8Write(val, pos)\n  } else {\n    buf.set(uint8ArrayFromString(val), pos)\n  }\n}\n\n/**\n * Creates a new writer\n */\nexport function createWriter (): Writer {\n  return new Uint8ArrayWriter()\n}\n", "import { createWriter } from './utils/writer.js'\nimport type { Codec } from './codec.js'\n\nexport function encodeMessage <T> (message: Partial<T>, codec: Pick<Codec<T>, 'encode'>): Uint8Array {\n  const w = createWriter()\n\n  codec.encode(message, w, {\n    lengthDelimited: false\n  })\n\n  return w.finish()\n}\n", "import type { Writer, Reader } from './index.js'\n\n// https://developers.google.com/protocol-buffers/docs/encoding#structure\nexport enum CODEC_TYPES {\n  VARINT = 0,\n  BIT64,\n  LENGTH_DELIMITED,\n  START_GROUP,\n  END_GROUP,\n  BIT32\n}\n\nexport interface EncodeOptions {\n  lengthDelimited?: boolean\n  writeDefaults?: boolean\n}\n\nexport interface EncodeFunction<T> {\n  (value: Partial<T>, writer: Writer, opts?: EncodeOptions): void\n}\n\n// protobuf types that contain multiple values\ntype CollectionTypes = any[] | Map<any, any>\n\n// protobuf types that are not collections or messages\ntype PrimitiveTypes = boolean | number | string | bigint | Uint8Array\n\n// recursive array/map field length limits\ntype CollectionLimits <T> = {\n  [K in keyof T]: T[K] extends CollectionTypes ? number :\n    T[K] extends PrimitiveTypes ? never : Limits<T[K]>\n}\n\n// recursive array member array/map field length limits\ntype ArrayElementLimits <T> = {\n  [K in keyof T as `${string & K}$`]: T[K] extends Array<infer ElementType> ?\n      (ElementType extends PrimitiveTypes ? never : Limits<ElementType>) :\n      (T[K] extends PrimitiveTypes ? never : Limits<T[K]>)\n}\n\n// recursive map value array/map field length limits\ntype MapValueLimits <T> = {\n  [K in keyof T as `${string & K}$value`]: T[K] extends Map<any, infer MapValueType> ?\n      (MapValueType extends PrimitiveTypes ? never : Limits<MapValueType>) :\n      (T[K] extends PrimitiveTypes ? never : Limits<T[K]>)\n}\n\n// union of collection and array elements\ntype Limits<T> = Partial<CollectionLimits<T> & ArrayElementLimits<T> & MapValueLimits<T>>\n\nexport interface DecodeOptions<T> {\n  /**\n   * Runtime-specified limits for lengths of repeated/map fields\n   */\n  limits?: Limits<T>\n}\n\nexport interface DecodeFunction<T> {\n  (reader: Reader, length?: number, opts?: DecodeOptions<T>): T\n}\n\nexport interface Codec<T> {\n  name: string\n  type: CODEC_TYPES\n  encode: EncodeFunction<T>\n  decode: DecodeFunction<T>\n}\n\nexport function createCodec <T> (name: string, type: CODEC_TYPES, encode: EncodeFunction<T>, decode: DecodeFunction<T>): Codec<T> {\n  return {\n    name,\n    type,\n    encode,\n    decode\n  }\n}\n", "import { createCodec, CODEC_TYPES } from '../codec.js'\nimport type { DecodeFunction, EncodeFunction, Codec } from '../codec.js'\n\nexport function enumeration <T> (v: any): Codec<T> {\n  function findValue (val: string | number): number {\n    // Use the reverse mapping to look up the enum key for the stored value\n    // https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings\n    if (v[val.toString()] == null) {\n      throw new Error('Invalid enum value')\n    }\n\n    return v[val]\n  }\n\n  const encode: EncodeFunction<number | string> = function enumEncode (val, writer) {\n    const enumValue = findValue(val)\n\n    writer.int32(enumValue)\n  }\n\n  const decode: DecodeFunction<number | string> = function enumDecode (reader) {\n    const val = reader.int32()\n\n    return findValue(val)\n  }\n\n  // @ts-expect-error yeah yeah\n  return createCodec('enum', CODEC_TYPES.VARINT, encode, decode)\n}\n", "import { createCodec, CODEC_TYPES } from '../codec.js'\nimport type { EncodeFunction, DecodeFunction, Codec } from '../codec.js'\n\nexport interface Factory<A, T> {\n  new (obj: A): T\n}\n\nexport function message <T> (encode: EncodeFunction<T>, decode: DecodeFunction<T>): Codec<T> {\n  return createCodec('message', CODEC_TYPES.LENGTH_DELIMITED, encode, decode)\n}\n", "import { decodeMessage, encodeMessage, enumeration, message } from 'protons-runtime'\nimport type { Codec, DecodeOptions } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport enum KeyType {\n  RSA = 'RSA',\n  Ed25519 = 'Ed25519',\n  secp256k1 = 'secp256k1',\n  ECDSA = 'ECDSA'\n}\n\nenum __KeyTypeValues {\n  RSA = 0,\n  Ed25519 = 1,\n  secp256k1 = 2,\n  ECDSA = 3\n}\n\nexport namespace KeyType {\n  export const codec = (): Codec<KeyType> => {\n    return enumeration<KeyType>(__KeyTypeValues)\n  }\n}\nexport interface PublicKey {\n  Type?: KeyType\n  Data?: Uint8Array\n}\n\nexport namespace PublicKey {\n  let _codec: Codec<PublicKey>\n\n  export const codec = (): Codec<PublicKey> => {\n    if (_codec == null) {\n      _codec = message<PublicKey>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Type != null) {\n          w.uint32(8)\n          KeyType.codec().encode(obj.Type, w)\n        }\n\n        if (obj.Data != null) {\n          w.uint32(18)\n          w.bytes(obj.Data)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.Type = KeyType.codec().decode(reader)\n              break\n            }\n            case 2: {\n              obj.Data = reader.bytes()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PublicKey>): Uint8Array => {\n    return encodeMessage(obj, PublicKey.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<PublicKey>): PublicKey => {\n    return decodeMessage(buf, PublicKey.codec(), opts)\n  }\n}\n\nexport interface PrivateKey {\n  Type?: KeyType\n  Data?: Uint8Array\n}\n\nexport namespace PrivateKey {\n  let _codec: Codec<PrivateKey>\n\n  export const codec = (): Codec<PrivateKey> => {\n    if (_codec == null) {\n      _codec = message<PrivateKey>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Type != null) {\n          w.uint32(8)\n          KeyType.codec().encode(obj.Type, w)\n        }\n\n        if (obj.Data != null) {\n          w.uint32(18)\n          w.bytes(obj.Data)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.Type = KeyType.codec().decode(reader)\n              break\n            }\n            case 2: {\n              obj.Data = reader.bytes()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PrivateKey>): Uint8Array => {\n    return encodeMessage(obj, PrivateKey.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<PrivateKey>): PrivateKey => {\n    return decodeMessage(buf, PrivateKey.codec(), opts)\n  }\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { randomBytes as randB } from '@noble/hashes/utils.js'\n\n/**\n * Generates a Uint8Array with length `number` populated by random bytes\n */\nexport default function randomBytes (length: number): Uint8Array {\n  if (isNaN(length) || length <= 0) {\n    throw new InvalidParametersError('random bytes length must be a Number bigger than 0')\n  }\n  return randB(length)\n}\n", "import { InvalidParametersError, InvalidPublicKeyError } from '@libp2p/interface'\nimport { sha256 } from '@noble/hashes/sha2.js'\nimport { create } from 'multiformats/hashes/digest'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport * as pb from '../keys.js'\nimport { decodeDer, encodeBitString, encodeInteger, encodeSequence } from './der.js'\nimport { RSAPrivateKey as RSAPrivateKeyClass, RSAPublicKey as RSAPublicKeyClass } from './rsa.js'\nimport { generateRSAKey, rsaKeySize } from './index.js'\nimport type { JWKKeyPair } from '../interface.js'\nimport type { RSAPrivateKey, RSAPublicKey } from '@libp2p/interface'\nimport type { Digest } from 'multiformats/hashes/digest'\n\nexport const MAX_RSA_KEY_SIZE = 8192\nconst SHA2_256_CODE = 0x12\nconst MAX_RSA_JWK_SIZE = 1062\n\nconst RSA_ALGORITHM_IDENTIFIER = Uint8Array.from([\n  0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00\n])\n\n/**\n * Convert a PKCS#1 in ASN1 DER format to a JWK private key\n */\nexport function pkcs1ToJwk (bytes: Uint8Array): JsonWebKey {\n  const message = decodeDer(bytes)\n\n  return pkcs1MessageToJwk(message)\n}\n\n/**\n * Convert a PKCS#1 in ASN1 DER format to a JWK private key\n */\nexport function pkcs1MessageToJwk (message: any): JsonWebKey {\n  return {\n    n: uint8ArrayToString(message[1], 'base64url'),\n    e: uint8ArrayToString(message[2], 'base64url'),\n    d: uint8ArrayToString(message[3], 'base64url'),\n    p: uint8ArrayToString(message[4], 'base64url'),\n    q: uint8ArrayToString(message[5], 'base64url'),\n    dp: uint8ArrayToString(message[6], 'base64url'),\n    dq: uint8ArrayToString(message[7], 'base64url'),\n    qi: uint8ArrayToString(message[8], 'base64url'),\n    kty: 'RSA'\n  }\n}\n\n/**\n * Convert a JWK private key into PKCS#1 in ASN1 DER format\n */\nexport function jwkToPkcs1 (jwk: JsonWebKey): Uint8Array {\n  if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {\n    throw new InvalidParametersError('JWK was missing components')\n  }\n\n  return encodeSequence([\n    encodeInteger(Uint8Array.from([0])),\n    encodeInteger(uint8ArrayFromString(jwk.n, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.e, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.d, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.p, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.q, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.dp, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.dq, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.qi, 'base64url'))\n  ]).subarray()\n}\n\n/**\n * Convert a PKIX in ASN1 DER format to a JWK public key\n */\nexport function pkixToJwk (bytes: Uint8Array): JsonWebKey {\n  const message = decodeDer(bytes, {\n    offset: 0\n  })\n\n  return pkixMessageToJwk(message)\n}\n\nexport function pkixMessageToJwk (message: any): JsonWebKey {\n  const keys = decodeDer(message[1], {\n    offset: 0\n  })\n\n  // this looks fragile but DER is a canonical format so we are safe to have\n  // deeply property chains like this\n  return {\n    kty: 'RSA',\n    n: uint8ArrayToString(\n      keys[0],\n      'base64url'\n    ),\n    e: uint8ArrayToString(\n      keys[1],\n      'base64url'\n    )\n  }\n}\n\n/**\n * Convert a JWK public key to PKIX in ASN1 DER format\n */\nexport function jwkToPkix (jwk: JsonWebKey): Uint8Array {\n  if (jwk.n == null || jwk.e == null) {\n    throw new InvalidParametersError('JWK was missing components')\n  }\n\n  const subjectPublicKeyInfo = encodeSequence([\n    RSA_ALGORITHM_IDENTIFIER,\n    encodeBitString(\n      encodeSequence([\n        encodeInteger(uint8ArrayFromString(jwk.n, 'base64url')),\n        encodeInteger(uint8ArrayFromString(jwk.e, 'base64url'))\n      ])\n    )\n  ])\n\n  return subjectPublicKeyInfo.subarray()\n}\n\n/**\n * Turn PKCS#1 DER bytes into a PrivateKey\n */\nexport function pkcs1ToRSAPrivateKey (bytes: Uint8Array): RSAPrivateKey {\n  const message = decodeDer(bytes)\n\n  return pkcs1MessageToRSAPrivateKey(message)\n}\n\n/**\n * Turn PKCS#1 DER bytes into a PrivateKey\n */\nexport function pkcs1MessageToRSAPrivateKey (message: any): RSAPrivateKey {\n  const jwk = pkcs1MessageToJwk(message)\n\n  return jwkToRSAPrivateKey(jwk)\n}\n\n/**\n * Turn a PKIX message into a PublicKey\n */\nexport function pkixToRSAPublicKey (bytes: Uint8Array, digest?: Digest<18, number>): RSAPublicKey {\n  if (bytes.byteLength >= MAX_RSA_JWK_SIZE) {\n    throw new InvalidPublicKeyError('Key size is too large')\n  }\n\n  const message = decodeDer(bytes, {\n    offset: 0\n  })\n\n  return pkixMessageToRSAPublicKey(message, bytes, digest)\n}\n\nexport function pkixMessageToRSAPublicKey (message: any, bytes: Uint8Array, digest?: Digest<18, number>): RSAPublicKey {\n  const jwk = pkixMessageToJwk(message)\n\n  if (digest == null) {\n    const hash = sha256(pb.PublicKey.encode({\n      Type: pb.KeyType.RSA,\n      Data: bytes\n    }))\n    digest = create(SHA2_256_CODE, hash)\n  }\n\n  return new RSAPublicKeyClass(jwk, digest)\n}\n\nexport function jwkToRSAPrivateKey (jwk: JsonWebKey): RSAPrivateKey {\n  if (rsaKeySize(jwk) > MAX_RSA_KEY_SIZE) {\n    throw new InvalidParametersError('Key size is too large')\n  }\n\n  const keys = jwkToJWKKeyPair(jwk)\n  const hash = sha256(pb.PublicKey.encode({\n    Type: pb.KeyType.RSA,\n    Data: jwkToPkix(keys.publicKey)\n  }))\n  const digest = create(SHA2_256_CODE, hash)\n\n  return new RSAPrivateKeyClass(keys.privateKey, new RSAPublicKeyClass(keys.publicKey, digest))\n}\n\nexport async function generateRSAKeyPair (bits: number): Promise<RSAPrivateKey> {\n  if (bits > MAX_RSA_KEY_SIZE) {\n    throw new InvalidParametersError('Key size is too large')\n  }\n\n  const keys = await generateRSAKey(bits)\n  const hash = sha256(pb.PublicKey.encode({\n    Type: pb.KeyType.RSA,\n    Data: jwkToPkix(keys.publicKey)\n  }))\n  const digest = create(SHA2_256_CODE, hash)\n\n  return new RSAPrivateKeyClass(keys.privateKey, new RSAPublicKeyClass(keys.publicKey, digest))\n}\n\n/**\n * Takes a jwk key and returns a JWK KeyPair\n */\nexport function jwkToJWKKeyPair (key: JsonWebKey): JWKKeyPair {\n  if (key == null) {\n    throw new InvalidParametersError('Missing key parameter')\n  }\n\n  return {\n    privateKey: key,\n    publicKey: {\n      kty: key.kty,\n      n: key.n,\n      e: key.e\n    }\n  }\n}\n", "import { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { hashAndSign, utils, hashAndVerify } from './index.js'\nimport type { RSAPublicKey as RSAPublicKeyInterface, RSAPrivateKey as RSAPrivateKeyInterface, AbortOptions } from '@libp2p/interface'\nimport type { Digest } from 'multiformats/hashes/digest'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport class RSAPublicKey implements RSAPublicKeyInterface {\n  public readonly type = 'RSA'\n  public readonly jwk: JsonWebKey\n  private _raw?: Uint8Array\n  private readonly _multihash: Digest<18, number>\n\n  constructor (jwk: JsonWebKey, digest: Digest<18, number>) {\n    this.jwk = jwk\n    this._multihash = digest\n  }\n\n  get raw (): Uint8Array {\n    if (this._raw == null) {\n      this._raw = utils.jwkToPkix(this.jwk)\n    }\n\n    return this._raw\n  }\n\n  toMultihash (): Digest<18, number> {\n    return this._multihash\n  }\n\n  toCID (): CID<unknown, 114, 18, 1> {\n    return CID.createV1(114, this._multihash)\n  }\n\n  toString (): string {\n    return base58btc.encode(this.toMultihash().bytes).substring(1)\n  }\n\n  equals (key?: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  verify (data: Uint8Array | Uint8ArrayList, sig: Uint8Array, options?: AbortOptions): boolean | Promise<boolean> {\n    return hashAndVerify(this.jwk, sig, data, options)\n  }\n}\n\nexport class RSAPrivateKey implements RSAPrivateKeyInterface {\n  public readonly type = 'RSA'\n  public readonly jwk: JsonWebKey\n  private _raw?: Uint8Array\n  public readonly publicKey: RSAPublicKey\n\n  constructor (jwk: JsonWebKey, publicKey: RSAPublicKey) {\n    this.jwk = jwk\n    this.publicKey = publicKey\n  }\n\n  get raw (): Uint8Array {\n    if (this._raw == null) {\n      this._raw = utils.jwkToPkcs1(this.jwk)\n    }\n\n    return this._raw\n  }\n\n  equals (key: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  sign (message: Uint8Array | Uint8ArrayList, options?: AbortOptions): Uint8Array | Promise<Uint8Array> {\n    return hashAndSign(this.jwk, message, options)\n  }\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport randomBytes from '../../random-bytes.js'\nimport webcrypto from '../../webcrypto/index.js'\nimport * as utils from './utils.js'\nimport type { JWKKeyPair } from '../interface.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport const RSAES_PKCS1_V1_5_OID = '1.2.840.113549.1.1.1'\nexport { utils }\n\nexport async function generateRSAKey (bits: number, options?: AbortOptions): Promise<JWKKeyPair> {\n  const pair = await webcrypto.get().subtle.generateKey(\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      modulusLength: bits,\n      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n      hash: { name: 'SHA-256' }\n    },\n    true,\n    ['sign', 'verify']\n  )\n  options?.signal?.throwIfAborted()\n\n  const keys = await exportKey(pair, options)\n\n  return {\n    privateKey: keys[0],\n    publicKey: keys[1]\n  }\n}\n\nexport { randomBytes as getRandomValues }\n\nexport async function hashAndSign (key: JsonWebKey, msg: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<Uint8Array> {\n  const privateKey = await webcrypto.get().subtle.importKey(\n    'jwk',\n    key,\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: { name: 'SHA-256' }\n    },\n    false,\n    ['sign']\n  )\n  options?.signal?.throwIfAborted()\n\n  const sig = await webcrypto.get().subtle.sign(\n    { name: 'RSASSA-PKCS1-v1_5' },\n    privateKey,\n    msg instanceof Uint8Array ? msg : msg.subarray()\n  )\n  options?.signal?.throwIfAborted()\n\n  return new Uint8Array(sig, 0, sig.byteLength)\n}\n\nexport async function hashAndVerify (key: JsonWebKey, sig: Uint8Array, msg: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<boolean> {\n  const publicKey = await webcrypto.get().subtle.importKey(\n    'jwk',\n    key,\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: { name: 'SHA-256' }\n    },\n    false,\n    ['verify']\n  )\n  options?.signal?.throwIfAborted()\n\n  const result = await webcrypto.get().subtle.verify(\n    { name: 'RSASSA-PKCS1-v1_5' },\n    publicKey,\n    sig,\n    msg instanceof Uint8Array ? msg : msg.subarray()\n  )\n  options?.signal?.throwIfAborted()\n\n  return result\n}\n\nasync function exportKey (pair: CryptoKeyPair, options?: AbortOptions): Promise<[JsonWebKey, JsonWebKey]> {\n  if (pair.privateKey == null || pair.publicKey == null) {\n    throw new InvalidParametersError('Private and public key are required')\n  }\n\n  const result = await Promise.all([\n    webcrypto.get().subtle.exportKey('jwk', pair.privateKey),\n    webcrypto.get().subtle.exportKey('jwk', pair.publicKey)\n  ])\n  options?.signal?.throwIfAborted()\n\n  return result\n}\n\nexport function rsaKeySize (jwk: JsonWebKey): number {\n  if (jwk.kty !== 'RSA') {\n    throw new InvalidParametersError('invalid key type')\n  } else if (jwk.n == null) {\n    throw new InvalidParametersError('invalid key modulus')\n  }\n  const bytes = uint8ArrayFromString(jwk.n, 'base64url')\n  return bytes.length * 8\n}\n", "/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash, clean, type CHash, type Hash } from './utils.ts';\n\n/** Internal class for HMAC. */\nexport class _HMAC<T extends Hash<T>> implements Hash<_HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, key: Uint8Array) {\n    ahash(hash);\n    abytes(key, undefined, 'key');\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    clean(pad);\n  }\n  update(buf: Uint8Array): this {\n    aexists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    abytes(out, this.outputLen, 'output');\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest(): Uint8Array {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: _HMAC<T>): _HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  clone(): _HMAC<T> {\n    return this._cloneInto();\n  }\n  destroy(): void {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac: {\n  (hash: CHash, key: Uint8Array, message: Uint8Array): Uint8Array;\n  create(hash: CHash, key: Uint8Array): _HMAC<any>;\n} = (hash: CHash, key: Uint8Array, message: Uint8Array): Uint8Array =>\n  new _HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Uint8Array) => new _HMAC<any>(hash, key);\n", "/**\n * Short Weierstrass curve methods. The formula is: y\u00B2 = x\u00B3 + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac as nobleHmac } from '@noble/hashes/hmac.js';\nimport { ahash } from '@noble/hashes/utils.js';\nimport {\n  abool,\n  abytes,\n  aInRange,\n  bitLen,\n  bitMask,\n  bytesToHex,\n  bytesToNumberBE,\n  concatBytes,\n  createHmacDrbg,\n  hexToBytes,\n  isBytes,\n  memoized,\n  numberToHexUnpadded,\n  validateObject,\n  randomBytes as wcRandomBytes,\n  type CHash,\n  type Signer,\n} from '../utils.ts';\nimport {\n  createCurveFields,\n  createKeygen,\n  mulEndoUnsafe,\n  negateCt,\n  normalizeZ,\n  wNAF,\n  type AffinePoint,\n  type CurveLengths,\n  type CurvePoint,\n  type CurvePointCons,\n} from './curve.ts';\nimport {\n  FpInvertBatch,\n  getMinHashLength,\n  mapHashToField,\n  validateField,\n  type IField,\n} from './modular.ts';\n\nexport type { AffinePoint };\n\ntype EndoBasis = [[bigint, bigint], [bigint, bigint]];\n/**\n * When Weierstrass curve has `a=0`, it becomes Koblitz curve.\n * Koblitz curves allow using **efficiently-computable GLV endomorphism \u03C8**.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n *\n * Endomorphism consists of beta, lambda and splitScalar:\n *\n * 1. GLV endomorphism \u03C8 transforms a point: `P = (x, y) \u21A6 \u03C8(P) = (\u03B2\u00B7x mod p, y)`\n * 2. GLV scalar decomposition transforms a scalar: `k \u2261 k\u2081 + k\u2082\u00B7\u03BB (mod n)`\n * 3. Then these are combined: `k\u00B7P = k\u2081\u00B7P + k\u2082\u00B7\u03C8(P)`\n * 4. Two 128-bit point-by-scalar multiplications + one point addition is faster than\n *    one 256-bit multiplication.\n *\n * where\n * * beta: \u03B2 \u2208 F\u209A with \u03B2\u00B3 = 1, \u03B2 \u2260 1\n * * lambda: \u03BB \u2208 F\u2099 with \u03BB\u00B3 = 1, \u03BB \u2260 1\n * * splitScalar decomposes k \u21A6 k\u2081, k\u2082, by using reduced basis vectors.\n *   Gauss lattice reduction calculates them from initial basis vectors `(n, 0), (-\u03BB, 0)`\n *\n * Check out `test/misc/endomorphism.js` and\n * [gist](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n */\nexport type EndomorphismOpts = {\n  beta: bigint;\n  basises?: EndoBasis;\n  splitScalar?: (k: bigint) => { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\n};\n// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)\nconst divNearest = (num: bigint, den: bigint) => (num + (num >= 0 ? den : -den) / _2n) / den;\n\nexport type ScalarEndoParts = { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\n\n/**\n * Splits scalar for GLV endomorphism.\n */\nexport function _splitEndoScalar(k: bigint, basis: EndoBasis, n: bigint): ScalarEndoParts {\n  // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`\n  // Since part can be negative, we need to do this on point.\n  // TODO: verifyScalar function which consumes lambda\n  const [[a1, b1], [a2, b2]] = basis;\n  const c1 = divNearest(b2 * k, n);\n  const c2 = divNearest(-b1 * k, n);\n  // |k1|/|k2| is < sqrt(N), but can be negative.\n  // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.\n  let k1 = k - c1 * a1 - c2 * a2;\n  let k2 = -c1 * b1 - c2 * b2;\n  const k1neg = k1 < _0n;\n  const k2neg = k2 < _0n;\n  if (k1neg) k1 = -k1;\n  if (k2neg) k2 = -k2;\n  // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.\n  // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.\n  const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n; // Half bits of N\n  if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {\n    throw new Error('splitScalar (endomorphism): failed, k=' + k);\n  }\n  return { k1neg, k1, k2neg, k2 };\n}\n\n/**\n * Option to enable hedged signatures with improved security.\n *\n * * Randomly generated k is bad, because broken CSPRNG would leak private keys.\n * * Deterministic k (RFC6979) is better; but is suspectible to fault attacks.\n *\n * We allow using technique described in RFC6979 3.6: additional k', a.k.a. adding randomness\n * to deterministic sig. If CSPRNG is broken & randomness is weak, it would STILL be as secure\n * as ordinary sig without ExtraEntropy.\n *\n * * `true` means \"fetch data, from CSPRNG, incorporate it into k generation\"\n * * `false` means \"disable extra entropy, use purely deterministic k\"\n * * `Uint8Array` passed means \"incorporate following data into k generation\"\n *\n * https://paulmillr.com/posts/deterministic-signatures/\n */\nexport type ECDSAExtraEntropy = boolean | Uint8Array;\n/**\n * - `compact` is the default format\n * - `recovered` is the same as compact, but with an extra byte indicating recovery byte\n * - `der` is ASN.1 DER encoding\n */\nexport type ECDSASignatureFormat = 'compact' | 'recovered' | 'der';\n/**\n * - `prehash`: (default: true) indicates whether to do sha256(message).\n *   When a custom hash is used, it must be set to `false`.\n */\nexport type ECDSARecoverOpts = {\n  prehash?: boolean;\n};\n/**\n * - `prehash`: (default: true) indicates whether to do sha256(message).\n *   When a custom hash is used, it must be set to `false`.\n * - `lowS`: (default: true) prohibits signatures which have (sig.s >= CURVE.n/2n).\n *   Compatible with BTC/ETH. Setting `lowS: false` allows to create malleable signatures,\n *   which is default openssl behavior.\n *   Non-malleable signatures can still be successfully verified in openssl.\n * - `format`: (default: 'compact') 'compact' or 'recovered' with recovery byte\n */\nexport type ECDSAVerifyOpts = {\n  prehash?: boolean;\n  lowS?: boolean;\n  format?: ECDSASignatureFormat;\n};\n/**\n * - `prehash`: (default: true) indicates whether to do sha256(message).\n *   When a custom hash is used, it must be set to `false`.\n * - `lowS`: (default: true) prohibits signatures which have (sig.s >= CURVE.n/2n).\n *   Compatible with BTC/ETH. Setting `lowS: false` allows to create malleable signatures,\n *   which is default openssl behavior.\n *   Non-malleable signatures can still be successfully verified in openssl.\n * - `format`: (default: 'compact') 'compact' or 'recovered' with recovery byte\n * - `extraEntropy`: (default: false) creates sigs with increased security, see {@link ECDSAExtraEntropy}\n */\nexport type ECDSASignOpts = {\n  prehash?: boolean;\n  lowS?: boolean;\n  format?: ECDSASignatureFormat;\n  extraEntropy?: ECDSAExtraEntropy;\n};\n\nfunction validateSigFormat(format: string): ECDSASignatureFormat {\n  if (!['compact', 'recovered', 'der'].includes(format))\n    throw new Error('Signature format must be \"compact\", \"recovered\", or \"der\"');\n  return format as ECDSASignatureFormat;\n}\n\nfunction validateSigOpts<T extends ECDSASignOpts, D extends Required<ECDSASignOpts>>(\n  opts: T,\n  def: D\n): Required<ECDSASignOpts> {\n  const optsn: ECDSASignOpts = {};\n  for (let optName of Object.keys(def)) {\n    // @ts-ignore\n    optsn[optName] = opts[optName] === undefined ? def[optName] : opts[optName];\n  }\n  abool(optsn.lowS!, 'lowS');\n  abool(optsn.prehash!, 'prehash');\n  if (optsn.format !== undefined) validateSigFormat(optsn.format);\n  return optsn as Required<ECDSASignOpts>;\n}\n\n/** Instance methods for 3D XYZ projective points. */\nexport interface WeierstrassPoint<T> extends CurvePoint<T, WeierstrassPoint<T>> {\n  /** projective X coordinate. Different from affine x. */\n  readonly X: T;\n  /** projective Y coordinate. Different from affine y. */\n  readonly Y: T;\n  /** projective z coordinate */\n  readonly Z: T;\n  /** affine x coordinate. Different from projective X. */\n  get x(): T;\n  /** affine y coordinate. Different from projective Y. */\n  get y(): T;\n  /** Encodes point using IEEE P1363 (DER) encoding. First byte is 2/3/4. Default = isCompressed. */\n  toBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n}\n\n/** Static methods for 3D XYZ projective points. */\nexport interface WeierstrassPointCons<T> extends CurvePointCons<WeierstrassPoint<T>> {\n  /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n  new (X: T, Y: T, Z: T): WeierstrassPoint<T>;\n  CURVE(): WeierstrassOpts<T>;\n}\n\n/**\n * Weierstrass curve options.\n *\n * * p: prime characteristic (order) of finite field, in which arithmetics is done\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * h: cofactor, usually 1. h*n is group order; n is subgroup order\n * * a: formula param, must be in field of p\n * * b: formula param, must be in field of p\n * * Gx: x coordinate of generator point a.k.a. base point\n * * Gy: y coordinate of generator point\n */\nexport type WeierstrassOpts<T> = Readonly<{\n  p: bigint;\n  n: bigint;\n  h: bigint;\n  a: T;\n  b: T;\n  Gx: T;\n  Gy: T;\n}>;\n\n// When a cofactor != 1, there can be an effective methods to:\n// 1. Determine whether a point is torsion-free\n// 2. Clear torsion component\nexport type WeierstrassExtraOpts<T> = Partial<{\n  Fp: IField<T>;\n  Fn: IField<bigint>;\n  allowInfinityPoint: boolean;\n  endo: EndomorphismOpts;\n  isTorsionFree: (c: WeierstrassPointCons<T>, point: WeierstrassPoint<T>) => boolean;\n  clearCofactor: (c: WeierstrassPointCons<T>, point: WeierstrassPoint<T>) => WeierstrassPoint<T>;\n  fromBytes: (bytes: Uint8Array) => AffinePoint<T>;\n  toBytes: (\n    c: WeierstrassPointCons<T>,\n    point: WeierstrassPoint<T>,\n    isCompressed: boolean\n  ) => Uint8Array;\n}>;\n\n/**\n * Options for ECDSA signatures over a Weierstrass curve.\n *\n * * lowS: (default: true) whether produced / verified signatures occupy low half of ecdsaOpts.p. Prevents malleability.\n * * hmac: (default: noble-hashes hmac) function, would be used to init hmac-drbg for k generation.\n * * randomBytes: (default: webcrypto os-level CSPRNG) custom method for fetching secure randomness.\n * * bits2int, bits2int_modN: used in sigs, sometimes overridden by curves\n */\nexport type ECDSAOpts = Partial<{\n  lowS: boolean;\n  hmac: (key: Uint8Array, message: Uint8Array) => Uint8Array;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n  bits2int: (bytes: Uint8Array) => bigint;\n  bits2int_modN: (bytes: Uint8Array) => bigint;\n}>;\n\n/**\n * Elliptic Curve Diffie-Hellman interface.\n * Provides keygen, secret-to-public conversion, calculating shared secrets.\n */\nexport interface ECDH {\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n  getPublicKey: (secretKey: Uint8Array, isCompressed?: boolean) => Uint8Array;\n  getSharedSecret: (\n    secretKeyA: Uint8Array,\n    publicKeyB: Uint8Array,\n    isCompressed?: boolean\n  ) => Uint8Array;\n  Point: WeierstrassPointCons<bigint>;\n  utils: {\n    isValidSecretKey: (secretKey: Uint8Array) => boolean;\n    isValidPublicKey: (publicKey: Uint8Array, isCompressed?: boolean) => boolean;\n    randomSecretKey: (seed?: Uint8Array) => Uint8Array;\n  };\n  lengths: CurveLengths;\n}\n\n/**\n * ECDSA interface.\n * Only supported for prime fields, not Fp2 (extension fields).\n */\nexport interface ECDSA extends ECDH {\n  sign: (message: Uint8Array, secretKey: Uint8Array, opts?: ECDSASignOpts) => Uint8Array;\n  verify: (\n    signature: Uint8Array,\n    message: Uint8Array,\n    publicKey: Uint8Array,\n    opts?: ECDSAVerifyOpts\n  ) => boolean;\n  recoverPublicKey(signature: Uint8Array, message: Uint8Array, opts?: ECDSARecoverOpts): Uint8Array;\n  Signature: ECDSASignatureCons;\n}\nexport class DERErr extends Error {\n  constructor(m = '') {\n    super(m);\n  }\n}\nexport type IDER = {\n  // asn.1 DER encoding utils\n  Err: typeof DERErr;\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (tag: number, data: string) => string;\n    // v - value, l - left bytes (unparsed)\n    decode(tag: number, data: Uint8Array): { v: Uint8Array; l: Uint8Array };\n  };\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(num: bigint): string;\n    decode(data: Uint8Array): bigint;\n  };\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint };\n  hexFromSig(sig: { r: bigint; s: bigint }): string;\n};\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexport const DER: IDER = {\n  // asn.1 DER encoding utils\n  Err: DERErr,\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (tag: number, data: string): string => {\n      const { Err: E } = DER;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length & 1) throw new E('tlv.encode: unpadded data');\n      const dataLen = data.length / 2;\n      const len = numberToHexUnpadded(dataLen);\n      if ((len.length / 2) & 0b1000_0000) throw new E('tlv.encode: long form length too big');\n      // length of length with long form flag\n      const lenLen = dataLen > 127 ? numberToHexUnpadded((len.length / 2) | 0b1000_0000) : '';\n      const t = numberToHexUnpadded(tag);\n      return t + lenLen + len + data;\n    },\n    // v - value, l - left bytes (unparsed)\n    decode(tag: number, data: Uint8Array): { v: Uint8Array; l: Uint8Array } {\n      const { Err: E } = DER;\n      let pos = 0;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length < 2 || data[pos++] !== tag) throw new E('tlv.decode: wrong tlv');\n      const first = data[pos++];\n      const isLong = !!(first & 0b1000_0000); // First bit of first length byte is flag for short/long form\n      let length = 0;\n      if (!isLong) length = first;\n      else {\n        // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n        const lenLen = first & 0b0111_1111;\n        if (!lenLen) throw new E('tlv.decode(long): indefinite length not supported');\n        if (lenLen > 4) throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n        const lengthBytes = data.subarray(pos, pos + lenLen);\n        if (lengthBytes.length !== lenLen) throw new E('tlv.decode: length bytes not complete');\n        if (lengthBytes[0] === 0) throw new E('tlv.decode(long): zero leftmost byte');\n        for (const b of lengthBytes) length = (length << 8) | b;\n        pos += lenLen;\n        if (length < 128) throw new E('tlv.decode(long): not minimal encoding');\n      }\n      const v = data.subarray(pos, pos + length);\n      if (v.length !== length) throw new E('tlv.decode: wrong value length');\n      return { v, l: data.subarray(pos + length) };\n    },\n  },\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(num: bigint): string {\n      const { Err: E } = DER;\n      if (num < _0n) throw new E('integer: negative integers are not allowed');\n      let hex = numberToHexUnpadded(num);\n      // Pad with zero byte if negative flag is present\n      if (Number.parseInt(hex[0], 16) & 0b1000) hex = '00' + hex;\n      if (hex.length & 1) throw new E('unexpected DER parsing assertion: unpadded hex');\n      return hex;\n    },\n    decode(data: Uint8Array): bigint {\n      const { Err: E } = DER;\n      if (data[0] & 0b1000_0000) throw new E('invalid signature integer: negative');\n      if (data[0] === 0x00 && !(data[1] & 0b1000_0000))\n        throw new E('invalid signature integer: unnecessary leading zero');\n      return bytesToNumberBE(data);\n    },\n  },\n  toSig(bytes: Uint8Array): { r: bigint; s: bigint } {\n    // parse DER signature\n    const { Err: E, _int: int, _tlv: tlv } = DER;\n    const data = abytes(bytes, undefined, 'signature');\n    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n    if (seqLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n    const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n    if (sLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    return { r: int.decode(rBytes), s: int.decode(sBytes) };\n  },\n  hexFromSig(sig: { r: bigint; s: bigint }): string {\n    const { _tlv: tlv, _int: int } = DER;\n    const rs = tlv.encode(0x02, int.encode(sig.r));\n    const ss = tlv.encode(0x02, int.encode(sig.s));\n    const seq = rs + ss;\n    return tlv.encode(0x30, seq);\n  },\n};\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\n/**\n * Creates weierstrass Point constructor, based on specified curve options.\n *\n * See {@link WeierstrassOpts}.\n *\n * @example\n```js\nconst opts = {\n  p: 0xfffffffffffffffffffffffffffffffeffffac73n,\n  n: 0x100000000000000000001b8fa16dfab9aca16b6b3n,\n  h: 1n,\n  a: 0n,\n  b: 7n,\n  Gx: 0x3b4c382ce37aa192a4019e763036f4f5dd4d7ebbn,\n  Gy: 0x938cf935318fdced6bc28286531733c3f03c4feen,\n};\nconst secp160k1_Point = weierstrass(opts);\n```\n */\nexport function weierstrass<T>(\n  params: WeierstrassOpts<T>,\n  extraOpts: WeierstrassExtraOpts<T> = {}\n): WeierstrassPointCons<T> {\n  const validated = createCurveFields('weierstrass', params, extraOpts);\n  const { Fp, Fn } = validated;\n  let CURVE = validated.CURVE as WeierstrassOpts<T>;\n  const { h: cofactor, n: CURVE_ORDER } = CURVE;\n  validateObject(\n    extraOpts,\n    {},\n    {\n      allowInfinityPoint: 'boolean',\n      clearCofactor: 'function',\n      isTorsionFree: 'function',\n      fromBytes: 'function',\n      toBytes: 'function',\n      endo: 'object',\n    }\n  );\n\n  const { endo } = extraOpts;\n  if (endo) {\n    // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });\n    if (!Fp.is0(CURVE.a) || typeof endo.beta !== 'bigint' || !Array.isArray(endo.basises)) {\n      throw new Error('invalid endo: expected \"beta\": bigint and \"basises\": array');\n    }\n  }\n\n  const lengths = getWLengths(Fp, Fn);\n\n  function assertCompressionIsSupported() {\n    if (!Fp.isOdd) throw new Error('compression is not supported: Field does not have .isOdd()');\n  }\n\n  // Implements IEEE P1363 point encoding\n  function pointToBytes(\n    _c: WeierstrassPointCons<T>,\n    point: WeierstrassPoint<T>,\n    isCompressed: boolean\n  ): Uint8Array {\n    const { x, y } = point.toAffine();\n    const bx = Fp.toBytes(x);\n    abool(isCompressed, 'isCompressed');\n    if (isCompressed) {\n      assertCompressionIsSupported();\n      const hasEvenY = !Fp.isOdd!(y);\n      return concatBytes(pprefix(hasEvenY), bx);\n    } else {\n      return concatBytes(Uint8Array.of(0x04), bx, Fp.toBytes(y));\n    }\n  }\n  function pointFromBytes(bytes: Uint8Array) {\n    abytes(bytes, undefined, 'Point');\n    const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths; // e.g. for 32-byte: 33, 65\n    const length = bytes.length;\n    const head = bytes[0];\n    const tail = bytes.subarray(1);\n    // No actual validation is done here: use .assertValidity()\n    if (length === comp && (head === 0x02 || head === 0x03)) {\n      const x = Fp.fromBytes(tail);\n      if (!Fp.isValid(x)) throw new Error('bad point: is not on curve, wrong x');\n      const y2 = weierstrassEquation(x); // y\u00B2 = x\u00B3 + ax + b\n      let y: T;\n      try {\n        y = Fp.sqrt(y2); // y = y\u00B2 ^ (p+1)/4\n      } catch (sqrtError) {\n        const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n        throw new Error('bad point: is not on curve, sqrt error' + err);\n      }\n      assertCompressionIsSupported();\n      const evenY = Fp.isOdd!(y);\n      const evenH = (head & 1) === 1; // ECDSA-specific\n      if (evenH !== evenY) y = Fp.neg(y);\n      return { x, y };\n    } else if (length === uncomp && head === 0x04) {\n      // TODO: more checks\n      const L = Fp.BYTES;\n      const x = Fp.fromBytes(tail.subarray(0, L));\n      const y = Fp.fromBytes(tail.subarray(L, L * 2));\n      if (!isValidXY(x, y)) throw new Error('bad point: is not on curve');\n      return { x, y };\n    } else {\n      throw new Error(\n        `bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`\n      );\n    }\n  }\n\n  const encodePoint = extraOpts.toBytes || pointToBytes;\n  const decodePoint = extraOpts.fromBytes || pointFromBytes;\n  function weierstrassEquation(x: T): T {\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x\u00B2 * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b); // x\u00B3 + a * x + b\n  }\n\n  // TODO: move top-level\n  /** Checks whether equation holds for given x, y: y\u00B2 == x\u00B3 + ax + b */\n  function isValidXY(x: T, y: T): boolean {\n    const left = Fp.sqr(y); // y\u00B2\n    const right = weierstrassEquation(x); // x\u00B3 + ax + b\n    return Fp.eql(left, right);\n  }\n\n  // Validate whether the passed curve params are valid.\n  // Test 1: equation y\u00B2 = x\u00B3 + ax + b should work for generator point.\n  if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error('bad curve params: generator point');\n\n  // Test 2: discriminant \u0394 part should be non-zero: 4a\u00B3 + 27b\u00B2 != 0.\n  // Guarantees curve is genus-1, smooth (non-singular).\n  const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n  const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n  if (Fp.is0(Fp.add(_4a3, _27b2))) throw new Error('bad curve params: a or b');\n\n  /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */\n  function acoord(title: string, n: T, banZero = false) {\n    if (!Fp.isValid(n) || (banZero && Fp.is0(n))) throw new Error(`bad point coordinate ${title}`);\n    return n;\n  }\n\n  function aprjpoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('Weierstrass Point expected');\n  }\n\n  function splitEndoScalarN(k: bigint) {\n    if (!endo || !endo.basises) throw new Error('no endo');\n    return _splitEndoScalar(k, endo.basises, Fn.ORDER);\n  }\n\n  // Memoized toAffine / validity check. They are heavy. Points are immutable.\n\n  // Converts Projective point to affine (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  // (X, Y, Z) \u220B (x=X/Z, y=Y/Z)\n  const toAffineMemo = memoized((p: Point, iz?: T): AffinePoint<T> => {\n    const { X, Y, Z } = p;\n    // Fast-path for normalized points\n    if (Fp.eql(Z, Fp.ONE)) return { x: X, y: Y };\n    const is0 = p.is0();\n    // If invZ was 0, we return zero point. However we still want to execute\n    // all operations, so we replace invZ with a random number, 1.\n    if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(Z);\n    const x = Fp.mul(X, iz);\n    const y = Fp.mul(Y, iz);\n    const zz = Fp.mul(Z, iz);\n    if (is0) return { x: Fp.ZERO, y: Fp.ZERO };\n    if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n    return { x, y };\n  });\n  // NOTE: on exception this will crash 'cached' and no value will be set.\n  // Otherwise true will be return\n  const assertValidMemo = memoized((p: Point) => {\n    if (p.is0()) {\n      // (0, 1, 0) aka ZERO is invalid in most contexts.\n      // In BLS, ZERO can be serialized, so we allow it.\n      // (0, 0, 0) is invalid representation of ZERO.\n      if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y)) return;\n      throw new Error('bad point: ZERO');\n    }\n    // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n    const { x, y } = p.toAffine();\n    if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not field elements');\n    if (!isValidXY(x, y)) throw new Error('bad point: equation left != right');\n    if (!p.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    return true;\n  });\n\n  function finishEndo(\n    endoBeta: EndomorphismOpts['beta'],\n    k1p: Point,\n    k2p: Point,\n    k1neg: boolean,\n    k2neg: boolean\n  ) {\n    k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);\n    k1p = negateCt(k1neg, k1p);\n    k2p = negateCt(k2neg, k2p);\n    return k1p.add(k2p);\n  }\n\n  /**\n   * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z) \u220B (x=X/Z, y=Y/Z).\n   * Default Point works in 2d / affine coordinates: (x, y).\n   * We're doing calculations in projective, because its operations don't require costly inversion.\n   */\n  class Point implements WeierstrassPoint<T> {\n    // base / generator point\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    static readonly ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    // math field\n    static readonly Fp = Fp;\n    // scalar field\n    static readonly Fn = Fn;\n\n    readonly X: T;\n    readonly Y: T;\n    readonly Z: T;\n\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n    constructor(X: T, Y: T, Z: T) {\n      this.X = acoord('x', X);\n      this.Y = acoord('y', Y, true);\n      this.Z = acoord('z', Z);\n      Object.freeze(this);\n    }\n\n    static CURVE(): WeierstrassOpts<T> {\n      return CURVE;\n    }\n\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n    static fromAffine(p: AffinePoint<T>): Point {\n      const { x, y } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n      // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)\n      if (Fp.is0(x) && Fp.is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n\n    static fromBytes(bytes: Uint8Array): Point {\n      const P = Point.fromAffine(decodePoint(abytes(bytes, undefined, 'point')));\n      P.assertValidity();\n      return P;\n    }\n\n    static fromHex(hex: string): Point {\n      return Point.fromBytes(hexToBytes(hex));\n    }\n\n    get x(): T {\n      return this.toAffine().x;\n    }\n    get y(): T {\n      return this.toAffine().y;\n    }\n\n    /**\n     *\n     * @param windowSize\n     * @param isLazy true will defer table computation until the first multiplication\n     * @returns\n     */\n    precompute(windowSize: number = 8, isLazy = true): Point {\n      wnaf.createCache(this, windowSize);\n      if (!isLazy) this.multiply(_3n); // random number\n      return this;\n    }\n\n    // TODO: return `this`\n    /** A point on curve is valid if it conforms to equation. */\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    hasEvenY(): boolean {\n      const { y } = this.toAffine();\n      if (!Fp.isOdd) throw new Error(\"Field doesn't support isOdd\");\n      return !Fp.isOdd(y);\n    }\n\n    /** Compare one point to another. */\n    equals(other: Point): boolean {\n      aprjpoint(other);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const { X: X2, Y: Y2, Z: Z2 } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n\n    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */\n    negate(): Point {\n      return new Point(this.X, Fp.neg(this.Y), this.Z);\n    }\n\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const { a, b } = CURVE;\n      const b3 = Fp.mul(b, _3n);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      let t0 = Fp.mul(X1, X1); // step 1\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    }\n\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(other: Point): Point {\n      aprjpoint(other);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const { X: X2, Y: Y2, Z: Z2 } = other;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, _3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n      return new Point(X3, Y3, Z3);\n    }\n\n    subtract(other: Point) {\n      return this.add(other.negate());\n    }\n\n    is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(scalar: bigint): Point {\n      const { endo } = extraOpts;\n      if (!Fn.isValidNot0(scalar)) throw new Error('invalid scalar: out of range'); // 0 is invalid\n      let point: Point, fake: Point; // Fake point is used to const-time mult\n      const mul = (n: bigint) => wnaf.cached(this, n, (p) => normalizeZ(Point, p));\n      /** See docs for {@link EndomorphismOpts} */\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);\n        const { p: k1p, f: k1f } = mul(k1);\n        const { p: k2p, f: k2f } = mul(k2);\n        fake = k1f.add(k2f);\n        point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);\n      } else {\n        const { p, f } = mul(scalar);\n        point = p;\n        fake = f;\n      }\n      // Normalize `z` for both points, but return only real one\n      return normalizeZ(Point, [point, fake])[0];\n    }\n\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed secret key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(sc: bigint): Point {\n      const { endo } = extraOpts;\n      const p = this as Point;\n      if (!Fn.isValid(sc)) throw new Error('invalid scalar: out of range'); // 0 is valid\n      if (sc === _0n || p.is0()) return Point.ZERO; // 0\n      if (sc === _1n) return p; // 1\n      if (wnaf.hasCache(this)) return this.multiply(sc); // precomputes\n      // We don't have method for double scalar multiplication (aP + bQ):\n      // Even with using Strauss-Shamir trick, it's 35% slower than na\u00EFve mul+add.\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);\n        const { p1, p2 } = mulEndoUnsafe(Point, p, k1, k2); // 30% faster vs wnaf.unsafe\n        return finishEndo(endo.beta, p1, p2, k1neg, k2neg);\n      } else {\n        return wnaf.unsafe(p, sc);\n      }\n    }\n\n    /**\n     * Converts Projective point to affine (x, y) coordinates.\n     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n     */\n    toAffine(invertedZ?: T): AffinePoint<T> {\n      return toAffineMemo(this, invertedZ);\n    }\n\n    /**\n     * Checks whether Point is free of torsion elements (is in prime subgroup).\n     * Always torsion-free for cofactor=1 curves.\n     */\n    isTorsionFree(): boolean {\n      const { isTorsionFree } = extraOpts;\n      if (cofactor === _1n) return true;\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      return wnaf.unsafe(this, CURVE_ORDER).is0();\n    }\n\n    clearCofactor(): Point {\n      const { clearCofactor } = extraOpts;\n      if (cofactor === _1n) return this; // Fast-path\n      if (clearCofactor) return clearCofactor(Point, this) as Point;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    isSmallOrder(): boolean {\n      // can we use this.clearCofactor()?\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    toBytes(isCompressed = true): Uint8Array {\n      abool(isCompressed, 'isCompressed');\n      this.assertValidity();\n      return encodePoint(Point, this, isCompressed);\n    }\n\n    toHex(isCompressed = true): string {\n      return bytesToHex(this.toBytes(isCompressed));\n    }\n\n    toString() {\n      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n    }\n  }\n  const bits = Fn.BITS;\n  const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);\n  Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n  return Point;\n}\n\n/** Methods of ECDSA signature instance. */\nexport interface ECDSASignature {\n  readonly r: bigint;\n  readonly s: bigint;\n  readonly recovery?: number;\n  addRecoveryBit(recovery: number): ECDSASignature & { readonly recovery: number };\n  hasHighS(): boolean;\n  recoverPublicKey(messageHash: Uint8Array): WeierstrassPoint<bigint>;\n  toBytes(format?: string): Uint8Array;\n  toHex(format?: string): string;\n}\n/** Methods of ECDSA signature constructor. */\nexport type ECDSASignatureCons = {\n  new (r: bigint, s: bigint, recovery?: number): ECDSASignature;\n  fromBytes(bytes: Uint8Array, format?: ECDSASignatureFormat): ECDSASignature;\n  fromHex(hex: string, format?: ECDSASignatureFormat): ECDSASignature;\n};\n\n// Points start with byte 0x02 when y is even; otherwise 0x03\nfunction pprefix(hasEvenY: boolean): Uint8Array {\n  return Uint8Array.of(hasEvenY ? 0x02 : 0x03);\n}\n\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio<T>(\n  Fp: IField<T>,\n  Z: T\n): (u: T, v: T) => { isValid: boolean; value: T } {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = _0n;\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n  // 2n ** c1 == 2n << (c1-1)\n  const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n  let sqrtRatio = (u: T, v: T): { isValid: boolean; value: T } => {\n    let tv1 = c6; // 1. tv1 = c6\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n    for (let i = c1; i > _1n; i--) {\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\n      tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n    return { isValid: isQR, value: tv3 };\n  };\n  if (Fp.ORDER % _4n === _3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n    sqrtRatio = (u: T, v: T) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n      return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  }\n  // No curves uses that\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n  return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU<T>(\n  Fp: IField<T>,\n  opts: {\n    A: T;\n    B: T;\n    Z: T;\n  }\n): (u: T) => { x: T; y: T } {\n  validateField(Fp);\n  const { A, B, Z } = opts;\n  if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))\n    throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, Z);\n  if (!Fp.isOdd) throw new Error('Field does not have .isOdd()');\n  // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n  return (u: T): { x: T; y: T } => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n    tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3\n    tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n    tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n    tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n    tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n    const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n    y = Fp.mul(y, value); // 20.   y = y * y1\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n    const e1 = Fp.isOdd!(u) === Fp.isOdd!(y); // 23.  e1 = sgn0(u) == sgn0(y)\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n    const tv4_inv = FpInvertBatch(Fp, [tv4], true)[0];\n    x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n    return { x, y };\n  };\n}\n\nfunction getWLengths<T>(Fp: IField<T>, Fn: IField<bigint>) {\n  return {\n    secretKey: Fn.BYTES,\n    publicKey: 1 + Fp.BYTES,\n    publicKeyUncompressed: 1 + 2 * Fp.BYTES,\n    publicKeyHasPrefix: true,\n    signature: 2 * Fn.BYTES,\n  };\n}\n\n/**\n * Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.\n * This helper ensures no signature functionality is present. Less code, smaller bundle size.\n */\nexport function ecdh(\n  Point: WeierstrassPointCons<bigint>,\n  ecdhOpts: { randomBytes?: (bytesLength?: number) => Uint8Array } = {}\n): ECDH {\n  const { Fn } = Point;\n  const randomBytes_ = ecdhOpts.randomBytes || wcRandomBytes;\n  const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: getMinHashLength(Fn.ORDER) });\n\n  function isValidSecretKey(secretKey: Uint8Array) {\n    try {\n      const num = Fn.fromBytes(secretKey);\n      return Fn.isValidNot0(num);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  function isValidPublicKey(publicKey: Uint8Array, isCompressed?: boolean): boolean {\n    const { publicKey: comp, publicKeyUncompressed } = lengths;\n    try {\n      const l = publicKey.length;\n      if (isCompressed === true && l !== comp) return false;\n      if (isCompressed === false && l !== publicKeyUncompressed) return false;\n      return !!Point.fromBytes(publicKey);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Produces cryptographically secure secret key from random of size\n   * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n   */\n  function randomSecretKey(seed = randomBytes_(lengths.seed)): Uint8Array {\n    return mapHashToField(abytes(seed, lengths.seed, 'seed'), Fn.ORDER);\n  }\n\n  /**\n   * Computes public key for a secret key. Checks for validity of the secret key.\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\n   */\n  function getPublicKey(secretKey: Uint8Array, isCompressed = true): Uint8Array {\n    return Point.BASE.multiply(Fn.fromBytes(secretKey)).toBytes(isCompressed);\n  }\n\n  /**\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n   */\n  function isProbPub(item: Uint8Array): boolean | undefined {\n    const { secretKey, publicKey, publicKeyUncompressed } = lengths;\n    if (!isBytes(item)) return undefined;\n    if (('_lengths' in Fn && Fn._lengths) || secretKey === publicKey) return undefined;\n    const l = abytes(item, undefined, 'key').length;\n    return l === publicKey || l === publicKeyUncompressed;\n  }\n\n  /**\n   * ECDH (Elliptic Curve Diffie Hellman).\n   * Computes shared public key from secret key A and public key B.\n   * Checks: 1) secret key validity 2) shared key is on-curve.\n   * Does NOT hash the result.\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns shared public key\n   */\n  function getSharedSecret(\n    secretKeyA: Uint8Array,\n    publicKeyB: Uint8Array,\n    isCompressed = true\n  ): Uint8Array {\n    if (isProbPub(secretKeyA) === true) throw new Error('first arg must be private key');\n    if (isProbPub(publicKeyB) === false) throw new Error('second arg must be public key');\n    const s = Fn.fromBytes(secretKeyA);\n    const b = Point.fromBytes(publicKeyB); // checks for being on-curve\n    return b.multiply(s).toBytes(isCompressed);\n  }\n\n  const utils = {\n    isValidSecretKey,\n    isValidPublicKey,\n    randomSecretKey,\n  };\n  const keygen = createKeygen(randomSecretKey, getPublicKey);\n\n  return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });\n}\n\n/**\n * Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.\n *\n * @param Point created using {@link weierstrass} function\n * @param hash used for 1) message prehash-ing 2) k generation in `sign`, using hmac_drbg(hash)\n * @param ecdsaOpts rarely needed, see {@link ECDSAOpts}\n *\n * @example\n * ```js\n * const p256_Point = weierstrass(...);\n * const p256_sha256 = ecdsa(p256_Point, sha256);\n * const p256_sha224 = ecdsa(p256_Point, sha224);\n * const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });\n * ```\n */\nexport function ecdsa(\n  Point: WeierstrassPointCons<bigint>,\n  hash: CHash,\n  ecdsaOpts: ECDSAOpts = {}\n): ECDSA {\n  ahash(hash);\n  validateObject(\n    ecdsaOpts,\n    {},\n    {\n      hmac: 'function',\n      lowS: 'boolean',\n      randomBytes: 'function',\n      bits2int: 'function',\n      bits2int_modN: 'function',\n    }\n  );\n  ecdsaOpts = Object.assign({}, ecdsaOpts);\n  const randomBytes = ecdsaOpts.randomBytes || wcRandomBytes;\n  const hmac = ecdsaOpts.hmac || ((key, msg) => nobleHmac(hash, key, msg));\n\n  const { Fp, Fn } = Point;\n  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;\n  const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);\n  const defaultSigOpts: Required<ECDSASignOpts> = {\n    prehash: true,\n    lowS: typeof ecdsaOpts.lowS === 'boolean' ? ecdsaOpts.lowS : true,\n    format: 'compact' as ECDSASignatureFormat,\n    extraEntropy: false,\n  };\n  const hasLargeCofactor = CURVE_ORDER * _2n < Fp.ORDER; // Won't CURVE().h > 2n be more effective?\n\n  function isBiggerThanHalfOrder(number: bigint) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n  function validateRS(title: string, num: bigint): bigint {\n    if (!Fn.isValidNot0(num))\n      throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);\n    return num;\n  }\n  function assertSmallCofactor(): void {\n    // ECDSA recovery is hard for cofactor > 1 curves.\n    // In sign, `r = q.x mod n`, and here we recover q.x from r.\n    // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.\n    // However, for cofactor>1, r+n may not get q.x:\n    // r+n*i would need to be done instead where i is unknown.\n    // To easily get i, we either need to:\n    // a. increase amount of valid recid values (4, 5...); OR\n    // b. prohibit non-prime-order signatures (recid > 1).\n    if (hasLargeCofactor)\n      throw new Error('\"recovered\" sig type is not supported for cofactor >2 curves');\n  }\n  function validateSigLength(bytes: Uint8Array, format: ECDSASignatureFormat) {\n    validateSigFormat(format);\n    const size = lengths.signature!;\n    const sizer = format === 'compact' ? size : format === 'recovered' ? size + 1 : undefined;\n    return abytes(bytes, sizer);\n  }\n\n  /**\n   * ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.\n   */\n  class Signature implements ECDSASignature {\n    readonly r: bigint;\n    readonly s: bigint;\n    readonly recovery?: number;\n\n    constructor(r: bigint, s: bigint, recovery?: number) {\n      this.r = validateRS('r', r); // r in [1..N-1];\n      this.s = validateRS('s', s); // s in [1..N-1];\n      if (recovery != null) {\n        assertSmallCofactor();\n        if (![0, 1, 2, 3].includes(recovery)) throw new Error('invalid recovery id');\n        this.recovery = recovery;\n      }\n      Object.freeze(this);\n    }\n\n    static fromBytes(\n      bytes: Uint8Array,\n      format: ECDSASignatureFormat = defaultSigOpts.format\n    ): Signature {\n      validateSigLength(bytes, format);\n      let recid: number | undefined;\n      if (format === 'der') {\n        const { r, s } = DER.toSig(abytes(bytes));\n        return new Signature(r, s);\n      }\n      if (format === 'recovered') {\n        recid = bytes[0];\n        format = 'compact';\n        bytes = bytes.subarray(1);\n      }\n      const L = lengths.signature! / 2;\n      const r = bytes.subarray(0, L);\n      const s = bytes.subarray(L, L * 2);\n      return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);\n    }\n\n    static fromHex(hex: string, format?: ECDSASignatureFormat) {\n      return this.fromBytes(hexToBytes(hex), format);\n    }\n\n    private assertRecovery(): number {\n      const { recovery } = this;\n      if (recovery == null) throw new Error('invalid recovery id: must be present');\n      return recovery;\n    }\n\n    addRecoveryBit(recovery: number): RecoveredSignature {\n      return new Signature(this.r, this.s, recovery) as RecoveredSignature;\n    }\n\n    recoverPublicKey(messageHash: Uint8Array): WeierstrassPoint<bigint> {\n      const { r, s } = this;\n      const recovery = this.assertRecovery();\n      const radj = recovery === 2 || recovery === 3 ? r + CURVE_ORDER : r;\n      if (!Fp.isValid(radj)) throw new Error('invalid recovery id: sig.r+curve.n != R.x');\n      const x = Fp.toBytes(radj);\n      const R = Point.fromBytes(concatBytes(pprefix((recovery & 1) === 0), x));\n      const ir = Fn.inv(radj); // r^-1\n      const h = bits2int_modN(abytes(messageHash, undefined, 'msgHash')); // Truncate hash\n      const u1 = Fn.create(-h * ir); // -hr^-1\n      const u2 = Fn.create(s * ir); // sr^-1\n      // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.\n      const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));\n      if (Q.is0()) throw new Error('invalid recovery: point at infinify');\n      Q.assertValidity();\n      return Q;\n    }\n\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS(): boolean {\n      return isBiggerThanHalfOrder(this.s);\n    }\n\n    toBytes(format: ECDSASignatureFormat = defaultSigOpts.format) {\n      validateSigFormat(format);\n      if (format === 'der') return hexToBytes(DER.hexFromSig(this));\n      const { r, s } = this;\n      const rb = Fn.toBytes(r);\n      const sb = Fn.toBytes(s);\n      if (format === 'recovered') {\n        assertSmallCofactor();\n        return concatBytes(Uint8Array.of(this.assertRecovery()), rb, sb);\n      }\n      return concatBytes(rb, sb);\n    }\n\n    toHex(format?: ECDSASignatureFormat) {\n      return bytesToHex(this.toBytes(format));\n    }\n  }\n  type RecoveredSignature = Signature & { recovery: number };\n\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n  const bits2int =\n    ecdsaOpts.bits2int ||\n    function bits2int_def(bytes: Uint8Array): bigint {\n      // Our custom check \"just in case\", for protection against DoS\n      if (bytes.length > 8192) throw new Error('input is too large');\n      // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n      // for some cases, since bytes.length * 8 is not actual bitLength.\n      const num = bytesToNumberBE(bytes); // check for == u8 done here\n      const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits\n      return delta > 0 ? num >> BigInt(delta) : num;\n    };\n  const bits2int_modN =\n    ecdsaOpts.bits2int_modN ||\n    function bits2int_modN_def(bytes: Uint8Array): bigint {\n      return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n  // Pads output with zero as per spec\n  const ORDER_MASK = bitMask(fnBits);\n  /** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */\n  function int2octets(num: bigint): Uint8Array {\n    // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`\n    aInRange('num < 2^' + fnBits, num, _0n, ORDER_MASK);\n    return Fn.toBytes(num);\n  }\n\n  function validateMsgAndHash(message: Uint8Array, prehash: boolean) {\n    abytes(message, undefined, 'message');\n    return prehash ? abytes(hash(message), undefined, 'prehashed message') : message;\n  }\n\n  /**\n   * Steps A, D of RFC6979 3.2.\n   * Creates RFC6979 seed; converts msg/privKey to numbers.\n   * Used only in sign, not in verify.\n   *\n   * Warning: we cannot assume here that message has same amount of bytes as curve order,\n   * this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.\n   */\n  function prepSig(message: Uint8Array, secretKey: Uint8Array, opts: ECDSASignOpts) {\n    const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);\n    message = validateMsgAndHash(message, prehash); // RFC6979 3.2 A: h1 = H(m)\n    // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n    const h1int = bits2int_modN(message);\n    const d = Fn.fromBytes(secretKey); // validate secret key, convert to bigint\n    if (!Fn.isValidNot0(d)) throw new Error('invalid private key');\n    const seedArgs = [int2octets(d), int2octets(h1int)];\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\n    if (extraEntropy != null && extraEntropy !== false) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      // gen random bytes OR pass as-is\n      const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;\n      seedArgs.push(abytes(e, undefined, 'extraEntropy')); // check for being bytes\n    }\n    const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2\n    const m = h1int; // no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n    // To transform k => Signature:\n    // q = k\u22C5G\n    // r = q.x mod n\n    // s = k^-1(m + rd) mod n\n    // Can use scalar blinding b^-1(bm + bdr) where b \u2208 [1,q\u22121] according to\n    // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n    // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n    function k2sig(kBytes: Uint8Array): Signature | undefined {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      // Important: all mod() calls here must be done over N\n      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n      if (!Fn.isValidNot0(k)) return; // Valid scalars (including k) must be in 1..N-1\n      const ik = Fn.inv(k); // k^-1 mod n\n      const q = Point.BASE.multiply(k).toAffine(); // q = k\u22C5G\n      const r = Fn.create(q.x); // r = q.x mod n\n      if (r === _0n) return;\n      const s = Fn.create(ik * Fn.create(m + r * d)); // s = k^-1(m + rd) mod n\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3 when q.x>n)\n      let normS = s;\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = Fn.neg(s); // if lowS was passed, ensure s is always in the bottom half of N\n        recovery ^= 1;\n      }\n      return new Signature(r, normS, hasLargeCofactor ? undefined : recovery);\n    }\n    return { seed, k2sig };\n  }\n\n  /**\n   * Signs message hash with a secret key.\n   *\n   * ```\n   * sign(m, d) where\n   *   k = rfc6979_hmac_drbg(m, d)\n   *   (x, y) = G \u00D7 k\n   *   r = x mod n\n   *   s = (m + dr) / k mod n\n   * ```\n   */\n  function sign(message: Uint8Array, secretKey: Uint8Array, opts: ECDSASignOpts = {}): Uint8Array {\n    const { seed, k2sig } = prepSig(message, secretKey, opts); // Steps A, D of RFC6979 3.2.\n    const drbg = createHmacDrbg<Signature>(hash.outputLen, Fn.BYTES, hmac);\n    const sig = drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    return sig.toBytes(opts.format);\n  }\n\n  /**\n   * Verifies a signature against message and public key.\n   * Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.\n   * Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n   *\n   * ```\n   * verify(r, s, h, P) where\n   *   u1 = hs^-1 mod n\n   *   u2 = rs^-1 mod n\n   *   R = u1\u22C5G + u2\u22C5P\n   *   mod(R.x, n) == r\n   * ```\n   */\n  function verify(\n    signature: Uint8Array,\n    message: Uint8Array,\n    publicKey: Uint8Array,\n    opts: ECDSAVerifyOpts = {}\n  ): boolean {\n    const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);\n    publicKey = abytes(publicKey, undefined, 'publicKey');\n    message = validateMsgAndHash(message, prehash);\n    if (!isBytes(signature as any)) {\n      const end = signature instanceof Signature ? ', use sig.toBytes()' : '';\n      throw new Error('verify expects Uint8Array signature' + end);\n    }\n    validateSigLength(signature, format); // execute this twice because we want loud error\n    try {\n      const sig = Signature.fromBytes(signature, format);\n      const P = Point.fromBytes(publicKey);\n      if (lowS && sig.hasHighS()) return false;\n      const { r, s } = sig;\n      const h = bits2int_modN(message); // mod n, not mod p\n      const is = Fn.inv(s); // s^-1 mod n\n      const u1 = Fn.create(h * is); // u1 = hs^-1 mod n\n      const u2 = Fn.create(r * is); // u2 = rs^-1 mod n\n      const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2)); // u1\u22C5G + u2\u22C5P\n      if (R.is0()) return false;\n      const v = Fn.create(R.x); // v = r.x mod n\n      return v === r;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function recoverPublicKey(\n    signature: Uint8Array,\n    message: Uint8Array,\n    opts: ECDSARecoverOpts = {}\n  ): Uint8Array {\n    const { prehash } = validateSigOpts(opts, defaultSigOpts);\n    message = validateMsgAndHash(message, prehash);\n    return Signature.fromBytes(signature, 'recovered').recoverPublicKey(message).toBytes();\n  }\n\n  return Object.freeze({\n    keygen,\n    getPublicKey,\n    getSharedSecret,\n    utils,\n    lengths,\n    Point,\n    sign,\n    verify,\n    recoverPublicKey,\n    Signature,\n    hash,\n  }) satisfies Signer;\n}\n", "/**\n * SECG secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Belongs to Koblitz curves: it has efficiently-computable GLV endomorphism \u03C8,\n * check out {@link EndomorphismOpts}. Seems to be rigid (not backdoored).\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { randomBytes } from '@noble/hashes/utils.js';\nimport { createKeygen, type CurveLengths } from './abstract/curve.ts';\nimport { createHasher, type H2CHasher, isogenyMap } from './abstract/hash-to-curve.ts';\nimport { Field, mapHashToField, pow2 } from './abstract/modular.ts';\nimport {\n  type ECDSA,\n  ecdsa,\n  type EndomorphismOpts,\n  mapToCurveSimpleSWU,\n  type WeierstrassPoint as PointType,\n  weierstrass,\n  type WeierstrassOpts,\n  type WeierstrassPointCons,\n} from './abstract/weierstrass.ts';\nimport { abytes, asciiToBytes, bytesToNumberBE, concatBytes } from './utils.ts';\n\n// Seems like generator was produced from some seed:\n// `Pointk1.BASE.multiply(Pointk1.Fn.inv(2n, N)).toAffine().x`\n// // gives short x 0x3b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63n\nconst secp256k1_CURVE: WeierstrassOpts<bigint> = {\n  p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n  n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n  h: BigInt(1),\n  a: BigInt(0),\n  b: BigInt(7),\n  Gx: BigInt('0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n  Gy: BigInt('0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'),\n};\n\nconst secp256k1_ENDO: EndomorphismOpts = {\n  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n  basises: [\n    [BigInt('0x3086d221a7d46bcde86c90e49284eb15'), -BigInt('0xe4437ed6010e88286f547fa90abfe4c3')],\n    [BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'), BigInt('0x3086d221a7d46bcde86c90e49284eb15')],\n  ],\n};\n\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _2n = /* @__PURE__ */ BigInt(2);\n\n/**\n * \u221An = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y: bigint): bigint {\n  const P = secp256k1_CURVE.p;\n  // prettier-ignore\n  const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n  // prettier-ignore\n  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n  const b2 = (y * y * y) % P; // x^3, 11\n  const b3 = (b2 * b2 * y) % P; // x^7\n  const b6 = (pow2(b3, _3n, P) * b3) % P;\n  const b9 = (pow2(b6, _3n, P) * b3) % P;\n  const b11 = (pow2(b9, _2n, P) * b2) % P;\n  const b22 = (pow2(b11, _11n, P) * b11) % P;\n  const b44 = (pow2(b22, _22n, P) * b22) % P;\n  const b88 = (pow2(b44, _44n, P) * b44) % P;\n  const b176 = (pow2(b88, _88n, P) * b88) % P;\n  const b220 = (pow2(b176, _44n, P) * b44) % P;\n  const b223 = (pow2(b220, _3n, P) * b3) % P;\n  const t1 = (pow2(b223, _23n, P) * b22) % P;\n  const t2 = (pow2(t1, _6n, P) * b2) % P;\n  const root = pow2(t2, _2n, P);\n  if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error('Cannot find square root');\n  return root;\n}\n\nconst Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });\nconst Pointk1 = /* @__PURE__ */ weierstrass(secp256k1_CURVE, {\n  Fp: Fpk1,\n  endo: secp256k1_ENDO,\n});\n\n/**\n * secp256k1 curve: ECDSA and ECDH methods.\n *\n * Uses sha256 to hash messages. To use a different hash,\n * pass `{ prehash: false }` to sign / verify.\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1.js';\n * const { secretKey, publicKey } = secp256k1.keygen();\n * // const publicKey = secp256k1.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello noble');\n * const sig = secp256k1.sign(msg, secretKey);\n * const isValid = secp256k1.verify(sig, msg, publicKey);\n * // const sigKeccak = secp256k1.sign(keccak256(msg), secretKey, { prehash: false });\n * ```\n */\nexport const secp256k1: ECDSA = /* @__PURE__ */ ecdsa(Pointk1, sha256);\n\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES: { [tag: string]: Uint8Array } = {};\nfunction taggedHash(tag: string, ...messages: Uint8Array[]): Uint8Array {\n  let tagP = TAGGED_HASH_PREFIXES[tag];\n  if (tagP === undefined) {\n    const tagH = sha256(asciiToBytes(tag));\n    tagP = concatBytes(tagH, tagH);\n    TAGGED_HASH_PREFIXES[tag] = tagP;\n  }\n  return sha256(concatBytes(tagP, ...messages));\n}\n\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point: PointType<bigint>) => point.toBytes(true).slice(1);\nconst hasEven = (y: bigint) => y % _2n === _0n;\n\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv: Uint8Array) {\n  const { Fn, BASE } = Pointk1;\n  const d_ = Fn.fromBytes(priv);\n  const p = BASE.multiply(d_); // P = d'\u22C5G; 0 < d' < n check is done inside\n  const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);\n  return { scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x: bigint): PointType<bigint> {\n  const Fp = Fpk1;\n  if (!Fp.isValidNot0(x)) throw new Error('invalid x: Fail if x \u2265 p');\n  const xx = Fp.create(x * x);\n  const c = Fp.create(xx * x + BigInt(7)); // Let c = x\u00B3 + 7 mod p.\n  let y = Fp.sqrt(c); // Let y = c^(p+1)/4 mod p. Same as sqrt().\n  // Return the unique point P such that x(P) = x and\n  // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n  if (!hasEven(y)) y = Fp.neg(y);\n  const p = Pointk1.fromAffine({ x, y });\n  p.assertValidity();\n  return p;\n}\nconst num = bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args: Uint8Array[]): bigint {\n  return Pointk1.Fn.create(num(taggedHash('BIP0340/challenge', ...args)));\n}\n\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(secretKey: Uint8Array): Uint8Array {\n  return schnorrGetExtPubKey(secretKey).bytes; // d'=int(sk). Fail if d'=0 or d'\u2265n. Ret bytes(d'\u22C5G)\n}\n\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(\n  message: Uint8Array,\n  secretKey: Uint8Array,\n  auxRand: Uint8Array = randomBytes(32)\n): Uint8Array {\n  const { Fn } = Pointk1;\n  const m = abytes(message, undefined, 'message');\n  const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey); // checks for isWithinCurveOrder\n  const a = abytes(auxRand, 32, 'auxRand'); // Auxiliary random data a: a 32-byte array\n  const t = Fn.toBytes(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n  const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n  // Let k' = int(rand) mod n. Fail if k' = 0. Let R = k'\u22C5G\n  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);\n  const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n  const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n  sig.set(rx, 0);\n  sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);\n  // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n  if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');\n  return sig;\n}\n\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature: Uint8Array, message: Uint8Array, publicKey: Uint8Array): boolean {\n  const { Fp, Fn, BASE } = Pointk1;\n  const sig = abytes(signature, 64, 'signature');\n  const m = abytes(message, undefined, 'message');\n  const pub = abytes(publicKey, 32, 'publicKey');\n  try {\n    const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n    const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r \u2265 p.\n    if (!Fp.isValidNot0(r)) return false;\n    const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s \u2265 n.\n    if (!Fn.isValidNot0(s)) return false;\n\n    const e = challenge(Fn.toBytes(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n    // R = s\u22C5G - e\u22C5P, where -eP == (n-e)P\n    const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));\n    const { x, y } = R.toAffine();\n    // Fail if is_infinite(R) / not has_even_y(R) / x(R) \u2260 r.\n    if (R.is0() || !hasEven(y) || x !== r) return false;\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\nexport type SecpSchnorr = {\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n  getPublicKey: typeof schnorrGetPublicKey;\n  sign: typeof schnorrSign;\n  verify: typeof schnorrVerify;\n  Point: WeierstrassPointCons<bigint>;\n  utils: {\n    randomSecretKey: (seed?: Uint8Array) => Uint8Array;\n    pointToBytes: (point: PointType<bigint>) => Uint8Array;\n    lift_x: typeof lift_x;\n    taggedHash: typeof taggedHash;\n  };\n  lengths: CurveLengths;\n};\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1.js';\n * const { secretKey, publicKey } = schnorr.keygen();\n * // const publicKey = schnorr.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, secretKey);\n * const isValid = schnorr.verify(sig, msg, publicKey);\n * ```\n */\nexport const schnorr: SecpSchnorr = /* @__PURE__ */ (() => {\n  const size = 32;\n  const seedLength = 48;\n  const randomSecretKey = (seed = randomBytes(seedLength)): Uint8Array => {\n    return mapHashToField(seed, secp256k1_CURVE.n);\n  };\n  return {\n    keygen: createKeygen(randomSecretKey, schnorrGetPublicKey),\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    Point: Pointk1,\n    utils: {\n      randomSecretKey,\n      taggedHash,\n      lift_x,\n      pointToBytes,\n    },\n    lengths: {\n      secretKey: size,\n      publicKey: size,\n      publicKeyHasPrefix: false,\n      signature: size * 2,\n      seed: seedLength,\n    },\n  };\n})();\n\nconst isoMap = /* @__PURE__ */ (() =>\n  isogenyMap(\n    Fpk1,\n    [\n      // xNum\n      [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n      ],\n      // xDen\n      [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n      // yNum\n      [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n      ],\n      // yDen\n      [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n    ].map((i) => i.map((j) => BigInt(j))) as [bigint[], bigint[], bigint[], bigint[]]\n  ))();\nconst mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n  }))();\n\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */\nexport const secp256k1_hasher: H2CHasher<WeierstrassPointCons<bigint>> = /* @__PURE__ */ (() =>\n  createHasher(\n    Pointk1,\n    (scalars: bigint[]) => {\n      const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n      return isoMap(x, y);\n    },\n    {\n      DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n      encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n      p: Fpk1.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha256,\n    }\n  ))();\n", "import { secp256k1 as secp } from '@noble/curves/secp256k1.js'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { SigningError, VerificationError } from '../../errors.js'\nimport { isPromise } from '../../util.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst PUBLIC_KEY_BYTE_LENGTH = 33\nconst PRIVATE_KEY_BYTE_LENGTH = 32\n\nexport { PUBLIC_KEY_BYTE_LENGTH as publicKeyLength }\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength }\n\n/**\n * Hash and sign message with private key\n */\nexport function hashAndSign (key: Uint8Array, msg: Uint8Array | Uint8ArrayList, options?: AbortOptions): Uint8Array | Promise<Uint8Array> {\n  const p = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray())\n\n  if (isPromise(p)) {\n    return p\n      .then(({ digest }) => {\n        options?.signal?.throwIfAborted()\n        return secp.sign(digest, key, {\n          prehash: false,\n          format: 'der'\n        })\n      })\n      .catch(err => {\n        if (err.name === 'AbortError') {\n          throw err\n        }\n\n        throw new SigningError(String(err))\n      })\n  }\n\n  try {\n    return secp.sign(p.digest, key, {\n      prehash: false,\n      format: 'der'\n    })\n  } catch (err) {\n    throw new SigningError(String(err))\n  }\n}\n\n/**\n * Hash message and verify signature with public key\n */\nexport function hashAndVerify (key: Uint8Array, sig: Uint8Array, msg: Uint8Array | Uint8ArrayList, options?: AbortOptions): boolean | Promise<boolean> {\n  const p = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray())\n\n  if (isPromise(p)) {\n    return p\n      .then(({ digest }) => {\n        options?.signal?.throwIfAborted()\n        return secp.verify(sig, digest, key, {\n          prehash: false,\n          format: 'der'\n        })\n      })\n      .catch(err => {\n        if (err.name === 'AbortError') {\n          throw err\n        }\n\n        throw new VerificationError(String(err))\n      })\n  }\n\n  try {\n    options?.signal?.throwIfAborted()\n    return secp.verify(sig, p.digest, key, {\n      prehash: false,\n      format: 'der'\n    })\n  } catch (err) {\n    throw new VerificationError(String(err))\n  }\n}\n", "import { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { identity } from 'multiformats/hashes/identity'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { publicKeyToProtobuf } from '../index.js'\nimport { validateSecp256k1PublicKey, compressSecp256k1PublicKey, computeSecp256k1PublicKey, validateSecp256k1PrivateKey } from './utils.js'\nimport { hashAndVerify, hashAndSign } from './index.js'\nimport type { Secp256k1PublicKey as Secp256k1PublicKeyInterface, Secp256k1PrivateKey as Secp256k1PrivateKeyInterface, AbortOptions } from '@libp2p/interface'\nimport type { Digest } from 'multiformats/hashes/digest'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport class Secp256k1PublicKey implements Secp256k1PublicKeyInterface {\n  public readonly type = 'secp256k1'\n  public readonly raw: Uint8Array\n  public readonly _key: Uint8Array\n\n  constructor (key: Uint8Array) {\n    this._key = validateSecp256k1PublicKey(key)\n    this.raw = compressSecp256k1PublicKey(this._key)\n  }\n\n  toMultihash (): Digest<0x0, number> {\n    return identity.digest(publicKeyToProtobuf(this))\n  }\n\n  toCID (): CID<unknown, 114, 0x0, 1> {\n    return CID.createV1(114, this.toMultihash())\n  }\n\n  toString (): string {\n    return base58btc.encode(this.toMultihash().bytes).substring(1)\n  }\n\n  equals (key: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  verify (data: Uint8Array | Uint8ArrayList, sig: Uint8Array, options?: AbortOptions): boolean {\n    return hashAndVerify(this._key, sig, data, options)\n  }\n}\n\nexport class Secp256k1PrivateKey implements Secp256k1PrivateKeyInterface {\n  public readonly type = 'secp256k1'\n  public readonly raw: Uint8Array\n  public readonly publicKey: Secp256k1PublicKey\n\n  constructor (key: Uint8Array, publicKey?: Uint8Array) {\n    this.raw = validateSecp256k1PrivateKey(key)\n    this.publicKey = new Secp256k1PublicKey(publicKey ?? computeSecp256k1PublicKey(key))\n  }\n\n  equals (key?: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  sign (message: Uint8Array | Uint8ArrayList, options?: AbortOptions): Uint8Array | Promise<Uint8Array> {\n    return hashAndSign(this.raw, message, options)\n  }\n}\n", "import { InvalidPrivateKeyError, InvalidPublicKeyError } from '@libp2p/interface'\nimport { secp256k1 as secp } from '@noble/curves/secp256k1.js'\nimport { Secp256k1PublicKey as Secp256k1PublicKeyClass, Secp256k1PrivateKey as Secp256k1PrivateKeyClass } from './secp256k1.js'\nimport type { Secp256k1PublicKey, Secp256k1PrivateKey } from '@libp2p/interface'\n\nconst PRIVATE_KEY_BYTE_LENGTH = 32\n\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength }\n\nexport function unmarshalSecp256k1PrivateKey (bytes: Uint8Array): Secp256k1PrivateKey {\n  return new Secp256k1PrivateKeyClass(bytes)\n}\n\nexport function unmarshalSecp256k1PublicKey (bytes: Uint8Array): Secp256k1PublicKey {\n  return new Secp256k1PublicKeyClass(bytes)\n}\n\nexport async function generateSecp256k1KeyPair (): Promise<Secp256k1PrivateKey> {\n  const privateKeyBytes = generateSecp256k1PrivateKey()\n  return new Secp256k1PrivateKeyClass(privateKeyBytes)\n}\n\nexport function compressSecp256k1PublicKey (key: Uint8Array): Uint8Array {\n  return secp.Point.fromBytes(key).toBytes()\n}\n\nexport function decompressSecp256k1PublicKey (key: Uint8Array): Uint8Array {\n  return secp.Point.fromBytes(key).toBytes(false)\n}\n\nexport function validateSecp256k1PrivateKey (key: Uint8Array): Uint8Array {\n  try {\n    secp.getPublicKey(key, true)\n\n    return key\n  } catch (err) {\n    throw new InvalidPrivateKeyError(String(err))\n  }\n}\n\nexport function validateSecp256k1PublicKey (key: Uint8Array): Uint8Array {\n  try {\n    secp.Point.fromBytes(key)\n\n    return key\n  } catch (err) {\n    throw new InvalidPublicKeyError(String(err))\n  }\n}\n\nexport function computeSecp256k1PublicKey (privateKey: Uint8Array): Uint8Array {\n  try {\n    return secp.getPublicKey(privateKey, true)\n  } catch (err) {\n    throw new InvalidPrivateKeyError(String(err))\n  }\n}\n\nexport function generateSecp256k1PrivateKey (): Uint8Array {\n  return secp.utils.randomSecretKey()\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { base64urlToBuffer } from '../../util.js'\nimport webcrypto from '../../webcrypto/index.js'\nimport type { Curve } from './index.js'\nimport type { ECDHKey, ECDHKeyPair, JWKEncodedPrivateKey, JWKEncodedPublicKey } from '../interface.js'\n\nconst curveLengths = {\n  'P-256': 32,\n  'P-384': 48,\n  'P-521': 66\n}\n\nconst curveTypes = Object.keys(curveLengths)\nconst names = curveTypes.join(' / ')\n\nexport async function generateEphemeralKeyPair (curve: Curve): Promise<ECDHKey> {\n  if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n    throw new InvalidParametersError(`Unknown curve: ${curve}. Must be ${names}`)\n  }\n\n  const pair = await webcrypto.get().subtle.generateKey(\n    {\n      name: 'ECDH',\n      namedCurve: curve\n    },\n    true,\n    ['deriveBits']\n  )\n\n  // forcePrivate is used for testing only\n  const genSharedKey = async (theirPub: Uint8Array, forcePrivate?: ECDHKeyPair): Promise<Uint8Array> => {\n    let privateKey\n\n    if (forcePrivate != null) {\n      privateKey = await webcrypto.get().subtle.importKey(\n        'jwk',\n        unmarshalPrivateKey(curve, forcePrivate),\n        {\n          name: 'ECDH',\n          namedCurve: curve\n        },\n        false,\n        ['deriveBits']\n      )\n    } else {\n      privateKey = pair.privateKey\n    }\n\n    const key = await webcrypto.get().subtle.importKey(\n      'jwk',\n      unmarshalPublicKey(curve, theirPub),\n      {\n        name: 'ECDH',\n        namedCurve: curve\n      },\n      false,\n      []\n    )\n\n    const buffer = await webcrypto.get().subtle.deriveBits(\n      {\n        name: 'ECDH',\n        public: key\n      },\n      privateKey,\n      curveLengths[curve] * 8\n    )\n\n    return new Uint8Array(buffer, 0, buffer.byteLength)\n  }\n\n  const publicKey = await webcrypto.get().subtle.exportKey('jwk', pair.publicKey)\n\n  const ecdhKey: ECDHKey = {\n    key: marshalPublicKey(publicKey),\n    genSharedKey\n  }\n\n  return ecdhKey\n}\n\n// Marshal converts a jwk encoded ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\nfunction marshalPublicKey (jwk: JsonWebKey): Uint8Array {\n  if (jwk.crv == null || jwk.x == null || jwk.y == null) {\n    throw new InvalidParametersError('JWK was missing components')\n  }\n\n  if (jwk.crv !== 'P-256' && jwk.crv !== 'P-384' && jwk.crv !== 'P-521') {\n    throw new InvalidParametersError(`Unknown curve: ${jwk.crv}. Must be ${names}`)\n  }\n\n  const byteLen = curveLengths[jwk.crv]\n\n  return uint8ArrayConcat([\n    Uint8Array.from([4]), // uncompressed point\n    base64urlToBuffer(jwk.x, byteLen),\n    base64urlToBuffer(jwk.y, byteLen)\n  ], 1 + byteLen * 2)\n}\n\n/**\n * Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\n */\nfunction unmarshalPublicKey (curve: Curve, key: Uint8Array): JWKEncodedPublicKey {\n  if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n    throw new InvalidParametersError(`Unknown curve: ${curve}. Must be ${names}`)\n  }\n\n  const byteLen = curveLengths[curve]\n\n  if (!uint8ArrayEquals(key.subarray(0, 1), Uint8Array.from([4]))) {\n    throw new InvalidParametersError('Cannot unmarshal public key - invalid key format')\n  }\n\n  return {\n    kty: 'EC',\n    crv: curve,\n    x: uint8ArrayToString(key.subarray(1, byteLen + 1), 'base64url'),\n    y: uint8ArrayToString(key.subarray(1 + byteLen), 'base64url'),\n    ext: true\n  }\n}\n\nconst unmarshalPrivateKey = (curve: Curve, key: ECDHKeyPair): JWKEncodedPrivateKey => ({\n  ...unmarshalPublicKey(curve, key.public),\n  d: uint8ArrayToString(key.private, 'base64url')\n})\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport * as hmac from '../hmac/index.js'\nimport type { EnhancedKey, EnhancedKeyPair } from './interface.js'\n\ninterface Cipher {\n  ivSize: number\n  keySize: number\n}\n\nconst cipherMap: Record<string, Cipher> = {\n  'AES-128': {\n    ivSize: 16,\n    keySize: 16\n  },\n  'AES-256': {\n    ivSize: 16,\n    keySize: 32\n  },\n  Blowfish: {\n    ivSize: 8,\n    keySize: 32\n  }\n}\n\n/**\n * Generates a set of keys for each party by stretching the shared key.\n * (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\n */\nexport async function keyStretcher (cipherType: 'AES-128' | 'AES-256' | 'Blowfish', hash: 'SHA1' | 'SHA256' | 'SHA512', secret: Uint8Array): Promise<EnhancedKeyPair> {\n  if (cipherType !== 'AES-128' && cipherType !== 'AES-256' && cipherType !== 'Blowfish') {\n    throw new InvalidParametersError('Cipher type was missing or unsupported')\n  }\n\n  if (hash !== 'SHA1' && hash !== 'SHA256' && hash !== 'SHA512') {\n    throw new InvalidParametersError('Hash type was missing or unsupported')\n  }\n\n  if (secret == null || !(secret instanceof Uint8Array)) {\n    throw new InvalidParametersError('Secret was missing or an incorrect type')\n  }\n\n  const cipher = cipherMap[cipherType]\n  const cipherKeySize = cipher.keySize\n  const ivSize = cipher.ivSize\n  const hmacKeySize = 20\n  const seed = uint8ArrayFromString('key expansion')\n  const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize)\n\n  const m = await hmac.create(hash, secret)\n  let a = await m.digest(seed)\n\n  const result = []\n  let j = 0\n\n  while (j < resultLength) {\n    const b = await m.digest(uint8ArrayConcat([a, seed]))\n    let todo = b.length\n\n    if (j + todo > resultLength) {\n      todo = resultLength - j\n    }\n\n    result.push(b)\n    j += todo\n    a = await m.digest(a)\n  }\n\n  const half = resultLength / 2\n  const resultBuffer = uint8ArrayConcat(result)\n  const r1 = resultBuffer.subarray(0, half)\n  const r2 = resultBuffer.subarray(half, resultLength)\n\n  const createKey = (res: Uint8Array): EnhancedKey => ({\n    iv: res.subarray(0, ivSize),\n    cipherKey: res.subarray(ivSize, ivSize + cipherKeySize),\n    macKey: res.subarray(ivSize + cipherKeySize)\n  })\n\n  return {\n    k1: createKey(r1),\n    k2: createKey(r2)\n  }\n}\n", "/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://www.rfc-editor.org/rfc/rfc6151\n * @module\n */\nimport { Chi, HashMD, Maj } from './_md.ts';\nimport { type CHash, clean, createHasher, rotl } from './utils.ts';\n\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n  0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n\n/** Internal SHA1 legacy hash class. */\nexport class _SHA1 extends HashMD<_SHA1> {\n  private A = SHA1_IV[0] | 0;\n  private B = SHA1_IV[1] | 0;\n  private C = SHA1_IV[2] | 0;\n  private D = SHA1_IV[3] | 0;\n  private E = SHA1_IV[4] | 0;\n\n  constructor() {\n    super(64, 20, 8, false);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { A, B, C, D, E } = this;\n    return [A, B, C, D, E];\n  }\n  protected set(A: number, B: number, C: number, D: number, E: number): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) SHA1_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 80; i++)\n      SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n    // Compression function main loop, 80 rounds\n    let { A, B, C, D, E } = this;\n    for (let i = 0; i < 80; i++) {\n      let F, K;\n      if (i < 20) {\n        F = Chi(B, C, D);\n        K = 0x5a827999;\n      } else if (i < 40) {\n        F = B ^ C ^ D;\n        K = 0x6ed9eba1;\n      } else if (i < 60) {\n        F = Maj(B, C, D);\n        K = 0x8f1bbcdc;\n      } else {\n        F = B ^ C ^ D;\n        K = 0xca62c1d6;\n      }\n      const T = (rotl(A, 5) + F + E + K + SHA1_W[i]) | 0;\n      E = D;\n      D = C;\n      C = rotl(B, 30);\n      B = A;\n      A = T;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    this.set(A, B, C, D, E);\n  }\n  protected roundClean(): void {\n    clean(SHA1_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexport const sha1: CHash = /* @__PURE__ */ createHasher(() => new _SHA1());\n\n/** Per-round constants */\nconst p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) =>\n  Math.floor(p32 * Math.abs(Math.sin(i + 1)))\n);\n\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** Internal MD5 legacy hash class. */\nexport class _MD5 extends HashMD<_MD5> {\n  private A = MD5_IV[0] | 0;\n  private B = MD5_IV[1] | 0;\n  private C = MD5_IV[2] | 0;\n  private D = MD5_IV[3] | 0;\n\n  constructor() {\n    super(64, 16, 8, true);\n  }\n  protected get(): [number, number, number, number] {\n    const { A, B, C, D } = this;\n    return [A, B, C, D];\n  }\n  protected set(A: number, B: number, C: number, D: number): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) MD5_W[i] = view.getUint32(offset, true);\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D } = this;\n    for (let i = 0; i < 64; i++) {\n      let F, g, s;\n      if (i < 16) {\n        F = Chi(B, C, D);\n        g = i;\n        s = [7, 12, 17, 22];\n      } else if (i < 32) {\n        F = Chi(D, B, C);\n        g = (5 * i + 1) % 16;\n        s = [5, 9, 14, 20];\n      } else if (i < 48) {\n        F = B ^ C ^ D;\n        g = (3 * i + 5) % 16;\n        s = [4, 11, 16, 23];\n      } else {\n        F = C ^ (B | ~D);\n        g = (7 * i) % 16;\n        s = [6, 10, 15, 21];\n      }\n      F = F + A + K[i] + MD5_W[g];\n      A = D;\n      D = C;\n      C = B;\n      B = B + rotl(F, s[i % 4]);\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    this.set(A, B, C, D);\n  }\n  protected roundClean(): void {\n    clean(MD5_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nexport const md5: CHash = /* @__PURE__ */ createHasher(() => new _MD5());\n\n// RIPEMD-160\n\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n]);\nconst Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (() => {\n  const L = [Id160];\n  const R = [Pi160];\n  const res = [L, R];\n  for (let i = 0; i < 4; i++) for (let j of res) j.push(j[i].map((k) => Rho160[k]));\n  return res;\n})();\nconst idxL = /* @__PURE__ */ (() => idxLR[0])();\nconst idxR = /* @__PURE__ */ (() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\n\nconst shifts160 = /* @__PURE__ */ [\n  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n  0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n  0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction ripemd_f(group: number, x: number, y: number, z: number): number {\n  if (group === 0) return x ^ y ^ z;\n  if (group === 1) return (x & y) | (~x & z);\n  if (group === 2) return (x | ~y) ^ z;\n  if (group === 3) return (x & z) | (y & ~z);\n  return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nexport class _RIPEMD160 extends HashMD<_RIPEMD160> {\n  private h0 = 0x67452301 | 0;\n  private h1 = 0xefcdab89 | 0;\n  private h2 = 0x98badcfe | 0;\n  private h3 = 0x10325476 | 0;\n  private h4 = 0xc3d2e1f0 | 0;\n\n  constructor() {\n    super(64, 20, 8, true);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { h0, h1, h2, h3, h4 } = this;\n    return [h0, h1, h2, h3, h4];\n  }\n  protected set(h0: number, h1: number, h2: number, h3: number, h4: number): void {\n    this.h0 = h0 | 0;\n    this.h1 = h1 | 0;\n    this.h2 = h2 | 0;\n    this.h3 = h3 | 0;\n    this.h4 = h4 | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) BUF_160[i] = view.getUint32(offset, true);\n    // prettier-ignore\n    let al = this.h0 | 0, ar = al,\n        bl = this.h1 | 0, br = bl,\n        cl = this.h2 | 0, cr = cl,\n        dl = this.h3 | 0, dr = dl,\n        el = this.h4 | 0, er = el;\n\n    // Instead of iterating 0 to 80, we split it into 5 groups\n    // And use the groups in constants, functions, etc. Much simpler\n    for (let group = 0; group < 5; group++) {\n      const rGroup = 4 - group;\n      const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n      const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n      const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n      for (let i = 0; i < 16; i++) {\n        const tl = (rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;\n        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n      }\n      // 2 loops are 10% faster\n      for (let i = 0; i < 16; i++) {\n        const tr = (rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;\n        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n      }\n    }\n    // Add the compressed chunk to the current hash value\n    this.set(\n      (this.h1 + cl + dr) | 0,\n      (this.h2 + dl + er) | 0,\n      (this.h3 + el + ar) | 0,\n      (this.h4 + al + br) | 0,\n      (this.h0 + bl + cr) | 0\n    );\n  }\n  protected roundClean(): void {\n    clean(BUF_160);\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nexport const ripemd160: CHash = /* @__PURE__ */ createHasher(() => new _RIPEMD160());\n", "/**\n * PBKDF (RFC 2898). Can be used to create a key from password and salt.\n * @module\n */\nimport { hmac } from './hmac.ts';\n// prettier-ignore\nimport {\n  ahash, anumber,\n  asyncLoop, checkOpts, clean, createView, kdfInputToBytes,\n  type CHash,\n  type Hash,\n  type KDFInput\n} from './utils.ts';\n\n/**\n * PBKDF2 options:\n * * c: iterations, should probably be higher than 100_000\n * * dkLen: desired length of derived key in bytes\n * * asyncTick: max time in ms for which async function can block execution\n */\nexport type Pbkdf2Opt = {\n  c: number;\n  dkLen?: number;\n  asyncTick?: number;\n};\n// Common start and end for sync/async functions\nfunction pbkdf2Init(hash: CHash, _password: KDFInput, _salt: KDFInput, _opts: Pbkdf2Opt) {\n  ahash(hash);\n  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);\n  const { c, dkLen, asyncTick } = opts;\n  anumber(c, 'c');\n  anumber(dkLen, 'dkLen');\n  anumber(asyncTick, 'asyncTick');\n  if (c < 1) throw new Error('iterations (c) must be >= 1');\n  const password = kdfInputToBytes(_password, 'password');\n  const salt = kdfInputToBytes(_salt, 'salt');\n  // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n  const DK = new Uint8Array(dkLen);\n  // U1 = PRF(Password, Salt + INT_32_BE(i))\n  const PRF = hmac.create(hash, password);\n  const PRFSalt = PRF._cloneInto().update(salt);\n  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\n\nfunction pbkdf2Output<T extends Hash<T>>(\n  PRF: Hash<T>,\n  PRFSalt: Hash<T>,\n  DK: Uint8Array,\n  prfW: Hash<T>,\n  u: Uint8Array\n) {\n  PRF.destroy();\n  PRFSalt.destroy();\n  if (prfW) prfW.destroy();\n  clean(u);\n  return DK;\n}\n\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n * @example\n * const key = pbkdf2(sha256, 'password', 'salt', { dkLen: 32, c: Math.pow(2, 18) });\n */\nexport function pbkdf2(\n  hash: CHash,\n  password: KDFInput,\n  salt: KDFInput,\n  opts: Pbkdf2Opt\n): Uint8Array {\n  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n  let prfW: any; // Working copy\n  const arr = new Uint8Array(4);\n  const view = createView(arr);\n  const u = new Uint8Array(PRF.outputLen);\n  // DK = T1 + T2 + \u22EF + Tdklen/hlen\n  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n    // Ti = F(Password, Salt, c, i)\n    const Ti = DK.subarray(pos, pos + PRF.outputLen);\n    view.setInt32(0, ti, false);\n    // F(Password, Salt, c, i) = U1 ^ U2 ^ \u22EF ^ Uc\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n    Ti.set(u.subarray(0, Ti.length));\n    for (let ui = 1; ui < c; ui++) {\n      // Uc = PRF(Password, Uc\u22121)\n      PRF._cloneInto(prfW).update(u).digestInto(u);\n      for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];\n    }\n  }\n  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function. Async version.\n * @example\n * await pbkdf2Async(sha256, 'password', 'salt', { dkLen: 32, c: 500_000 });\n */\nexport async function pbkdf2Async(\n  hash: CHash,\n  password: KDFInput,\n  salt: KDFInput,\n  opts: Pbkdf2Opt\n): Promise<Uint8Array> {\n  const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n  let prfW: any; // Working copy\n  const arr = new Uint8Array(4);\n  const view = createView(arr);\n  const u = new Uint8Array(PRF.outputLen);\n  // DK = T1 + T2 + \u22EF + Tdklen/hlen\n  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n    // Ti = F(Password, Salt, c, i)\n    const Ti = DK.subarray(pos, pos + PRF.outputLen);\n    view.setInt32(0, ti, false);\n    // F(Password, Salt, c, i) = U1 ^ U2 ^ \u22EF ^ Uc\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n    Ti.set(u.subarray(0, Ti.length));\n    await asyncLoop(c - 1, asyncTick, () => {\n      // Uc = PRF(Password, Uc\u22121)\n      PRF._cloneInto(prfW).update(u).digestInto(u);\n      for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];\n    });\n  }\n  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { sha1 } from '@noble/hashes/legacy.js'\nimport { pbkdf2 as pbkdf2Sync } from '@noble/hashes/pbkdf2.js'\nimport { sha256, sha512 } from '@noble/hashes/sha2.js'\nimport { base64 } from 'multiformats/bases/base64'\n\n/**\n * Maps an IPFS hash name to its @noble/hashes equivalent.\n *\n * See https://github.com/multiformats/multihash/blob/master/hashtable.csv\n *\n * @private\n */\nconst hashName = {\n  sha1,\n  'sha2-256': sha256,\n  'sha2-512': sha512\n}\n\n/**\n * Computes the Password-Based Key Derivation Function 2.\n */\nexport default function pbkdf2 (password: string, salt: string | Uint8Array, iterations: number, keySize: number, hash: string): string {\n  if (hash !== 'sha1' && hash !== 'sha2-256' && hash !== 'sha2-512') {\n    const types = Object.keys(hashName).join(' / ')\n    throw new InvalidParametersError(`Hash '${hash}' is unknown or not supported. Must be ${types}`)\n  }\n\n  const hasher = hashName[hash]\n  const dek = pbkdf2Sync(\n    hasher,\n    password,\n    salt, {\n      c: iterations,\n      dkLen: keySize\n    }\n  )\n\n  return base64.encode(dek).substring(1)\n}\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "index_browser_exports", "keys_exports", "pbkdf2", "randomBytes", "index_browser_exports", "__export", "create", "SigningError", "message", "VerificationError", "WebCryptoMissingError", "webcrypto_browser_default", "win", "nativeCrypto", "WebCryptoMissingError", "webcrypto_default", "webcrypto_browser_default", "lengths_default", "hashTypes", "sign", "key", "data", "buf", "webcrypto_default", "create", "hashType", "secret", "hash", "lengths_default", "keys_exports", "__export", "generateEphemeralKeyPair", "generateKeyPair", "generateKeyPairFromSeed", "keyStretcher", "privateKeyFromCryptoKeyPair", "privateKeyFromProtobuf", "privateKeyFromRaw", "privateKeyToCryptoKeyPair", "privateKeyToProtobuf", "publicKeyFromMultihash", "publicKeyFromProtobuf", "publicKeyFromRaw", "publicKeyToProtobuf", "InvalidParametersError", "message", "InvalidPublicKeyError", "InvalidPrivateKeyError", "UnsupportedKeyTypeError", "message", "base58_exports", "__export", "base58btc", "base58flickr", "empty", "equals", "aa", "bb", "ii", "coerce", "o", "fromString", "str", "toString", "b", "base", "ALPHABET", "name", "BASE_MAP", "j", "i", "x", "xc", "BASE", "LEADER", "FACTOR", "iFACTOR", "encode", "source", "zeroes", "length", "pbegin", "pend", "size", "b58", "carry", "it1", "it2", "str", "decodeUnsafe", "psz", "b256", "it3", "it4", "vch", "decode", "string", "buffer", "src", "_brrp__multiformats_scope_baseX", "base_x_default", "Encoder", "name", "prefix", "baseEncode", "bytes", "Decoder", "baseDecode", "prefixCodePoint", "text", "decoder", "or", "ComposedDecoder", "decoders", "input", "left", "right", "Codec", "from", "encode", "decode", "baseX", "alphabet", "base_x_default", "coerce", "string", "alphabetIdx", "bitsPerChar", "end", "out", "bits", "buffer", "written", "i", "value", "data", "pad", "mask", "createAlphabetIdx", "rfc4648", "base58btc", "baseX", "base58flickr", "base32_exports", "__export", "base32", "base32hex", "base32hexpad", "base32hexpadupper", "base32hexupper", "base32pad", "base32padupper", "base32upper", "base32z", "base32", "rfc4648", "base32upper", "base32pad", "base32padupper", "base32hex", "base32hexupper", "base32hexpad", "base32hexpadupper", "base32z", "base36_exports", "__export", "base36", "base36upper", "base36", "baseX", "base36upper", "encode_1", "encode", "MSB", "REST", "MSBALL", "INT", "num", "out", "offset", "oldOffset", "decode", "read", "MSB$1", "REST$1", "buf", "res", "shift", "counter", "b", "l", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "length", "value", "varint", "_brrp_varint", "varint_default", "decode", "data", "offset", "varint_default", "encodeTo", "int", "target", "encodingLength", "create", "code", "digest", "size", "sizeOffset", "encodingLength", "digestOffset", "bytes", "encodeTo", "Digest", "decode", "multihash", "coerce", "equals", "a", "b", "data", "format", "link", "base", "bytes", "version", "toStringV0", "baseCache", "base58btc", "toStringV1", "base32", "cache", "baseCache", "cid", "CID", "_CID", "version", "code", "multihash", "bytes", "DAG_PB_CODE", "SHA_256_CODE", "digest", "create", "other", "self", "unknown", "equals", "base", "format", "input", "value", "encodeCID", "cidSymbol", "decode", "remainder", "specs", "prefixSize", "multihashBytes", "coerce", "digestBytes", "Digest", "initialBytes", "offset", "next", "i", "length", "codec", "multihashCode", "digestSize", "size", "multihashSize", "source", "prefix", "parseCIDtoBytes", "decoder", "base58btc", "base32", "base36", "toStringV0", "toStringV1", "codeOffset", "encodingLength", "hashOffset", "encodeTo", "identity_exports", "__export", "identity", "code", "name", "encode", "coerce", "digest", "input", "options", "create", "identity", "equals", "a", "b", "i", "alloc", "size", "allocUnsafe", "concat", "arrays", "length", "acc", "curr", "output", "allocUnsafe", "offset", "arr", "symbol", "findBufAndOffset", "bufs", "index", "offset", "buf", "bufEnd", "isUint8ArrayList", "value", "Uint8ArrayList", "_Uint8ArrayList", "data", "length", "res", "i", "bytes", "beginInclusive", "endExclusive", "concat", "list", "bufStart", "sliceStartInBuf", "sliceEndsInBuf", "start", "search", "needle", "M", "radix", "rightmostPositions", "c", "j", "right", "lastIndex", "lastPatIndex", "skip", "char", "byteOffset", "allocUnsafe", "littleEndian", "alloc", "other", "equals", "acc", "curr", "base10_exports", "__export", "base10", "base10", "baseX", "base16_exports", "__export", "base16", "base16upper", "base16", "rfc4648", "base16upper", "base2_exports", "__export", "base2", "base2", "rfc4648", "base256emoji_exports", "__export", "base256emoji", "alphabet", "alphabetBytesToChars", "p", "c", "i", "alphabetCharsToBytes", "codePoint", "encode", "data", "decode", "str", "byts", "char", "byt", "base256emoji", "from", "base64_exports", "__export", "base64", "base64pad", "base64url", "base64urlpad", "base64", "rfc4648", "base64pad", "base64url", "base64urlpad", "base8_exports", "__export", "base8", "base8", "rfc4648", "identity_exports", "__export", "identity", "identity", "from", "buf", "toString", "str", "fromString", "textEncoder", "textDecoder", "sha2_browser_exports", "__export", "sha256", "sha512", "DEFAULT_MIN_DIGEST_LENGTH", "from", "name", "code", "encode", "minDigestLength", "maxDigestLength", "Hasher", "input", "options", "result", "createDigest", "digest", "truncate", "create", "sha", "name", "data", "sha256", "from", "sha512", "bases", "identity_exports", "base2_exports", "base8_exports", "base10_exports", "base16_exports", "base32_exports", "base36_exports", "base58_exports", "base64_exports", "base256emoji_exports", "hashes", "sha2_browser_exports", "createCodec", "name", "prefix", "encode", "decode", "string", "buf", "str", "ascii", "i", "allocUnsafe", "BASES", "bases", "bases_default", "fromString", "string", "encoding", "base", "bases_default", "toString", "array", "encoding", "base", "bases_default", "TAG_MASK", "LONG_LENGTH_MASK", "LONG_LENGTH_BYTES_MASK", "decoders", "readSequence", "readInteger", "readBitString", "readOctetString", "readNull", "readObjectIdentifier", "decodeDer", "buf", "context", "tag", "readLength", "length", "count", "str", "i", "entries", "result", "start", "end", "vals", "finalOffset", "byte", "val1", "val2", "oid", "num", "val", "unusedBits", "bytes", "encodeNumber", "value", "number", "array", "Uint8ArrayList", "encodeLength", "encodeInteger", "contents", "mask", "encodeBitString", "encodeOctetString", "encodeSequence", "values", "output", "ECDSA_P_256_OID", "ECDSA_P_384_OID", "ECDSA_P_521_OID", "generateECDSAKey", "curve", "keyPair", "hashAndSign", "key", "msg", "options", "privateKey", "signature", "hashAndVerify", "sig", "publicKey", "result", "OID_256", "OID_384", "OID_521", "P_256_KEY_JWK", "P_384_KEY_JWK", "P_521_KEY_JWK", "P_256_KEY_LENGTH", "P_384_KEY_LENGTH", "P_521_KEY_LENGTH", "unmarshalECDSAPrivateKey", "bytes", "message", "decodeDer", "pkiMessageToECDSAPrivateKey", "privateKey", "d", "toString", "coordinates", "offset", "x", "y", "ECDSAPrivateKey", "InvalidParametersError", "unmarshalECDSAPublicKey", "pkiMessageToECDSAPublicKey", "ECDSAPublicKey", "privateKeyToPKIMessage", "encodeSequence", "encodeInteger", "encodeOctetString", "fromString", "getOID", "encodeBitString", "Uint8ArrayList", "publicKeyToPKIMessage", "publicKey", "curve", "generateECDSAKeyPair", "key", "generateECDSAKey", "ECDSAPublicKey", "jwk", "publicKeyToPKIMessage", "identity", "publicKeyToProtobuf", "CID", "base58btc", "key", "equals", "data", "sig", "options", "hashAndVerify", "ECDSAPrivateKey", "privateKeyToPKIMessage", "message", "hashAndSign", "isBytes", "a", "anumber", "n", "title", "prefix", "abytes", "value", "length", "bytes", "len", "needsLen", "ofLen", "got", "ahash", "h", "aexists", "instance", "checkFinished", "aoutput", "out", "min", "clean", "arrays", "i", "createView", "arr", "rotr", "word", "shift", "rotl", "hasHexBuiltin", "hexes", "_", "i", "bytesToHex", "bytes", "abytes", "hex", "asciis", "asciiToBase16", "ch", "hexToBytes", "hl", "al", "array", "ai", "hi", "n1", "n2", "char", "utf8ToBytes", "str", "kdfInputToBytes", "data", "errorTitle", "abytes", "concatBytes", "arrays", "sum", "i", "a", "res", "pad", "checkOpts", "defaults", "opts", "createHasher", "hashCons", "info", "hashC", "msg", "tmp", "randomBytes", "bytesLength", "cr", "oidNist", "suffix", "Chi", "a", "b", "c", "Maj", "HashMD", "blockLen", "outputLen", "padOffset", "isLE", "createView", "data", "aexists", "abytes", "view", "buffer", "len", "pos", "take", "dataView", "out", "aoutput", "clean", "i", "oview", "outLen", "state", "res", "to", "length", "finished", "destroyed", "SHA256_IV", "SHA512_IV", "U32_MASK64", "_32n", "fromBig", "n", "le", "split", "lst", "len", "Ah", "Al", "i", "h", "l", "shrSH", "h", "_l", "s", "shrSL", "l", "rotrSH", "rotrSL", "rotrBH", "rotrBL", "add", "Ah", "Al", "Bh", "Bl", "l", "add3L", "Cl", "add3H", "low", "Ch", "add4L", "Dl", "add4H", "Dh", "add5L", "El", "add5H", "Eh", "SHA256_K", "SHA256_W", "SHA2_32B", "HashMD", "outputLen", "A", "B", "C", "D", "E", "F", "G", "H", "view", "offset", "i", "W15", "W2", "s0", "rotr", "s1", "sigma1", "T1", "Chi", "T2", "Maj", "clean", "_SHA256", "SHA256_IV", "K512", "split", "n", "SHA512_Kh", "SHA512_Kl", "SHA512_W_H", "SHA512_W_L", "SHA2_64B", "HashMD", "outputLen", "Ah", "Al", "Bh", "Bl", "Ch", "Cl", "Dh", "Dl", "Eh", "El", "Fh", "Fl", "Gh", "Gl", "Hh", "Hl", "view", "offset", "i", "W15h", "W15l", "s0h", "rotrSH", "shrSH", "s0l", "rotrSL", "shrSL", "W2h", "W2l", "s1h", "rotrBH", "s1l", "rotrBL", "SUMl", "add4L", "SUMh", "add4H", "sigma1h", "sigma1l", "CHIh", "CHIl", "T1ll", "add5L", "T1h", "add5H", "T1l", "sigma0h", "sigma0l", "MAJh", "MAJl", "add", "All", "add3L", "add3H", "clean", "_SHA512", "SHA512_IV", "sha256", "createHasher", "_SHA256", "oidNist", "sha512", "createHasher", "_SHA512", "oidNist", "_0n", "_1n", "abool", "value", "title", "prefix", "abignumber", "n", "isPosBig", "anumber", "numberToHexUnpadded", "num", "hex", "abignumber", "hexToNumber", "_0n", "bytesToNumberBE", "bytes", "bytesToHex", "bytesToNumberLE", "copyBytes", "abytes", "numberToBytesBE", "n", "len", "anumber", "res", "hexToBytes", "numberToBytesLE", "copyBytes", "bytes", "isPosBig", "n", "_0n", "inRange", "min", "max", "aInRange", "title", "bitLen", "len", "_1n", "bitMask", "n", "_1n", "createHmacDrbg", "hashLen", "qByteLen", "hmacFn", "anumber", "u8n", "len", "NULL", "byte0", "byte1", "_maxDrbgIters", "v", "k", "i", "reset", "h", "msgs", "concatBytes", "reseed", "seed", "gen", "out", "sl", "pred", "res", "validateObject", "object", "fields", "optFields", "checkField", "fieldName", "expectedType", "isOpt", "val", "current", "iter", "f", "memoized", "fn", "map", "arg", "args", "val", "computed", "_0n", "_1n", "_2n", "_3n", "_4n", "_5n", "_7n", "_8n", "_9n", "_16n", "mod", "a", "b", "result", "pow2", "x", "power", "modulo", "res", "_0n", "invert", "number", "a", "mod", "b", "y", "_1n", "u", "v", "q", "r", "m", "n", "assertIsSquare", "Fp", "root", "sqrt3mod4", "p1div4", "_4n", "sqrt5mod8", "p5div8", "_5n", "_8n", "n2", "_2n", "nv", "sqrt9mod16", "P", "Fp_", "Field", "tn", "tonelliShanks", "c1", "c2", "c3", "c4", "_7n", "_16n", "tv1", "tv2", "tv3", "tv4", "e1", "e2", "e3", "_3n", "Q", "S", "Z", "_Fp", "FpLegendre", "cc", "Q1div2", "M", "c", "t", "R", "i", "t_tmp", "exponent", "FpSqrt", "_9n", "isNegativeLE", "num", "FIELD_FIELDS", "validateField", "field", "initial", "opts", "map", "val", "validateObject", "FpPow", "p", "d", "FpInvertBatch", "nums", "passZero", "inverted", "multipliedAcc", "acc", "invertedAcc", "FpLegendre", "Fp", "n", "p1mod2", "_1n", "_2n", "powered", "yes", "zero", "no", "nLength", "n", "nBitLength", "anumber", "_nBitLength", "nByteLength", "_Field", "_0n", "_1n", "ORDER", "opts", "_nbitLength", "num", "mod", "lhs", "rhs", "power", "FpPow", "invert", "FpSqrt", "numberToBytesLE", "numberToBytesBE", "bytes", "skipValidation", "abytes", "allowedLengths", "BYTES", "isLE", "modFromBytes", "padded", "scalar", "bytesToNumberLE", "bytesToNumberBE", "lst", "FpInvertBatch", "a", "b", "condition", "Field", "getFieldBytesLength", "fieldOrder", "bitLength", "getMinHashLength", "length", "mapHashToField", "key", "isLE", "abytes", "len", "fieldLen", "minLen", "num", "bytesToNumberLE", "bytesToNumberBE", "reduced", "mod", "_1n", "numberToBytesLE", "numberToBytesBE", "_0n", "_1n", "negateCt", "condition", "item", "neg", "normalizeZ", "c", "points", "invertedZs", "FpInvertBatch", "p", "i", "validateW", "W", "bits", "calcWOpts", "scalarBits", "windows", "windowSize", "maxNumber", "mask", "bitMask", "shiftBy", "calcOffsets", "n", "window", "wOpts", "wbits", "nextN", "offsetStart", "offset", "isZero", "isNeg", "isNegF", "pointPrecomputes", "pointWindowSizes", "getW", "P", "assert0", "n", "_0n", "wNAF", "Point", "bits", "elm", "p", "d", "_1n", "point", "W", "windows", "windowSize", "calcWOpts", "points", "base", "window", "i", "precomputes", "f", "wo", "nextN", "offset", "isZero", "isNeg", "isNegF", "offsetF", "calcOffsets", "negateCt", "acc", "item", "transform", "comp", "scalar", "prev", "validateW", "mulEndoUnsafe", "k1", "k2", "p1", "p2", "createField", "order", "field", "isLE", "validateField", "Field", "createCurveFields", "type", "CURVE", "curveOpts", "FpFnLE", "p", "val", "_0n", "Fp", "Fn", "params", "createKeygen", "randomSecretKey", "getPublicKey", "seed", "secretKey", "_0n", "_1n", "_2n", "_8n", "isEdValidXY", "Fp", "CURVE", "x", "y", "x2", "y2", "left", "right", "edwards", "params", "extraOpts", "validated", "createCurveFields", "Fn", "cofactor", "validateObject", "MASK", "modP", "n", "uvRatio", "u", "v", "acoord", "title", "banZero", "min", "aInRange", "aedpoint", "other", "Point", "toAffineMemo", "memoized", "p", "iz", "X", "Y", "Z", "is0", "zz", "assertValidMemo", "a", "d", "T", "X2", "Y2", "Z2", "Z4", "aX2", "XY", "ZT", "bytes", "zip215", "len", "copyBytes", "abytes", "abool", "normed", "lastByte", "bytesToNumberLE", "max", "isValid", "isXOdd", "isLastByteOdd", "hex", "hexToBytes", "windowSize", "isLazy", "wnaf", "X1", "Y1", "Z1", "X1Z2", "X2Z1", "Y1Z2", "Y2Z1", "A", "B", "C", "D", "x1y1", "E", "G", "F", "H", "X3", "Y3", "T3", "Z3", "T1", "T2", "scalar", "f", "normalizeZ", "acc", "invertedZ", "bytesToHex", "wNAF", "eddsa", "Point", "cHash", "eddsaOpts", "validateObject", "prehash", "BASE", "Fp", "Fn", "randomBytes", "adjustScalarBytes", "bytes", "domain", "data", "ctx", "phflag", "abool", "modN_LE", "hash", "bytesToNumberLE", "getPrivateScalar", "key", "len", "lengths", "abytes", "hashed", "head", "prefix", "scalar", "getExtendedPublicKey", "secretKey", "point", "pointBytes", "getPublicKey", "hashDomainToScalar", "context", "msgs", "msg", "concatBytes", "sign", "options", "r", "R", "k", "s", "rs", "verifyOpts", "verify", "sig", "publicKey", "zip215", "mid", "A", "SB", "_size", "randomSecretKey", "seed", "isValidSecretKey", "isBytes", "isValidPublicKey", "utils", "y", "size", "is25519", "u", "_1n", "createKeygen", "_1n", "_2n", "_5n", "_8n", "ed25519_CURVE_p", "ed25519_CURVE", "ed25519_pow_2_252_3", "x", "_10n", "_20n", "_40n", "_80n", "P", "b2", "b4", "pow2", "_2n", "b5", "_1n", "b10", "b20", "b40", "b80", "b160", "b240", "b250", "adjustScalarBytes", "bytes", "ED25519_SQRT_M1", "uvRatio", "u", "v", "v3", "mod", "v7", "pow", "vx2", "root1", "root2", "useRoot1", "useRoot2", "noRoot", "isNegativeLE", "ed25519_Point", "edwards", "ed", "opts", "eddsa", "ed25519_Point", "sha512", "adjustScalarBytes", "ed25519", "PUBLIC_KEY_BYTE_LENGTH", "PRIVATE_KEY_BYTE_LENGTH", "KEYS_BYTE_LENGTH", "ed25519Supported", "webCryptoEd25519SupportedPromise", "webcrypto_default", "generateKey", "privateKeyRaw", "ed25519", "publicKey", "concatKeys", "generateKeyFromSeed", "seed", "KEYS_BYTE_LENGTH", "hashAndSignWebCrypto", "privateKey", "msg", "PRIVATE_KEY_BYTE_LENGTH", "jwk", "toString", "key", "sig", "hashAndSignNoble", "hashAndSign", "hashAndVerifyWebCrypto", "hashAndVerifyNoble", "hashAndVerify", "i", "base64urlToBuffer", "str", "len", "buf", "fromString", "concat", "isPromise", "thing", "Ed25519PublicKey", "key", "ensureEd25519Key", "PUBLIC_KEY_BYTE_LENGTH", "identity", "publicKeyToProtobuf", "CID", "base58btc", "equals", "data", "sig", "options", "result", "hashAndVerify", "isPromise", "res", "Ed25519PrivateKey", "publicKey", "PRIVATE_KEY_BYTE_LENGTH", "message", "hashAndSign", "unmarshalEd25519PrivateKey", "bytes", "PRIVATE_KEY_BYTE_LENGTH", "ensureEd25519Key", "PUBLIC_KEY_BYTE_LENGTH", "privateKeyBytes", "publicKeyBytes", "Ed25519PrivateKey", "unmarshalEd25519PublicKey", "Ed25519PublicKey", "generateEd25519KeyPair", "privateKey", "publicKey", "generateKey", "generateEd25519KeyPairFromSeed", "seed", "generateKeyFromSeed", "key", "length", "InvalidParametersError", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "MSB", "REST", "encodingLength", "value", "encodeUint8Array", "buf", "offset", "decodeUint8Array", "buf", "offset", "b", "res", "REST", "MSB", "N4", "N5", "N6", "N7", "f32", "f8b", "writeFloatLE", "val", "buf", "pos", "readFloatLE", "buf", "pos", "f8b", "f32", "f64", "d8b", "writeDoubleLE", "val", "buf", "pos", "readDoubleLE", "buf", "pos", "d8b", "f64", "MAX_SAFE_NUMBER_INTEGER", "MIN_SAFE_NUMBER_INTEGER", "LongBits", "_LongBits", "lo", "hi", "unsigned", "mask", "part0", "part1", "part2", "value", "zero", "negative", "TWO_32", "sign", "length", "string", "len", "c", "i", "read", "buffer", "start", "end", "parts", "chunk", "t", "write", "offset", "c1", "c2", "indexOutOfRange", "reader", "writeLength", "readFixed32End", "buf", "end", "Uint8ArrayReader", "buffer", "value", "readFloatLE", "readDoubleLE", "length", "start", "bytes", "read", "wireType", "bits", "LongBits", "i", "lo", "hi", "decodeUint8Array", "encodingLength", "createReader", "decodeMessage", "buf", "codec", "opts", "reader", "createReader", "pool", "size", "SIZE", "MAX", "slab", "offset", "allocUnsafe", "buf", "Op", "fn", "len", "val", "noop", "State", "writer", "bufferPool", "pool", "alloc", "size", "allocUnsafe", "Uint8ArrayWriter", "value", "VarintOp", "writeVarint64", "LongBits", "bits", "encodeUint8Array", "encodingLength", "writeByte", "writeFixed32", "writeFloatLE", "writeDoubleLE", "writeBytes", "length", "write", "head", "tail", "buf", "pos", "writeVarint32", "writeBytesBuffer", "writeStringBuffer", "fromString", "createWriter", "encodeMessage", "message", "codec", "w", "createWriter", "CODEC_TYPES", "createCodec", "name", "type", "encode", "decode", "enumeration", "v", "findValue", "val", "encode", "writer", "enumValue", "decode", "reader", "createCodec", "CODEC_TYPES", "message", "encode", "decode", "createCodec", "CODEC_TYPES", "KeyType", "__KeyTypeValues", "enumeration", "PublicKey", "_codec", "message", "obj", "w", "opts", "reader", "length", "end", "tag", "encodeMessage", "buf", "decodeMessage", "PrivateKey", "randomBytes", "length", "InvalidParametersError", "utils_exports", "__export", "MAX_RSA_KEY_SIZE", "generateRSAKeyPair", "jwkToJWKKeyPair", "jwkToPkcs1", "jwkToPkix", "jwkToRSAPrivateKey", "pkcs1MessageToJwk", "pkcs1MessageToRSAPrivateKey", "pkcs1ToJwk", "pkcs1ToRSAPrivateKey", "pkixMessageToJwk", "pkixMessageToRSAPublicKey", "pkixToJwk", "pkixToRSAPublicKey", "RSAPublicKey", "jwk", "digest", "utils_exports", "CID", "base58btc", "key", "equals", "data", "sig", "options", "hashAndVerify", "RSAPrivateKey", "publicKey", "message", "hashAndSign", "MAX_RSA_KEY_SIZE", "SHA2_256_CODE", "MAX_RSA_JWK_SIZE", "RSA_ALGORITHM_IDENTIFIER", "pkcs1ToJwk", "bytes", "message", "decodeDer", "pkcs1MessageToJwk", "toString", "jwkToPkcs1", "jwk", "InvalidParametersError", "encodeSequence", "encodeInteger", "fromString", "pkixToJwk", "pkixMessageToJwk", "keys", "jwkToPkix", "encodeBitString", "pkcs1ToRSAPrivateKey", "pkcs1MessageToRSAPrivateKey", "jwkToRSAPrivateKey", "pkixToRSAPublicKey", "digest", "InvalidPublicKeyError", "pkixMessageToRSAPublicKey", "hash", "sha256", "PublicKey", "KeyType", "create", "RSAPublicKey", "rsaKeySize", "jwkToJWKKeyPair", "RSAPrivateKey", "generateRSAKeyPair", "bits", "generateRSAKey", "key", "RSAES_PKCS1_V1_5_OID", "generateRSAKey", "bits", "options", "pair", "webcrypto_default", "keys", "exportKey", "hashAndSign", "key", "msg", "options", "privateKey", "webcrypto_default", "sig", "hashAndVerify", "publicKey", "result", "exportKey", "pair", "InvalidParametersError", "rsaKeySize", "jwk", "fromString", "_HMAC", "hash", "key", "ahash", "abytes", "blockLen", "pad", "i", "clean", "buf", "aexists", "out", "to", "oHash", "iHash", "finished", "destroyed", "outputLen", "hmac", "message", "divNearest", "num", "den", "_2n", "_splitEndoScalar", "k", "basis", "n", "a1", "b1", "a2", "b2", "c1", "c2", "k1", "k2", "k1neg", "_0n", "k2neg", "MAX_NUM", "bitMask", "bitLen", "_1n", "validateSigFormat", "format", "validateSigOpts", "opts", "def", "optsn", "optName", "abool", "DERErr", "m", "DER", "tag", "data", "E", "dataLen", "len", "numberToHexUnpadded", "lenLen", "pos", "first", "isLong", "length", "lengthBytes", "b", "v", "hex", "bytesToNumberBE", "bytes", "int", "tlv", "abytes", "seqBytes", "seqLeftBytes", "rBytes", "rLeftBytes", "sBytes", "sLeftBytes", "sig", "rs", "ss", "seq", "_3n", "_4n", "weierstrass", "params", "extraOpts", "validated", "createCurveFields", "Fp", "Fn", "CURVE", "cofactor", "CURVE_ORDER", "validateObject", "endo", "lengths", "getWLengths", "assertCompressionIsSupported", "pointToBytes", "_c", "point", "isCompressed", "x", "y", "bx", "hasEvenY", "concatBytes", "pprefix", "pointFromBytes", "comp", "uncomp", "head", "tail", "y2", "weierstrassEquation", "sqrtError", "err", "evenY", "L", "isValidXY", "encodePoint", "decodePoint", "x2", "x3", "left", "right", "_4a3", "_27b2", "acoord", "title", "banZero", "aprjpoint", "other", "Point", "splitEndoScalarN", "toAffineMemo", "memoized", "p", "iz", "X", "Y", "Z", "is0", "zz", "assertValidMemo", "finishEndo", "endoBeta", "k1p", "k2p", "negateCt", "P", "hexToBytes", "windowSize", "isLazy", "wnaf", "X1", "Y1", "Z1", "X2", "Y2", "Z2", "U1", "U2", "a", "b3", "X3", "Y3", "Z3", "t0", "t1", "t2", "t3", "t4", "t5", "scalar", "fake", "mul", "normalizeZ", "k1f", "k2f", "f", "sc", "p1", "p2", "mulEndoUnsafe", "invertedZ", "isTorsionFree", "clearCofactor", "bytesToHex", "bits", "wNAF", "getWLengths", "Fp", "Fn", "ecdh", "Point", "ecdhOpts", "randomBytes_", "randomBytes", "lengths", "getMinHashLength", "isValidSecretKey", "secretKey", "num", "isValidPublicKey", "publicKey", "isCompressed", "comp", "publicKeyUncompressed", "l", "randomSecretKey", "seed", "mapHashToField", "abytes", "getPublicKey", "isProbPub", "item", "isBytes", "getSharedSecret", "secretKeyA", "publicKeyB", "s", "utils", "keygen", "createKeygen", "ecdsa", "hash", "ecdsaOpts", "ahash", "validateObject", "hmac", "key", "msg", "CURVE_ORDER", "fnBits", "defaultSigOpts", "hasLargeCofactor", "_2n", "isBiggerThanHalfOrder", "number", "HALF", "_1n", "validateRS", "title", "assertSmallCofactor", "validateSigLength", "bytes", "format", "validateSigFormat", "size", "sizer", "Signature", "r", "recovery", "recid", "DER", "L", "hex", "hexToBytes", "messageHash", "radj", "x", "concatBytes", "pprefix", "ir", "h", "bits2int_modN", "u1", "u2", "Q", "rb", "sb", "bytesToHex", "bits2int", "bytesToNumberBE", "delta", "ORDER_MASK", "bitMask", "int2octets", "aInRange", "_0n", "validateMsgAndHash", "message", "prehash", "prepSig", "opts", "lowS", "extraEntropy", "validateSigOpts", "h1int", "d", "seedArgs", "e", "m", "k2sig", "kBytes", "k", "ik", "q", "normS", "sign", "createHmacDrbg", "verify", "signature", "end", "sig", "P", "is", "R", "recoverPublicKey", "secp256k1_CURVE", "secp256k1_ENDO", "_2n", "sqrtMod", "y", "P", "secp256k1_CURVE", "_3n", "_6n", "_11n", "_22n", "_23n", "_44n", "_88n", "b2", "b3", "b6", "pow2", "b9", "b11", "b22", "b44", "b88", "b176", "b220", "b223", "t1", "t2", "root", "Fpk1", "Field", "Pointk1", "weierstrass", "secp256k1_ENDO", "secp256k1", "ecdsa", "sha256", "PUBLIC_KEY_BYTE_LENGTH", "PRIVATE_KEY_BYTE_LENGTH", "hashAndSign", "key", "msg", "options", "p", "sha256", "isPromise", "digest", "secp256k1", "err", "SigningError", "hashAndVerify", "sig", "VerificationError", "Secp256k1PublicKey", "key", "validateSecp256k1PublicKey", "compressSecp256k1PublicKey", "identity", "publicKeyToProtobuf", "CID", "base58btc", "equals", "data", "sig", "options", "hashAndVerify", "Secp256k1PrivateKey", "publicKey", "validateSecp256k1PrivateKey", "computeSecp256k1PublicKey", "message", "hashAndSign", "unmarshalSecp256k1PrivateKey", "bytes", "Secp256k1PrivateKey", "unmarshalSecp256k1PublicKey", "Secp256k1PublicKey", "generateSecp256k1KeyPair", "privateKeyBytes", "generateSecp256k1PrivateKey", "compressSecp256k1PublicKey", "key", "secp256k1", "validateSecp256k1PrivateKey", "key", "secp256k1", "err", "InvalidPrivateKeyError", "validateSecp256k1PublicKey", "InvalidPublicKeyError", "computeSecp256k1PublicKey", "privateKey", "generateSecp256k1PrivateKey", "curveLengths", "curveTypes", "names", "generateEphemeralKeyPair", "curve", "InvalidParametersError", "pair", "webcrypto_default", "genSharedKey", "theirPub", "forcePrivate", "privateKey", "unmarshalPrivateKey", "key", "unmarshalPublicKey", "buffer", "publicKey", "marshalPublicKey", "jwk", "byteLen", "concat", "base64urlToBuffer", "equals", "toString", "cipherMap", "keyStretcher", "cipherType", "hash", "secret", "InvalidParametersError", "cipher", "cipherKeySize", "ivSize", "hmacKeySize", "seed", "fromString", "resultLength", "m", "create", "a", "result", "j", "b", "concat", "todo", "half", "resultBuffer", "r1", "r2", "createKey", "res", "generateKeyPair", "type", "bits", "generateEd25519KeyPair", "generateSecp256k1KeyPair", "generateRSAKeyPair", "toBits", "generateECDSAKeyPair", "toCurve", "UnsupportedKeyTypeError", "generateKeyPairFromSeed", "seed", "generateEd25519KeyPairFromSeed", "publicKeyFromProtobuf", "buf", "digest", "Type", "Data", "PublicKey", "data", "KeyType", "pkixToRSAPublicKey", "unmarshalEd25519PublicKey", "unmarshalSecp256k1PublicKey", "unmarshalECDSAPublicKey", "publicKeyFromRaw", "PUBLIC_KEY_BYTE_LENGTH", "message", "decodeDer", "ecdsaOid", "ECDSA_P_256_OID", "ECDSA_P_384_OID", "ECDSA_P_521_OID", "pkiMessageToECDSAPublicKey", "RSAES_PKCS1_V1_5_OID", "pkixMessageToRSAPublicKey", "InvalidParametersError", "publicKeyFromMultihash", "publicKeyToProtobuf", "key", "privateKeyFromProtobuf", "decoded", "PrivateKey", "pkcs1ToRSAPrivateKey", "unmarshalEd25519PrivateKey", "unmarshalSecp256k1PrivateKey", "unmarshalECDSAPrivateKey", "privateKeyFromRaw", "PRIVATE_KEY_BYTE_LENGTH", "pkiMessageToECDSAPrivateKey", "pkcs1MessageToRSAPrivateKey", "privateKeyToProtobuf", "curve", "privateKeyToCryptoKeyPair", "privateKey", "privateKeyFromCryptoKeyPair", "keyPair", "jwk", "jwkToRSAPrivateKey", "ECDSAPrivateKey", "SHA1_IV", "SHA1_W", "_SHA1", "HashMD", "A", "B", "C", "D", "E", "view", "offset", "i", "rotl", "F", "K", "Chi", "Maj", "T", "clean", "sha1", "createHasher", "pbkdf2Init", "hash", "_password", "_salt", "_opts", "ahash", "opts", "checkOpts", "c", "dkLen", "asyncTick", "anumber", "password", "kdfInputToBytes", "salt", "DK", "PRF", "hmac", "PRFSalt", "pbkdf2Output", "prfW", "u", "clean", "pbkdf2", "arr", "view", "createView", "ti", "pos", "Ti", "ui", "i", "hashName", "sha1", "sha256", "sha512", "pbkdf2", "password", "salt", "iterations", "keySize", "hash", "types", "InvalidParametersError", "hasher", "dek", "base64"]
}
