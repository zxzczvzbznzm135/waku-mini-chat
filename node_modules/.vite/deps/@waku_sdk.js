import {
  __commonJS,
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField,
  __toESM
} from "./chunk-WOOG5QLI.js";

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s2 = 1e3;
    var m2 = s2 * 60;
    var h = m2 * 60;
    var d2 = h * 24;
    var w = d2 * 7;
    var y = d2 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n2 = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y;
        case "weeks":
        case "week":
        case "w":
          return n2 * w;
        case "days":
        case "day":
        case "d":
          return n2 * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) {
        return Math.round(ms / d2) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms / m2) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms / s2) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) {
        return plural(ms, msAbs, d2, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m2) {
        return plural(ms, msAbs, m2, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms, msAbs, s2, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n2, name3) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms / n2) + " " + name3 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup2(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split3 = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split3) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name3) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name3, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name3, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup2;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs2;
    exports.save = save2;
    exports.load = load2;
    exports.useColors = useColors2;
    exports.storage = localstorage2();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors2() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m2;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs2(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save2(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load2() {
      let r2;
      try {
        r2 = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r2 && typeof process !== "undefined" && "env" in process) {
        r2 = process.env.DEBUG;
      }
      return r2;
    }
    function localstorage2() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/lodash.debounce/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.debounce/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString2 = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce4(func2, wait2, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func2 != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait2 = toNumber(wait2) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait2) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func2.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait2);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait2 - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait2 || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait2);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait2);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString2.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = debounce4;
  }
});

// node_modules/netmask/lib/netmask.js
var require_netmask = __commonJS({
  "node_modules/netmask/lib/netmask.js"(exports) {
    (function() {
      var Netmask2, atob, chr, chr0, chrA, chra, ip2long, long2ip;
      long2ip = function(long) {
        var a2, b, c2, d2;
        a2 = (long & 255 << 24) >>> 24;
        b = (long & 255 << 16) >>> 16;
        c2 = (long & 255 << 8) >>> 8;
        d2 = long & 255;
        return [a2, b, c2, d2].join(".");
      };
      ip2long = function(ip) {
        var b, c2, i2, j, n2, ref;
        b = [];
        for (i2 = j = 0; j <= 3; i2 = ++j) {
          if (ip.length === 0) {
            break;
          }
          if (i2 > 0) {
            if (ip[0] !== ".") {
              throw new Error("Invalid IP");
            }
            ip = ip.substring(1);
          }
          ref = atob(ip), n2 = ref[0], c2 = ref[1];
          ip = ip.substring(c2);
          b.push(n2);
        }
        if (ip.length !== 0) {
          throw new Error("Invalid IP");
        }
        switch (b.length) {
          case 1:
            if (b[0] > 4294967295) {
              throw new Error("Invalid IP");
            }
            return b[0] >>> 0;
          case 2:
            if (b[0] > 255 || b[1] > 16777215) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1]) >>> 0;
          case 3:
            if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
          case 4:
            if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
          default:
            throw new Error("Invalid IP");
        }
      };
      chr = function(b) {
        return b.charCodeAt(0);
      };
      chr0 = chr("0");
      chra = chr("a");
      chrA = chr("A");
      atob = function(s2) {
        var base4, dmax, i2, n2, start2;
        n2 = 0;
        base4 = 10;
        dmax = "9";
        i2 = 0;
        if (s2.length > 1 && s2[i2] === "0") {
          if (s2[i2 + 1] === "x" || s2[i2 + 1] === "X") {
            i2 += 2;
            base4 = 16;
          } else if ("0" <= s2[i2 + 1] && s2[i2 + 1] <= "9") {
            i2++;
            base4 = 8;
            dmax = "7";
          }
        }
        start2 = i2;
        while (i2 < s2.length) {
          if ("0" <= s2[i2] && s2[i2] <= dmax) {
            n2 = n2 * base4 + (chr(s2[i2]) - chr0) >>> 0;
          } else if (base4 === 16) {
            if ("a" <= s2[i2] && s2[i2] <= "f") {
              n2 = n2 * base4 + (10 + chr(s2[i2]) - chra) >>> 0;
            } else if ("A" <= s2[i2] && s2[i2] <= "F") {
              n2 = n2 * base4 + (10 + chr(s2[i2]) - chrA) >>> 0;
            } else {
              break;
            }
          } else {
            break;
          }
          if (n2 > 4294967295) {
            throw new Error("too large");
          }
          i2++;
        }
        if (i2 === start2) {
          throw new Error("empty octet");
        }
        return [n2, i2];
      };
      Netmask2 = function() {
        function Netmask3(net, mask) {
          var error, i2, j, ref;
          if (typeof net !== "string") {
            throw new Error("Missing `net' parameter");
          }
          if (!mask) {
            ref = net.split("/", 2), net = ref[0], mask = ref[1];
          }
          if (!mask) {
            mask = 32;
          }
          if (typeof mask === "string" && mask.indexOf(".") > -1) {
            try {
              this.maskLong = ip2long(mask);
            } catch (error1) {
              error = error1;
              throw new Error("Invalid mask: " + mask);
            }
            for (i2 = j = 32; j >= 0; i2 = --j) {
              if (this.maskLong === 4294967295 << 32 - i2 >>> 0) {
                this.bitmask = i2;
                break;
              }
            }
          } else if (mask || mask === 0) {
            this.bitmask = parseInt(mask, 10);
            this.maskLong = 0;
            if (this.bitmask > 0) {
              this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
            }
          } else {
            throw new Error("Invalid mask: empty");
          }
          try {
            this.netLong = (ip2long(net) & this.maskLong) >>> 0;
          } catch (error1) {
            error = error1;
            throw new Error("Invalid net address: " + net);
          }
          if (!(this.bitmask <= 32)) {
            throw new Error("Invalid mask for ip4: " + mask);
          }
          this.size = Math.pow(2, 32 - this.bitmask);
          this.base = long2ip(this.netLong);
          this.mask = long2ip(this.maskLong);
          this.hostmask = long2ip(~this.maskLong);
          this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
          this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
          this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
        }
        Netmask3.prototype.contains = function(ip) {
          if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
            ip = new Netmask3(ip);
          }
          if (ip instanceof Netmask3) {
            return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
          } else {
            return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
          }
        };
        Netmask3.prototype.next = function(count) {
          if (count == null) {
            count = 1;
          }
          return new Netmask3(long2ip(this.netLong + this.size * count), this.mask);
        };
        Netmask3.prototype.forEach = function(fn) {
          var index, lastLong, long;
          long = ip2long(this.first);
          lastLong = ip2long(this.last);
          index = 0;
          while (long <= lastLong) {
            fn(long2ip(long), long, index);
            index++;
            long++;
          }
        };
        Netmask3.prototype.toString = function() {
          return this.base + "/" + this.bitmask;
        };
        return Netmask3;
      }();
      exports.ip2long = ip2long;
      exports.long2ip = long2ip;
      exports.Netmask = Netmask2;
    }).call(exports);
  }
});

// node_modules/event-iterator/lib/event-iterator.js
var require_event_iterator = __commonJS({
  "node_modules/event-iterator/lib/event-iterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EventQueue = class {
      constructor() {
        this.pullQueue = [];
        this.pushQueue = [];
        this.eventHandlers = {};
        this.isPaused = false;
        this.isStopped = false;
      }
      push(value) {
        if (this.isStopped)
          return;
        const resolution = { value, done: false };
        if (this.pullQueue.length) {
          const placeholder = this.pullQueue.shift();
          if (placeholder)
            placeholder.resolve(resolution);
        } else {
          this.pushQueue.push(Promise.resolve(resolution));
          if (this.highWaterMark !== void 0 && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {
            this.isPaused = true;
            if (this.eventHandlers.highWater) {
              this.eventHandlers.highWater();
            } else if (console) {
              console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
            }
          }
        }
      }
      stop() {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        for (const placeholder of this.pullQueue) {
          placeholder.resolve({ value: void 0, done: true });
        }
        this.pullQueue.length = 0;
      }
      fail(error) {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        if (this.pullQueue.length) {
          for (const placeholder of this.pullQueue) {
            placeholder.reject(error);
          }
          this.pullQueue.length = 0;
        } else {
          const rejection = Promise.reject(error);
          rejection.catch(() => {
          });
          this.pushQueue.push(rejection);
        }
      }
      remove() {
        Promise.resolve().then(() => {
          if (this.removeCallback)
            this.removeCallback();
        });
      }
      [Symbol.asyncIterator]() {
        return {
          next: (value) => {
            const result = this.pushQueue.shift();
            if (result) {
              if (this.lowWaterMark !== void 0 && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {
                this.isPaused = false;
                if (this.eventHandlers.lowWater) {
                  this.eventHandlers.lowWater();
                }
              }
              return result;
            } else if (this.isStopped) {
              return Promise.resolve({ value: void 0, done: true });
            } else {
              return new Promise((resolve, reject) => {
                this.pullQueue.push({ resolve, reject });
              });
            }
          },
          return: () => {
            this.isStopped = true;
            this.pushQueue.length = 0;
            this.remove();
            return Promise.resolve({ value: void 0, done: true });
          }
        };
      }
    };
    var EventIterator2 = class {
      constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {
        const queue = new EventQueue();
        queue.highWaterMark = highWaterMark;
        queue.lowWaterMark = lowWaterMark;
        queue.removeCallback = listen({
          push: (value) => queue.push(value),
          stop: () => queue.stop(),
          fail: (error) => queue.fail(error),
          on: (event, fn) => {
            queue.eventHandlers[event] = fn;
          }
        }) || (() => {
        });
        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
        Object.freeze(this);
      }
    };
    exports.EventIterator = EventIterator2;
    exports.default = EventIterator2;
  }
});

// node_modules/event-iterator/lib/dom.js
var require_dom = __commonJS({
  "node_modules/event-iterator/lib/dom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var event_iterator_1 = require_event_iterator();
    exports.EventIterator = event_iterator_1.EventIterator;
    function subscribe(event, options, evOptions) {
      return new event_iterator_1.EventIterator(({ push }) => {
        this.addEventListener(event, push, options);
        return () => this.removeEventListener(event, push, options);
      }, evOptions);
    }
    exports.subscribe = subscribe;
    exports.default = event_iterator_1.EventIterator;
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener2(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names4 = [], events, name3;
      if (this._eventsCount === 0) return names4;
      for (name3 in events = this._events) {
        if (has.call(events, name3)) names4.push(prefix ? name3.slice(1) : name3);
      }
      if (Object.getOwnPropertySymbols) {
        return names4.concat(Object.getOwnPropertySymbols(events));
      }
      return names4;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
        ee[i2] = handlers[i2].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length3 = listeners.length, j;
        for (i2 = 0; i2 < length3; i2++) {
          if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a2);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener2(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener2(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener2(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length3 = listeners.length; i2 < length3; i2++) {
          if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
            events.push(listeners[i2]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/hashlru/index.js
var require_hashlru = __commonJS({
  "node_modules/hashlru/index.js"(exports, module) {
    module.exports = function(max) {
      if (!max) throw Error("hashlru must have a max value, of type number, greater than 0");
      var size = 0, cache3 = /* @__PURE__ */ Object.create(null), _cache2 = /* @__PURE__ */ Object.create(null);
      function update(key, value) {
        cache3[key] = value;
        size++;
        if (size >= max) {
          size = 0;
          _cache2 = cache3;
          cache3 = /* @__PURE__ */ Object.create(null);
        }
      }
      return {
        has: function(key) {
          return cache3[key] !== void 0 || _cache2[key] !== void 0;
        },
        remove: function(key) {
          if (cache3[key] !== void 0)
            cache3[key] = void 0;
          if (_cache2[key] !== void 0)
            _cache2[key] = void 0;
        },
        get: function(key) {
          var v = cache3[key];
          if (v !== void 0) return v;
          if ((v = _cache2[key]) !== void 0) {
            update(key, v);
            return v;
          }
        },
        set: function(key, value) {
          if (cache3[key] !== void 0) cache3[key] = value;
          else update(key, value);
        },
        clear: function() {
          cache3 = /* @__PURE__ */ Object.create(null);
          _cache2 = /* @__PURE__ */ Object.create(null);
        }
      };
    };
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports, module) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout2 = this._timeouts.shift();
      if (timeout2 === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout2 = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout2);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i2 = 0; i2 < this._errors.length; i2++) {
        var error = this._errors[i2];
        var message2 = error.message;
        var count = (counts[message2] || 0) + 1;
        counts[message2] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports) {
    var RetryOperation = require_retry_operation();
    exports.operation = function(options) {
      var timeouts = exports.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i2 = 0; i2 < opts.retries; i2++) {
        timeouts.push(this.createTimeout(i2, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i2, opts));
      }
      timeouts.sort(function(a2, b) {
        return a2 - b;
      });
      return timeouts;
    };
    exports.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout2 = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout2 = Math.min(timeout2, opts.maxTimeout);
      return timeout2;
    };
    exports.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i2 = 0; i2 < methods.length; i2++) {
        var method = methods[i2];
        var original = obj[method];
        obj[method] = (function retryWrapper(original2) {
          var op = exports.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }).bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports, module) {
    module.exports = require_retry();
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "node_modules/js-sha3/src/sha3.js"(exports, module) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      var isArray = root.JS_SHA3_NO_NODE_JS || !Array.isArray ? function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      } : Array.isArray;
      var isView = ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) ? function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      } : ArrayBuffer.isView;
      var formatMessage = function(message2) {
        var type = typeof message2;
        if (type === "string") {
          return [message2, true];
        }
        if (type !== "object" || message2 === null) {
          throw new Error(INPUT_ERROR);
        }
        if (ARRAY_BUFFER && message2.constructor === ArrayBuffer) {
          return [new Uint8Array(message2), false];
        }
        if (!isArray(message2) && !isView(message2)) {
          throw new Error(INPUT_ERROR);
        }
        return [message2, false];
      };
      var empty2 = function(message2) {
        return formatMessage(message2)[0].length === 0;
      };
      var cloneArray2 = function(array) {
        var newArray = [];
        for (var i3 = 0; i3 < array.length; ++i3) {
          newArray[i3] = array[i3];
        }
        return newArray;
      };
      var createOutputMethod = function(bits2, padding, outputType) {
        return function(message2) {
          return new Keccak(bits2, padding, bits2).update(message2)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding, outputType) {
        return function(message2, outputBits) {
          return new Keccak(bits2, padding, outputBits).update(message2)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding, outputType) {
        return function(message2, outputBits, n2, s2) {
          return methods["cshake" + bits2].update(message2, outputBits, n2, s2)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding, outputType) {
        return function(key, message2, outputBits, s2) {
          return methods["kmac" + bits2].update(key, message2, outputBits, s2)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits2, padding) {
        for (var i3 = 0; i3 < OUTPUT_TYPES.length; ++i3) {
          var type = OUTPUT_TYPES[i3];
          method[type] = createMethod2(bits2, padding, type);
        }
        return method;
      };
      var createMethod = function(bits2, padding) {
        var method = createOutputMethod(bits2, padding, "hex");
        method.create = function() {
          return new Keccak(bits2, padding, bits2);
        };
        method.update = function(message2) {
          return method.create().update(message2);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding);
      };
      var createShakeMethod = function(bits2, padding) {
        var method = createShakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits2, padding, outputBits);
        };
        method.update = function(message2, outputBits) {
          return method.create(outputBits).update(message2);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding);
      };
      var createCshakeMethod = function(bits2, padding) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits, n2, s2) {
          if (empty2(n2) && empty2(s2)) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding, outputBits).bytepad([n2, s2], w);
          }
        };
        method.update = function(message2, outputBits, n2, s2) {
          return method.create(outputBits, n2, s2).update(message2);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);
      };
      var createKmacMethod = function(bits2, padding) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding, "hex");
        method.create = function(key, outputBits, s2) {
          return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s2], w).bytepad([key], w);
        };
        method.update = function(key, message2, outputBits, s2) {
          return method.create(key, outputBits, s2).update(message2);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i2 = 0; i2 < algorithms.length; ++i2) {
        var algorithm = algorithms[i2];
        var bits = algorithm.bits;
        for (var j = 0; j < bits.length; ++j) {
          var methodName = algorithm.name + "_" + bits[j];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i3 = 0; i3 < 50; ++i3) {
          this.s[i3] = 0;
        }
      }
      Keccak.prototype.update = function(message2) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var result = formatMessage(message2);
        message2 = result[0];
        var isString = result[1];
        var blocks = this.blocks, byteCount = this.byteCount, length3 = message2.length, blockCount = this.blockCount, index = 0, s2 = this.s, i3, code2;
        while (index < length3) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i3 = 1; i3 < blockCount + 1; ++i3) {
              blocks[i3] = 0;
            }
          }
          if (isString) {
            for (i3 = this.start; index < length3 && i3 < byteCount; ++index) {
              code2 = message2.charCodeAt(index);
              if (code2 < 128) {
                blocks[i3 >> 2] |= code2 << SHIFT[i3++ & 3];
              } else if (code2 < 2048) {
                blocks[i3 >> 2] |= (192 | code2 >> 6) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code2 & 63) << SHIFT[i3++ & 3];
              } else if (code2 < 55296 || code2 >= 57344) {
                blocks[i3 >> 2] |= (224 | code2 >> 12) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code2 & 63) << SHIFT[i3++ & 3];
              } else {
                code2 = 65536 + ((code2 & 1023) << 10 | message2.charCodeAt(++index) & 1023);
                blocks[i3 >> 2] |= (240 | code2 >> 18) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code2 & 63) << SHIFT[i3++ & 3];
              }
            }
          } else {
            for (i3 = this.start; index < length3 && i3 < byteCount; ++index) {
              blocks[i3 >> 2] |= message2[index] << SHIFT[i3++ & 3];
            }
          }
          this.lastByteIndex = i3;
          if (i3 >= byteCount) {
            this.start = i3 - byteCount;
            this.block = blocks[blockCount];
            for (i3 = 0; i3 < blockCount; ++i3) {
              s2[i3] ^= blocks[i3];
            }
            f3(s2);
            this.reset = true;
          } else {
            this.start = i3;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x, right) {
        var o2 = x & 255, n2 = 1;
        var bytes = [o2];
        x = x >> 8;
        o2 = x & 255;
        while (o2 > 0) {
          bytes.unshift(o2);
          x = x >> 8;
          o2 = x & 255;
          ++n2;
        }
        if (right) {
          bytes.push(n2);
        } else {
          bytes.unshift(n2);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var result = formatMessage(str);
        str = result[0];
        var isString = result[1];
        var bytes = 0, length3 = str.length;
        if (isString) {
          for (var i3 = 0; i3 < str.length; ++i3) {
            var code2 = str.charCodeAt(i3);
            if (code2 < 128) {
              bytes += 1;
            } else if (code2 < 2048) {
              bytes += 2;
            } else if (code2 < 55296 || code2 >= 57344) {
              bytes += 3;
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++i3) & 1023);
              bytes += 4;
            }
          }
        } else {
          bytes = length3;
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w) {
        var bytes = this.encode(w);
        for (var i3 = 0; i3 < strs.length; ++i3) {
          bytes += this.encodeString(strs[i3]);
        }
        var paddingBytes = (w - bytes % w) % w;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i3 = this.lastByteIndex, blockCount = this.blockCount, s2 = this.s;
        blocks[i3 >> 2] |= this.padding[i3 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i3 = 1; i3 < blockCount + 1; ++i3) {
            blocks[i3] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i3 = 0; i3 < blockCount; ++i3) {
          s2[i3] ^= blocks[i3];
        }
        f3(s2);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j2 = 0;
        var hex = "", block;
        while (j2 < outputBlocks) {
          for (i3 = 0; i3 < blockCount && j2 < outputBlocks; ++i3, ++j2) {
            block = s2[i3];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j2 % blockCount === 0) {
            s2 = cloneArray2(s2);
            f3(s2);
            i3 = 0;
          }
        }
        if (extraBytes) {
          block = s2[i3];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j2 = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer);
        while (j2 < outputBlocks) {
          for (i3 = 0; i3 < blockCount && j2 < outputBlocks; ++i3, ++j2) {
            array[j2] = s2[i3];
          }
          if (j2 % blockCount === 0) {
            s2 = cloneArray2(s2);
            f3(s2);
          }
        }
        if (extraBytes) {
          array[j2] = s2[i3];
          buffer = buffer.slice(0, bytes);
        }
        return buffer;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j2 = 0;
        var array = [], offset, block;
        while (j2 < outputBlocks) {
          for (i3 = 0; i3 < blockCount && j2 < outputBlocks; ++i3, ++j2) {
            offset = j2 << 2;
            block = s2[i3];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j2 % blockCount === 0) {
            s2 = cloneArray2(s2);
            f3(s2);
          }
        }
        if (extraBytes) {
          offset = j2 << 2;
          block = s2[i3];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding, outputBits) {
        Keccak.call(this, bits2, padding, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f3 = function(s2) {
        var h, l2, n2, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n2 = 0; n2 < 48; n2 += 2) {
          c0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
          c1 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
          c2 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
          c3 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
          c4 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
          c5 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
          c6 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
          c7 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
          c8 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
          c9 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
          h = c8 ^ (c2 << 1 | c3 >>> 31);
          l2 = c9 ^ (c3 << 1 | c2 >>> 31);
          s2[0] ^= h;
          s2[1] ^= l2;
          s2[10] ^= h;
          s2[11] ^= l2;
          s2[20] ^= h;
          s2[21] ^= l2;
          s2[30] ^= h;
          s2[31] ^= l2;
          s2[40] ^= h;
          s2[41] ^= l2;
          h = c0 ^ (c4 << 1 | c5 >>> 31);
          l2 = c1 ^ (c5 << 1 | c4 >>> 31);
          s2[2] ^= h;
          s2[3] ^= l2;
          s2[12] ^= h;
          s2[13] ^= l2;
          s2[22] ^= h;
          s2[23] ^= l2;
          s2[32] ^= h;
          s2[33] ^= l2;
          s2[42] ^= h;
          s2[43] ^= l2;
          h = c2 ^ (c6 << 1 | c7 >>> 31);
          l2 = c3 ^ (c7 << 1 | c6 >>> 31);
          s2[4] ^= h;
          s2[5] ^= l2;
          s2[14] ^= h;
          s2[15] ^= l2;
          s2[24] ^= h;
          s2[25] ^= l2;
          s2[34] ^= h;
          s2[35] ^= l2;
          s2[44] ^= h;
          s2[45] ^= l2;
          h = c4 ^ (c8 << 1 | c9 >>> 31);
          l2 = c5 ^ (c9 << 1 | c8 >>> 31);
          s2[6] ^= h;
          s2[7] ^= l2;
          s2[16] ^= h;
          s2[17] ^= l2;
          s2[26] ^= h;
          s2[27] ^= l2;
          s2[36] ^= h;
          s2[37] ^= l2;
          s2[46] ^= h;
          s2[47] ^= l2;
          h = c6 ^ (c0 << 1 | c1 >>> 31);
          l2 = c7 ^ (c1 << 1 | c0 >>> 31);
          s2[8] ^= h;
          s2[9] ^= l2;
          s2[18] ^= h;
          s2[19] ^= l2;
          s2[28] ^= h;
          s2[29] ^= l2;
          s2[38] ^= h;
          s2[39] ^= l2;
          s2[48] ^= h;
          s2[49] ^= l2;
          b0 = s2[0];
          b1 = s2[1];
          b32 = s2[11] << 4 | s2[10] >>> 28;
          b33 = s2[10] << 4 | s2[11] >>> 28;
          b14 = s2[20] << 3 | s2[21] >>> 29;
          b15 = s2[21] << 3 | s2[20] >>> 29;
          b46 = s2[31] << 9 | s2[30] >>> 23;
          b47 = s2[30] << 9 | s2[31] >>> 23;
          b28 = s2[40] << 18 | s2[41] >>> 14;
          b29 = s2[41] << 18 | s2[40] >>> 14;
          b20 = s2[2] << 1 | s2[3] >>> 31;
          b21 = s2[3] << 1 | s2[2] >>> 31;
          b2 = s2[13] << 12 | s2[12] >>> 20;
          b3 = s2[12] << 12 | s2[13] >>> 20;
          b34 = s2[22] << 10 | s2[23] >>> 22;
          b35 = s2[23] << 10 | s2[22] >>> 22;
          b16 = s2[33] << 13 | s2[32] >>> 19;
          b17 = s2[32] << 13 | s2[33] >>> 19;
          b48 = s2[42] << 2 | s2[43] >>> 30;
          b49 = s2[43] << 2 | s2[42] >>> 30;
          b40 = s2[5] << 30 | s2[4] >>> 2;
          b41 = s2[4] << 30 | s2[5] >>> 2;
          b22 = s2[14] << 6 | s2[15] >>> 26;
          b23 = s2[15] << 6 | s2[14] >>> 26;
          b4 = s2[25] << 11 | s2[24] >>> 21;
          b5 = s2[24] << 11 | s2[25] >>> 21;
          b36 = s2[34] << 15 | s2[35] >>> 17;
          b37 = s2[35] << 15 | s2[34] >>> 17;
          b18 = s2[45] << 29 | s2[44] >>> 3;
          b19 = s2[44] << 29 | s2[45] >>> 3;
          b10 = s2[6] << 28 | s2[7] >>> 4;
          b11 = s2[7] << 28 | s2[6] >>> 4;
          b42 = s2[17] << 23 | s2[16] >>> 9;
          b43 = s2[16] << 23 | s2[17] >>> 9;
          b24 = s2[26] << 25 | s2[27] >>> 7;
          b25 = s2[27] << 25 | s2[26] >>> 7;
          b6 = s2[36] << 21 | s2[37] >>> 11;
          b7 = s2[37] << 21 | s2[36] >>> 11;
          b38 = s2[47] << 24 | s2[46] >>> 8;
          b39 = s2[46] << 24 | s2[47] >>> 8;
          b30 = s2[8] << 27 | s2[9] >>> 5;
          b31 = s2[9] << 27 | s2[8] >>> 5;
          b12 = s2[18] << 20 | s2[19] >>> 12;
          b13 = s2[19] << 20 | s2[18] >>> 12;
          b44 = s2[29] << 7 | s2[28] >>> 25;
          b45 = s2[28] << 7 | s2[29] >>> 25;
          b26 = s2[38] << 8 | s2[39] >>> 24;
          b27 = s2[39] << 8 | s2[38] >>> 24;
          b8 = s2[48] << 14 | s2[49] >>> 18;
          b9 = s2[49] << 14 | s2[48] >>> 18;
          s2[0] = b0 ^ ~b2 & b4;
          s2[1] = b1 ^ ~b3 & b5;
          s2[10] = b10 ^ ~b12 & b14;
          s2[11] = b11 ^ ~b13 & b15;
          s2[20] = b20 ^ ~b22 & b24;
          s2[21] = b21 ^ ~b23 & b25;
          s2[30] = b30 ^ ~b32 & b34;
          s2[31] = b31 ^ ~b33 & b35;
          s2[40] = b40 ^ ~b42 & b44;
          s2[41] = b41 ^ ~b43 & b45;
          s2[2] = b2 ^ ~b4 & b6;
          s2[3] = b3 ^ ~b5 & b7;
          s2[12] = b12 ^ ~b14 & b16;
          s2[13] = b13 ^ ~b15 & b17;
          s2[22] = b22 ^ ~b24 & b26;
          s2[23] = b23 ^ ~b25 & b27;
          s2[32] = b32 ^ ~b34 & b36;
          s2[33] = b33 ^ ~b35 & b37;
          s2[42] = b42 ^ ~b44 & b46;
          s2[43] = b43 ^ ~b45 & b47;
          s2[4] = b4 ^ ~b6 & b8;
          s2[5] = b5 ^ ~b7 & b9;
          s2[14] = b14 ^ ~b16 & b18;
          s2[15] = b15 ^ ~b17 & b19;
          s2[24] = b24 ^ ~b26 & b28;
          s2[25] = b25 ^ ~b27 & b29;
          s2[34] = b34 ^ ~b36 & b38;
          s2[35] = b35 ^ ~b37 & b39;
          s2[44] = b44 ^ ~b46 & b48;
          s2[45] = b45 ^ ~b47 & b49;
          s2[6] = b6 ^ ~b8 & b0;
          s2[7] = b7 ^ ~b9 & b1;
          s2[16] = b16 ^ ~b18 & b10;
          s2[17] = b17 ^ ~b19 & b11;
          s2[26] = b26 ^ ~b28 & b20;
          s2[27] = b27 ^ ~b29 & b21;
          s2[36] = b36 ^ ~b38 & b30;
          s2[37] = b37 ^ ~b39 & b31;
          s2[46] = b46 ^ ~b48 & b40;
          s2[47] = b47 ^ ~b49 & b41;
          s2[8] = b8 ^ ~b0 & b2;
          s2[9] = b9 ^ ~b1 & b3;
          s2[18] = b18 ^ ~b10 & b12;
          s2[19] = b19 ^ ~b11 & b13;
          s2[28] = b28 ^ ~b20 & b22;
          s2[29] = b29 ^ ~b21 & b23;
          s2[38] = b38 ^ ~b30 & b32;
          s2[39] = b39 ^ ~b31 & b33;
          s2[48] = b48 ^ ~b40 & b42;
          s2[49] = b49 ^ ~b41 & b43;
          s2[0] ^= RC[n2];
          s2[1] ^= RC[n2 + 1];
        }
      };
      if (COMMON_JS) {
        module.exports = methods;
      } else {
        for (i2 = 0; i2 < methodNames.length; ++i2) {
          root[methodNames[i2]] = methods[methodNames[i2]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// node_modules/hi-base32/src/base32.js
var require_base32 = __commonJS({
  "node_modules/hi-base32/src/base32.js"(exports, module) {
    (function() {
      "use strict";
      var root = typeof window === "object" ? window : {};
      var NODE_JS = !root.HI_BASE32_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      }
      var COMMON_JS = !root.HI_BASE32_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var BASE32_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split("");
      var BASE32_DECODE_CHAR = {
        "A": 0,
        "B": 1,
        "C": 2,
        "D": 3,
        "E": 4,
        "F": 5,
        "G": 6,
        "H": 7,
        "I": 8,
        "J": 9,
        "K": 10,
        "L": 11,
        "M": 12,
        "N": 13,
        "O": 14,
        "P": 15,
        "Q": 16,
        "R": 17,
        "S": 18,
        "T": 19,
        "U": 20,
        "V": 21,
        "W": 22,
        "X": 23,
        "Y": 24,
        "Z": 25,
        "2": 26,
        "3": 27,
        "4": 28,
        "5": 29,
        "6": 30,
        "7": 31
      };
      var blocks = [0, 0, 0, 0, 0, 0, 0, 0];
      var throwInvalidUtf8 = function(position, partial) {
        if (partial.length > 10) {
          partial = "..." + partial.substr(-10);
        }
        var err = new Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading " + position + " bytes: " + partial + " <-");
        err.position = position;
        throw err;
      };
      var toUtf8String = function(bytes) {
        var str = "", length3 = bytes.length, i2 = 0, followingChars = 0, b, c2;
        while (i2 < length3) {
          b = bytes[i2++];
          if (b <= 127) {
            str += String.fromCharCode(b);
            continue;
          } else if (b > 191 && b <= 223) {
            c2 = b & 31;
            followingChars = 1;
          } else if (b <= 239) {
            c2 = b & 15;
            followingChars = 2;
          } else if (b <= 247) {
            c2 = b & 7;
            followingChars = 3;
          } else {
            throwInvalidUtf8(i2, str);
          }
          for (var j = 0; j < followingChars; ++j) {
            b = bytes[i2++];
            if (b < 128 || b > 191) {
              throwInvalidUtf8(i2, str);
            }
            c2 <<= 6;
            c2 += b & 63;
          }
          if (c2 >= 55296 && c2 <= 57343) {
            throwInvalidUtf8(i2, str);
          }
          if (c2 > 1114111) {
            throwInvalidUtf8(i2, str);
          }
          if (c2 <= 65535) {
            str += String.fromCharCode(c2);
          } else {
            c2 -= 65536;
            str += String.fromCharCode((c2 >> 10) + 55296);
            str += String.fromCharCode((c2 & 1023) + 56320);
          }
        }
        return str;
      };
      var decodeAsBytes = function(base32Str) {
        if (base32Str === "") {
          return [];
        } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
          throw new Error("Invalid base32 characters");
        }
        base32Str = base32Str.replace(/=/g, "");
        var v1, v2, v32, v42, v52, v6, v7, v8, bytes = [], index = 0, length3 = base32Str.length;
        for (var i2 = 0, count = length3 >> 3 << 3; i2 < count; ) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v32 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v52 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v8 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v32 << 1 | v42 >>> 4) & 255;
          bytes[index++] = (v42 << 4 | v52 >>> 1) & 255;
          bytes[index++] = (v52 << 7 | v6 << 2 | v7 >>> 3) & 255;
          bytes[index++] = (v7 << 5 | v8) & 255;
        }
        var remain = length3 - count;
        if (remain === 2) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
        } else if (remain === 4) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v32 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v32 << 1 | v42 >>> 4) & 255;
        } else if (remain === 5) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v32 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v52 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v32 << 1 | v42 >>> 4) & 255;
          bytes[index++] = (v42 << 4 | v52 >>> 1) & 255;
        } else if (remain === 7) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v32 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v52 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v32 << 1 | v42 >>> 4) & 255;
          bytes[index++] = (v42 << 4 | v52 >>> 1) & 255;
          bytes[index++] = (v52 << 7 | v6 << 2 | v7 >>> 3) & 255;
        }
        return bytes;
      };
      var encodeAscii = function(str) {
        var v1, v2, v32, v42, v52, base32Str = "", length3 = str.length;
        for (var i2 = 0, count = parseInt(length3 / 5) * 5; i2 < count; ) {
          v1 = str.charCodeAt(i2++);
          v2 = str.charCodeAt(i2++);
          v32 = str.charCodeAt(i2++);
          v42 = str.charCodeAt(i2++);
          v52 = str.charCodeAt(i2++);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v32 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v42 << 3 | v52 >>> 5) & 31] + BASE32_ENCODE_CHAR[v52 & 31];
        }
        var remain = length3 - count;
        if (remain === 1) {
          v1 = str.charCodeAt(i2);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
        } else if (remain === 2) {
          v1 = str.charCodeAt(i2++);
          v2 = str.charCodeAt(i2);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
        } else if (remain === 3) {
          v1 = str.charCodeAt(i2++);
          v2 = str.charCodeAt(i2++);
          v32 = str.charCodeAt(i2);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[v32 << 1 & 31] + "===";
        } else if (remain === 4) {
          v1 = str.charCodeAt(i2++);
          v2 = str.charCodeAt(i2++);
          v32 = str.charCodeAt(i2++);
          v42 = str.charCodeAt(i2);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v32 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[v42 << 3 & 31] + "=";
        }
        return base32Str;
      };
      var encodeUtf8 = function(str) {
        var v1, v2, v32, v42, v52, code2, end = false, base32Str = "", index = 0, i2, start2 = 0, bytes = 0, length3 = str.length;
        if (str === "") {
          return base32Str;
        }
        do {
          blocks[0] = blocks[5];
          blocks[1] = blocks[6];
          blocks[2] = blocks[7];
          for (i2 = start2; index < length3 && i2 < 5; ++index) {
            code2 = str.charCodeAt(index);
            if (code2 < 128) {
              blocks[i2++] = code2;
            } else if (code2 < 2048) {
              blocks[i2++] = 192 | code2 >> 6;
              blocks[i2++] = 128 | code2 & 63;
            } else if (code2 < 55296 || code2 >= 57344) {
              blocks[i2++] = 224 | code2 >> 12;
              blocks[i2++] = 128 | code2 >> 6 & 63;
              blocks[i2++] = 128 | code2 & 63;
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++index) & 1023);
              blocks[i2++] = 240 | code2 >> 18;
              blocks[i2++] = 128 | code2 >> 12 & 63;
              blocks[i2++] = 128 | code2 >> 6 & 63;
              blocks[i2++] = 128 | code2 & 63;
            }
          }
          bytes += i2 - start2;
          start2 = i2 - 5;
          if (index === length3) {
            ++index;
          }
          if (index > length3 && i2 < 6) {
            end = true;
          }
          v1 = blocks[0];
          if (i2 > 4) {
            v2 = blocks[1];
            v32 = blocks[2];
            v42 = blocks[3];
            v52 = blocks[4];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v32 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v42 << 3 | v52 >>> 5) & 31] + BASE32_ENCODE_CHAR[v52 & 31];
          } else if (i2 === 1) {
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
          } else if (i2 === 2) {
            v2 = blocks[1];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
          } else if (i2 === 3) {
            v2 = blocks[1];
            v32 = blocks[2];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[v32 << 1 & 31] + "===";
          } else {
            v2 = blocks[1];
            v32 = blocks[2];
            v42 = blocks[3];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v32 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[v42 << 3 & 31] + "=";
          }
        } while (!end);
        return base32Str;
      };
      var encodeBytes = function(bytes) {
        var v1, v2, v32, v42, v52, base32Str = "", length3 = bytes.length;
        for (var i2 = 0, count = parseInt(length3 / 5) * 5; i2 < count; ) {
          v1 = bytes[i2++];
          v2 = bytes[i2++];
          v32 = bytes[i2++];
          v42 = bytes[i2++];
          v52 = bytes[i2++];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v32 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v42 << 3 | v52 >>> 5) & 31] + BASE32_ENCODE_CHAR[v52 & 31];
        }
        var remain = length3 - count;
        if (remain === 1) {
          v1 = bytes[i2];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
        } else if (remain === 2) {
          v1 = bytes[i2++];
          v2 = bytes[i2];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
        } else if (remain === 3) {
          v1 = bytes[i2++];
          v2 = bytes[i2++];
          v32 = bytes[i2];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[v32 << 1 & 31] + "===";
        } else if (remain === 4) {
          v1 = bytes[i2++];
          v2 = bytes[i2++];
          v32 = bytes[i2++];
          v42 = bytes[i2];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v32 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[v42 << 3 & 31] + "=";
        }
        return base32Str;
      };
      var encode10 = function(input, asciiOnly) {
        var notString = typeof input !== "string";
        if (notString && input.constructor === ArrayBuffer) {
          input = new Uint8Array(input);
        }
        if (notString) {
          return encodeBytes(input);
        } else if (asciiOnly) {
          return encodeAscii(input);
        } else {
          return encodeUtf8(input);
        }
      };
      var decode10 = function(base32Str, asciiOnly) {
        if (!asciiOnly) {
          return toUtf8String(decodeAsBytes(base32Str));
        }
        if (base32Str === "") {
          return "";
        } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
          throw new Error("Invalid base32 characters");
        }
        var v1, v2, v32, v42, v52, v6, v7, v8, str = "", length3 = base32Str.indexOf("=");
        if (length3 === -1) {
          length3 = base32Str.length;
        }
        for (var i2 = 0, count = length3 >> 3 << 3; i2 < count; ) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v32 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v52 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v8 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v32 << 1 | v42 >>> 4) & 255) + String.fromCharCode((v42 << 4 | v52 >>> 1) & 255) + String.fromCharCode((v52 << 7 | v6 << 2 | v7 >>> 3) & 255) + String.fromCharCode((v7 << 5 | v8) & 255);
        }
        var remain = length3 - count;
        if (remain === 2) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255);
        } else if (remain === 4) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v32 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v32 << 1 | v42 >>> 4) & 255);
        } else if (remain === 5) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v32 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v52 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v32 << 1 | v42 >>> 4) & 255) + String.fromCharCode((v42 << 4 | v52 >>> 1) & 255);
        } else if (remain === 7) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v32 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v52 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v32 << 1 | v42 >>> 4) & 255) + String.fromCharCode((v42 << 4 | v52 >>> 1) & 255) + String.fromCharCode((v52 << 7 | v6 << 2 | v7 >>> 3) & 255);
        }
        return str;
      };
      var exports2 = {
        encode: encode10,
        decode: decode10
      };
      decode10.asBytes = decodeAsBytes;
      if (COMMON_JS) {
        module.exports = exports2;
      } else {
        root.base32 = exports2;
        if (AMD) {
          define(function() {
            return exports2;
          });
        }
      }
    })();
  }
});

// node_modules/lodash/lodash.js
var require_lodash2 = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module) {
    (function() {
      var undefined2;
      var VERSION = "4.17.23";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag2 = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "[']", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag2] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag2] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "c",
        "": "D",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "N",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "Y",
        "": "y",
        "": "y",
        "": "Ae",
        "": "ae",
        "": "Th",
        "": "th",
        "": "ss",
        // Latin Extended-A block.
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "C",
        "": "C",
        "": "C",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "D",
        "": "D",
        "": "d",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "H",
        "": "H",
        "": "h",
        "": "h",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "J",
        "": "j",
        "": "K",
        "": "k",
        "": "k",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "R",
        "": "R",
        "": "R",
        "": "r",
        "": "r",
        "": "r",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "T",
        "": "T",
        "": "T",
        "": "t",
        "": "t",
        "": "t",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "W",
        "": "w",
        "": "Y",
        "": "y",
        "": "Y",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "z",
        "": "z",
        "": "z",
        "": "IJ",
        "": "ij",
        "": "Oe",
        "": "oe",
        "": "'n",
        "": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e2) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func2, thisArg, args) {
        switch (args.length) {
          case 0:
            return func2.call(thisArg);
          case 1:
            return func2.call(thisArg, args[0]);
          case 2:
            return func2.call(thisArg, args[0], args[1]);
          case 3:
            return func2.call(thisArg, args[0], args[1], args[2]);
        }
        return func2.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length3 = array == null ? 0 : array.length;
        while (++index < length3) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length3 = array == null ? 0 : array.length;
        while (++index < length3) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length3 = array == null ? 0 : array.length;
        while (length3--) {
          if (iteratee(array[length3], length3, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length3 = array == null ? 0 : array.length;
        while (++index < length3) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length3 = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length3) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length3 = array == null ? 0 : array.length;
        return !!length3 && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length3 = array == null ? 0 : array.length;
        while (++index < length3) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length3 = array == null ? 0 : array.length, result = Array(length3);
        while (++index < length3) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length3 = values.length, offset = array.length;
        while (++index < length3) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length3 = array == null ? 0 : array.length;
        if (initAccum && length3) {
          accumulator = array[++index];
        }
        while (++index < length3) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length3 = array == null ? 0 : array.length;
        if (initAccum && length3) {
          accumulator = array[--length3];
        }
        while (length3--) {
          accumulator = iteratee(accumulator, array[length3], length3, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length3 = array == null ? 0 : array.length;
        while (++index < length3) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string3) {
        return string3.split("");
      }
      function asciiWords(string3) {
        return string3.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length3 = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length3) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length3 = array.length;
        while (++index < length3) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length3 = array == null ? 0 : array.length;
        return length3 ? baseSum(array, iteratee) / length3 : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length3 = array.length;
        array.sort(comparer);
        while (length3--) {
          array[length3] = array[length3].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length3 = array.length;
        while (++index < length3) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n2, iteratee) {
        var index = -1, result = Array(n2);
        while (++index < n2) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string3) {
        return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
      }
      function baseUnary(func2) {
        return function(value) {
          return func2(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache3, key) {
        return cache3.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length3 = strSymbols.length;
        while (++index < length3 && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length3 = array.length, result = 0;
        while (length3--) {
          if (array[length3] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string3) {
        return reHasUnicode.test(string3);
      }
      function hasUnicodeWord(string3) {
        return reHasUnicodeWord.test(string3);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func2, transform) {
        return function(arg) {
          return func2(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length3 = array.length, resIndex = 0, result = [];
        while (++index < length3) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length3 = array.length;
        while (++index < length3) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string3) {
        return hasUnicode(string3) ? unicodeSize(string3) : asciiSize(string3);
      }
      function stringToArray(string3) {
        return hasUnicode(string3) ? unicodeToArray(string3) : asciiToArray(string3);
      }
      function trimmedEndIndex(string3) {
        var index = string3.length;
        while (index-- && reWhitespace.test(string3.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string3) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string3)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string3) {
        return string3.match(reUnicode) || [];
      }
      function unicodeWords(string3) {
        return string3.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty2 = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe2 = Buffer ? Buffer.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable2 = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty2 = function() {
          try {
            var func2 = getNative(Object2, "defineProperty");
            func2({}, "", {});
            return func2;
          } catch (e2) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty2.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end = view.end, length3 = end - start2, index = isRight ? end : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length3, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length3 && takeCount == length3) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length3-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash3(entries) {
          var index = -1, length3 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length3) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty2.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty2.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash3.prototype.clear = hashClear;
        Hash3.prototype["delete"] = hashDelete;
        Hash3.prototype.get = hashGet;
        Hash3.prototype.has = hashHas;
        Hash3.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length3 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length3) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length3 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length3) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash3(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash3()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length3 = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length3) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length3 = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length3)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length3 = array.length;
          return length3 ? array[baseRandom(0, length3 - 1)] : undefined2;
        }
        function arraySampleSize(array, n2) {
          return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length3 = array.length;
          while (length3--) {
            if (eq(array[length3][0], key)) {
              return length3;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty2) {
            defineProperty2(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length3 = paths.length, result2 = Array2(length3), skip = object == null;
          while (++index < length3) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number2, lower, upper) {
          if (number2 === number2) {
            if (upper !== undefined2) {
              number2 = number2 <= upper ? number2 : upper;
            }
            if (lower !== undefined2) {
              number2 = number2 >= lower ? number2 : lower;
            }
          }
          return number2;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length3 = props.length;
          if (object == null) {
            return !length3;
          }
          object = Object2(object);
          while (length3--) {
            var key = props[length3], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func2, wait2, args) {
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func2.apply(undefined2, args);
          }, wait2);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length3 = array.length, result2 = [], valuesLength = values2.length;
          if (!length3) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length3) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length3 = array.length;
          while (++index < length3) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start2, end) {
          var length3 = array.length;
          start2 = toInteger(start2);
          if (start2 < 0) {
            start2 = -start2 > length3 ? 0 : length3 + start2;
          }
          end = end === undefined2 || end > length3 ? length3 : toInteger(end);
          if (end < 0) {
            end += length3;
          }
          end = start2 > end ? 0 : toLength(end);
          while (start2 < end) {
            array[start2++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length3 = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length3) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length3 = path.length;
          while (object != null && index < length3) {
            object = object[toKey(path[index++])];
          }
          return index && index == length3 ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString2(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty2.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number2, start2, end) {
          return number2 >= nativeMin(start2, end) && number2 < nativeMax(start2, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length3 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length3 >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length3 && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache3 = caches[othIndex];
                  if (!(cache3 ? cacheHas(cache3, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func2 = object == null ? object : object[toKey(last(path))];
          return func2 == null ? undefined2 : apply(func2, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag2;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length3 = index, noCustomizer = !customizer;
          if (object == null) {
            return !length3;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length3) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity3;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty2.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n2) {
          var length3 = array.length;
          if (!length3) {
            return;
          }
          n2 += n2 < 0 ? length3 : 0;
          return isIndex(n2, length3) ? array[n2] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity3];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length3 = paths.length, result2 = {};
          while (++index < length3) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length3 = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length3) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length3 = array ? indexes.length : 0, lastIndex = length3 - 1;
          while (length3--) {
            var index = indexes[length3];
            if (length3 == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start2, end, step, fromRight) {
          var index = -1, length3 = nativeMax(nativeCeil((end - start2) / (step || 1)), 0), result2 = Array2(length3);
          while (length3--) {
            result2[fromRight ? length3 : ++index] = start2;
            start2 += step;
          }
          return result2;
        }
        function baseRepeat(string3, n2) {
          var result2 = "";
          if (!string3 || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n2 % 2) {
              result2 += string3;
            }
            n2 = nativeFloor(n2 / 2);
            if (n2) {
              string3 += string3;
            }
          } while (n2);
          return result2;
        }
        function baseRest(func2, start2) {
          return setToString(overRest(func2, start2, identity3), func2 + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n2) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n2, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length3 = path.length, lastIndex = length3 - 1, nested = object;
          while (nested != null && ++index < length3) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity3 : function(func2, data) {
          metaMap.set(func2, data);
          return func2;
        };
        var baseSetToString = !defineProperty2 ? identity3 : function(func2, string3) {
          return defineProperty2(func2, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string3),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start2, end) {
          var index = -1, length3 = array.length;
          if (start2 < 0) {
            start2 = -start2 > length3 ? 0 : length3 + start2;
          }
          end = end > length3 ? length3 : end;
          if (end < 0) {
            end += length3;
          }
          length3 = start2 > end ? 0 : end - start2 >>> 0;
          start2 >>>= 0;
          var result2 = Array2(length3);
          while (++index < length3) {
            result2[index] = array[index + start2];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity3, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length3 = array.length, resIndex = 0, result2 = [];
          while (++index < length3) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length3 = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length3 >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length3) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          var index = -1, length3 = path.length;
          if (!length3) {
            return true;
          }
          var isRootPrimitive = object == null || typeof object !== "object" && typeof object !== "function";
          while (++index < length3) {
            var key = path[index];
            if (typeof key !== "string") {
              continue;
            }
            if (key === "__proto__" && !hasOwnProperty2.call(object, "__proto__")) {
              return false;
            }
            if (key === "constructor" && index + 1 < length3 && typeof path[index + 1] === "string" && path[index + 1] === "prototype") {
              if (isRootPrimitive && index === 0) {
                continue;
              }
              return false;
            }
          }
          var obj = parent(object, path);
          return obj == null || delete obj[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length3 = array.length, index = fromRight ? length3 : -1;
          while ((fromRight ? index-- : ++index < length3) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length3) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length3 : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length3 = arrays.length;
          if (length3 < 2) {
            return length3 ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length3);
          while (++index < length3) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length3) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length3 = props.length, valsLength = values2.length, result2 = {};
          while (++index < length3) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity3;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString3(value));
        }
        var castRest = baseRest;
        function castSlice(array, start2, end) {
          var length3 = array.length;
          end = end === undefined2 ? length3 : end;
          return !start2 && end >= length3 ? array : baseSlice(array, start2, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length3 = buffer.length, result2 = allocUnsafe2 ? allocUnsafe2(length3) : new buffer.constructor(length3);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol3) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol3)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length3 = objCriteria.length, ordersLength = orders.length;
          while (++index < length3) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length3 = source.length;
          array || (array = Array2(length3));
          while (++index < length3) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length3 = props.length;
          while (++index < length3) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func2 = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func2(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length3 = sources.length, customizer = length3 > 1 ? sources[length3 - 1] : undefined2, guard = length3 > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length3--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length3 < 3 ? undefined2 : customizer;
              length3 = 1;
            }
            object = Object2(object);
            while (++index < length3) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length3 = collection.length, index = fromRight ? length3 : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length3) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length3 = props.length;
            while (length3--) {
              var key = props[fromRight ? length3 : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func2, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func2);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func2;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string3) {
            string3 = toString3(string3);
            var strSymbols = hasUnicode(string3) ? stringToArray(string3) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string3.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string3.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string3) {
            return arrayReduce(words(deburr(string3).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func2, bitmask, arity) {
          var Ctor = createCtor(func2);
          function wrapper() {
            var length3 = arguments.length, args = Array2(length3), index = length3, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length3 < 3 && args[0] !== placeholder && args[length3 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length3 -= holders.length;
            if (length3 < arity) {
              return createRecurry(
                func2,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length3
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func2;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length3 = funcs.length, index = length3, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func2 = funcs[index];
              if (typeof func2 != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func2) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length3;
            while (++index < length3) {
              func2 = funcs[index];
              var funcName = getFuncName(func2), data = funcName == "wrapper" ? getData(func2) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func2.length == 1 && isLaziable(func2) ? wrapper[funcName]() : wrapper.thru(func2);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length3 ? funcs[index2].apply(this, args) : value;
              while (++index2 < length3) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func2, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func2);
          function wrapper() {
            var length3 = arguments.length, args = Array2(length3), index = length3;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length3 -= holdersCount;
            if (isCurried && length3 < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func2,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length3
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func2] : func2;
            length3 = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length3 > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length3) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length3, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length3) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length3 / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length3).join("") : result2.slice(0, length3);
        }
        function createPartial(func2, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func2);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func2;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start2, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start2, end, step)) {
              end = step = undefined2;
            }
            start2 = toFinite(start2);
            if (end === undefined2) {
              end = start2;
              start2 = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start2 < end ? 1 : -1 : toFinite(step);
            return baseRange(start2, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func2, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func2,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func2)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func2, bitmask);
        }
        function createRound(methodName) {
          var func2 = Math2[methodName];
          return function(number2, precision) {
            number2 = toNumber(number2);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number2)) {
              var pair2 = (toString3(number2) + "e").split("e"), value = func2(pair2[0] + "e" + (+pair2[1] + precision));
              pair2 = (toString3(value) + "e").split("e");
              return +(pair2[0] + "e" + (+pair2[1] - precision));
            }
            return func2(number2);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag2) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func2, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length3 = partials ? partials.length : 0;
          if (!length3) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length3 -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func2);
          var newData = [
            func2,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func2 = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func2.length : nativeMax(newData[9] - length3, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func2, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func2, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func2, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func2, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject2(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag2:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func2) {
          return setToString(overRest(func2, undefined2, flatten2), func2 + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop2 : function(func2) {
          return metaMap.get(func2);
        };
        function getFuncName(func2) {
          var result2 = func2.name + "", array = realNames[result2], length3 = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
          while (length3--) {
            var data = array[length3], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func2) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func2) {
          var object = hasOwnProperty2.call(lodash, "placeholder") ? lodash : func2;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map3, key) {
          var data = map3.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length3 = result2.length;
          while (length3--) {
            var key = result2[length3], value = object[key];
            result2[length3] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e2) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol3) {
            return propertyIsEnumerable2.call(object, symbol3);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag2 || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag2;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start2, end, transforms) {
          var index = -1, length3 = transforms.length;
          while (++index < length3) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start2 += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start2 + size2);
                break;
              case "takeRight":
                start2 = nativeMax(start2, end - size2);
                break;
            }
          }
          return { "start": start2, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length3 = path.length, result2 = false;
          while (++index < length3) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length3) {
            return result2;
          }
          length3 = object == null ? 0 : object.length;
          return !!length3 && isLength(length3) && isIndex(key, length3) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length3 = array.length, result2 = new array.constructor(length3);
          if (length3 && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag2:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length3 = details.length;
          if (!length3) {
            return source;
          }
          var lastIndex = length3 - 1;
          details[lastIndex] = (length3 > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length3 > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length3) {
          var type = typeof value;
          length3 = length3 == null ? MAX_SAFE_INTEGER : length3;
          return !!length3 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length3);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func2) {
          var funcName = getFuncName(func2), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func2 === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func2 === data[0];
        }
        function isMasked(func2) {
          return !!maskSrcKey && maskSrcKey in func2;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func2) {
          var result2 = memoize(func2, function(key) {
            if (cache3.size === MAX_MEMOIZE_SIZE) {
              cache3.clear();
            }
            return key;
          });
          var cache3 = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString2(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func2, start2, transform2) {
          start2 = nativeMax(start2 === undefined2 ? func2.length - 1 : start2, 0);
          return function() {
            var args = arguments, index = -1, length3 = nativeMax(args.length - start2, 0), array = Array2(length3);
            while (++index < length3) {
              array[index] = args[start2 + index];
            }
            index = -1;
            var otherArgs = Array2(start2 + 1);
            while (++index < start2) {
              otherArgs[index] = args[index];
            }
            otherArgs[start2] = transform2(array);
            return apply(func2, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length3 = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length3--) {
            var index = indexes[length3];
            array[length3] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func2, wait2) {
          return root.setTimeout(func2, wait2);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func2) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func2.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length3 = array.length, lastIndex = length3 - 1;
          size2 = size2 === undefined2 ? length3 : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string3) {
          var result2 = [];
          if (string3.charCodeAt(0) === 46) {
            result2.push("");
          }
          string3.replace(rePropName, function(match, number2, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func2) {
          if (func2 != null) {
            try {
              return funcToString.call(func2);
            } catch (e2) {
            }
            try {
              return func2 + "";
            } catch (e2) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair2) {
            var value = "_." + pair2[0];
            if (bitmask & pair2[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length3 = array == null ? 0 : array.length;
          if (!length3 || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length3 / size2));
          while (index < length3) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length3 = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length3) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat3() {
          var length3 = arguments.length;
          if (!length3) {
            return [];
          }
          var args = Array2(length3 - 1), array = arguments[0], index = length3;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n2, guard) {
          var length3 = array == null ? 0 : array.length;
          if (!length3) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          return baseSlice(array, n2 < 0 ? 0 : n2, length3);
        }
        function dropRight(array, n2, guard) {
          var length3 = array == null ? 0 : array.length;
          if (!length3) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          n2 = length3 - n2;
          return baseSlice(array, 0, n2 < 0 ? 0 : n2);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start2, end) {
          var length3 = array == null ? 0 : array.length;
          if (!length3) {
            return [];
          }
          if (start2 && typeof start2 != "number" && isIterateeCall(array, value, start2)) {
            start2 = 0;
            end = length3;
          }
          return baseFill(array, value, start2, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length3 = array == null ? 0 : array.length;
          if (!length3) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length3 + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length3 = array == null ? 0 : array.length;
          if (!length3) {
            return -1;
          }
          var index = length3 - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length3 + index, 0) : nativeMin(index, length3 - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten2(array) {
          var length3 = array == null ? 0 : array.length;
          return length3 ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length3 = array == null ? 0 : array.length;
          return length3 ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length3 = array == null ? 0 : array.length;
          if (!length3) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length3 = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length3) {
            var pair2 = pairs[index];
            result2[pair2[0]] = pair2[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length3 = array == null ? 0 : array.length;
          if (!length3) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length3 + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length3 = array == null ? 0 : array.length;
          return length3 ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length3 = array == null ? 0 : array.length;
          return length3 ? array[length3 - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length3 = array == null ? 0 : array.length;
          if (!length3) {
            return -1;
          }
          var index = length3;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length3 + index, 0) : nativeMin(index, length3 - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n2) {
          return array && array.length ? baseNth(array, toInteger(n2)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length3 = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length3) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length3 = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length3) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start2, end) {
          var length3 = array == null ? 0 : array.length;
          if (!length3) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start2, end)) {
            start2 = 0;
            end = length3;
          } else {
            start2 = start2 == null ? 0 : toInteger(start2);
            end = end === undefined2 ? length3 : toInteger(end);
          }
          return baseSlice(array, start2, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length3 = array == null ? 0 : array.length;
          if (length3) {
            var index = baseSortedIndex(array, value);
            if (index < length3 && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length3 = array == null ? 0 : array.length;
          if (length3) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length3 = array == null ? 0 : array.length;
          return length3 ? baseSlice(array, 1, length3) : [];
        }
        function take2(array, n2, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          return baseSlice(array, 0, n2 < 0 ? 0 : n2);
        }
        function takeRight(array, n2, guard) {
          var length3 = array == null ? 0 : array.length;
          if (!length3) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          n2 = length3 - n2;
          return baseSlice(array, n2 < 0 ? 0 : n2, length3);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length3 = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length3 = nativeMax(group.length, length3);
              return true;
            }
          });
          return baseTimes(length3, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor2 = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length3 = arrays.length, iteratee2 = length3 > 1 ? arrays[length3 - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length3 = paths.length, start2 = length3 ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length3 > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
            return this.thru(interceptor);
          }
          value = value.slice(start2, +start2 + (length3 ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length3 && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone3 = wrapperClone(parent2);
            clone3.__index__ = 0;
            clone3.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone3;
            } else {
              result2 = clone3;
            }
            var previous = clone3;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func2 = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func2(collection, getIteratee(predicate, 3));
        }
        function filter2(collection, predicate) {
          var func2 = isArray(collection) ? arrayFilter : baseFilter;
          return func2(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map2(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func2 = isArray(collection) ? arrayEach : baseEach;
          return func2(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func2 = isArray(collection) ? arrayEachRight : baseEachRight;
          return func2(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length3 = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length3 + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length3 && collection.indexOf(value, fromIndex) > -1 : !!length3 && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map2(collection, iteratee2) {
          var func2 = isArray(collection) ? arrayMap : baseMap;
          return func2(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func2 = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func2(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func2 = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func2(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func2 = isArray(collection) ? arrayFilter : baseFilter;
          return func2(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func2 = isArray(collection) ? arraySample : baseSample;
          return func2(collection);
        }
        function sampleSize(collection, n2, guard) {
          if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined2) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          var func2 = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func2(collection, n2);
        }
        function shuffle2(collection) {
          var func2 = isArray(collection) ? arrayShuffle : baseShuffle;
          return func2(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag2 || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func2 = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func2(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length3 = iteratees.length;
          if (length3 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length3 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n2, func2) {
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 < 1) {
              return func2.apply(this, arguments);
            }
          };
        }
        function ary(func2, n2, guard) {
          n2 = guard ? undefined2 : n2;
          n2 = func2 && n2 == null ? func2.length : n2;
          return createWrap(func2, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n2);
        }
        function before(n2, func2) {
          var result2;
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 > 0) {
              result2 = func2.apply(this, arguments);
            }
            if (n2 <= 1) {
              func2 = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func2, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func2, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func2, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func2, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func2, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func2, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce4(func2, wait2, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait2 = toNumber(wait2) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait2) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func2.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait2);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait2 - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait2 || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait2);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait2);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func2, args) {
          return baseDelay(func2, 1, args);
        });
        var delay3 = baseRest(function(func2, wait2, args) {
          return baseDelay(func2, toNumber(wait2) || 0, args);
        });
        function flip(func2) {
          return createWrap(func2, WRAP_FLIP_FLAG);
        }
        function memoize(func2, resolver) {
          if (typeof func2 != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized3 = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache3 = memoized3.cache;
            if (cache3.has(key)) {
              return cache3.get(key);
            }
            var result2 = func2.apply(this, args);
            memoized3.cache = cache3.set(key, result2) || cache3;
            return result2;
          };
          memoized3.cache = new (memoize.Cache || MapCache)();
          return memoized3;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func2) {
          return before(2, func2);
        }
        var overArgs = castRest(function(func2, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length3 = nativeMin(args.length, funcsLength);
            while (++index < length3) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func2, this, args);
          });
        });
        var partial = baseRest(function(func2, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func2, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func2, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func2, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func2, indexes) {
          return createWrap(func2, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func2, start2) {
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start2 = start2 === undefined2 ? start2 : toInteger(start2);
          return baseRest(func2, start2);
        }
        function spread(func2, start2) {
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start2 = start2 == null ? 0 : nativeMax(toInteger(start2), 0);
          return baseRest(function(args) {
            var array = args[start2], otherArgs = castSlice(args, 0, start2);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func2, this, otherArgs);
          });
        }
        function throttle(func2, wait2, options) {
          var leading = true, trailing = true;
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce4(func2, wait2, {
            "leading": leading,
            "maxWait": wait2,
            "trailing": trailing
          });
        }
        function unary(func2) {
          return ary(func2, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone2(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable2.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag2 || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty2.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError2(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger2(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject2(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger2(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func2 = tag == mapTag2 ? mapToArray : tag == setTag ? setToArray : values;
          return func2(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign3 = value < 0 ? -1 : 1;
            return sign3 * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString3(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty2.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create4(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length3 = sources.length;
          var guard = length3 > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length3 = 1;
          }
          while (++index < length3) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert4 = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity3));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty2.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge3 = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length3 = paths.length;
          while (length3--) {
            baseUnset(result2, paths[length3]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length3 = path.length;
          if (!length3) {
            length3 = 1;
            object = undefined2;
          }
          while (++index < length3) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length3;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number2, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number2), lower, upper);
        }
        function inRange3(number2, start2, end) {
          start2 = toFinite(start2);
          if (end === undefined2) {
            end = start2;
            start2 = 0;
          } else {
            end = toFinite(end);
          }
          number2 = toNumber(number2);
          return baseInRange(number2, start2, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string3) {
          return upperFirst(toString3(string3).toLowerCase());
        }
        function deburr(string3) {
          string3 = toString3(string3);
          return string3 && string3.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string3, target, position) {
          string3 = toString3(string3);
          target = baseToString(target);
          var length3 = string3.length;
          position = position === undefined2 ? length3 : baseClamp(toInteger(position), 0, length3);
          var end = position;
          position -= target.length;
          return position >= 0 && string3.slice(position, end) == target;
        }
        function escape(string3) {
          string3 = toString3(string3);
          return string3 && reHasUnescapedHtml.test(string3) ? string3.replace(reUnescapedHtml, escapeHtmlChar) : string3;
        }
        function escapeRegExp(string3) {
          string3 = toString3(string3);
          return string3 && reHasRegExpChar.test(string3) ? string3.replace(reRegExpChar, "\\$&") : string3;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string3, length3, chars) {
          string3 = toString3(string3);
          length3 = toInteger(length3);
          var strLength = length3 ? stringSize(string3) : 0;
          if (!length3 || strLength >= length3) {
            return string3;
          }
          var mid = (length3 - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string3 + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string3, length3, chars) {
          string3 = toString3(string3);
          length3 = toInteger(length3);
          var strLength = length3 ? stringSize(string3) : 0;
          return length3 && strLength < length3 ? string3 + createPadding(length3 - strLength, chars) : string3;
        }
        function padStart(string3, length3, chars) {
          string3 = toString3(string3);
          length3 = toInteger(length3);
          var strLength = length3 ? stringSize(string3) : 0;
          return length3 && strLength < length3 ? createPadding(length3 - strLength, chars) + string3 : string3;
        }
        function parseInt2(string3, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString3(string3).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string3, n2, guard) {
          if (guard ? isIterateeCall(string3, n2, guard) : n2 === undefined2) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          return baseRepeat(toString3(string3), n2);
        }
        function replace() {
          var args = arguments, string3 = toString3(args[0]);
          return args.length < 3 ? string3 : string3.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split3(string3, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string3, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string3 = toString3(string3);
          if (string3 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string3)) {
              return castSlice(stringToArray(string3), 0, limit);
            }
          }
          return string3.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string3, target, position) {
          string3 = toString3(string3);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string3.length);
          target = baseToString(target);
          return string3.slice(position, position + target.length) == target;
        }
        function template(string3, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string3, options, guard)) {
            options = undefined2;
          }
          string3 = toString3(string3);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string3.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string3.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty2.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError2(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString3(value).toLowerCase();
        }
        function toUpper(value) {
          return toString3(value).toUpperCase();
        }
        function trim(string3, chars, guard) {
          string3 = toString3(string3);
          if (string3 && (guard || chars === undefined2)) {
            return baseTrim(string3);
          }
          if (!string3 || !(chars = baseToString(chars))) {
            return string3;
          }
          var strSymbols = stringToArray(string3), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start2, end).join("");
        }
        function trimEnd(string3, chars, guard) {
          string3 = toString3(string3);
          if (string3 && (guard || chars === undefined2)) {
            return string3.slice(0, trimmedEndIndex(string3) + 1);
          }
          if (!string3 || !(chars = baseToString(chars))) {
            return string3;
          }
          var strSymbols = stringToArray(string3), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string3, chars, guard) {
          string3 = toString3(string3);
          if (string3 && (guard || chars === undefined2)) {
            return string3.replace(reTrimStart, "");
          }
          if (!string3 || !(chars = baseToString(chars))) {
            return string3;
          }
          var strSymbols = stringToArray(string3), start2 = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start2).join("");
        }
        function truncate(string3, options) {
          var length3 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length3 = "length" in options ? toInteger(options.length) : length3;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string3 = toString3(string3);
          var strLength = string3.length;
          if (hasUnicode(string3)) {
            var strSymbols = stringToArray(string3);
            strLength = strSymbols.length;
          }
          if (length3 >= strLength) {
            return string3;
          }
          var end = length3 - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string3.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string3.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString3(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string3.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape2(string3) {
          string3 = toString3(string3);
          return string3 && reHasEscapedHtml.test(string3) ? string3.replace(reEscapedHtml, unescapeHtmlChar) : string3;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string3, pattern, guard) {
          string3 = toString3(string3);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string3) ? unicodeWords(string3) : asciiWords(string3);
          }
          return string3.match(pattern) || [];
        }
        var attempt = baseRest(function(func2, args) {
          try {
            return apply(func2, undefined2, args);
          } catch (e2) {
            return isError2(e2) ? e2 : new Error2(e2);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length3 = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length3 ? [] : arrayMap(pairs, function(pair2) {
            if (typeof pair2[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair2[0]), pair2[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length3) {
              var pair2 = pairs[index];
              if (apply(pair2[0], this, args)) {
                return apply(pair2[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity3(value) {
          return value;
        }
        function iteratee(func2) {
          return baseIteratee(typeof func2 == "function" ? func2 : baseClone(func2, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func2 = source[methodName];
            object[methodName] = func2;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func2, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func2.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop2() {
        }
        function nthArg(n2) {
          n2 = toInteger(n2);
          return baseRest(function(args) {
            return baseNth(args, n2);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n2, iteratee2) {
          n2 = toInteger(n2);
          if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length3 = nativeMin(n2, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n2 -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length3, iteratee2);
          while (++index < n2) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString3(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString3(prefix) + id;
        }
        var add3 = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity3, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity3);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity3, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity3) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat3;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create4;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce4;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay3;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter2;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten2;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert4;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map2;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge3;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle2;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split3;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take2;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor2;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add3;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone2;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity3;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange3;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer2;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError2;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger2;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject2;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop2;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString3;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape2;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func2, methodName) {
            if (!hasOwnProperty2.call(lodash.prototype, methodName)) {
              source[methodName] = func2;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n2) {
            n2 = n2 === undefined2 ? 1 : nativeMax(toInteger(n2), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n2, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n2) {
            return this.reverse()[methodName](n2).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity3);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start2, end) {
          start2 = toInteger(start2);
          var result2 = this;
          if (result2.__filtered__ && (start2 > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start2 < 0) {
            result2 = result2.takeRight(-start2);
          } else if (start2) {
            result2 = result2.drop(start2);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start2);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func2, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func2.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func2.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func2 = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func2.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func2.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func2, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty2.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _2 = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _2;
        define(function() {
          return _2;
        });
      } else if (freeModule) {
        (freeModule.exports = _2)._ = _2;
        freeExports._ = _2;
      } else {
        root._ = _2;
      }
    }).call(exports);
  }
});

// node_modules/@waku/core/dist/index.js
var dist_exports2 = {};
__export(dist_exports2, {
  ConnectionManager: () => ConnectionManager,
  FilterCodecs: () => FilterCodecs,
  FilterCore: () => FilterCore,
  LightPushCodec: () => LightPushCodec,
  LightPushCodecV2: () => LightPushCodecV2,
  LightPushCore: () => LightPushCore,
  MetadataCodec: () => MetadataCodec,
  StoreCodec: () => StoreCodec,
  StoreCore: () => StoreCore,
  StreamManager: () => StreamManager,
  createDecoder: () => createDecoder,
  createEncoder: () => createEncoder,
  message: () => message_exports2,
  messageHash: () => messageHash,
  messageHashStr: () => messageHashStr,
  wakuMetadata: () => wakuMetadata,
  waku_filter: () => filter_exports2,
  waku_light_push: () => light_push_exports2,
  waku_store: () => store_exports
});

// node_modules/@waku/core/dist/lib/message/version_0.js
var version_0_exports = {};
__export(version_0_exports, {
  DecodedMessage: () => DecodedMessage,
  Decoder: () => Decoder2,
  Encoder: () => Encoder2,
  Version: () => Version,
  createDecoder: () => createDecoder,
  createEncoder: () => createEncoder,
  proto: () => message_exports
});

// node_modules/@waku/proto/dist/generated/message.js
var message_exports = {};
__export(message_exports, {
  RateLimitProof: () => RateLimitProof,
  WakuMessage: () => WakuMessage
});

// node_modules/uint8arrays/dist/src/alloc.js
function alloc(size = 0) {
  return new Uint8Array(size);
}
function allocUnsafe(size = 0) {
  return new Uint8Array(size);
}

// node_modules/uint8-varint/dist/src/index.js
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var MSB = 128;
var REST = 127;
function encodingLength(value) {
  if (value < N1) {
    return 1;
  }
  if (value < N2) {
    return 2;
  }
  if (value < N3) {
    return 3;
  }
  if (value < N4) {
    return 4;
  }
  if (value < N5) {
    return 5;
  }
  if (value < N6) {
    return 6;
  }
  if (value < N7) {
    return 7;
  }
  if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {
    throw new RangeError("Could not encode varint");
  }
  return 8;
}
function encodeUint8Array(value, buf, offset = 0) {
  switch (encodingLength(value)) {
    case 8: {
      buf[offset++] = value & 255 | MSB;
      value /= 128;
    }
    case 7: {
      buf[offset++] = value & 255 | MSB;
      value /= 128;
    }
    case 6: {
      buf[offset++] = value & 255 | MSB;
      value /= 128;
    }
    case 5: {
      buf[offset++] = value & 255 | MSB;
      value /= 128;
    }
    case 4: {
      buf[offset++] = value & 255 | MSB;
      value >>>= 7;
    }
    case 3: {
      buf[offset++] = value & 255 | MSB;
      value >>>= 7;
    }
    case 2: {
      buf[offset++] = value & 255 | MSB;
      value >>>= 7;
    }
    case 1: {
      buf[offset++] = value & 255;
      value >>>= 7;
      break;
    }
    default:
      throw new Error("unreachable");
  }
  return buf;
}
function encodeUint8ArrayList(value, buf, offset = 0) {
  switch (encodingLength(value)) {
    case 8: {
      buf.set(offset++, value & 255 | MSB);
      value /= 128;
    }
    case 7: {
      buf.set(offset++, value & 255 | MSB);
      value /= 128;
    }
    case 6: {
      buf.set(offset++, value & 255 | MSB);
      value /= 128;
    }
    case 5: {
      buf.set(offset++, value & 255 | MSB);
      value /= 128;
    }
    case 4: {
      buf.set(offset++, value & 255 | MSB);
      value >>>= 7;
    }
    case 3: {
      buf.set(offset++, value & 255 | MSB);
      value >>>= 7;
    }
    case 2: {
      buf.set(offset++, value & 255 | MSB);
      value >>>= 7;
    }
    case 1: {
      buf.set(offset++, value & 255);
      value >>>= 7;
      break;
    }
    default:
      throw new Error("unreachable");
  }
  return buf;
}
function decodeUint8Array(buf, offset) {
  let b = buf[offset];
  let res = 0;
  res += b & REST;
  if (b < MSB) {
    return res;
  }
  b = buf[offset + 1];
  res += (b & REST) << 7;
  if (b < MSB) {
    return res;
  }
  b = buf[offset + 2];
  res += (b & REST) << 14;
  if (b < MSB) {
    return res;
  }
  b = buf[offset + 3];
  res += (b & REST) << 21;
  if (b < MSB) {
    return res;
  }
  b = buf[offset + 4];
  res += (b & REST) * N4;
  if (b < MSB) {
    return res;
  }
  b = buf[offset + 5];
  res += (b & REST) * N5;
  if (b < MSB) {
    return res;
  }
  b = buf[offset + 6];
  res += (b & REST) * N6;
  if (b < MSB) {
    return res;
  }
  b = buf[offset + 7];
  res += (b & REST) * N7;
  if (b < MSB) {
    return res;
  }
  throw new RangeError("Could not decode varint");
}
function decodeUint8ArrayList(buf, offset) {
  let b = buf.get(offset);
  let res = 0;
  res += b & REST;
  if (b < MSB) {
    return res;
  }
  b = buf.get(offset + 1);
  res += (b & REST) << 7;
  if (b < MSB) {
    return res;
  }
  b = buf.get(offset + 2);
  res += (b & REST) << 14;
  if (b < MSB) {
    return res;
  }
  b = buf.get(offset + 3);
  res += (b & REST) << 21;
  if (b < MSB) {
    return res;
  }
  b = buf.get(offset + 4);
  res += (b & REST) * N4;
  if (b < MSB) {
    return res;
  }
  b = buf.get(offset + 5);
  res += (b & REST) * N5;
  if (b < MSB) {
    return res;
  }
  b = buf.get(offset + 6);
  res += (b & REST) * N6;
  if (b < MSB) {
    return res;
  }
  b = buf.get(offset + 7);
  res += (b & REST) * N7;
  if (b < MSB) {
    return res;
  }
  throw new RangeError("Could not decode varint");
}
function encode(value, buf, offset = 0) {
  if (buf == null) {
    buf = allocUnsafe(encodingLength(value));
  }
  if (buf instanceof Uint8Array) {
    return encodeUint8Array(value, buf, offset);
  } else {
    return encodeUint8ArrayList(value, buf, offset);
  }
}
function decode(buf, offset = 0) {
  if (buf instanceof Uint8Array) {
    return decodeUint8Array(buf, offset);
  } else {
    return decodeUint8ArrayList(buf, offset);
  }
}

// node_modules/protons-runtime/dist/src/utils/float.js
var f32 = new Float32Array([-0]);
var f8b = new Uint8Array(f32.buffer);
function writeFloatLE(val, buf, pos) {
  f32[0] = val;
  buf[pos] = f8b[0];
  buf[pos + 1] = f8b[1];
  buf[pos + 2] = f8b[2];
  buf[pos + 3] = f8b[3];
}
function readFloatLE(buf, pos) {
  f8b[0] = buf[pos];
  f8b[1] = buf[pos + 1];
  f8b[2] = buf[pos + 2];
  f8b[3] = buf[pos + 3];
  return f32[0];
}
var f64 = new Float64Array([-0]);
var d8b = new Uint8Array(f64.buffer);
function writeDoubleLE(val, buf, pos) {
  f64[0] = val;
  buf[pos] = d8b[0];
  buf[pos + 1] = d8b[1];
  buf[pos + 2] = d8b[2];
  buf[pos + 3] = d8b[3];
  buf[pos + 4] = d8b[4];
  buf[pos + 5] = d8b[5];
  buf[pos + 6] = d8b[6];
  buf[pos + 7] = d8b[7];
}
function readDoubleLE(buf, pos) {
  d8b[0] = buf[pos];
  d8b[1] = buf[pos + 1];
  d8b[2] = buf[pos + 2];
  d8b[3] = buf[pos + 3];
  d8b[4] = buf[pos + 4];
  d8b[5] = buf[pos + 5];
  d8b[6] = buf[pos + 6];
  d8b[7] = buf[pos + 7];
  return f64[0];
}

// node_modules/protons-runtime/dist/src/utils/longbits.js
var MAX_SAFE_NUMBER_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
var MIN_SAFE_NUMBER_INTEGER = BigInt(Number.MIN_SAFE_INTEGER);
var LongBits = class _LongBits {
  constructor(lo, hi) {
    __publicField(this, "lo");
    __publicField(this, "hi");
    this.lo = lo | 0;
    this.hi = hi | 0;
  }
  /**
   * Converts this long bits to a possibly unsafe JavaScript number
   */
  toNumber(unsigned = false) {
    if (!unsigned && this.hi >>> 31 > 0) {
      const lo = ~this.lo + 1 >>> 0;
      let hi = ~this.hi >>> 0;
      if (lo === 0) {
        hi = hi + 1 >>> 0;
      }
      return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  }
  /**
   * Converts this long bits to a bigint
   */
  toBigInt(unsigned = false) {
    if (unsigned) {
      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
    }
    if (this.hi >>> 31 !== 0) {
      const lo = ~this.lo + 1 >>> 0;
      let hi = ~this.hi >>> 0;
      if (lo === 0) {
        hi = hi + 1 >>> 0;
      }
      return -(BigInt(lo) + (BigInt(hi) << 32n));
    }
    return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
  }
  /**
   * Converts this long bits to a string
   */
  toString(unsigned = false) {
    return this.toBigInt(unsigned).toString();
  }
  /**
   * Zig-zag encodes this long bits
   */
  zzEncode() {
    const mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  }
  /**
   * Zig-zag decodes this long bits
   */
  zzDecode() {
    const mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  }
  /**
   * Calculates the length of this longbits when encoded as a varint.
   */
  length() {
    const part0 = this.lo;
    const part1 = (this.lo >>> 28 | this.hi << 4) >>> 0;
    const part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  }
  /**
   * Constructs new long bits from the specified number
   */
  static fromBigInt(value) {
    if (value === 0n) {
      return zero;
    }
    if (value < MAX_SAFE_NUMBER_INTEGER && value > MIN_SAFE_NUMBER_INTEGER) {
      return this.fromNumber(Number(value));
    }
    const negative = value < 0n;
    if (negative) {
      value = -value;
    }
    let hi = value >> 32n;
    let lo = value - (hi << 32n);
    if (negative) {
      hi = ~hi | 0n;
      lo = ~lo | 0n;
      if (++lo > TWO_32) {
        lo = 0n;
        if (++hi > TWO_32) {
          hi = 0n;
        }
      }
    }
    return new _LongBits(Number(lo), Number(hi));
  }
  /**
   * Constructs new long bits from the specified number
   */
  static fromNumber(value) {
    if (value === 0) {
      return zero;
    }
    const sign3 = value < 0;
    if (sign3) {
      value = -value;
    }
    let lo = value >>> 0;
    let hi = (value - lo) / 4294967296 >>> 0;
    if (sign3) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295) {
          hi = 0;
        }
      }
    }
    return new _LongBits(lo, hi);
  }
  /**
   * Constructs new long bits from a number, long or string
   */
  static from(value) {
    if (typeof value === "number") {
      return _LongBits.fromNumber(value);
    }
    if (typeof value === "bigint") {
      return _LongBits.fromBigInt(value);
    }
    if (typeof value === "string") {
      return _LongBits.fromBigInt(BigInt(value));
    }
    return value.low != null || value.high != null ? new _LongBits(value.low >>> 0, value.high >>> 0) : zero;
  }
};
var zero = new LongBits(0, 0);
zero.toBigInt = function() {
  return 0n;
};
zero.zzEncode = zero.zzDecode = function() {
  return this;
};
zero.length = function() {
  return 1;
};
var TWO_32 = 4294967296n;

// node_modules/protons-runtime/dist/src/utils/utf8.js
function length(string3) {
  let len = 0;
  let c2 = 0;
  for (let i2 = 0; i2 < string3.length; ++i2) {
    c2 = string3.charCodeAt(i2);
    if (c2 < 128) {
      len += 1;
    } else if (c2 < 2048) {
      len += 2;
    } else if ((c2 & 64512) === 55296 && (string3.charCodeAt(i2 + 1) & 64512) === 56320) {
      ++i2;
      len += 4;
    } else {
      len += 3;
    }
  }
  return len;
}
function read(buffer, start2, end) {
  const len = end - start2;
  if (len < 1) {
    return "";
  }
  let parts;
  const chunk = [];
  let i2 = 0;
  let t2;
  while (start2 < end) {
    t2 = buffer[start2++];
    if (t2 < 128) {
      chunk[i2++] = t2;
    } else if (t2 > 191 && t2 < 224) {
      chunk[i2++] = (t2 & 31) << 6 | buffer[start2++] & 63;
    } else if (t2 > 239 && t2 < 365) {
      t2 = ((t2 & 7) << 18 | (buffer[start2++] & 63) << 12 | (buffer[start2++] & 63) << 6 | buffer[start2++] & 63) - 65536;
      chunk[i2++] = 55296 + (t2 >> 10);
      chunk[i2++] = 56320 + (t2 & 1023);
    } else {
      chunk[i2++] = (t2 & 15) << 12 | (buffer[start2++] & 63) << 6 | buffer[start2++] & 63;
    }
    if (i2 > 8191) {
      (parts ?? (parts = [])).push(String.fromCharCode.apply(String, chunk));
      i2 = 0;
    }
  }
  if (parts != null) {
    if (i2 > 0) {
      parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
    }
    return parts.join("");
  }
  return String.fromCharCode.apply(String, chunk.slice(0, i2));
}
function write(string3, buffer, offset) {
  const start2 = offset;
  let c1;
  let c2;
  for (let i2 = 0; i2 < string3.length; ++i2) {
    c1 = string3.charCodeAt(i2);
    if (c1 < 128) {
      buffer[offset++] = c1;
    } else if (c1 < 2048) {
      buffer[offset++] = c1 >> 6 | 192;
      buffer[offset++] = c1 & 63 | 128;
    } else if ((c1 & 64512) === 55296 && ((c2 = string3.charCodeAt(i2 + 1)) & 64512) === 56320) {
      c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
      ++i2;
      buffer[offset++] = c1 >> 18 | 240;
      buffer[offset++] = c1 >> 12 & 63 | 128;
      buffer[offset++] = c1 >> 6 & 63 | 128;
      buffer[offset++] = c1 & 63 | 128;
    } else {
      buffer[offset++] = c1 >> 12 | 224;
      buffer[offset++] = c1 >> 6 & 63 | 128;
      buffer[offset++] = c1 & 63 | 128;
    }
  }
  return offset - start2;
}

// node_modules/protons-runtime/dist/src/utils/reader.js
function indexOutOfRange(reader, writeLength) {
  return RangeError(`index out of range: ${reader.pos} + ${writeLength ?? 1} > ${reader.len}`);
}
function readFixed32End(buf, end) {
  return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
}
var Uint8ArrayReader = class {
  constructor(buffer) {
    __publicField(this, "buf");
    __publicField(this, "pos");
    __publicField(this, "len");
    __publicField(this, "_slice", Uint8Array.prototype.subarray);
    this.buf = buffer;
    this.pos = 0;
    this.len = buffer.length;
  }
  /**
   * Reads a varint as an unsigned 32 bit value
   */
  uint32() {
    let value = 4294967295;
    value = (this.buf[this.pos] & 127) >>> 0;
    if (this.buf[this.pos++] < 128) {
      return value;
    }
    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
    if (this.buf[this.pos++] < 128) {
      return value;
    }
    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
    if (this.buf[this.pos++] < 128) {
      return value;
    }
    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
    if (this.buf[this.pos++] < 128) {
      return value;
    }
    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
    if (this.buf[this.pos++] < 128) {
      return value;
    }
    if ((this.pos += 5) > this.len) {
      this.pos = this.len;
      throw indexOutOfRange(this, 10);
    }
    return value;
  }
  /**
   * Reads a varint as a signed 32 bit value
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Reads a zig-zag encoded varint as a signed 32 bit value
   */
  sint32() {
    const value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
  }
  /**
   * Reads a varint as a boolean
   */
  bool() {
    return this.uint32() !== 0;
  }
  /**
   * Reads fixed 32 bits as an unsigned 32 bit integer
   */
  fixed32() {
    if (this.pos + 4 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const res = readFixed32End(this.buf, this.pos += 4);
    return res;
  }
  /**
   * Reads fixed 32 bits as a signed 32 bit integer
   */
  sfixed32() {
    if (this.pos + 4 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const res = readFixed32End(this.buf, this.pos += 4) | 0;
    return res;
  }
  /**
   * Reads a float (32 bit) as a number
   */
  float() {
    if (this.pos + 4 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const value = readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
  }
  /**
   * Reads a double (64 bit float) as a number
   */
  double() {
    if (this.pos + 8 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const value = readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
  }
  /**
   * Reads a sequence of bytes preceded by its length as a varint
   */
  bytes() {
    const length3 = this.uint32();
    const start2 = this.pos;
    const end = this.pos + length3;
    if (end > this.len) {
      throw indexOutOfRange(this, length3);
    }
    this.pos += length3;
    return start2 === end ? new Uint8Array(0) : this.buf.subarray(start2, end);
  }
  /**
   * Reads a string preceded by its byte length as a varint
   */
  string() {
    const bytes = this.bytes();
    return read(bytes, 0, bytes.length);
  }
  /**
   * Skips the specified number of bytes if specified, otherwise skips a varint
   */
  skip(length3) {
    if (typeof length3 === "number") {
      if (this.pos + length3 > this.len) {
        throw indexOutOfRange(this, length3);
      }
      this.pos += length3;
    } else {
      do {
        if (this.pos >= this.len) {
          throw indexOutOfRange(this);
        }
      } while ((this.buf[this.pos++] & 128) !== 0);
    }
    return this;
  }
  /**
   * Skips the next element of the specified wire type
   */
  skipType(wireType) {
    switch (wireType) {
      case 0:
        this.skip();
        break;
      case 1:
        this.skip(8);
        break;
      case 2:
        this.skip(this.uint32());
        break;
      case 3:
        while ((wireType = this.uint32() & 7) !== 4) {
          this.skipType(wireType);
        }
        break;
      case 5:
        this.skip(4);
        break;
      default:
        throw Error(`invalid wire type ${wireType} at offset ${this.pos}`);
    }
    return this;
  }
  readLongVarint() {
    const bits = new LongBits(0, 0);
    let i2 = 0;
    if (this.len - this.pos > 4) {
      for (; i2 < 4; ++i2) {
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits;
        }
      }
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
      if (this.buf[this.pos++] < 128) {
        return bits;
      }
      i2 = 0;
    } else {
      for (; i2 < 3; ++i2) {
        if (this.pos >= this.len) {
          throw indexOutOfRange(this);
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits;
        }
      }
      bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
      return bits;
    }
    if (this.len - this.pos > 4) {
      for (; i2 < 5; ++i2) {
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits;
        }
      }
    } else {
      for (; i2 < 5; ++i2) {
        if (this.pos >= this.len) {
          throw indexOutOfRange(this);
        }
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits;
        }
      }
    }
    throw Error("invalid varint encoding");
  }
  readFixed64() {
    if (this.pos + 8 > this.len) {
      throw indexOutOfRange(this, 8);
    }
    const lo = readFixed32End(this.buf, this.pos += 4);
    const hi = readFixed32End(this.buf, this.pos += 4);
    return new LongBits(lo, hi);
  }
  /**
   * Reads a varint as a signed 64 bit value
   */
  int64() {
    return this.readLongVarint().toBigInt();
  }
  /**
   * Reads a varint as a signed 64 bit value returned as a possibly unsafe
   * JavaScript number
   */
  int64Number() {
    return this.readLongVarint().toNumber();
  }
  /**
   * Reads a varint as a signed 64 bit value returned as a string
   */
  int64String() {
    return this.readLongVarint().toString();
  }
  /**
   * Reads a varint as an unsigned 64 bit value
   */
  uint64() {
    return this.readLongVarint().toBigInt(true);
  }
  /**
   * Reads a varint as an unsigned 64 bit value returned as a possibly unsafe
   * JavaScript number
   */
  uint64Number() {
    const value = decodeUint8Array(this.buf, this.pos);
    this.pos += encodingLength(value);
    return value;
  }
  /**
   * Reads a varint as an unsigned 64 bit value returned as a string
   */
  uint64String() {
    return this.readLongVarint().toString(true);
  }
  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value
   */
  sint64() {
    return this.readLongVarint().zzDecode().toBigInt();
  }
  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
   * possibly unsafe JavaScript number
   */
  sint64Number() {
    return this.readLongVarint().zzDecode().toNumber();
  }
  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
   * string
   */
  sint64String() {
    return this.readLongVarint().zzDecode().toString();
  }
  /**
   * Reads fixed 64 bits
   */
  fixed64() {
    return this.readFixed64().toBigInt();
  }
  /**
   * Reads fixed 64 bits returned as a possibly unsafe JavaScript number
   */
  fixed64Number() {
    return this.readFixed64().toNumber();
  }
  /**
   * Reads fixed 64 bits returned as a string
   */
  fixed64String() {
    return this.readFixed64().toString();
  }
  /**
   * Reads zig-zag encoded fixed 64 bits
   */
  sfixed64() {
    return this.readFixed64().toBigInt();
  }
  /**
   * Reads zig-zag encoded fixed 64 bits returned as a possibly unsafe
   * JavaScript number
   */
  sfixed64Number() {
    return this.readFixed64().toNumber();
  }
  /**
   * Reads zig-zag encoded fixed 64 bits returned as a string
   */
  sfixed64String() {
    return this.readFixed64().toString();
  }
};
function createReader(buf) {
  return new Uint8ArrayReader(buf instanceof Uint8Array ? buf : buf.subarray());
}

// node_modules/protons-runtime/dist/src/decode.js
function decodeMessage(buf, codec, opts) {
  const reader = createReader(buf);
  return codec.decode(reader, void 0, opts);
}

// node_modules/multiformats/dist/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});

// node_modules/multiformats/dist/src/bytes.js
var empty = new Uint8Array(0);
function equals(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce(o2) {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array") {
    return o2;
  }
  if (o2 instanceof ArrayBuffer) {
    return new Uint8Array(o2);
  }
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString(str) {
  return new TextEncoder().encode(str);
}
function toString(b) {
  return new TextDecoder().decode(b);
}

// node_modules/multiformats/dist/src/vendor/base-x.js
function base(ALPHABET, name3) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode10(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length3 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length3) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length3 = i3;
      pbegin++;
    }
    var it2 = size - length3;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length3 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length3) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length3 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length3;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode10(string3) {
    var buffer = decodeUnsafe(string3);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name3} character`);
  }
  return {
    encode: encode10,
    decodeUnsafe,
    decode: decode10
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// node_modules/multiformats/dist/src/bases/base.js
var Encoder = class {
  constructor(name3, prefix, baseEncode) {
    __publicField(this, "name");
    __publicField(this, "prefix");
    __publicField(this, "baseEncode");
    this.name = name3;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  constructor(name3, prefix, baseDecode) {
    __publicField(this, "name");
    __publicField(this, "prefix");
    __publicField(this, "baseDecode");
    __publicField(this, "prefixCodePoint");
    this.name = name3;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
};
var ComposedDecoder = class {
  constructor(decoders4) {
    __publicField(this, "decoders");
    this.decoders = decoders4;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or(left, right) {
  return new ComposedDecoder({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec = class {
  constructor(name3, prefix, baseEncode, baseDecode) {
    __publicField(this, "name");
    __publicField(this, "prefix");
    __publicField(this, "baseEncode");
    __publicField(this, "baseDecode");
    __publicField(this, "encoder");
    __publicField(this, "decoder");
    this.name = name3;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name3, prefix, baseEncode);
    this.decoder = new Decoder(name3, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from({ name: name3, prefix, encode: encode10, decode: decode10 }) {
  return new Codec(name3, prefix, encode10, decode10);
}
function baseX({ name: name3, prefix, alphabet: alphabet2 }) {
  const { encode: encode10, decode: decode10 } = base_x_default(alphabet2, name3);
  return from({
    prefix,
    name: name3,
    encode: encode10,
    decode: (text) => coerce(decode10(text))
  });
}
function decode2(string3, alphabetIdx, bitsPerChar, name3) {
  let end = string3.length;
  while (string3[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value = alphabetIdx[string3[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name3} character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode2(data, alphabet2, bitsPerChar) {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer = buffer << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet2[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx(alphabet2) {
  const alphabetIdx = {};
  for (let i2 = 0; i2 < alphabet2.length; ++i2) {
    alphabetIdx[alphabet2[i2]] = i2;
  }
  return alphabetIdx;
}
function rfc4648({ name: name3, prefix, bitsPerChar, alphabet: alphabet2 }) {
  const alphabetIdx = createAlphabetIdx(alphabet2);
  return from({
    prefix,
    name: name3,
    encode(input) {
      return encode2(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode2(input, alphabetIdx, bitsPerChar, name3);
    }
  });
}

// node_modules/multiformats/dist/src/bases/base10.js
var base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/multiformats/dist/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/multiformats/dist/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base2
});
var base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
var alphabet = Array.from("");
var alphabetBytesToChars = alphabet.reduce((p2, c2, i2) => {
  p2[i2] = c2;
  return p2;
}, []);
var alphabetCharsToBytes = alphabet.reduce((p2, c2, i2) => {
  const codePoint = c2.codePointAt(0);
  if (codePoint == null) {
    throw new Error(`Invalid character: ${c2}`);
  }
  p2[codePoint] = i2;
  return p2;
}, []);
function encode3(data) {
  return data.reduce((p2, c2) => {
    p2 += alphabetBytesToChars[c2];
    return p2;
  }, "");
}
function decode3(str) {
  const byts = [];
  for (const char of str) {
    const codePoint = char.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${char}`);
    }
    const byt = alphabetCharsToBytes[codePoint];
    if (byt == null) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji = from({
  prefix: "",
  name: "base256emoji",
  encode: encode3,
  decode: decode3
});

// node_modules/multiformats/dist/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/multiformats/dist/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/multiformats/dist/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/multiformats/dist/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/multiformats/dist/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/multiformats/dist/src/bases/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});
var identity = from({
  prefix: "\0",
  name: "identity",
  encode: (buf) => toString(buf),
  decode: (str) => fromString(str)
});

// node_modules/multiformats/dist/src/codecs/json.js
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();

// node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});

// node_modules/multiformats/dist/src/vendor/varint.js
var encode_1 = encode4;
var MSB2 = 128;
var REST2 = 127;
var MSBALL = ~REST2;
var INT = Math.pow(2, 31);
function encode4(num3, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num3 >= INT) {
    out[offset++] = num3 & 255 | MSB2;
    num3 /= 128;
  }
  while (num3 & MSBALL) {
    out[offset++] = num3 & 255 | MSB2;
    num3 >>>= 7;
  }
  out[offset] = num3 | 0;
  encode4.bytes = offset - oldOffset + 1;
  return out;
}
var decode4 = read2;
var MSB$1 = 128;
var REST$1 = 127;
function read2(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l2 = buf.length;
  do {
    if (counter >= l2) {
      read2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read2.bytes = counter - offset;
  return res;
}
var N12 = Math.pow(2, 7);
var N22 = Math.pow(2, 14);
var N32 = Math.pow(2, 21);
var N42 = Math.pow(2, 28);
var N52 = Math.pow(2, 35);
var N62 = Math.pow(2, 42);
var N72 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length2 = function(value) {
  return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode4,
  encodingLength: length2
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// node_modules/multiformats/dist/src/varint.js
function decode5(data, offset = 0) {
  const code2 = varint_default.decode(data, offset);
  return [code2, varint_default.decode.bytes];
}
function encodeTo(int, target, offset = 0) {
  varint_default.encode(int, target, offset);
  return target;
}
function encodingLength2(int) {
  return varint_default.encodingLength(int);
}

// node_modules/multiformats/dist/src/hashes/digest.js
function create(code2, digest2) {
  const size = digest2.byteLength;
  const sizeOffset = encodingLength2(code2);
  const digestOffset = sizeOffset + encodingLength2(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo(code2, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest2, digestOffset);
  return new Digest(code2, size, digest2, bytes);
}
function decode6(multihash) {
  const bytes = coerce(multihash);
  const [code2, sizeOffset] = decode5(bytes);
  const [size, digestOffset] = decode5(bytes.subarray(sizeOffset));
  const digest2 = bytes.subarray(sizeOffset + digestOffset);
  if (digest2.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest(code2, size, digest2, bytes);
}
function equals2(a2, b) {
  if (a2 === b) {
    return true;
  } else {
    const data = b;
    return a2.code === data.code && a2.size === data.size && data.bytes instanceof Uint8Array && equals(a2.bytes, data.bytes);
  }
}
var Digest = class {
  /**
   * Creates a multihash digest.
   */
  constructor(code2, size, digest2, bytes) {
    __publicField(this, "code");
    __publicField(this, "size");
    __publicField(this, "digest");
    __publicField(this, "bytes");
    this.code = code2;
    this.size = size;
    this.digest = digest2;
    this.bytes = bytes;
  }
};

// node_modules/multiformats/dist/src/hashes/identity.js
var code = 0;
var name = "identity";
var encode5 = coerce;
function digest(input, options) {
  if ((options == null ? void 0 : options.truncate) != null && options.truncate !== input.byteLength) {
    if (options.truncate < 0 || options.truncate > input.byteLength) {
      throw new Error(`Invalid truncate option, must be less than or equal to ${input.byteLength}`);
    }
    input = input.subarray(0, options.truncate);
  }
  return create(code, encode5(input));
}
var identity2 = { code, name, encode: encode5, digest };

// node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});

// node_modules/multiformats/dist/src/hashes/hasher.js
var DEFAULT_MIN_DIGEST_LENGTH = 20;
function from2({ name: name3, code: code2, encode: encode10, minDigestLength, maxDigestLength }) {
  return new Hasher(name3, code2, encode10, minDigestLength, maxDigestLength);
}
var Hasher = class {
  constructor(name3, code2, encode10, minDigestLength, maxDigestLength) {
    __publicField(this, "name");
    __publicField(this, "code");
    __publicField(this, "encode");
    __publicField(this, "minDigestLength");
    __publicField(this, "maxDigestLength");
    this.name = name3;
    this.code = code2;
    this.encode = encode10;
    this.minDigestLength = minDigestLength ?? DEFAULT_MIN_DIGEST_LENGTH;
    this.maxDigestLength = maxDigestLength;
  }
  digest(input, options) {
    if ((options == null ? void 0 : options.truncate) != null) {
      if (options.truncate < this.minDigestLength) {
        throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);
      }
      if (this.maxDigestLength != null && options.truncate > this.maxDigestLength) {
        throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`);
      }
    }
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      if (result instanceof Uint8Array) {
        return createDigest(result, this.code, options == null ? void 0 : options.truncate);
      }
      return result.then((digest2) => createDigest(digest2, this.code, options == null ? void 0 : options.truncate));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
function createDigest(digest2, code2, truncate) {
  if (truncate != null && truncate !== digest2.byteLength) {
    if (truncate > digest2.byteLength) {
      throw new Error(`Invalid truncate option, must be less than or equal to ${digest2.byteLength}`);
    }
    digest2 = digest2.subarray(0, truncate);
  }
  return create(code2, digest2);
}

// node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha(name3) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name3, data));
}
var sha256 = from2({
  name: "sha2-256",
  code: 18,
  encode: sha("SHA-256")
});
var sha512 = from2({
  name: "sha2-512",
  code: 19,
  encode: sha("SHA-512")
});

// node_modules/multiformats/dist/src/cid.js
function format(link, base4) {
  const { bytes, version: version5 } = link;
  switch (version5) {
    case 0:
      return toStringV0(bytes, baseCache(link), base4 ?? base58btc.encoder);
    default:
      return toStringV1(bytes, baseCache(link), base4 ?? base32.encoder);
  }
}
var cache = /* @__PURE__ */ new WeakMap();
function baseCache(cid) {
  const baseCache2 = cache.get(cid);
  if (baseCache2 == null) {
    const baseCache3 = /* @__PURE__ */ new Map();
    cache.set(cid, baseCache3);
    return baseCache3;
  }
  return baseCache2;
}
var _a;
var CID = class _CID {
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version5, code2, multihash, bytes) {
    __publicField(this, "code");
    __publicField(this, "version");
    __publicField(this, "multihash");
    __publicField(this, "bytes");
    __publicField(this, "/");
    __publicField(this, _a, "CID");
    this.code = code2;
    this.version = version5;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code2, multihash } = this;
        if (code2 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code2, digest: digest2 } = this.multihash;
        const multihash = create(code2, digest2);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals2(self2.multihash, unknown.multihash);
  }
  toString(base4) {
    return format(this, base4);
  }
  toJSON() {
    return { "/": format(this) };
  }
  link() {
    return this;
  }
  // Legacy
  [(_a = Symbol.toStringTag, Symbol.for("nodejs.util.inspect.custom"))]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version5, code: code2, multihash, bytes } = value;
      return new _CID(version5, code2, multihash, bytes ?? encodeCID(version5, code2, multihash.bytes));
    } else if (value[cidSymbol] === true) {
      const { version: version5, multihash, code: code2 } = value;
      const digest2 = decode6(multihash);
      return _CID.create(version5, code2, digest2);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version5, code2, digest2) {
    if (typeof code2 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest2.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version5) {
      case 0: {
        if (code2 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new _CID(version5, code2, digest2, digest2.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID(version5, code2, digest2.bytes);
        return new _CID(version5, code2, digest2, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest2) {
    return _CID.create(0, DAG_PB_CODE, digest2);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code2, digest2) {
    return _CID.create(1, code2, digest2);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest2) : _CID.createV1(specs.codec, digest2);
    return [cid, bytes.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length3] = decode5(initialBytes.subarray(offset));
      offset += length3;
      return i2;
    };
    let version5 = next();
    let codec = DAG_PB_CODE;
    if (version5 === 18) {
      version5 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version5 !== 0 && version5 !== 1) {
      throw new RangeError(`Invalid CID version ${version5}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version5, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base4) {
    const [prefix, bytes] = parseCIDtoBytes(source, base4);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes(source, base4) {
  switch (source[0]) {
    case "Q": {
      const decoder = base4 ?? base58btc;
      return [
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base4 ?? base58btc;
      return [base58btc.prefix, decoder.decode(source)];
    }
    case base32.prefix: {
      const decoder = base4 ?? base32;
      return [base32.prefix, decoder.decode(source)];
    }
    case base36.prefix: {
      const decoder = base4 ?? base36;
      return [base36.prefix, decoder.decode(source)];
    }
    default: {
      if (base4 == null) {
        throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base4.decode(source)];
    }
  }
}
function toStringV0(bytes, cache3, base4) {
  const { prefix } = base4;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base4.name} encoding`);
  }
  const cid = cache3.get(prefix);
  if (cid == null) {
    const cid2 = base4.encode(bytes).slice(1);
    cache3.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV1(bytes, cache3, base4) {
  const { prefix } = base4;
  const cid = cache3.get(prefix);
  if (cid == null) {
    const cid2 = base4.encode(bytes);
    cache3.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
function encodeCID(version5, code2, multihash) {
  const codeOffset = encodingLength2(version5);
  const hashOffset = codeOffset + encodingLength2(code2);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version5, bytes, 0);
  encodeTo(code2, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
var cidSymbol = Symbol.for("@ipld/js-cid/CID");

// node_modules/multiformats/dist/src/basics.js
var bases = { ...identity_exports, ...base2_exports, ...base8_exports, ...base10_exports, ...base16_exports, ...base32_exports, ...base36_exports, ...base58_exports, ...base64_exports, ...base256emoji_exports };
var hashes = { ...sha2_browser_exports, ...identity_exports2 };

// node_modules/uint8arrays/dist/src/util/bases.js
function createCodec(name3, prefix, encode10, decode10) {
  return {
    name: name3,
    prefix,
    encoder: {
      name: name3,
      prefix,
      encode: encode10
    },
    decoder: {
      decode: decode10
    }
  };
}
var string = createCodec("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf) => {
  let string3 = "a";
  for (let i2 = 0; i2 < buf.length; i2++) {
    string3 += String.fromCharCode(buf[i2]);
  }
  return string3;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf[i2] = str.charCodeAt(i2);
  }
  return buf;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// node_modules/uint8arrays/dist/src/from-string.js
function fromString2(string3, encoding = "utf8") {
  const base4 = bases_default[encoding];
  if (base4 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base4.decoder.decode(`${base4.prefix}${string3}`);
}

// node_modules/protons-runtime/dist/src/utils/pool.js
function pool(size) {
  const SIZE = size ?? 8192;
  const MAX = SIZE >>> 1;
  let slab;
  let offset = SIZE;
  return function poolAlloc(size2) {
    if (size2 < 1 || size2 > MAX) {
      return allocUnsafe(size2);
    }
    if (offset + size2 > SIZE) {
      slab = allocUnsafe(SIZE);
      offset = 0;
    }
    const buf = slab.subarray(offset, offset += size2);
    if ((offset & 7) !== 0) {
      offset = (offset | 7) + 1;
    }
    return buf;
  };
}

// node_modules/protons-runtime/dist/src/utils/writer.js
var Op = class {
  constructor(fn, len, val) {
    /**
     * Function to call
     */
    __publicField(this, "fn");
    /**
     * Value byte length
     */
    __publicField(this, "len");
    /**
     * Next operation
     */
    __publicField(this, "next");
    /**
     * Value to write
     */
    __publicField(this, "val");
    this.fn = fn;
    this.len = len;
    this.next = void 0;
    this.val = val;
  }
};
function noop() {
}
var State = class {
  constructor(writer) {
    /**
     * Current head
     */
    __publicField(this, "head");
    /**
     * Current tail
     */
    __publicField(this, "tail");
    /**
     * Current buffer length
     */
    __publicField(this, "len");
    /**
     * Next state
     */
    __publicField(this, "next");
    this.head = writer.head;
    this.tail = writer.tail;
    this.len = writer.len;
    this.next = writer.states;
  }
};
var bufferPool = pool();
function alloc2(size) {
  if (globalThis.Buffer != null) {
    return allocUnsafe(size);
  }
  return bufferPool(size);
}
var Uint8ArrayWriter = class {
  constructor() {
    /**
     * Current length
     */
    __publicField(this, "len");
    /**
     * Operations head
     */
    __publicField(this, "head");
    /**
     * Operations tail
     */
    __publicField(this, "tail");
    /**
     * Linked forked states
     */
    __publicField(this, "states");
    this.len = 0;
    this.head = new Op(noop, 0, 0);
    this.tail = this.head;
    this.states = null;
  }
  /**
   * Pushes a new operation to the queue
   */
  _push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
  }
  /**
   * Writes an unsigned 32 bit value as a varint
   */
  uint32(value) {
    this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
    return this;
  }
  /**
   * Writes a signed 32 bit value as a varint`
   */
  int32(value) {
    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
  }
  /**
   * Writes a 32 bit value as a varint, zig-zag encoded
   */
  sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
  }
  /**
   * Writes an unsigned 64 bit value as a varint
   */
  uint64(value) {
    const bits = LongBits.fromBigInt(value);
    return this._push(writeVarint64, bits.length(), bits);
  }
  /**
   * Writes an unsigned 64 bit value as a varint
   */
  uint64Number(value) {
    return this._push(encodeUint8Array, encodingLength(value), value);
  }
  /**
   * Writes an unsigned 64 bit value as a varint
   */
  uint64String(value) {
    return this.uint64(BigInt(value));
  }
  /**
   * Writes a signed 64 bit value as a varint
   */
  int64(value) {
    return this.uint64(value);
  }
  /**
   * Writes a signed 64 bit value as a varint
   */
  int64Number(value) {
    return this.uint64Number(value);
  }
  /**
   * Writes a signed 64 bit value as a varint
   */
  int64String(value) {
    return this.uint64String(value);
  }
  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded
   */
  sint64(value) {
    const bits = LongBits.fromBigInt(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
  }
  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded
   */
  sint64Number(value) {
    const bits = LongBits.fromNumber(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
  }
  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded
   */
  sint64String(value) {
    return this.sint64(BigInt(value));
  }
  /**
   * Writes a boolish value as a varint
   */
  bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
  }
  /**
   * Writes an unsigned 32 bit value as fixed 32 bits
   */
  fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
  }
  /**
   * Writes a signed 32 bit value as fixed 32 bits
   */
  sfixed32(value) {
    return this.fixed32(value);
  }
  /**
   * Writes an unsigned 64 bit value as fixed 64 bits
   */
  fixed64(value) {
    const bits = LongBits.fromBigInt(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  }
  /**
   * Writes an unsigned 64 bit value as fixed 64 bits
   */
  fixed64Number(value) {
    const bits = LongBits.fromNumber(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  }
  /**
   * Writes an unsigned 64 bit value as fixed 64 bits
   */
  fixed64String(value) {
    return this.fixed64(BigInt(value));
  }
  /**
   * Writes a signed 64 bit value as fixed 64 bits
   */
  sfixed64(value) {
    return this.fixed64(value);
  }
  /**
   * Writes a signed 64 bit value as fixed 64 bits
   */
  sfixed64Number(value) {
    return this.fixed64Number(value);
  }
  /**
   * Writes a signed 64 bit value as fixed 64 bits
   */
  sfixed64String(value) {
    return this.fixed64String(value);
  }
  /**
   * Writes a float (32 bit)
   */
  float(value) {
    return this._push(writeFloatLE, 4, value);
  }
  /**
   * Writes a double (64 bit float).
   *
   * @function
   * @param {number} value - Value to write
   * @returns {Writer} `this`
   */
  double(value) {
    return this._push(writeDoubleLE, 8, value);
  }
  /**
   * Writes a sequence of bytes
   */
  bytes(value) {
    const len = value.length >>> 0;
    if (len === 0) {
      return this._push(writeByte, 1, 0);
    }
    return this.uint32(len)._push(writeBytes, len, value);
  }
  /**
   * Writes a string
   */
  string(value) {
    const len = length(value);
    return len !== 0 ? this.uint32(len)._push(write, len, value) : this._push(writeByte, 1, 0);
  }
  /**
   * Forks this writer's state by pushing it to a stack.
   * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
   */
  fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
  }
  /**
   * Resets this instance to the last state
   */
  reset() {
    if (this.states != null) {
      this.head = this.states.head;
      this.tail = this.states.tail;
      this.len = this.states.len;
      this.states = this.states.next;
    } else {
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
    }
    return this;
  }
  /**
   * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
   */
  ldelim() {
    const head = this.head;
    const tail = this.tail;
    const len = this.len;
    this.reset().uint32(len);
    if (len !== 0) {
      this.tail.next = head.next;
      this.tail = tail;
      this.len += len;
    }
    return this;
  }
  /**
   * Finishes the write operation
   */
  finish() {
    let head = this.head.next;
    const buf = alloc2(this.len);
    let pos = 0;
    while (head != null) {
      head.fn(head.val, buf, pos);
      pos += head.len;
      head = head.next;
    }
    return buf;
  }
};
function writeByte(val, buf, pos) {
  buf[pos] = val & 255;
}
function writeVarint32(val, buf, pos) {
  while (val > 127) {
    buf[pos++] = val & 127 | 128;
    val >>>= 7;
  }
  buf[pos] = val;
}
var VarintOp = class extends Op {
  constructor(len, val) {
    super(writeVarint32, len, val);
    __publicField(this, "next");
    this.next = void 0;
  }
};
function writeVarint64(val, buf, pos) {
  while (val.hi !== 0) {
    buf[pos++] = val.lo & 127 | 128;
    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
    val.hi >>>= 7;
  }
  while (val.lo > 127) {
    buf[pos++] = val.lo & 127 | 128;
    val.lo = val.lo >>> 7;
  }
  buf[pos++] = val.lo;
}
function writeFixed32(val, buf, pos) {
  buf[pos] = val & 255;
  buf[pos + 1] = val >>> 8 & 255;
  buf[pos + 2] = val >>> 16 & 255;
  buf[pos + 3] = val >>> 24;
}
function writeBytes(val, buf, pos) {
  buf.set(val, pos);
}
if (globalThis.Buffer != null) {
  Uint8ArrayWriter.prototype.bytes = function(value) {
    const len = value.length >>> 0;
    this.uint32(len);
    if (len > 0) {
      this._push(writeBytesBuffer, len, value);
    }
    return this;
  };
  Uint8ArrayWriter.prototype.string = function(value) {
    const len = globalThis.Buffer.byteLength(value);
    this.uint32(len);
    if (len > 0) {
      this._push(writeStringBuffer, len, value);
    }
    return this;
  };
}
function writeBytesBuffer(val, buf, pos) {
  buf.set(val, pos);
}
function writeStringBuffer(val, buf, pos) {
  if (val.length < 40) {
    write(val, buf, pos);
  } else if (buf.utf8Write != null) {
    buf.utf8Write(val, pos);
  } else {
    buf.set(fromString2(val), pos);
  }
}
function createWriter() {
  return new Uint8ArrayWriter();
}

// node_modules/protons-runtime/dist/src/encode.js
function encodeMessage(message2, codec) {
  const w = createWriter();
  codec.encode(message2, w, {
    lengthDelimited: false
  });
  return w.finish();
}

// node_modules/protons-runtime/dist/src/codec.js
var CODEC_TYPES;
(function(CODEC_TYPES2) {
  CODEC_TYPES2[CODEC_TYPES2["VARINT"] = 0] = "VARINT";
  CODEC_TYPES2[CODEC_TYPES2["BIT64"] = 1] = "BIT64";
  CODEC_TYPES2[CODEC_TYPES2["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
  CODEC_TYPES2[CODEC_TYPES2["START_GROUP"] = 3] = "START_GROUP";
  CODEC_TYPES2[CODEC_TYPES2["END_GROUP"] = 4] = "END_GROUP";
  CODEC_TYPES2[CODEC_TYPES2["BIT32"] = 5] = "BIT32";
})(CODEC_TYPES || (CODEC_TYPES = {}));
function createCodec2(name3, type, encode10, decode10) {
  return {
    name: name3,
    type,
    encode: encode10,
    decode: decode10
  };
}

// node_modules/protons-runtime/dist/src/codecs/enum.js
function enumeration(v) {
  function findValue(val) {
    if (v[val.toString()] == null) {
      throw new Error("Invalid enum value");
    }
    return v[val];
  }
  const encode10 = function enumEncode(val, writer) {
    const enumValue = findValue(val);
    writer.int32(enumValue);
  };
  const decode10 = function enumDecode(reader) {
    const val = reader.int32();
    return findValue(val);
  };
  return createCodec2("enum", CODEC_TYPES.VARINT, encode10, decode10);
}

// node_modules/protons-runtime/dist/src/codecs/message.js
function message(encode10, decode10) {
  return createCodec2("message", CODEC_TYPES.LENGTH_DELIMITED, encode10, decode10);
}

// node_modules/protons-runtime/dist/src/index.js
var MaxLengthError = class extends Error {
  constructor() {
    super(...arguments);
    /**
     * This will be removed in a future release
     *
     * @deprecated use the `.name` property instead
     */
    __publicField(this, "code", "ERR_MAX_LENGTH");
    __publicField(this, "name", "MaxLengthError");
  }
};
var MaxSizeError = class extends Error {
  constructor() {
    super(...arguments);
    /**
     * This will be removed in a future release
     *
     * @deprecated use the `.name` property instead
     */
    __publicField(this, "code", "ERR_MAX_SIZE");
    __publicField(this, "name", "MaxSizeError");
  }
};

// node_modules/@waku/proto/dist/generated/message.js
var RateLimitProof;
(function(RateLimitProof6) {
  let _codec;
  RateLimitProof6.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.proof != null && obj.proof.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.proof);
        }
        if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.merkleRoot);
        }
        if (obj.epoch != null && obj.epoch.byteLength > 0) {
          w.uint32(26);
          w.bytes(obj.epoch);
        }
        if (obj.shareX != null && obj.shareX.byteLength > 0) {
          w.uint32(34);
          w.bytes(obj.shareX);
        }
        if (obj.shareY != null && obj.shareY.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.shareY);
        }
        if (obj.nullifier != null && obj.nullifier.byteLength > 0) {
          w.uint32(50);
          w.bytes(obj.nullifier);
        }
        if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {
          w.uint32(58);
          w.bytes(obj.rlnIdentifier);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          proof: alloc(0),
          merkleRoot: alloc(0),
          epoch: alloc(0),
          shareX: alloc(0),
          shareY: alloc(0),
          nullifier: alloc(0),
          rlnIdentifier: alloc(0)
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.proof = reader.bytes();
              break;
            }
            case 2: {
              obj.merkleRoot = reader.bytes();
              break;
            }
            case 3: {
              obj.epoch = reader.bytes();
              break;
            }
            case 4: {
              obj.shareX = reader.bytes();
              break;
            }
            case 5: {
              obj.shareY = reader.bytes();
              break;
            }
            case 6: {
              obj.nullifier = reader.bytes();
              break;
            }
            case 7: {
              obj.rlnIdentifier = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  RateLimitProof6.encode = (obj) => {
    return encodeMessage(obj, RateLimitProof6.codec());
  };
  RateLimitProof6.decode = (buf, opts) => {
    return decodeMessage(buf, RateLimitProof6.codec(), opts);
  };
})(RateLimitProof || (RateLimitProof = {}));
var WakuMessage;
(function(WakuMessage6) {
  let _codec;
  WakuMessage6.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.payload != null && obj.payload.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.payload);
        }
        if (obj.contentTopic != null && obj.contentTopic !== "") {
          w.uint32(18);
          w.string(obj.contentTopic);
        }
        if (obj.version != null) {
          w.uint32(24);
          w.uint32(obj.version);
        }
        if (obj.timestamp != null) {
          w.uint32(80);
          w.sint64(obj.timestamp);
        }
        if (obj.meta != null) {
          w.uint32(90);
          w.bytes(obj.meta);
        }
        if (obj.rateLimitProof != null) {
          w.uint32(170);
          RateLimitProof.codec().encode(obj.rateLimitProof, w);
        }
        if (obj.ephemeral != null) {
          w.uint32(248);
          w.bool(obj.ephemeral);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27;
        const obj = {
          payload: alloc(0),
          contentTopic: ""
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.payload = reader.bytes();
              break;
            }
            case 2: {
              obj.contentTopic = reader.string();
              break;
            }
            case 3: {
              obj.version = reader.uint32();
              break;
            }
            case 10: {
              obj.timestamp = reader.sint64();
              break;
            }
            case 11: {
              obj.meta = reader.bytes();
              break;
            }
            case 21: {
              obj.rateLimitProof = RateLimitProof.codec().decode(reader, reader.uint32(), {
                limits: (_a27 = opts.limits) == null ? void 0 : _a27.rateLimitProof
              });
              break;
            }
            case 31: {
              obj.ephemeral = reader.bool();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  WakuMessage6.encode = (obj) => {
    return encodeMessage(obj, WakuMessage6.codec());
  };
  WakuMessage6.decode = (buf, opts) => {
    return decodeMessage(buf, WakuMessage6.codec(), opts);
  };
})(WakuMessage || (WakuMessage = {}));

// node_modules/@waku/proto/dist/generated/filter.js
var filter_exports = {};
__export(filter_exports, {
  FilterRequest: () => FilterRequest,
  FilterRpc: () => FilterRpc,
  MessagePush: () => MessagePush,
  RateLimitProof: () => RateLimitProof2,
  WakuMessage: () => WakuMessage2
});
var FilterRequest;
(function(FilterRequest2) {
  let ContentFilter;
  (function(ContentFilter2) {
    let _codec2;
    ContentFilter2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.contentTopic != null && obj.contentTopic !== "") {
            w.uint32(10);
            w.string(obj.contentTopic);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length3, opts = {}) => {
          const obj = {
            contentTopic: ""
          };
          const end = length3 == null ? reader.len : reader.pos + length3;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.contentTopic = reader.string();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    ContentFilter2.encode = (obj) => {
      return encodeMessage(obj, ContentFilter2.codec());
    };
    ContentFilter2.decode = (buf, opts) => {
      return decodeMessage(buf, ContentFilter2.codec(), opts);
    };
  })(ContentFilter = FilterRequest2.ContentFilter || (FilterRequest2.ContentFilter = {}));
  let _codec;
  FilterRequest2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.subscribe != null && obj.subscribe !== false) {
          w.uint32(8);
          w.bool(obj.subscribe);
        }
        if (obj.topic != null && obj.topic !== "") {
          w.uint32(18);
          w.string(obj.topic);
        }
        if (obj.contentFilters != null) {
          for (const value of obj.contentFilters) {
            w.uint32(26);
            FilterRequest2.ContentFilter.codec().encode(value, w);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27, _b14;
        const obj = {
          subscribe: false,
          topic: "",
          contentFilters: []
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.subscribe = reader.bool();
              break;
            }
            case 2: {
              obj.topic = reader.string();
              break;
            }
            case 3: {
              if (((_a27 = opts.limits) == null ? void 0 : _a27.contentFilters) != null && obj.contentFilters.length === opts.limits.contentFilters) {
                throw new MaxLengthError('Decode error - map field "contentFilters" had too many elements');
              }
              obj.contentFilters.push(FilterRequest2.ContentFilter.codec().decode(reader, reader.uint32(), {
                limits: (_b14 = opts.limits) == null ? void 0 : _b14.contentFilters$
              }));
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  FilterRequest2.encode = (obj) => {
    return encodeMessage(obj, FilterRequest2.codec());
  };
  FilterRequest2.decode = (buf, opts) => {
    return decodeMessage(buf, FilterRequest2.codec(), opts);
  };
})(FilterRequest || (FilterRequest = {}));
var MessagePush;
(function(MessagePush3) {
  let _codec;
  MessagePush3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.messages != null) {
          for (const value of obj.messages) {
            w.uint32(10);
            WakuMessage2.codec().encode(value, w);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27, _b14;
        const obj = {
          messages: []
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (((_a27 = opts.limits) == null ? void 0 : _a27.messages) != null && obj.messages.length === opts.limits.messages) {
                throw new MaxLengthError('Decode error - map field "messages" had too many elements');
              }
              obj.messages.push(WakuMessage2.codec().decode(reader, reader.uint32(), {
                limits: (_b14 = opts.limits) == null ? void 0 : _b14.messages$
              }));
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  MessagePush3.encode = (obj) => {
    return encodeMessage(obj, MessagePush3.codec());
  };
  MessagePush3.decode = (buf, opts) => {
    return decodeMessage(buf, MessagePush3.codec(), opts);
  };
})(MessagePush || (MessagePush = {}));
var FilterRpc;
(function(FilterRpc2) {
  let _codec;
  FilterRpc2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.requestId != null && obj.requestId !== "") {
          w.uint32(10);
          w.string(obj.requestId);
        }
        if (obj.request != null) {
          w.uint32(18);
          FilterRequest.codec().encode(obj.request, w);
        }
        if (obj.push != null) {
          w.uint32(26);
          MessagePush.codec().encode(obj.push, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27, _b14;
        const obj = {
          requestId: ""
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.requestId = reader.string();
              break;
            }
            case 2: {
              obj.request = FilterRequest.codec().decode(reader, reader.uint32(), {
                limits: (_a27 = opts.limits) == null ? void 0 : _a27.request
              });
              break;
            }
            case 3: {
              obj.push = MessagePush.codec().decode(reader, reader.uint32(), {
                limits: (_b14 = opts.limits) == null ? void 0 : _b14.push
              });
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  FilterRpc2.encode = (obj) => {
    return encodeMessage(obj, FilterRpc2.codec());
  };
  FilterRpc2.decode = (buf, opts) => {
    return decodeMessage(buf, FilterRpc2.codec(), opts);
  };
})(FilterRpc || (FilterRpc = {}));
var RateLimitProof2;
(function(RateLimitProof6) {
  let _codec;
  RateLimitProof6.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.proof != null && obj.proof.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.proof);
        }
        if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.merkleRoot);
        }
        if (obj.epoch != null && obj.epoch.byteLength > 0) {
          w.uint32(26);
          w.bytes(obj.epoch);
        }
        if (obj.shareX != null && obj.shareX.byteLength > 0) {
          w.uint32(34);
          w.bytes(obj.shareX);
        }
        if (obj.shareY != null && obj.shareY.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.shareY);
        }
        if (obj.nullifier != null && obj.nullifier.byteLength > 0) {
          w.uint32(50);
          w.bytes(obj.nullifier);
        }
        if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {
          w.uint32(58);
          w.bytes(obj.rlnIdentifier);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          proof: alloc(0),
          merkleRoot: alloc(0),
          epoch: alloc(0),
          shareX: alloc(0),
          shareY: alloc(0),
          nullifier: alloc(0),
          rlnIdentifier: alloc(0)
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.proof = reader.bytes();
              break;
            }
            case 2: {
              obj.merkleRoot = reader.bytes();
              break;
            }
            case 3: {
              obj.epoch = reader.bytes();
              break;
            }
            case 4: {
              obj.shareX = reader.bytes();
              break;
            }
            case 5: {
              obj.shareY = reader.bytes();
              break;
            }
            case 6: {
              obj.nullifier = reader.bytes();
              break;
            }
            case 7: {
              obj.rlnIdentifier = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  RateLimitProof6.encode = (obj) => {
    return encodeMessage(obj, RateLimitProof6.codec());
  };
  RateLimitProof6.decode = (buf, opts) => {
    return decodeMessage(buf, RateLimitProof6.codec(), opts);
  };
})(RateLimitProof2 || (RateLimitProof2 = {}));
var WakuMessage2;
(function(WakuMessage6) {
  let _codec;
  WakuMessage6.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.payload != null && obj.payload.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.payload);
        }
        if (obj.contentTopic != null && obj.contentTopic !== "") {
          w.uint32(18);
          w.string(obj.contentTopic);
        }
        if (obj.version != null) {
          w.uint32(24);
          w.uint32(obj.version);
        }
        if (obj.timestamp != null) {
          w.uint32(80);
          w.sint64(obj.timestamp);
        }
        if (obj.meta != null) {
          w.uint32(90);
          w.bytes(obj.meta);
        }
        if (obj.rateLimitProof != null) {
          w.uint32(170);
          RateLimitProof2.codec().encode(obj.rateLimitProof, w);
        }
        if (obj.ephemeral != null) {
          w.uint32(248);
          w.bool(obj.ephemeral);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27;
        const obj = {
          payload: alloc(0),
          contentTopic: ""
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.payload = reader.bytes();
              break;
            }
            case 2: {
              obj.contentTopic = reader.string();
              break;
            }
            case 3: {
              obj.version = reader.uint32();
              break;
            }
            case 10: {
              obj.timestamp = reader.sint64();
              break;
            }
            case 11: {
              obj.meta = reader.bytes();
              break;
            }
            case 21: {
              obj.rateLimitProof = RateLimitProof2.codec().decode(reader, reader.uint32(), {
                limits: (_a27 = opts.limits) == null ? void 0 : _a27.rateLimitProof
              });
              break;
            }
            case 31: {
              obj.ephemeral = reader.bool();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  WakuMessage6.encode = (obj) => {
    return encodeMessage(obj, WakuMessage6.codec());
  };
  WakuMessage6.decode = (buf, opts) => {
    return decodeMessage(buf, WakuMessage6.codec(), opts);
  };
})(WakuMessage2 || (WakuMessage2 = {}));

// node_modules/@waku/proto/dist/generated/topic_only_message.js
var topic_only_message_exports = {};
__export(topic_only_message_exports, {
  TopicOnlyMessage: () => TopicOnlyMessage
});
var TopicOnlyMessage;
(function(TopicOnlyMessage2) {
  let _codec;
  TopicOnlyMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.contentTopic != null && obj.contentTopic !== "") {
          w.uint32(18);
          w.string(obj.contentTopic);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          contentTopic: ""
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2: {
              obj.contentTopic = reader.string();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  TopicOnlyMessage2.encode = (obj) => {
    return encodeMessage(obj, TopicOnlyMessage2.codec());
  };
  TopicOnlyMessage2.decode = (buf, opts) => {
    return decodeMessage(buf, TopicOnlyMessage2.codec(), opts);
  };
})(TopicOnlyMessage || (TopicOnlyMessage = {}));

// node_modules/@waku/proto/dist/generated/filter_v2.js
var filter_v2_exports = {};
__export(filter_v2_exports, {
  FilterSubscribeRequest: () => FilterSubscribeRequest,
  FilterSubscribeResponse: () => FilterSubscribeResponse,
  MessagePush: () => MessagePush2,
  RateLimitProof: () => RateLimitProof3,
  WakuMessage: () => WakuMessage3
});
var FilterSubscribeRequest;
(function(FilterSubscribeRequest2) {
  let FilterSubscribeType;
  (function(FilterSubscribeType2) {
    FilterSubscribeType2["SUBSCRIBER_PING"] = "SUBSCRIBER_PING";
    FilterSubscribeType2["SUBSCRIBE"] = "SUBSCRIBE";
    FilterSubscribeType2["UNSUBSCRIBE"] = "UNSUBSCRIBE";
    FilterSubscribeType2["UNSUBSCRIBE_ALL"] = "UNSUBSCRIBE_ALL";
  })(FilterSubscribeType = FilterSubscribeRequest2.FilterSubscribeType || (FilterSubscribeRequest2.FilterSubscribeType = {}));
  let __FilterSubscribeTypeValues;
  (function(__FilterSubscribeTypeValues2) {
    __FilterSubscribeTypeValues2[__FilterSubscribeTypeValues2["SUBSCRIBER_PING"] = 0] = "SUBSCRIBER_PING";
    __FilterSubscribeTypeValues2[__FilterSubscribeTypeValues2["SUBSCRIBE"] = 1] = "SUBSCRIBE";
    __FilterSubscribeTypeValues2[__FilterSubscribeTypeValues2["UNSUBSCRIBE"] = 2] = "UNSUBSCRIBE";
    __FilterSubscribeTypeValues2[__FilterSubscribeTypeValues2["UNSUBSCRIBE_ALL"] = 3] = "UNSUBSCRIBE_ALL";
  })(__FilterSubscribeTypeValues || (__FilterSubscribeTypeValues = {}));
  (function(FilterSubscribeType2) {
    FilterSubscribeType2.codec = () => {
      return enumeration(__FilterSubscribeTypeValues);
    };
  })(FilterSubscribeType = FilterSubscribeRequest2.FilterSubscribeType || (FilterSubscribeRequest2.FilterSubscribeType = {}));
  let _codec;
  FilterSubscribeRequest2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.requestId != null && obj.requestId !== "") {
          w.uint32(10);
          w.string(obj.requestId);
        }
        if (obj.filterSubscribeType != null && __FilterSubscribeTypeValues[obj.filterSubscribeType] !== 0) {
          w.uint32(16);
          FilterSubscribeRequest2.FilterSubscribeType.codec().encode(obj.filterSubscribeType, w);
        }
        if (obj.pubsubTopic != null) {
          w.uint32(82);
          w.string(obj.pubsubTopic);
        }
        if (obj.contentTopics != null) {
          for (const value of obj.contentTopics) {
            w.uint32(90);
            w.string(value);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27;
        const obj = {
          requestId: "",
          filterSubscribeType: FilterSubscribeType.SUBSCRIBER_PING,
          contentTopics: []
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.requestId = reader.string();
              break;
            }
            case 2: {
              obj.filterSubscribeType = FilterSubscribeRequest2.FilterSubscribeType.codec().decode(reader);
              break;
            }
            case 10: {
              obj.pubsubTopic = reader.string();
              break;
            }
            case 11: {
              if (((_a27 = opts.limits) == null ? void 0 : _a27.contentTopics) != null && obj.contentTopics.length === opts.limits.contentTopics) {
                throw new MaxLengthError('Decode error - map field "contentTopics" had too many elements');
              }
              obj.contentTopics.push(reader.string());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  FilterSubscribeRequest2.encode = (obj) => {
    return encodeMessage(obj, FilterSubscribeRequest2.codec());
  };
  FilterSubscribeRequest2.decode = (buf, opts) => {
    return decodeMessage(buf, FilterSubscribeRequest2.codec(), opts);
  };
})(FilterSubscribeRequest || (FilterSubscribeRequest = {}));
var FilterSubscribeResponse;
(function(FilterSubscribeResponse3) {
  let _codec;
  FilterSubscribeResponse3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.requestId != null && obj.requestId !== "") {
          w.uint32(10);
          w.string(obj.requestId);
        }
        if (obj.statusCode != null && obj.statusCode !== 0) {
          w.uint32(80);
          w.uint32(obj.statusCode);
        }
        if (obj.statusDesc != null) {
          w.uint32(90);
          w.string(obj.statusDesc);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          requestId: "",
          statusCode: 0
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.requestId = reader.string();
              break;
            }
            case 10: {
              obj.statusCode = reader.uint32();
              break;
            }
            case 11: {
              obj.statusDesc = reader.string();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  FilterSubscribeResponse3.encode = (obj) => {
    return encodeMessage(obj, FilterSubscribeResponse3.codec());
  };
  FilterSubscribeResponse3.decode = (buf, opts) => {
    return decodeMessage(buf, FilterSubscribeResponse3.codec(), opts);
  };
})(FilterSubscribeResponse || (FilterSubscribeResponse = {}));
var MessagePush2;
(function(MessagePush3) {
  let _codec;
  MessagePush3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.wakuMessage != null) {
          w.uint32(10);
          WakuMessage3.codec().encode(obj.wakuMessage, w);
        }
        if (obj.pubsubTopic != null) {
          w.uint32(18);
          w.string(obj.pubsubTopic);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27;
        const obj = {};
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.wakuMessage = WakuMessage3.codec().decode(reader, reader.uint32(), {
                limits: (_a27 = opts.limits) == null ? void 0 : _a27.wakuMessage
              });
              break;
            }
            case 2: {
              obj.pubsubTopic = reader.string();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  MessagePush3.encode = (obj) => {
    return encodeMessage(obj, MessagePush3.codec());
  };
  MessagePush3.decode = (buf, opts) => {
    return decodeMessage(buf, MessagePush3.codec(), opts);
  };
})(MessagePush2 || (MessagePush2 = {}));
var RateLimitProof3;
(function(RateLimitProof6) {
  let _codec;
  RateLimitProof6.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.proof != null && obj.proof.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.proof);
        }
        if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.merkleRoot);
        }
        if (obj.epoch != null && obj.epoch.byteLength > 0) {
          w.uint32(26);
          w.bytes(obj.epoch);
        }
        if (obj.shareX != null && obj.shareX.byteLength > 0) {
          w.uint32(34);
          w.bytes(obj.shareX);
        }
        if (obj.shareY != null && obj.shareY.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.shareY);
        }
        if (obj.nullifier != null && obj.nullifier.byteLength > 0) {
          w.uint32(50);
          w.bytes(obj.nullifier);
        }
        if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {
          w.uint32(58);
          w.bytes(obj.rlnIdentifier);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          proof: alloc(0),
          merkleRoot: alloc(0),
          epoch: alloc(0),
          shareX: alloc(0),
          shareY: alloc(0),
          nullifier: alloc(0),
          rlnIdentifier: alloc(0)
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.proof = reader.bytes();
              break;
            }
            case 2: {
              obj.merkleRoot = reader.bytes();
              break;
            }
            case 3: {
              obj.epoch = reader.bytes();
              break;
            }
            case 4: {
              obj.shareX = reader.bytes();
              break;
            }
            case 5: {
              obj.shareY = reader.bytes();
              break;
            }
            case 6: {
              obj.nullifier = reader.bytes();
              break;
            }
            case 7: {
              obj.rlnIdentifier = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  RateLimitProof6.encode = (obj) => {
    return encodeMessage(obj, RateLimitProof6.codec());
  };
  RateLimitProof6.decode = (buf, opts) => {
    return decodeMessage(buf, RateLimitProof6.codec(), opts);
  };
})(RateLimitProof3 || (RateLimitProof3 = {}));
var WakuMessage3;
(function(WakuMessage6) {
  let _codec;
  WakuMessage6.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.payload != null && obj.payload.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.payload);
        }
        if (obj.contentTopic != null && obj.contentTopic !== "") {
          w.uint32(18);
          w.string(obj.contentTopic);
        }
        if (obj.version != null) {
          w.uint32(24);
          w.uint32(obj.version);
        }
        if (obj.timestamp != null) {
          w.uint32(80);
          w.sint64(obj.timestamp);
        }
        if (obj.meta != null) {
          w.uint32(90);
          w.bytes(obj.meta);
        }
        if (obj.rateLimitProof != null) {
          w.uint32(170);
          RateLimitProof3.codec().encode(obj.rateLimitProof, w);
        }
        if (obj.ephemeral != null) {
          w.uint32(248);
          w.bool(obj.ephemeral);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27;
        const obj = {
          payload: alloc(0),
          contentTopic: ""
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.payload = reader.bytes();
              break;
            }
            case 2: {
              obj.contentTopic = reader.string();
              break;
            }
            case 3: {
              obj.version = reader.uint32();
              break;
            }
            case 10: {
              obj.timestamp = reader.sint64();
              break;
            }
            case 11: {
              obj.meta = reader.bytes();
              break;
            }
            case 21: {
              obj.rateLimitProof = RateLimitProof3.codec().decode(reader, reader.uint32(), {
                limits: (_a27 = opts.limits) == null ? void 0 : _a27.rateLimitProof
              });
              break;
            }
            case 31: {
              obj.ephemeral = reader.bool();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  WakuMessage6.encode = (obj) => {
    return encodeMessage(obj, WakuMessage6.codec());
  };
  WakuMessage6.decode = (buf, opts) => {
    return decodeMessage(buf, WakuMessage6.codec(), opts);
  };
})(WakuMessage3 || (WakuMessage3 = {}));

// node_modules/@waku/proto/dist/generated/light_push.js
var light_push_exports = {};
__export(light_push_exports, {
  LightPushRequestV3: () => LightPushRequestV3,
  LightPushResponseV3: () => LightPushResponseV3,
  PushRequest: () => PushRequest,
  PushResponse: () => PushResponse,
  PushRpc: () => PushRpc,
  RateLimitProof: () => RateLimitProof4,
  WakuMessage: () => WakuMessage4
});
var PushRequest;
(function(PushRequest2) {
  let _codec;
  PushRequest2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.pubsubTopic != null && obj.pubsubTopic !== "") {
          w.uint32(10);
          w.string(obj.pubsubTopic);
        }
        if (obj.message != null) {
          w.uint32(18);
          WakuMessage4.codec().encode(obj.message, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27;
        const obj = {
          pubsubTopic: ""
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.pubsubTopic = reader.string();
              break;
            }
            case 2: {
              obj.message = WakuMessage4.codec().decode(reader, reader.uint32(), {
                limits: (_a27 = opts.limits) == null ? void 0 : _a27.message
              });
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PushRequest2.encode = (obj) => {
    return encodeMessage(obj, PushRequest2.codec());
  };
  PushRequest2.decode = (buf, opts) => {
    return decodeMessage(buf, PushRequest2.codec(), opts);
  };
})(PushRequest || (PushRequest = {}));
var PushResponse;
(function(PushResponse2) {
  let _codec;
  PushResponse2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.isSuccess != null && obj.isSuccess !== false) {
          w.uint32(8);
          w.bool(obj.isSuccess);
        }
        if (obj.info != null) {
          w.uint32(18);
          w.string(obj.info);
        }
        if (obj.statusCode != null) {
          w.uint32(80);
          w.uint32(obj.statusCode);
        }
        if (obj.statusDesc != null) {
          w.uint32(90);
          w.string(obj.statusDesc);
        }
        if (obj.relayPeerCount != null) {
          w.uint32(96);
          w.uint32(obj.relayPeerCount);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          isSuccess: false
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.isSuccess = reader.bool();
              break;
            }
            case 2: {
              obj.info = reader.string();
              break;
            }
            case 10: {
              obj.statusCode = reader.uint32();
              break;
            }
            case 11: {
              obj.statusDesc = reader.string();
              break;
            }
            case 12: {
              obj.relayPeerCount = reader.uint32();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PushResponse2.encode = (obj) => {
    return encodeMessage(obj, PushResponse2.codec());
  };
  PushResponse2.decode = (buf, opts) => {
    return decodeMessage(buf, PushResponse2.codec(), opts);
  };
})(PushResponse || (PushResponse = {}));
var PushRpc;
(function(PushRpc3) {
  let _codec;
  PushRpc3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.requestId != null && obj.requestId !== "") {
          w.uint32(10);
          w.string(obj.requestId);
        }
        if (obj.request != null) {
          w.uint32(18);
          PushRequest.codec().encode(obj.request, w);
        }
        if (obj.response != null) {
          w.uint32(26);
          PushResponse.codec().encode(obj.response, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27, _b14;
        const obj = {
          requestId: ""
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.requestId = reader.string();
              break;
            }
            case 2: {
              obj.request = PushRequest.codec().decode(reader, reader.uint32(), {
                limits: (_a27 = opts.limits) == null ? void 0 : _a27.request
              });
              break;
            }
            case 3: {
              obj.response = PushResponse.codec().decode(reader, reader.uint32(), {
                limits: (_b14 = opts.limits) == null ? void 0 : _b14.response
              });
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PushRpc3.encode = (obj) => {
    return encodeMessage(obj, PushRpc3.codec());
  };
  PushRpc3.decode = (buf, opts) => {
    return decodeMessage(buf, PushRpc3.codec(), opts);
  };
})(PushRpc || (PushRpc = {}));
var LightPushRequestV3;
(function(LightPushRequestV32) {
  let _codec;
  LightPushRequestV32.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.requestId != null && obj.requestId !== "") {
          w.uint32(10);
          w.string(obj.requestId);
        }
        if (obj.pubsubTopic != null) {
          w.uint32(162);
          w.string(obj.pubsubTopic);
        }
        if (obj.message != null) {
          w.uint32(170);
          WakuMessage4.codec().encode(obj.message, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27;
        const obj = {
          requestId: ""
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.requestId = reader.string();
              break;
            }
            case 20: {
              obj.pubsubTopic = reader.string();
              break;
            }
            case 21: {
              obj.message = WakuMessage4.codec().decode(reader, reader.uint32(), {
                limits: (_a27 = opts.limits) == null ? void 0 : _a27.message
              });
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  LightPushRequestV32.encode = (obj) => {
    return encodeMessage(obj, LightPushRequestV32.codec());
  };
  LightPushRequestV32.decode = (buf, opts) => {
    return decodeMessage(buf, LightPushRequestV32.codec(), opts);
  };
})(LightPushRequestV3 || (LightPushRequestV3 = {}));
var LightPushResponseV3;
(function(LightPushResponseV32) {
  let _codec;
  LightPushResponseV32.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.requestId != null && obj.requestId !== "") {
          w.uint32(10);
          w.string(obj.requestId);
        }
        if (obj.statusCode != null && obj.statusCode !== 0) {
          w.uint32(80);
          w.uint32(obj.statusCode);
        }
        if (obj.statusDesc != null) {
          w.uint32(90);
          w.string(obj.statusDesc);
        }
        if (obj.relayPeerCount != null) {
          w.uint32(96);
          w.uint32(obj.relayPeerCount);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          requestId: "",
          statusCode: 0
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.requestId = reader.string();
              break;
            }
            case 10: {
              obj.statusCode = reader.uint32();
              break;
            }
            case 11: {
              obj.statusDesc = reader.string();
              break;
            }
            case 12: {
              obj.relayPeerCount = reader.uint32();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  LightPushResponseV32.encode = (obj) => {
    return encodeMessage(obj, LightPushResponseV32.codec());
  };
  LightPushResponseV32.decode = (buf, opts) => {
    return decodeMessage(buf, LightPushResponseV32.codec(), opts);
  };
})(LightPushResponseV3 || (LightPushResponseV3 = {}));
var RateLimitProof4;
(function(RateLimitProof6) {
  let _codec;
  RateLimitProof6.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.proof != null && obj.proof.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.proof);
        }
        if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.merkleRoot);
        }
        if (obj.epoch != null && obj.epoch.byteLength > 0) {
          w.uint32(26);
          w.bytes(obj.epoch);
        }
        if (obj.shareX != null && obj.shareX.byteLength > 0) {
          w.uint32(34);
          w.bytes(obj.shareX);
        }
        if (obj.shareY != null && obj.shareY.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.shareY);
        }
        if (obj.nullifier != null && obj.nullifier.byteLength > 0) {
          w.uint32(50);
          w.bytes(obj.nullifier);
        }
        if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {
          w.uint32(58);
          w.bytes(obj.rlnIdentifier);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          proof: alloc(0),
          merkleRoot: alloc(0),
          epoch: alloc(0),
          shareX: alloc(0),
          shareY: alloc(0),
          nullifier: alloc(0),
          rlnIdentifier: alloc(0)
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.proof = reader.bytes();
              break;
            }
            case 2: {
              obj.merkleRoot = reader.bytes();
              break;
            }
            case 3: {
              obj.epoch = reader.bytes();
              break;
            }
            case 4: {
              obj.shareX = reader.bytes();
              break;
            }
            case 5: {
              obj.shareY = reader.bytes();
              break;
            }
            case 6: {
              obj.nullifier = reader.bytes();
              break;
            }
            case 7: {
              obj.rlnIdentifier = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  RateLimitProof6.encode = (obj) => {
    return encodeMessage(obj, RateLimitProof6.codec());
  };
  RateLimitProof6.decode = (buf, opts) => {
    return decodeMessage(buf, RateLimitProof6.codec(), opts);
  };
})(RateLimitProof4 || (RateLimitProof4 = {}));
var WakuMessage4;
(function(WakuMessage6) {
  let _codec;
  WakuMessage6.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.payload != null && obj.payload.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.payload);
        }
        if (obj.contentTopic != null && obj.contentTopic !== "") {
          w.uint32(18);
          w.string(obj.contentTopic);
        }
        if (obj.version != null) {
          w.uint32(24);
          w.uint32(obj.version);
        }
        if (obj.timestamp != null) {
          w.uint32(80);
          w.sint64(obj.timestamp);
        }
        if (obj.meta != null) {
          w.uint32(90);
          w.bytes(obj.meta);
        }
        if (obj.rateLimitProof != null) {
          w.uint32(170);
          RateLimitProof4.codec().encode(obj.rateLimitProof, w);
        }
        if (obj.ephemeral != null) {
          w.uint32(248);
          w.bool(obj.ephemeral);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27;
        const obj = {
          payload: alloc(0),
          contentTopic: ""
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.payload = reader.bytes();
              break;
            }
            case 2: {
              obj.contentTopic = reader.string();
              break;
            }
            case 3: {
              obj.version = reader.uint32();
              break;
            }
            case 10: {
              obj.timestamp = reader.sint64();
              break;
            }
            case 11: {
              obj.meta = reader.bytes();
              break;
            }
            case 21: {
              obj.rateLimitProof = RateLimitProof4.codec().decode(reader, reader.uint32(), {
                limits: (_a27 = opts.limits) == null ? void 0 : _a27.rateLimitProof
              });
              break;
            }
            case 31: {
              obj.ephemeral = reader.bool();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  WakuMessage6.encode = (obj) => {
    return encodeMessage(obj, WakuMessage6.codec());
  };
  WakuMessage6.decode = (buf, opts) => {
    return decodeMessage(buf, WakuMessage6.codec(), opts);
  };
})(WakuMessage4 || (WakuMessage4 = {}));

// node_modules/@waku/proto/dist/generated/store_v3.js
var store_v3_exports = {};
__export(store_v3_exports, {
  RateLimitProof: () => RateLimitProof5,
  StoreQueryRequest: () => StoreQueryRequest,
  StoreQueryResponse: () => StoreQueryResponse,
  WakuMessage: () => WakuMessage5,
  WakuMessageKeyValue: () => WakuMessageKeyValue
});
var WakuMessageKeyValue;
(function(WakuMessageKeyValue2) {
  let _codec;
  WakuMessageKeyValue2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.messageHash != null) {
          w.uint32(10);
          w.bytes(obj.messageHash);
        }
        if (obj.message != null) {
          w.uint32(18);
          WakuMessage5.codec().encode(obj.message, w);
        }
        if (obj.pubsubTopic != null) {
          w.uint32(26);
          w.string(obj.pubsubTopic);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27;
        const obj = {};
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.messageHash = reader.bytes();
              break;
            }
            case 2: {
              obj.message = WakuMessage5.codec().decode(reader, reader.uint32(), {
                limits: (_a27 = opts.limits) == null ? void 0 : _a27.message
              });
              break;
            }
            case 3: {
              obj.pubsubTopic = reader.string();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  WakuMessageKeyValue2.encode = (obj) => {
    return encodeMessage(obj, WakuMessageKeyValue2.codec());
  };
  WakuMessageKeyValue2.decode = (buf, opts) => {
    return decodeMessage(buf, WakuMessageKeyValue2.codec(), opts);
  };
})(WakuMessageKeyValue || (WakuMessageKeyValue = {}));
var StoreQueryRequest;
(function(StoreQueryRequest3) {
  let _codec;
  StoreQueryRequest3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.requestId != null && obj.requestId !== "") {
          w.uint32(10);
          w.string(obj.requestId);
        }
        if (obj.includeData != null && obj.includeData !== false) {
          w.uint32(16);
          w.bool(obj.includeData);
        }
        if (obj.pubsubTopic != null) {
          w.uint32(82);
          w.string(obj.pubsubTopic);
        }
        if (obj.contentTopics != null) {
          for (const value of obj.contentTopics) {
            w.uint32(90);
            w.string(value);
          }
        }
        if (obj.timeStart != null) {
          w.uint32(96);
          w.sint64(obj.timeStart);
        }
        if (obj.timeEnd != null) {
          w.uint32(104);
          w.sint64(obj.timeEnd);
        }
        if (obj.messageHashes != null) {
          for (const value of obj.messageHashes) {
            w.uint32(162);
            w.bytes(value);
          }
        }
        if (obj.paginationCursor != null) {
          w.uint32(410);
          w.bytes(obj.paginationCursor);
        }
        if (obj.paginationForward != null && obj.paginationForward !== false) {
          w.uint32(416);
          w.bool(obj.paginationForward);
        }
        if (obj.paginationLimit != null) {
          w.uint32(424);
          w.uint64(obj.paginationLimit);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27, _b14;
        const obj = {
          requestId: "",
          includeData: false,
          contentTopics: [],
          messageHashes: [],
          paginationForward: false
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.requestId = reader.string();
              break;
            }
            case 2: {
              obj.includeData = reader.bool();
              break;
            }
            case 10: {
              obj.pubsubTopic = reader.string();
              break;
            }
            case 11: {
              if (((_a27 = opts.limits) == null ? void 0 : _a27.contentTopics) != null && obj.contentTopics.length === opts.limits.contentTopics) {
                throw new MaxLengthError('Decode error - map field "contentTopics" had too many elements');
              }
              obj.contentTopics.push(reader.string());
              break;
            }
            case 12: {
              obj.timeStart = reader.sint64();
              break;
            }
            case 13: {
              obj.timeEnd = reader.sint64();
              break;
            }
            case 20: {
              if (((_b14 = opts.limits) == null ? void 0 : _b14.messageHashes) != null && obj.messageHashes.length === opts.limits.messageHashes) {
                throw new MaxLengthError('Decode error - map field "messageHashes" had too many elements');
              }
              obj.messageHashes.push(reader.bytes());
              break;
            }
            case 51: {
              obj.paginationCursor = reader.bytes();
              break;
            }
            case 52: {
              obj.paginationForward = reader.bool();
              break;
            }
            case 53: {
              obj.paginationLimit = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  StoreQueryRequest3.encode = (obj) => {
    return encodeMessage(obj, StoreQueryRequest3.codec());
  };
  StoreQueryRequest3.decode = (buf, opts) => {
    return decodeMessage(buf, StoreQueryRequest3.codec(), opts);
  };
})(StoreQueryRequest || (StoreQueryRequest = {}));
var StoreQueryResponse;
(function(StoreQueryResponse3) {
  let _codec;
  StoreQueryResponse3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.requestId != null && obj.requestId !== "") {
          w.uint32(10);
          w.string(obj.requestId);
        }
        if (obj.statusCode != null) {
          w.uint32(80);
          w.uint32(obj.statusCode);
        }
        if (obj.statusDesc != null) {
          w.uint32(90);
          w.string(obj.statusDesc);
        }
        if (obj.messages != null) {
          for (const value of obj.messages) {
            w.uint32(162);
            WakuMessageKeyValue.codec().encode(value, w);
          }
        }
        if (obj.paginationCursor != null) {
          w.uint32(410);
          w.bytes(obj.paginationCursor);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27, _b14;
        const obj = {
          requestId: "",
          messages: []
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.requestId = reader.string();
              break;
            }
            case 10: {
              obj.statusCode = reader.uint32();
              break;
            }
            case 11: {
              obj.statusDesc = reader.string();
              break;
            }
            case 20: {
              if (((_a27 = opts.limits) == null ? void 0 : _a27.messages) != null && obj.messages.length === opts.limits.messages) {
                throw new MaxLengthError('Decode error - map field "messages" had too many elements');
              }
              obj.messages.push(WakuMessageKeyValue.codec().decode(reader, reader.uint32(), {
                limits: (_b14 = opts.limits) == null ? void 0 : _b14.messages$
              }));
              break;
            }
            case 51: {
              obj.paginationCursor = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  StoreQueryResponse3.encode = (obj) => {
    return encodeMessage(obj, StoreQueryResponse3.codec());
  };
  StoreQueryResponse3.decode = (buf, opts) => {
    return decodeMessage(buf, StoreQueryResponse3.codec(), opts);
  };
})(StoreQueryResponse || (StoreQueryResponse = {}));
var RateLimitProof5;
(function(RateLimitProof6) {
  let _codec;
  RateLimitProof6.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.proof != null && obj.proof.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.proof);
        }
        if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.merkleRoot);
        }
        if (obj.epoch != null && obj.epoch.byteLength > 0) {
          w.uint32(26);
          w.bytes(obj.epoch);
        }
        if (obj.shareX != null && obj.shareX.byteLength > 0) {
          w.uint32(34);
          w.bytes(obj.shareX);
        }
        if (obj.shareY != null && obj.shareY.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.shareY);
        }
        if (obj.nullifier != null && obj.nullifier.byteLength > 0) {
          w.uint32(50);
          w.bytes(obj.nullifier);
        }
        if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {
          w.uint32(58);
          w.bytes(obj.rlnIdentifier);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          proof: alloc(0),
          merkleRoot: alloc(0),
          epoch: alloc(0),
          shareX: alloc(0),
          shareY: alloc(0),
          nullifier: alloc(0),
          rlnIdentifier: alloc(0)
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.proof = reader.bytes();
              break;
            }
            case 2: {
              obj.merkleRoot = reader.bytes();
              break;
            }
            case 3: {
              obj.epoch = reader.bytes();
              break;
            }
            case 4: {
              obj.shareX = reader.bytes();
              break;
            }
            case 5: {
              obj.shareY = reader.bytes();
              break;
            }
            case 6: {
              obj.nullifier = reader.bytes();
              break;
            }
            case 7: {
              obj.rlnIdentifier = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  RateLimitProof6.encode = (obj) => {
    return encodeMessage(obj, RateLimitProof6.codec());
  };
  RateLimitProof6.decode = (buf, opts) => {
    return decodeMessage(buf, RateLimitProof6.codec(), opts);
  };
})(RateLimitProof5 || (RateLimitProof5 = {}));
var WakuMessage5;
(function(WakuMessage6) {
  let _codec;
  WakuMessage6.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.payload != null && obj.payload.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.payload);
        }
        if (obj.contentTopic != null && obj.contentTopic !== "") {
          w.uint32(18);
          w.string(obj.contentTopic);
        }
        if (obj.version != null) {
          w.uint32(24);
          w.uint32(obj.version);
        }
        if (obj.timestamp != null) {
          w.uint32(80);
          w.sint64(obj.timestamp);
        }
        if (obj.meta != null) {
          w.uint32(90);
          w.bytes(obj.meta);
        }
        if (obj.rateLimitProof != null) {
          w.uint32(170);
          RateLimitProof5.codec().encode(obj.rateLimitProof, w);
        }
        if (obj.ephemeral != null) {
          w.uint32(248);
          w.bool(obj.ephemeral);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27;
        const obj = {
          payload: alloc(0),
          contentTopic: ""
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.payload = reader.bytes();
              break;
            }
            case 2: {
              obj.contentTopic = reader.string();
              break;
            }
            case 3: {
              obj.version = reader.uint32();
              break;
            }
            case 10: {
              obj.timestamp = reader.sint64();
              break;
            }
            case 11: {
              obj.meta = reader.bytes();
              break;
            }
            case 21: {
              obj.rateLimitProof = RateLimitProof5.codec().decode(reader, reader.uint32(), {
                limits: (_a27 = opts.limits) == null ? void 0 : _a27.rateLimitProof
              });
              break;
            }
            case 31: {
              obj.ephemeral = reader.bool();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  WakuMessage6.encode = (obj) => {
    return encodeMessage(obj, WakuMessage6.codec());
  };
  WakuMessage6.decode = (buf, opts) => {
    return decodeMessage(buf, WakuMessage6.codec(), opts);
  };
})(WakuMessage5 || (WakuMessage5 = {}));

// node_modules/@waku/proto/dist/generated/peer_exchange.js
var peer_exchange_exports = {};
__export(peer_exchange_exports, {
  PeerExchangeQuery: () => PeerExchangeQuery,
  PeerExchangeRPC: () => PeerExchangeRPC,
  PeerExchangeResponse: () => PeerExchangeResponse,
  PeerInfo: () => PeerInfo
});
var PeerInfo;
(function(PeerInfo2) {
  let _codec;
  PeerInfo2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.enr != null) {
          w.uint32(10);
          w.bytes(obj.enr);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {};
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.enr = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerInfo2.encode = (obj) => {
    return encodeMessage(obj, PeerInfo2.codec());
  };
  PeerInfo2.decode = (buf, opts) => {
    return decodeMessage(buf, PeerInfo2.codec(), opts);
  };
})(PeerInfo || (PeerInfo = {}));
var PeerExchangeQuery;
(function(PeerExchangeQuery2) {
  let _codec;
  PeerExchangeQuery2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.numPeers != null) {
          w.uint32(8);
          w.uint64(obj.numPeers);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {};
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.numPeers = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerExchangeQuery2.encode = (obj) => {
    return encodeMessage(obj, PeerExchangeQuery2.codec());
  };
  PeerExchangeQuery2.decode = (buf, opts) => {
    return decodeMessage(buf, PeerExchangeQuery2.codec(), opts);
  };
})(PeerExchangeQuery || (PeerExchangeQuery = {}));
var PeerExchangeResponse;
(function(PeerExchangeResponse2) {
  let _codec;
  PeerExchangeResponse2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.peerInfos != null) {
          for (const value of obj.peerInfos) {
            w.uint32(10);
            PeerInfo.codec().encode(value, w);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27, _b14;
        const obj = {
          peerInfos: []
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (((_a27 = opts.limits) == null ? void 0 : _a27.peerInfos) != null && obj.peerInfos.length === opts.limits.peerInfos) {
                throw new MaxLengthError('Decode error - map field "peerInfos" had too many elements');
              }
              obj.peerInfos.push(PeerInfo.codec().decode(reader, reader.uint32(), {
                limits: (_b14 = opts.limits) == null ? void 0 : _b14.peerInfos$
              }));
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerExchangeResponse2.encode = (obj) => {
    return encodeMessage(obj, PeerExchangeResponse2.codec());
  };
  PeerExchangeResponse2.decode = (buf, opts) => {
    return decodeMessage(buf, PeerExchangeResponse2.codec(), opts);
  };
})(PeerExchangeResponse || (PeerExchangeResponse = {}));
var PeerExchangeRPC;
(function(PeerExchangeRPC3) {
  let _codec;
  PeerExchangeRPC3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.query != null) {
          w.uint32(10);
          PeerExchangeQuery.codec().encode(obj.query, w);
        }
        if (obj.response != null) {
          w.uint32(18);
          PeerExchangeResponse.codec().encode(obj.response, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27, _b14;
        const obj = {};
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.query = PeerExchangeQuery.codec().decode(reader, reader.uint32(), {
                limits: (_a27 = opts.limits) == null ? void 0 : _a27.query
              });
              break;
            }
            case 2: {
              obj.response = PeerExchangeResponse.codec().decode(reader, reader.uint32(), {
                limits: (_b14 = opts.limits) == null ? void 0 : _b14.response
              });
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerExchangeRPC3.encode = (obj) => {
    return encodeMessage(obj, PeerExchangeRPC3.codec());
  };
  PeerExchangeRPC3.decode = (buf, opts) => {
    return decodeMessage(buf, PeerExchangeRPC3.codec(), opts);
  };
})(PeerExchangeRPC || (PeerExchangeRPC = {}));

// node_modules/@waku/proto/dist/generated/metadata.js
var metadata_exports = {};
__export(metadata_exports, {
  WakuMetadataRequest: () => WakuMetadataRequest,
  WakuMetadataResponse: () => WakuMetadataResponse
});
var WakuMetadataRequest;
(function(WakuMetadataRequest2) {
  let _codec;
  WakuMetadataRequest2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.clusterId != null) {
          w.uint32(8);
          w.uint32(obj.clusterId);
        }
        if (obj.shards != null) {
          for (const value of obj.shards) {
            w.uint32(16);
            w.uint32(value);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27;
        const obj = {
          shards: []
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.clusterId = reader.uint32();
              break;
            }
            case 2: {
              if (((_a27 = opts.limits) == null ? void 0 : _a27.shards) != null && obj.shards.length === opts.limits.shards) {
                throw new MaxLengthError('Decode error - map field "shards" had too many elements');
              }
              obj.shards.push(reader.uint32());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  WakuMetadataRequest2.encode = (obj) => {
    return encodeMessage(obj, WakuMetadataRequest2.codec());
  };
  WakuMetadataRequest2.decode = (buf, opts) => {
    return decodeMessage(buf, WakuMetadataRequest2.codec(), opts);
  };
})(WakuMetadataRequest || (WakuMetadataRequest = {}));
var WakuMetadataResponse;
(function(WakuMetadataResponse2) {
  let _codec;
  WakuMetadataResponse2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.clusterId != null) {
          w.uint32(8);
          w.uint32(obj.clusterId);
        }
        if (obj.shards != null) {
          for (const value of obj.shards) {
            w.uint32(16);
            w.uint32(value);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27;
        const obj = {
          shards: []
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.clusterId = reader.uint32();
              break;
            }
            case 2: {
              if (((_a27 = opts.limits) == null ? void 0 : _a27.shards) != null && obj.shards.length === opts.limits.shards) {
                throw new MaxLengthError('Decode error - map field "shards" had too many elements');
              }
              obj.shards.push(reader.uint32());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  WakuMetadataResponse2.encode = (obj) => {
    return encodeMessage(obj, WakuMetadataResponse2.codec());
  };
  WakuMetadataResponse2.decode = (buf, opts) => {
    return decodeMessage(buf, WakuMetadataResponse2.codec(), opts);
  };
})(WakuMetadataResponse || (WakuMetadataResponse = {}));

// node_modules/@waku/proto/dist/generated/sds_message.js
var sds_message_exports = {};
__export(sds_message_exports, {
  HistoryEntry: () => HistoryEntry,
  SdsMessage: () => SdsMessage
});
var HistoryEntry;
(function(HistoryEntry2) {
  let _codec;
  HistoryEntry2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.messageId != null && obj.messageId !== "") {
          w.uint32(10);
          w.string(obj.messageId);
        }
        if (obj.retrievalHint != null) {
          w.uint32(18);
          w.bytes(obj.retrievalHint);
        }
        if (obj.senderId != null) {
          w.uint32(26);
          w.string(obj.senderId);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          messageId: ""
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.messageId = reader.string();
              break;
            }
            case 2: {
              obj.retrievalHint = reader.bytes();
              break;
            }
            case 3: {
              obj.senderId = reader.string();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  HistoryEntry2.encode = (obj) => {
    return encodeMessage(obj, HistoryEntry2.codec());
  };
  HistoryEntry2.decode = (buf, opts) => {
    return decodeMessage(buf, HistoryEntry2.codec(), opts);
  };
})(HistoryEntry || (HistoryEntry = {}));
var SdsMessage;
(function(SdsMessage2) {
  let _codec;
  SdsMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.senderId != null && obj.senderId !== "") {
          w.uint32(10);
          w.string(obj.senderId);
        }
        if (obj.messageId != null && obj.messageId !== "") {
          w.uint32(18);
          w.string(obj.messageId);
        }
        if (obj.channelId != null && obj.channelId !== "") {
          w.uint32(26);
          w.string(obj.channelId);
        }
        if (obj.lamportTimestamp != null) {
          w.uint32(80);
          w.uint64(obj.lamportTimestamp);
        }
        if (obj.causalHistory != null) {
          for (const value of obj.causalHistory) {
            w.uint32(90);
            HistoryEntry.codec().encode(value, w);
          }
        }
        if (obj.bloomFilter != null) {
          w.uint32(98);
          w.bytes(obj.bloomFilter);
        }
        if (obj.repairRequest != null) {
          for (const value of obj.repairRequest) {
            w.uint32(106);
            HistoryEntry.codec().encode(value, w);
          }
        }
        if (obj.content != null) {
          w.uint32(162);
          w.bytes(obj.content);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27, _b14, _c3, _d2;
        const obj = {
          senderId: "",
          messageId: "",
          channelId: "",
          causalHistory: [],
          repairRequest: []
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.senderId = reader.string();
              break;
            }
            case 2: {
              obj.messageId = reader.string();
              break;
            }
            case 3: {
              obj.channelId = reader.string();
              break;
            }
            case 10: {
              obj.lamportTimestamp = reader.uint64();
              break;
            }
            case 11: {
              if (((_a27 = opts.limits) == null ? void 0 : _a27.causalHistory) != null && obj.causalHistory.length === opts.limits.causalHistory) {
                throw new MaxLengthError('Decode error - map field "causalHistory" had too many elements');
              }
              obj.causalHistory.push(HistoryEntry.codec().decode(reader, reader.uint32(), {
                limits: (_b14 = opts.limits) == null ? void 0 : _b14.causalHistory$
              }));
              break;
            }
            case 12: {
              obj.bloomFilter = reader.bytes();
              break;
            }
            case 13: {
              if (((_c3 = opts.limits) == null ? void 0 : _c3.repairRequest) != null && obj.repairRequest.length === opts.limits.repairRequest) {
                throw new MaxLengthError('Decode error - map field "repairRequest" had too many elements');
              }
              obj.repairRequest.push(HistoryEntry.codec().decode(reader, reader.uint32(), {
                limits: (_d2 = opts.limits) == null ? void 0 : _d2.repairRequest$
              }));
              break;
            }
            case 20: {
              obj.content = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  SdsMessage2.encode = (obj) => {
    return encodeMessage(obj, SdsMessage2.codec());
  };
  SdsMessage2.decode = (buf, opts) => {
    return decodeMessage(buf, SdsMessage2.codec(), opts);
  };
})(SdsMessage || (SdsMessage = {}));

// node_modules/@waku/utils/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  AutoShardingRoutingInfo: () => AutoShardingRoutingInfo,
  BaseRoutingInfo: () => BaseRoutingInfo,
  Logger: () => Logger,
  MockWakuNode: () => MockWakuNode,
  StaticShardingRoutingInfo: () => StaticShardingRoutingInfo,
  contentTopicToPubsubTopic: () => contentTopicToPubsubTopic,
  contentTopicToShardIndex: () => contentTopicToShardIndex,
  contentTopicsByPubsubTopic: () => contentTopicsByPubsubTopic,
  createRoutingInfo: () => createRoutingInfo,
  decodeRelayShard: () => decodeRelayShard,
  delay: () => delay,
  encodeRelayShard: () => encodeRelayShard,
  ensureValidContentTopic: () => ensureValidContentTopic,
  formatPubsubTopic: () => formatPubsubTopic,
  getPseudoRandomSubset: () => getPseudoRandomSubset,
  groupByContentTopic: () => groupByContentTopic,
  isAutoSharding: () => isAutoSharding,
  isAutoShardingRoutingInfo: () => isAutoShardingRoutingInfo,
  isDefined: () => isDefined,
  isMessageSizeUnderCap: () => isMessageSizeUnderCap,
  isStaticSharding: () => isStaticSharding,
  isStaticShardingRoutingInfo: () => isStaticShardingRoutingInfo,
  isWireSizeUnderCap: () => isWireSizeUnderCap,
  pubsubTopicToSingleShardInfo: () => pubsubTopicToSingleShardInfo,
  pushOrInitMapSet: () => pushOrInitMapSet,
  shuffle: () => shuffle,
  toAsyncIterator: () => toAsyncIterator
});

// node_modules/@waku/utils/dist/common/is_defined.js
function isDefined(value) {
  return Boolean(value);
}

// node_modules/@waku/utils/dist/common/random_subset.js
function getPseudoRandomSubset(values, wantedNumber) {
  if (values.length <= wantedNumber || values.length <= 1) {
    return values;
  }
  return shuffle(values).slice(0, wantedNumber);
}
function shuffle(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  const randInt = () => {
    return Math.floor(Math.random() * Math.floor(arr.length));
  };
  for (let i2 = 0; i2 < arr.length; i2++) {
    const j = randInt();
    const tmp = arr[i2];
    arr[i2] = arr[j];
    arr[j] = tmp;
  }
  return arr;
}

// node_modules/@waku/utils/dist/common/group_by.js
function groupByContentTopic(values) {
  const groupedDecoders = /* @__PURE__ */ new Map();
  values.forEach((value) => {
    let decs = groupedDecoders.get(value.contentTopic);
    if (!decs) {
      groupedDecoders.set(value.contentTopic, []);
      decs = groupedDecoders.get(value.contentTopic);
    }
    decs.push(value);
  });
  return groupedDecoders;
}

// node_modules/@waku/utils/dist/common/to_async_iterator.js
var FRAME_RATE = 60;
async function toAsyncIterator(receiver, decoder, iteratorOptions) {
  const iteratorDelay = (iteratorOptions == null ? void 0 : iteratorOptions.iteratorDelay) ?? FRAME_RATE;
  const messages2 = [];
  let unsubscribe;
  unsubscribe = await receiver.subscribeWithUnsubscribe(decoder, (message2) => {
    messages2.push(message2);
  });
  const isWithTimeout = Number.isInteger(iteratorOptions == null ? void 0 : iteratorOptions.timeoutMs);
  const timeoutMs = (iteratorOptions == null ? void 0 : iteratorOptions.timeoutMs) ?? 0;
  const startTime = Date.now();
  async function* iterator() {
    while (true) {
      if (isWithTimeout && Date.now() - startTime >= timeoutMs) {
        return;
      }
      await wait(iteratorDelay);
      const message2 = messages2.shift();
      if (!unsubscribe && messages2.length === 0) {
        return message2;
      }
      if (!message2 && unsubscribe) {
        continue;
      }
      yield message2;
    }
  }
  return {
    iterator: iterator(),
    async stop() {
      if (unsubscribe) {
        await unsubscribe();
        unsubscribe = void 0;
      }
    }
  };
}
function wait(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}

// node_modules/@waku/utils/dist/common/is_size_valid.js
var MB = 1024 ** 2;
var SIZE_CAP_IN_MB = 1;
async function isMessageSizeUnderCap(encoder2, message2) {
  const buf = await encoder2.toWire(message2);
  if (!buf)
    return false;
  return isWireSizeUnderCap(buf);
}
var isWireSizeUnderCap = (buf) => buf.length / MB <= SIZE_CAP_IN_MB;

// node_modules/@waku/utils/dist/common/sharding/type_guards.js
function isStaticSharding(config) {
  return "clusterId" in config && !("numShardsInCluster" in config);
}
function isAutoSharding(config) {
  return "clusterId" in config && "numShardsInCluster" in config;
}

// node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@noble/hashes/esm/utils.js
function isBytes(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
function anumber(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error("positive integer expected, got " + n2);
}
function abytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function ahash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  anumber(h.outputLen);
  anumber(h.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function clean(...arrays) {
  for (let i2 = 0; i2 < arrays.length; i2++) {
    arrays[i2].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
var isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
var hasHexBuiltin = (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes = Array.from({ length: 256 }, (_2, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex(bytes) {
  abytes(bytes);
  if (hasHexBuiltin)
    return bytes.toHex();
  let hex = "";
  for (let i2 = 0; i2 < bytes.length; i2++) {
    hex += hexes[bytes[i2]];
  }
  return hex;
}
var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    abytes(a2);
    sum += a2.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    res.set(a2, pad);
    pad += a2.length;
  }
  return res;
}
var Hash = class {
};
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto2 && typeof crypto2.randomBytes === "function") {
    return Uint8Array.from(crypto2.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE4) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE4);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n3 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE4 ? 4 : 0;
  const l2 = isLE4 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE4);
  view.setUint32(byteOffset + l2, wl, isLE4);
}
function Chi(a2, b, c2) {
  return a2 & b ^ ~a2 & c2;
}
function Maj(a2, b, c2) {
  return a2 & b ^ a2 & c2 ^ b & c2;
}
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE4) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE4;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    data = toBytes(data);
    abytes(data);
    const { view, buffer, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take2 = Math.min(blockLen - this.pos, len - pos);
      if (take2 === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take2), this.pos);
      this.pos += take2;
      pos += take2;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE4 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer[i2] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE4);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE4);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length: length3, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length3;
    to.pos = pos;
    if (length3 % blockLen)
      to.buffer.set(buffer);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var SHA256_IV = Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA224_IV = Uint32Array.from([
  3238371032,
  914150663,
  812702999,
  4144912697,
  4290775857,
  1750603025,
  1694076839,
  3204075428
]);
var SHA384_IV = Uint32Array.from([
  3418070365,
  3238371032,
  1654270250,
  914150663,
  2438529370,
  812702999,
  355462360,
  4144912697,
  1731405415,
  4290775857,
  2394180231,
  1750603025,
  3675008525,
  1694076839,
  1203062813,
  3204075428
]);
var SHA512_IV = Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);

// node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n2, le = false) {
  if (le)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i2 = 0; i2 < len; i2++) {
    const { h, l: l2 } = fromBig(lst[i2], le);
    [Ah[i2], Al[i2]] = [h, l2];
  }
  return [Ah, Al];
}
var shrSH = (h, _l, s2) => h >>> s2;
var shrSL = (h, l2, s2) => h << 32 - s2 | l2 >>> s2;
var rotrSH = (h, l2, s2) => h >>> s2 | l2 << 32 - s2;
var rotrSL = (h, l2, s2) => h << 32 - s2 | l2 >>> s2;
var rotrBH = (h, l2, s2) => h << 64 - s2 | l2 >>> s2 - 32;
var rotrBL = (h, l2, s2) => h >>> s2 - 32 | l2 << 64 - s2;
function add(Ah, Al, Bh, Bl) {
  const l2 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

// node_modules/@noble/hashes/esm/sha2.js
var SHA256_K = Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W[i2 - 15];
      const W2 = SHA256_W[i2 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i2] + SHA256_W[i2] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    clean(SHA256_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super(28);
    this.A = SHA224_IV[0] | 0;
    this.B = SHA224_IV[1] | 0;
    this.C = SHA224_IV[2] | 0;
    this.D = SHA224_IV[3] | 0;
    this.E = SHA224_IV[4] | 0;
    this.F = SHA224_IV[5] | 0;
    this.G = SHA224_IV[6] | 0;
    this.H = SHA224_IV[7] | 0;
  }
};
var K512 = (() => split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
var SHA512_Kh = (() => K512[0])();
var SHA512_Kl = (() => K512[1])();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends HashMD {
  constructor(outputLen = 64) {
    super(128, outputLen, 16, false);
    this.Ah = SHA512_IV[0] | 0;
    this.Al = SHA512_IV[1] | 0;
    this.Bh = SHA512_IV[2] | 0;
    this.Bl = SHA512_IV[3] | 0;
    this.Ch = SHA512_IV[4] | 0;
    this.Cl = SHA512_IV[5] | 0;
    this.Dh = SHA512_IV[6] | 0;
    this.Dl = SHA512_IV[7] | 0;
    this.Eh = SHA512_IV[8] | 0;
    this.El = SHA512_IV[9] | 0;
    this.Fh = SHA512_IV[10] | 0;
    this.Fl = SHA512_IV[11] | 0;
    this.Gh = SHA512_IV[12] | 0;
    this.Gl = SHA512_IV[13] | 0;
    this.Hh = SHA512_IV[14] | 0;
    this.Hl = SHA512_IV[15] | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4) {
      SHA512_W_H[i2] = view.getUint32(offset);
      SHA512_W_L[i2] = view.getUint32(offset += 4);
    }
    for (let i2 = 16; i2 < 80; i2++) {
      const W15h = SHA512_W_H[i2 - 15] | 0;
      const W15l = SHA512_W_L[i2 - 15] | 0;
      const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
      const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i2 - 2] | 0;
      const W2l = SHA512_W_L[i2 - 2] | 0;
      const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
      const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
      const SUMl = add4L(s0l, s1l, SHA512_W_L[i2 - 7], SHA512_W_L[i2 - 16]);
      const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i2 - 7], SHA512_W_H[i2 - 16]);
      SHA512_W_H[i2] = SUMh | 0;
      SHA512_W_L[i2] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
      const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i2], SHA512_W_L[i2]);
      const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i2], SHA512_W_H[i2]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
      const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = add3L(T1l, sigma0l, MAJl);
      Ah = add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean(SHA512_W_H, SHA512_W_L);
  }
  destroy() {
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super(48);
    this.Ah = SHA384_IV[0] | 0;
    this.Al = SHA384_IV[1] | 0;
    this.Bh = SHA384_IV[2] | 0;
    this.Bl = SHA384_IV[3] | 0;
    this.Ch = SHA384_IV[4] | 0;
    this.Cl = SHA384_IV[5] | 0;
    this.Dh = SHA384_IV[6] | 0;
    this.Dl = SHA384_IV[7] | 0;
    this.Eh = SHA384_IV[8] | 0;
    this.El = SHA384_IV[9] | 0;
    this.Fh = SHA384_IV[10] | 0;
    this.Fl = SHA384_IV[11] | 0;
    this.Gh = SHA384_IV[12] | 0;
    this.Gl = SHA384_IV[13] | 0;
    this.Hh = SHA384_IV[14] | 0;
    this.Hl = SHA384_IV[15] | 0;
  }
};
var T224_IV = Uint32Array.from([
  2352822216,
  424955298,
  1944164710,
  2312950998,
  502970286,
  855612546,
  1738396948,
  1479516111,
  258812777,
  2077511080,
  2011393907,
  79989058,
  1067287976,
  1780299464,
  286451373,
  2446758561
]);
var T256_IV = Uint32Array.from([
  573645204,
  4230739756,
  2673172387,
  3360449730,
  596883563,
  1867755857,
  2520282905,
  1497426621,
  2519219938,
  2827943907,
  3193839141,
  1401305490,
  721525244,
  746961066,
  246885852,
  2177182882
]);
var SHA512_224 = class extends SHA512 {
  constructor() {
    super(28);
    this.Ah = T224_IV[0] | 0;
    this.Al = T224_IV[1] | 0;
    this.Bh = T224_IV[2] | 0;
    this.Bl = T224_IV[3] | 0;
    this.Ch = T224_IV[4] | 0;
    this.Cl = T224_IV[5] | 0;
    this.Dh = T224_IV[6] | 0;
    this.Dl = T224_IV[7] | 0;
    this.Eh = T224_IV[8] | 0;
    this.El = T224_IV[9] | 0;
    this.Fh = T224_IV[10] | 0;
    this.Fl = T224_IV[11] | 0;
    this.Gh = T224_IV[12] | 0;
    this.Gl = T224_IV[13] | 0;
    this.Hh = T224_IV[14] | 0;
    this.Hl = T224_IV[15] | 0;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super(32);
    this.Ah = T256_IV[0] | 0;
    this.Al = T256_IV[1] | 0;
    this.Bh = T256_IV[2] | 0;
    this.Bl = T256_IV[3] | 0;
    this.Ch = T256_IV[4] | 0;
    this.Cl = T256_IV[5] | 0;
    this.Dh = T256_IV[6] | 0;
    this.Dl = T256_IV[7] | 0;
    this.Eh = T256_IV[8] | 0;
    this.El = T256_IV[9] | 0;
    this.Fh = T256_IV[10] | 0;
    this.Fl = T256_IV[11] | 0;
    this.Gh = T256_IV[12] | 0;
    this.Gl = T256_IV[13] | 0;
    this.Hh = T256_IV[14] | 0;
    this.Hl = T256_IV[15] | 0;
  }
};
var sha2562 = createHasher(() => new SHA256());
var sha224 = createHasher(() => new SHA224());
var sha5122 = createHasher(() => new SHA512());
var sha384 = createHasher(() => new SHA384());
var sha512_256 = createHasher(() => new SHA512_256());
var sha512_224 = createHasher(() => new SHA512_224());

// node_modules/@noble/hashes/esm/sha256.js
var sha2563 = sha2562;

// node_modules/uint8arrays/dist/src/to-string.js
function toString2(array, encoding = "utf8") {
  const base4 = bases_default[encoding];
  if (base4 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base4.encoder.encode(array).substring(1);
}

// node_modules/@waku/utils/dist/bytes/index.js
function hexToBytes2(hex) {
  if (typeof hex === "string") {
    const _hex = hex.replace(/^0x/i, "");
    return fromString2(_hex.toLowerCase(), "base16");
  }
  return hex;
}
function numberToBytes(value) {
  const buffer = new ArrayBuffer(8);
  const view = new DataView(buffer);
  if (typeof value === "number") {
    view.setFloat64(0, value, false);
  } else {
    view.setBigInt64(0, value, false);
  }
  return new Uint8Array(buffer);
}
var bytesToHex2 = (bytes) => toString2(bytes, "base16");
var bytesToUtf8 = (b) => toString2(b, "utf8");
var utf8ToBytes2 = (s2) => fromString2(s2, "utf8");
function concat(byteArrays, totalLength) {
  const len = totalLength ?? byteArrays.reduce((acc, curr) => acc + curr.length, 0);
  const res = new Uint8Array(len);
  let offset = 0;
  for (const bytes of byteArrays) {
    res.set(bytes, offset);
    offset += bytes.length;
  }
  return res;
}

// node_modules/@waku/utils/dist/common/sharding/topics.js
var formatPubsubTopic = (clusterId, shard) => {
  return `/waku/2/rs/${clusterId}/${shard}`;
};
var pubsubTopicToSingleShardInfo = (pubsubTopics) => {
  const parts = pubsubTopics.split("/");
  if (parts.length != 6 || parts[1] !== "waku" || parts[2] !== "2" || parts[3] !== "rs")
    throw new Error("Invalid pubsub topic");
  const clusterId = parseInt(parts[4]);
  const shard = parseInt(parts[5]);
  if (isNaN(clusterId) || isNaN(shard))
    throw new Error("Invalid clusterId or shard");
  return {
    clusterId,
    shard
  };
};
function ensureValidContentTopic(contentTopic) {
  const parts = contentTopic.split("/");
  if (parts.length < 5 || parts.length > 6) {
    throw Error(`Content topic format is invalid: ${contentTopic}`);
  }
  let generation = 0;
  if (parts.length == 6) {
    generation = parseInt(parts[1]);
    if (isNaN(generation)) {
      throw new Error(`Invalid generation field in content topic: ${contentTopic}`);
    }
    if (generation > 0) {
      throw new Error(`Generation greater than 0 is not supported: ${contentTopic}`);
    }
  }
  const fields = parts.splice(-4);
  if (fields[0].length == 0) {
    throw new Error(`Application field cannot be empty: ${contentTopic}`);
  }
  if (fields[1].length == 0) {
    throw new Error(`Version field cannot be empty: ${contentTopic}`);
  }
  if (fields[2].length == 0) {
    throw new Error(`Topic name field cannot be empty: ${contentTopic}`);
  }
  if (fields[3].length == 0) {
    throw new Error(`Encoding field cannot be empty: ${contentTopic}`);
  }
  return {
    generation,
    application: fields[0],
    version: fields[1],
    topicName: fields[2],
    encoding: fields[3]
  };
}
function contentTopicToShardIndex(contentTopic, numShardsInCluster) {
  const { application, version: version5 } = ensureValidContentTopic(contentTopic);
  const digest2 = sha2563(concat([utf8ToBytes2(application), utf8ToBytes2(version5)]));
  const dataview = new DataView(digest2.buffer.slice(-8));
  return Number(dataview.getBigUint64(0, false) % BigInt(numShardsInCluster));
}
function contentTopicToPubsubTopic(contentTopic, clusterId, numShardsInCluster) {
  if (!contentTopic) {
    throw Error("Content topic must be specified");
  }
  const shardIndex = contentTopicToShardIndex(contentTopic, numShardsInCluster);
  return `/waku/2/rs/${clusterId}/${shardIndex}`;
}
function contentTopicsByPubsubTopic(contentTopics, clusterId, networkShards) {
  const groupedContentTopics = /* @__PURE__ */ new Map();
  for (const contentTopic of contentTopics) {
    const pubsubTopic = contentTopicToPubsubTopic(contentTopic, clusterId, networkShards);
    let topics = groupedContentTopics.get(pubsubTopic);
    if (!topics) {
      groupedContentTopics.set(pubsubTopic, []);
      topics = groupedContentTopics.get(pubsubTopic);
    }
    topics.push(contentTopic);
  }
  return groupedContentTopics;
}

// node_modules/@waku/utils/dist/common/sharding/routing_info.js
var BaseRoutingInfo = class {
  constructor(networkConfig, pubsubTopic, shardId) {
    __publicField(this, "networkConfig");
    __publicField(this, "pubsubTopic");
    __publicField(this, "shardId");
    this.networkConfig = networkConfig;
    this.pubsubTopic = pubsubTopic;
    this.shardId = shardId;
  }
};
var AutoShardingRoutingInfo = class _AutoShardingRoutingInfo extends BaseRoutingInfo {
  /**
   * No checks are done with this constructor,
   * Be sure you check that the network config (auto vs static)
   * matches other parameters.
   */
  constructor(networkConfig, pubsubTopic, shardId, contentTopic) {
    super(networkConfig, pubsubTopic, shardId);
    __publicField(this, "networkConfig");
    __publicField(this, "pubsubTopic");
    __publicField(this, "shardId");
    __publicField(this, "contentTopic");
    this.networkConfig = networkConfig;
    this.pubsubTopic = pubsubTopic;
    this.shardId = shardId;
    this.contentTopic = contentTopic;
  }
  static fromContentTopic(contentTopic, networkConfig) {
    ensureValidContentTopic(contentTopic);
    const shardId = contentTopicToShardIndex(contentTopic, networkConfig.numShardsInCluster);
    const pubsubTopic = formatPubsubTopic(networkConfig.clusterId, shardId);
    return new _AutoShardingRoutingInfo(networkConfig, pubsubTopic, shardId, contentTopic);
  }
  get clusterId() {
    return this.networkConfig.clusterId;
  }
  get isAutoSharding() {
    return true;
  }
  get isStaticSharding() {
    return false;
  }
};
var StaticShardingRoutingInfo = class _StaticShardingRoutingInfo extends BaseRoutingInfo {
  /**
   * No checks are done with this constructor,
   * Be sure you check that the network config (auto vs static)
   * matches other parameters.
   */
  constructor(networkConfig, pubsubTopic, shardId) {
    super(networkConfig, pubsubTopic, shardId);
    __publicField(this, "networkConfig");
    __publicField(this, "pubsubTopic");
    __publicField(this, "shardId");
    this.networkConfig = networkConfig;
    this.pubsubTopic = pubsubTopic;
    this.shardId = shardId;
  }
  /**
   * Create Routing Info for static sharding network, using shard
   *
   * @param shardId
   * @param networkConfig
   */
  static fromShard(shardId, networkConfig) {
    const pubsubTopic = formatPubsubTopic(networkConfig.clusterId, shardId);
    return new _StaticShardingRoutingInfo(networkConfig, pubsubTopic, shardId);
  }
  /**
   * Create Routing Info for static sharding network, using pubsub topic
   *
   * @param pubsubTopic
   * @param networkConfig
   *
   * @throws if the pubsub topic is malformed, or does not match the network config
   */
  static fromPubsubTopic(pubsubTopic, networkConfig) {
    const { clusterId, shard } = pubsubTopicToSingleShardInfo(pubsubTopic);
    if (clusterId != networkConfig.clusterId)
      throw "Pubsub topic does not match network config's cluster id";
    return new _StaticShardingRoutingInfo(networkConfig, pubsubTopic, shard);
  }
  get clusterId() {
    return this.networkConfig.clusterId;
  }
  get isAutoSharding() {
    return false;
  }
  get isStaticSharding() {
    return true;
  }
};
function isAutoShardingRoutingInfo(routingInfo) {
  return routingInfo.isAutoSharding;
}
function isStaticShardingRoutingInfo(routingInfo) {
  return routingInfo.isStaticSharding;
}
function createRoutingInfo(networkConfig, options) {
  if (isAutoSharding(networkConfig)) {
    if (options.contentTopic) {
      return AutoShardingRoutingInfo.fromContentTopic(options.contentTopic, networkConfig);
    }
    throw new Error("AutoSharding requires contentTopic");
  } else {
    if (options.shardId !== void 0) {
      return StaticShardingRoutingInfo.fromShard(options.shardId, networkConfig);
    } else if (options.pubsubTopic) {
      return StaticShardingRoutingInfo.fromPubsubTopic(options.pubsubTopic, networkConfig);
    }
    throw new Error("StaticSharding requires shardId or pubsubTopic");
  }
}

// node_modules/@waku/utils/dist/common/push_or_init_map.js
function pushOrInitMapSet(map2, key, newValue) {
  let arr = map2.get(key);
  if (typeof arr === "undefined") {
    map2.set(key, /* @__PURE__ */ new Set());
    arr = map2.get(key);
  }
  arr.add(newValue);
}

// node_modules/@waku/utils/dist/common/relay_shard_codec.js
var decodeRelayShard = (bytes) => {
  bytes = new Uint8Array(bytes);
  if (bytes.length < 3)
    throw new Error("Insufficient data");
  const view = new DataView(bytes.buffer);
  const clusterId = view.getUint16(0);
  const shards = [];
  if (bytes.length === 130) {
    for (let i2 = 0; i2 < 1024; i2++) {
      const byteIndex = Math.floor(i2 / 8) + 2;
      const bitIndex = 7 - i2 % 8;
      if (view.getUint8(byteIndex) & 1 << bitIndex) {
        shards.push(i2);
      }
    }
  } else {
    const numIndices = view.getUint8(2);
    for (let i2 = 0, offset = 3; i2 < numIndices; i2++, offset += 2) {
      if (offset + 1 >= bytes.length)
        throw new Error("Unexpected end of data");
      shards.push(view.getUint16(offset));
    }
  }
  return { clusterId, shards };
};
var encodeRelayShard = (shardInfo) => {
  const { clusterId, shards } = shardInfo;
  const totalLength = shards.length >= 64 ? 130 : 3 + 2 * shards.length;
  const buffer = new ArrayBuffer(totalLength);
  const view = new DataView(buffer);
  view.setUint16(0, clusterId);
  if (shards.length >= 64) {
    for (const index of shards) {
      const byteIndex = Math.floor(index / 8) + 2;
      const bitIndex = 7 - index % 8;
      view.setUint8(byteIndex, view.getUint8(byteIndex) | 1 << bitIndex);
    }
  } else {
    view.setUint8(2, shards.length);
    for (let i2 = 0, offset = 3; i2 < shards.length; i2++, offset += 2) {
      view.setUint16(offset, shards[i2]);
    }
  }
  return new Uint8Array(buffer);
};

// node_modules/@waku/utils/dist/common/delay.js
async function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// node_modules/@libp2p/interface/dist/src/connection.js
var connectionSymbol = Symbol.for("@libp2p/connection");

// node_modules/@libp2p/interface/dist/src/content-routing.js
var contentRoutingSymbol = Symbol.for("@libp2p/content-routing");

// node_modules/@libp2p/interface/dist/src/peer-discovery.js
var peerDiscoverySymbol = Symbol.for("@libp2p/peer-discovery");

// node_modules/@libp2p/interface/dist/src/peer-id.js
var peerIdSymbol = Symbol.for("@libp2p/peer-id");
function isPeerId(other) {
  return Boolean(other == null ? void 0 : other[peerIdSymbol]);
}

// node_modules/@libp2p/interface/dist/src/peer-routing.js
var peerRoutingSymbol = Symbol.for("@libp2p/peer-routing");

// node_modules/@libp2p/interface/dist/src/peer-store.js
var KEEP_ALIVE = "keep-alive";

// node_modules/@libp2p/interface/dist/src/pubsub.js
var TopicValidatorResult;
(function(TopicValidatorResult3) {
  TopicValidatorResult3["Accept"] = "accept";
  TopicValidatorResult3["Ignore"] = "ignore";
  TopicValidatorResult3["Reject"] = "reject";
})(TopicValidatorResult || (TopicValidatorResult = {}));
var pubSubSymbol = Symbol.for("@libp2p/pubsub");

// node_modules/@libp2p/interface/dist/src/transport.js
var transportSymbol = Symbol.for("@libp2p/transport");
var FaultTolerance;
(function(FaultTolerance4) {
  FaultTolerance4[FaultTolerance4["FATAL_ALL"] = 0] = "FATAL_ALL";
  FaultTolerance4[FaultTolerance4["NO_FATAL"] = 1] = "NO_FATAL";
})(FaultTolerance || (FaultTolerance = {}));

// node_modules/@libp2p/interface/dist/src/errors.js
var AbortError = class extends Error {
  constructor(message2 = "The operation was aborted") {
    super(message2);
    this.name = "AbortError";
  }
};
__publicField(AbortError, "name", "AbortError");
var UnexpectedPeerError = class extends Error {
  constructor(message2 = "Unexpected Peer") {
    super(message2);
    this.name = "UnexpectedPeerError";
  }
};
__publicField(UnexpectedPeerError, "name", "UnexpectedPeerError");
var InvalidCryptoExchangeError = class extends Error {
  constructor(message2 = "Invalid crypto exchange") {
    super(message2);
    this.name = "InvalidCryptoExchangeError";
  }
};
__publicField(InvalidCryptoExchangeError, "name", "InvalidCryptoExchangeError");
var InvalidParametersError = class extends Error {
  constructor(message2 = "Invalid parameters") {
    super(message2);
    this.name = "InvalidParametersError";
  }
};
__publicField(InvalidParametersError, "name", "InvalidParametersError");
var InvalidPublicKeyError = class extends Error {
  constructor(message2 = "Invalid public key") {
    super(message2);
    this.name = "InvalidPublicKeyError";
  }
};
__publicField(InvalidPublicKeyError, "name", "InvalidPublicKeyError");
var ConnectionClosingError = class extends Error {
  constructor(message2 = "The connection is closing") {
    super(message2);
    this.name = "ConnectionClosingError";
  }
};
__publicField(ConnectionClosingError, "name", "ConnectionClosingError");
var ConnectionClosedError = class extends Error {
  constructor(message2 = "The connection is closed") {
    super(message2);
    this.name = "ConnectionClosedError";
  }
};
__publicField(ConnectionClosedError, "name", "ConnectionClosedError");
var ConnectionFailedError = class extends Error {
  constructor(message2 = "Connection failed") {
    super(message2);
    this.name = "ConnectionFailedError";
  }
};
__publicField(ConnectionFailedError, "name", "ConnectionFailedError");
var MuxerClosedError = class extends Error {
  constructor(message2 = "The muxer is closed") {
    super(message2);
    this.name = "MuxerClosedError";
  }
};
__publicField(MuxerClosedError, "name", "MuxerClosedError");
var StreamResetError = class extends Error {
  constructor(message2 = "The stream has been reset") {
    super(message2);
    this.name = "StreamResetError";
  }
};
__publicField(StreamResetError, "name", "StreamResetError");
var StreamStateError = class extends Error {
  constructor(message2 = "The stream is in an invalid state") {
    super(message2);
    this.name = "StreamStateError";
  }
};
__publicField(StreamStateError, "name", "StreamStateError");
var NotFoundError = class extends Error {
  constructor(message2 = "Not found") {
    super(message2);
    this.name = "NotFoundError";
  }
};
__publicField(NotFoundError, "name", "NotFoundError");
var InvalidPeerIdError = class extends Error {
  constructor(message2 = "Invalid PeerID") {
    super(message2);
    this.name = "InvalidPeerIdError";
  }
};
__publicField(InvalidPeerIdError, "name", "InvalidPeerIdError");
var InvalidMultiaddrError = class extends Error {
  constructor(message2 = "Invalid multiaddr") {
    super(message2);
    this.name = "InvalidMultiaddrError";
  }
};
__publicField(InvalidMultiaddrError, "name", "InvalidMultiaddrError");
var InvalidCIDError = class extends Error {
  constructor(message2 = "Invalid CID") {
    super(message2);
    this.name = "InvalidCIDError";
  }
};
__publicField(InvalidCIDError, "name", "InvalidCIDError");
var InvalidMultihashError = class extends Error {
  constructor(message2 = "Invalid Multihash") {
    super(message2);
    this.name = "InvalidMultihashError";
  }
};
__publicField(InvalidMultihashError, "name", "InvalidMultihashError");
var UnsupportedProtocolError = class extends Error {
  constructor(message2 = "Unsupported protocol error") {
    super(message2);
    this.name = "UnsupportedProtocolError";
  }
};
__publicField(UnsupportedProtocolError, "name", "UnsupportedProtocolError");
var InvalidMessageError = class extends Error {
  constructor(message2 = "Invalid message") {
    super(message2);
    this.name = "InvalidMessageError";
  }
};
__publicField(InvalidMessageError, "name", "InvalidMessageError");
var ProtocolError = class extends Error {
  constructor(message2 = "Protocol error") {
    super(message2);
    this.name = "ProtocolError";
  }
};
__publicField(ProtocolError, "name", "ProtocolError");
var TimeoutError = class extends Error {
  constructor(message2 = "Timed out") {
    super(message2);
    this.name = "TimeoutError";
  }
};
__publicField(TimeoutError, "name", "TimeoutError");
var NotStartedError = class extends Error {
  constructor(message2 = "Not started") {
    super(message2);
    this.name = "NotStartedError";
  }
};
__publicField(NotStartedError, "name", "NotStartedError");
var DialError = class extends Error {
  constructor(message2 = "Dial error") {
    super(message2);
    this.name = "DialError";
  }
};
__publicField(DialError, "name", "DialError");
var LimitedConnectionError = class extends Error {
  constructor(message2 = "Limited connection") {
    super(message2);
    this.name = "LimitedConnectionError";
  }
};
__publicField(LimitedConnectionError, "name", "LimitedConnectionError");
var TooManyInboundProtocolStreamsError = class extends Error {
  constructor(message2 = "Too many inbound protocol streams") {
    super(message2);
    this.name = "TooManyInboundProtocolStreamsError";
  }
};
__publicField(TooManyInboundProtocolStreamsError, "name", "TooManyInboundProtocolStreamsError");
var TooManyOutboundProtocolStreamsError = class extends Error {
  constructor(message2 = "Too many outbound protocol streams") {
    super(message2);
    this.name = "TooManyOutboundProtocolStreamsError";
  }
};
__publicField(TooManyOutboundProtocolStreamsError, "name", "TooManyOutboundProtocolStreamsError");
var UnsupportedKeyTypeError = class extends Error {
  constructor(message2 = "Unsupported key type") {
    super(message2);
    this.name = "UnsupportedKeyTypeError";
  }
};
__publicField(UnsupportedKeyTypeError, "name", "UnsupportedKeyTypeError");

// node_modules/main-event/dist/src/events.browser.js
function setMaxListeners() {
}

// node_modules/main-event/dist/src/index.js
var _listeners;
var TypedEventEmitter = class extends EventTarget {
  constructor() {
    super();
    __privateAdd(this, _listeners, /* @__PURE__ */ new Map());
    setMaxListeners(Infinity, this);
  }
  listenerCount(type) {
    const listeners = __privateGet(this, _listeners).get(type);
    if (listeners == null) {
      return 0;
    }
    return listeners.length;
  }
  addEventListener(type, listener, options) {
    super.addEventListener(type, listener, options);
    let list = __privateGet(this, _listeners).get(type);
    if (list == null) {
      list = [];
      __privateGet(this, _listeners).set(type, list);
    }
    list.push({
      callback: listener,
      once: (options !== true && options !== false && (options == null ? void 0 : options.once)) ?? false
    });
  }
  removeEventListener(type, listener, options) {
    super.removeEventListener(type.toString(), listener ?? null, options);
    let list = __privateGet(this, _listeners).get(type);
    if (list == null) {
      return;
    }
    list = list.filter(({ callback }) => callback !== listener);
    __privateGet(this, _listeners).set(type, list);
  }
  dispatchEvent(event) {
    const result = super.dispatchEvent(event);
    let list = __privateGet(this, _listeners).get(event.type);
    if (list == null) {
      return result;
    }
    list = list.filter(({ once }) => !once);
    __privateGet(this, _listeners).set(event.type, list);
    return result;
  }
  safeDispatchEvent(type, detail = {}) {
    return this.dispatchEvent(new CustomEvent(type, detail));
  }
};
_listeners = new WeakMap();

// node_modules/@libp2p/interface/dist/src/startable.js
function isStartable(obj) {
  return obj != null && typeof obj.start === "function" && typeof obj.stop === "function";
}
async function start(...objs) {
  const startables = [];
  for (const obj of objs) {
    if (isStartable(obj)) {
      startables.push(obj);
    }
  }
  await Promise.all(startables.map(async (s2) => {
    if (s2.beforeStart != null) {
      await s2.beforeStart();
    }
  }));
  await Promise.all(startables.map(async (s2) => {
    await s2.start();
  }));
  await Promise.all(startables.map(async (s2) => {
    if (s2.afterStart != null) {
      await s2.afterStart();
    }
  }));
}
async function stop(...objs) {
  const startables = [];
  for (const obj of objs) {
    if (isStartable(obj)) {
      startables.push(obj);
    }
  }
  await Promise.all(startables.map(async (s2) => {
    if (s2.beforeStop != null) {
      await s2.beforeStop();
    }
  }));
  await Promise.all(startables.map(async (s2) => {
    await s2.stop();
  }));
  await Promise.all(startables.map(async (s2) => {
    if (s2.afterStop != null) {
      await s2.afterStop();
    }
  }));
}

// node_modules/@libp2p/interface/dist/src/index.js
var serviceCapabilities = Symbol.for("@libp2p/service-capabilities");
var serviceDependencies = Symbol.for("@libp2p/service-dependencies");

// node_modules/@waku/utils/dist/common/mock_node.js
var MockWakuNode = class {
  constructor(mockMessageEmitter) {
    __publicField(this, "mockMessageEmitter");
    __publicField(this, "relay");
    __publicField(this, "store");
    __publicField(this, "filter");
    __publicField(this, "lightPush");
    __publicField(this, "protocols");
    __publicField(this, "subscriptions");
    __publicField(this, "events");
    this.mockMessageEmitter = mockMessageEmitter;
    this.protocols = [];
    this.events = new TypedEventEmitter();
    this.subscriptions = [];
    this.lightPush = {
      multicodec: [],
      send: this._send.bind(this),
      start() {
      },
      stop() {
      }
    };
    this.filter = {
      start: async () => {
      },
      stop: async () => {
      },
      multicodec: "filter",
      subscribe: this._subscribe.bind(this),
      unsubscribe(_decoders) {
        throw "Not implemented";
      },
      unsubscribeAll() {
        throw "Not implemented";
      }
    };
  }
  get libp2p() {
    throw "No libp2p on MockWakuNode";
  }
  async _send(encoder2, message2, _sendOptions) {
    for (const { decoders: decoders4, callback } of this.subscriptions) {
      const protoMessage = await encoder2.toProtoObj(message2);
      if (!protoMessage)
        throw "Issue in mock encoding message";
      for (const decoder of decoders4) {
        const decodedMessage = await decoder.fromProtoObj(decoder.pubsubTopic, protoMessage);
        if (!decodedMessage)
          throw "Issue in mock decoding message";
        await callback(decodedMessage);
        if (this.mockMessageEmitter) {
          this.mockMessageEmitter.dispatchEvent(new CustomEvent("new-message", {
            detail: decodedMessage
          }));
        }
      }
    }
    return {
      failures: [],
      successes: []
    };
  }
  async _subscribe(decoders4, callback) {
    this.subscriptions.push({
      decoders: Array.isArray(decoders4) ? decoders4 : [decoders4],
      callback
    });
    if (this.mockMessageEmitter) {
      this.mockMessageEmitter.addEventListener("new-message", (event) => {
        void callback(event.detail);
      });
    }
    return Promise.resolve(true);
  }
  get peerId() {
    throw "no peerId on MockWakuNode";
  }
  get health() {
    throw "no health on MockWakuNode";
  }
  dial(_peer, _protocols) {
    throw new Error("Method not implemented.");
  }
  hangUp(_peer) {
    throw new Error("Method not implemented.");
  }
  start() {
    return Promise.resolve();
  }
  stop() {
    throw new Error("Method not implemented.");
  }
  waitForPeers(_protocols, _timeoutMs) {
    throw new Error("Method not implemented.");
  }
  createDecoder(_params) {
    throw new Error("Method not implemented.");
  }
  createEncoder(_params) {
    throw new Error("Method not implemented.");
  }
  isStarted() {
    throw new Error("Method not implemented.");
  }
  isConnected() {
    throw new Error("Method not implemented.");
  }
  getConnectedPeers() {
    throw new Error("Method not implemented.");
  }
};

// node_modules/@waku/utils/dist/logger.js
var import_debug = __toESM(require_browser(), 1);
var APP_NAME = "waku";
var Logger = class _Logger {
  constructor(prefix) {
    __publicField(this, "_info");
    __publicField(this, "_warn");
    __publicField(this, "_error");
    this._info = (0, import_debug.default)(_Logger.createDebugNamespace("info", prefix));
    this._warn = (0, import_debug.default)(_Logger.createDebugNamespace("warn", prefix));
    this._error = (0, import_debug.default)(_Logger.createDebugNamespace("error", prefix));
  }
  static createDebugNamespace(level, prefix) {
    return prefix ? `${APP_NAME}:${prefix}:${level}` : `${APP_NAME}:${level}`;
  }
  get info() {
    return this._info;
  }
  get warn() {
    return this._warn;
  }
  get error() {
    return this._error;
  }
  log(level, ...args) {
    const logger4 = this[level] || this.log;
    logger4(...args);
  }
};

// node_modules/@waku/core/dist/lib/message_hash/message_hash.js
function messageHash(pubsubTopic, message2) {
  const pubsubTopicBytes = utf8ToBytes2(pubsubTopic);
  const contentTopicBytes = utf8ToBytes2(message2.contentTopic);
  const timestampBytes = tryConvertTimestampToBytes(message2.timestamp);
  const bytes = concat([
    pubsubTopicBytes,
    message2.payload,
    contentTopicBytes,
    message2.meta,
    timestampBytes
  ].filter(isDefined));
  return sha2563(bytes);
}
function tryConvertTimestampToBytes(timestamp) {
  if (!timestamp) {
    return;
  }
  let bigIntTimestamp;
  if (typeof timestamp === "bigint") {
    bigIntTimestamp = timestamp;
  } else {
    bigIntTimestamp = BigInt(timestamp.valueOf()) * 1000000n;
  }
  return numberToBytes(bigIntTimestamp);
}
function messageHashStr(pubsubTopic, message2) {
  const hash = messageHash(pubsubTopic, message2);
  const hashStr = bytesToHex2(hash);
  return hashStr;
}

// node_modules/@waku/core/dist/lib/message/version_0.js
var log = new Logger("message:version-0");
var OneMillion = BigInt(1e6);
var Version = 0;
var DecodedMessage = class {
  constructor(pubsubTopic, proto) {
    __publicField(this, "pubsubTopic");
    __publicField(this, "proto");
    __publicField(this, "_hash");
    __publicField(this, "_hashStr");
    this.pubsubTopic = pubsubTopic;
    this.proto = proto;
  }
  get ephemeral() {
    return Boolean(this.proto.ephemeral);
  }
  get payload() {
    return this.proto.payload;
  }
  get contentTopic() {
    return this.proto.contentTopic;
  }
  get hash() {
    if (this._hash === void 0) {
      this._hash = messageHash(this.pubsubTopic, this.proto);
    }
    return this._hash;
  }
  get hashStr() {
    if (this._hashStr === void 0) {
      this._hashStr = bytesToHex2(this.hash);
    }
    return this._hashStr;
  }
  get timestamp() {
    try {
      if (this.proto.timestamp) {
        const timestamp = this.proto.timestamp / OneMillion;
        return new Date(Number(timestamp));
      }
      return;
    } catch (e2) {
      return;
    }
  }
  get meta() {
    return this.proto.meta;
  }
  get version() {
    return this.proto.version ?? Version;
  }
  get rateLimitProof() {
    return this.proto.rateLimitProof;
  }
};
var Encoder2 = class {
  constructor(contentTopic, ephemeral = false, routingInfo, metaSetter) {
    __publicField(this, "contentTopic");
    __publicField(this, "ephemeral");
    __publicField(this, "routingInfo");
    __publicField(this, "metaSetter");
    this.contentTopic = contentTopic;
    this.ephemeral = ephemeral;
    this.routingInfo = routingInfo;
    this.metaSetter = metaSetter;
    if (!contentTopic || contentTopic === "") {
      throw new Error("Content topic must be specified");
    }
  }
  get pubsubTopic() {
    return this.routingInfo.pubsubTopic;
  }
  async toWire(message2) {
    return message_exports.WakuMessage.encode(await this.toProtoObj(message2));
  }
  async toProtoObj(message2) {
    const timestamp = message2.timestamp ?? /* @__PURE__ */ new Date();
    const protoMessage = {
      payload: message2.payload,
      version: Version,
      contentTopic: this.contentTopic,
      timestamp: BigInt(timestamp.valueOf()) * OneMillion,
      meta: void 0,
      rateLimitProof: message2.rateLimitProof,
      ephemeral: this.ephemeral
    };
    if (this.metaSetter) {
      const meta = this.metaSetter(protoMessage);
      return { ...protoMessage, meta };
    }
    return protoMessage;
  }
};
function createEncoder({ contentTopic, routingInfo, ephemeral, metaSetter }) {
  return new Encoder2(contentTopic, ephemeral, routingInfo, metaSetter);
}
var Decoder2 = class {
  constructor(contentTopic, routingInfo) {
    __publicField(this, "contentTopic");
    __publicField(this, "routingInfo");
    this.contentTopic = contentTopic;
    this.routingInfo = routingInfo;
    if (!contentTopic || contentTopic === "") {
      throw new Error("Content topic must be specified");
    }
  }
  get pubsubTopic() {
    return this.routingInfo.pubsubTopic;
  }
  fromWireToProtoObj(bytes) {
    const protoMessage = message_exports.WakuMessage.decode(bytes);
    return Promise.resolve({
      payload: protoMessage.payload,
      contentTopic: protoMessage.contentTopic,
      version: protoMessage.version ?? void 0,
      timestamp: protoMessage.timestamp ?? void 0,
      meta: protoMessage.meta ?? void 0,
      rateLimitProof: protoMessage.rateLimitProof ?? void 0,
      ephemeral: protoMessage.ephemeral ?? false
    });
  }
  async fromProtoObj(pubsubTopic, proto) {
    if (proto.version ?? 0 !== Version) {
      log.error("Failed to decode due to incorrect version, expected:", Version, ", actual:", proto.version);
      return Promise.resolve(void 0);
    }
    return new DecodedMessage(pubsubTopic, proto);
  }
};
function createDecoder(contentTopic, routingInfo) {
  return new Decoder2(contentTopic, routingInfo);
}

// node_modules/@waku/core/dist/lib/message/index.js
var message_exports2 = {};
__export(message_exports2, {
  version_0: () => version_0_exports
});

// node_modules/@waku/core/dist/lib/filter/index.js
var filter_exports2 = {};
__export(filter_exports2, {
  FilterCodecs: () => FilterCodecs,
  FilterCore: () => FilterCore
});

// node_modules/@waku/interfaces/dist/light_push.js
var LightPushStatusCode;
(function(LightPushStatusCode2) {
  LightPushStatusCode2[LightPushStatusCode2["SUCCESS"] = 200] = "SUCCESS";
  LightPushStatusCode2[LightPushStatusCode2["BAD_REQUEST"] = 400] = "BAD_REQUEST";
  LightPushStatusCode2[LightPushStatusCode2["PAYLOAD_TOO_LARGE"] = 413] = "PAYLOAD_TOO_LARGE";
  LightPushStatusCode2[LightPushStatusCode2["INVALID_MESSAGE"] = 420] = "INVALID_MESSAGE";
  LightPushStatusCode2[LightPushStatusCode2["UNSUPPORTED_TOPIC"] = 421] = "UNSUPPORTED_TOPIC";
  LightPushStatusCode2[LightPushStatusCode2["TOO_MANY_REQUESTS"] = 429] = "TOO_MANY_REQUESTS";
  LightPushStatusCode2[LightPushStatusCode2["INTERNAL_ERROR"] = 500] = "INTERNAL_ERROR";
  LightPushStatusCode2[LightPushStatusCode2["UNAVAILABLE"] = 503] = "UNAVAILABLE";
  LightPushStatusCode2[LightPushStatusCode2["NO_RLN_PROOF"] = 504] = "NO_RLN_PROOF";
  LightPushStatusCode2[LightPushStatusCode2["NO_PEERS"] = 505] = "NO_PEERS";
})(LightPushStatusCode || (LightPushStatusCode = {}));
var StatusDescriptions = {
  [LightPushStatusCode.SUCCESS]: "Message sent successfully",
  [LightPushStatusCode.BAD_REQUEST]: "Bad request format",
  [LightPushStatusCode.PAYLOAD_TOO_LARGE]: "Message payload exceeds maximum size",
  [LightPushStatusCode.INVALID_MESSAGE]: "Message validation failed",
  [LightPushStatusCode.UNSUPPORTED_TOPIC]: "Unsupported pubsub topic",
  [LightPushStatusCode.TOO_MANY_REQUESTS]: "Rate limit exceeded",
  [LightPushStatusCode.INTERNAL_ERROR]: "Internal server error",
  [LightPushStatusCode.UNAVAILABLE]: "Service temporarily unavailable",
  [LightPushStatusCode.NO_RLN_PROOF]: "RLN proof generation failed",
  [LightPushStatusCode.NO_PEERS]: "No relay peers available"
};

// node_modules/@waku/interfaces/dist/protocols.js
var Protocols;
(function(Protocols2) {
  Protocols2["Relay"] = "relay";
  Protocols2["Store"] = "store";
  Protocols2["LightPush"] = "lightpush";
  Protocols2["Filter"] = "filter";
})(Protocols || (Protocols = {}));
var LightPushError;
(function(LightPushError2) {
  LightPushError2["GENERIC_FAIL"] = "Generic error";
  LightPushError2["DECODE_FAILED"] = "Failed to decode";
  LightPushError2["NO_PEER_AVAILABLE"] = "No peer available";
  LightPushError2["NO_STREAM_AVAILABLE"] = "No stream available";
  LightPushError2["NO_RESPONSE"] = "No response received";
  LightPushError2["STREAM_ABORTED"] = "Stream aborted";
  LightPushError2["ENCODE_FAILED"] = "Failed to encode";
  LightPushError2["EMPTY_PAYLOAD"] = "Payload is empty";
  LightPushError2["SIZE_TOO_BIG"] = "Size is too big";
  LightPushError2["TOPIC_NOT_CONFIGURED"] = "Topic not configured";
  LightPushError2["RLN_PROOF_GENERATION"] = "Proof generation failed";
  LightPushError2["REMOTE_PEER_REJECTED"] = "Remote peer rejected";
  LightPushError2["BAD_REQUEST"] = "Bad request format";
  LightPushError2["PAYLOAD_TOO_LARGE"] = "Message payload exceeds maximum size";
  LightPushError2["INVALID_MESSAGE"] = "Message validation failed";
  LightPushError2["UNSUPPORTED_TOPIC"] = "Unsupported pubsub topic";
  LightPushError2["TOO_MANY_REQUESTS"] = "Rate limit exceeded";
  LightPushError2["INTERNAL_ERROR"] = "Internal server error";
  LightPushError2["UNAVAILABLE"] = "Service temporarily unavailable";
  LightPushError2["NO_RLN_PROOF"] = "RLN proof generation failed";
  LightPushError2["NO_PEERS"] = "No relay peers available";
})(LightPushError || (LightPushError = {}));
var FilterError;
(function(FilterError2) {
  FilterError2["GENERIC_FAIL"] = "Generic error";
  FilterError2["DECODE_FAILED"] = "Failed to decode";
  FilterError2["NO_PEER_AVAILABLE"] = "No peer available";
  FilterError2["NO_STREAM_AVAILABLE"] = "No stream available";
  FilterError2["NO_RESPONSE"] = "No response received";
  FilterError2["STREAM_ABORTED"] = "Stream aborted";
  FilterError2["REMOTE_PEER_REJECTED"] = "Remote peer rejected";
  FilterError2["TOPIC_NOT_CONFIGURED"] = "Topic not configured";
  FilterError2["SUBSCRIPTION_FAILED"] = "Subscription failed";
  FilterError2["UNSUBSCRIBE_FAILED"] = "Unsubscribe failed";
  FilterError2["PING_FAILED"] = "Ping failed";
  FilterError2["TOPIC_DECODER_MISMATCH"] = "Topic decoder mismatch";
  FilterError2["INVALID_DECODER_TOPICS"] = "Invalid decoder topics";
  FilterError2["SUBSCRIPTION_LIMIT_EXCEEDED"] = "Subscription limit exceeded";
  FilterError2["INVALID_CONTENT_TOPIC"] = "Invalid content topic";
  FilterError2["PUSH_MESSAGE_FAILED"] = "Push message failed";
  FilterError2["EMPTY_MESSAGE"] = "Empty message received";
  FilterError2["MISSING_PUBSUB_TOPIC"] = "Pubsub topic missing from push message";
})(FilterError || (FilterError = {}));
var ProtocolError2;
(function(ProtocolError3) {
  ProtocolError3["GENERIC_FAIL"] = "Generic error";
  ProtocolError3["REMOTE_PEER_REJECTED"] = "Remote peer rejected";
  ProtocolError3["DECODE_FAILED"] = "Failed to decode";
  ProtocolError3["NO_PEER_AVAILABLE"] = "No peer available";
  ProtocolError3["NO_STREAM_AVAILABLE"] = "No stream available";
  ProtocolError3["NO_RESPONSE"] = "No response received";
  ProtocolError3["ENCODE_FAILED"] = "Failed to encode";
  ProtocolError3["EMPTY_PAYLOAD"] = "Payload is empty";
  ProtocolError3["SIZE_TOO_BIG"] = "Size is too big";
  ProtocolError3["TOPIC_NOT_CONFIGURED"] = "Topic not configured";
  ProtocolError3["STREAM_ABORTED"] = "Stream aborted";
  ProtocolError3["RLN_PROOF_GENERATION"] = "Proof generation failed";
  ProtocolError3["TOPIC_DECODER_MISMATCH"] = "Topic decoder mismatch";
  ProtocolError3["INVALID_DECODER_TOPICS"] = "Invalid decoder topics";
})(ProtocolError2 || (ProtocolError2 = {}));

// node_modules/@waku/interfaces/dist/waku.js
var WakuEvent;
(function(WakuEvent2) {
  WakuEvent2["Connection"] = "waku:connection";
  WakuEvent2["Health"] = "waku:health";
})(WakuEvent || (WakuEvent = {}));

// node_modules/@waku/interfaces/dist/connection_manager.js
var Tags;
(function(Tags2) {
  Tags2["BOOTSTRAP"] = "bootstrap";
  Tags2["PEER_EXCHANGE"] = "peer-exchange";
  Tags2["PEER_CACHE"] = "peer-cache";
})(Tags || (Tags = {}));
var CONNECTION_LOCKED_TAG = "locked";

// node_modules/@waku/interfaces/dist/dns_discovery.js
var DNS_DISCOVERY_TAG = "@waku/bootstrap";

// node_modules/@waku/interfaces/dist/constants.js
var DEFAULT_CLUSTER_ID = 1;
var DEFAULT_NUM_SHARDS = 8;
var DefaultNetworkConfig = {
  clusterId: DEFAULT_CLUSTER_ID,
  numShardsInCluster: DEFAULT_NUM_SHARDS
};

// node_modules/@waku/interfaces/dist/health_status.js
var HealthStatus;
(function(HealthStatus2) {
  HealthStatus2["Unhealthy"] = "Unhealthy";
  HealthStatus2["MinimallyHealthy"] = "MinimallyHealthy";
  HealthStatus2["SufficientlyHealthy"] = "SufficientlyHealthy";
})(HealthStatus || (HealthStatus = {}));

// node_modules/it-all/dist/src/index.js
function isAsyncIterable(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function all(source) {
  if (isAsyncIterable(source)) {
    return (async () => {
      const arr2 = [];
      for await (const entry of source) {
        arr2.push(entry);
      }
      return arr2;
    })();
  }
  const arr = [];
  for (const entry of source) {
    arr.push(entry);
  }
  return arr;
}
var src_default = all;

// node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array(buf) {
  return buf;
}

// node_modules/uint8arrays/dist/src/concat.js
function concat2(arrays, length3) {
  if (length3 == null) {
    length3 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe(length3);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output);
}

// node_modules/uint8arrays/dist/src/equals.js
function equals3(a2, b) {
  if (a2 === b) {
    return true;
  }
  if (a2.byteLength !== b.byteLength) {
    return false;
  }
  for (let i2 = 0; i2 < a2.byteLength; i2++) {
    if (a2[i2] !== b[i2]) {
      return false;
    }
  }
  return true;
}

// node_modules/uint8arraylist/dist/src/index.js
var symbol = Symbol.for("@achingbrain/uint8arraylist");
function findBufAndOffset(bufs, index) {
  if (index == null || index < 0) {
    throw new RangeError("index is out of bounds");
  }
  let offset = 0;
  for (const buf of bufs) {
    const bufEnd = offset + buf.byteLength;
    if (index < bufEnd) {
      return {
        buf,
        index: index - offset
      };
    }
    offset = bufEnd;
  }
  throw new RangeError("index is out of bounds");
}
function isUint8ArrayList(value) {
  return Boolean(value == null ? void 0 : value[symbol]);
}
var _a2;
var Uint8ArrayList = class _Uint8ArrayList {
  constructor(...data) {
    __publicField(this, "bufs");
    __publicField(this, "length");
    __publicField(this, _a2, true);
    this.bufs = [];
    this.length = 0;
    if (data.length > 0) {
      this.appendAll(data);
    }
  }
  *[(_a2 = symbol, Symbol.iterator)]() {
    yield* this.bufs;
  }
  get byteLength() {
    return this.length;
  }
  /**
   * Add one or more `bufs` to the end of this Uint8ArrayList
   */
  append(...bufs) {
    this.appendAll(bufs);
  }
  /**
   * Add all `bufs` to the end of this Uint8ArrayList
   */
  appendAll(bufs) {
    let length3 = 0;
    for (const buf of bufs) {
      if (buf instanceof Uint8Array) {
        length3 += buf.byteLength;
        this.bufs.push(buf);
      } else if (isUint8ArrayList(buf)) {
        length3 += buf.byteLength;
        this.bufs.push(...buf.bufs);
      } else {
        throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length3;
  }
  /**
   * Add one or more `bufs` to the start of this Uint8ArrayList
   */
  prepend(...bufs) {
    this.prependAll(bufs);
  }
  /**
   * Add all `bufs` to the start of this Uint8ArrayList
   */
  prependAll(bufs) {
    let length3 = 0;
    for (const buf of bufs.reverse()) {
      if (buf instanceof Uint8Array) {
        length3 += buf.byteLength;
        this.bufs.unshift(buf);
      } else if (isUint8ArrayList(buf)) {
        length3 += buf.byteLength;
        this.bufs.unshift(...buf.bufs);
      } else {
        throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length3;
  }
  /**
   * Read the value at `index`
   */
  get(index) {
    const res = findBufAndOffset(this.bufs, index);
    return res.buf[res.index];
  }
  /**
   * Set the value at `index` to `value`
   */
  set(index, value) {
    const res = findBufAndOffset(this.bufs, index);
    res.buf[res.index] = value;
  }
  /**
   * Copy bytes from `buf` to the index specified by `offset`
   */
  write(buf, offset = 0) {
    if (buf instanceof Uint8Array) {
      for (let i2 = 0; i2 < buf.length; i2++) {
        this.set(offset + i2, buf[i2]);
      }
    } else if (isUint8ArrayList(buf)) {
      for (let i2 = 0; i2 < buf.length; i2++) {
        this.set(offset + i2, buf.get(i2));
      }
    } else {
      throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
    }
  }
  /**
   * Remove bytes from the front of the pool
   */
  consume(bytes) {
    bytes = Math.trunc(bytes);
    if (Number.isNaN(bytes) || bytes <= 0) {
      return;
    }
    if (bytes === this.byteLength) {
      this.bufs = [];
      this.length = 0;
      return;
    }
    while (this.bufs.length > 0) {
      if (bytes >= this.bufs[0].byteLength) {
        bytes -= this.bufs[0].byteLength;
        this.length -= this.bufs[0].byteLength;
        this.bufs.shift();
      } else {
        this.bufs[0] = this.bufs[0].subarray(bytes);
        this.length -= bytes;
        break;
      }
    }
  }
  /**
   * Extracts a section of an array and returns a new array.
   *
   * This is a copy operation as it is with Uint8Arrays and Arrays
   * - note this is different to the behaviour of Node Buffers.
   */
  slice(beginInclusive, endExclusive) {
    const { bufs, length: length3 } = this._subList(beginInclusive, endExclusive);
    return concat2(bufs, length3);
  }
  /**
   * Returns a alloc from the given start and end element index.
   *
   * In the best case where the data extracted comes from a single Uint8Array
   * internally this is a no-copy operation otherwise it is a copy operation.
   */
  subarray(beginInclusive, endExclusive) {
    const { bufs, length: length3 } = this._subList(beginInclusive, endExclusive);
    if (bufs.length === 1) {
      return bufs[0];
    }
    return concat2(bufs, length3);
  }
  /**
   * Returns a allocList from the given start and end element index.
   *
   * This is a no-copy operation.
   */
  sublist(beginInclusive, endExclusive) {
    const { bufs, length: length3 } = this._subList(beginInclusive, endExclusive);
    const list = new _Uint8ArrayList();
    list.length = length3;
    list.bufs = [...bufs];
    return list;
  }
  _subList(beginInclusive, endExclusive) {
    beginInclusive = beginInclusive ?? 0;
    endExclusive = endExclusive ?? this.length;
    if (beginInclusive < 0) {
      beginInclusive = this.length + beginInclusive;
    }
    if (endExclusive < 0) {
      endExclusive = this.length + endExclusive;
    }
    if (beginInclusive < 0 || endExclusive > this.length) {
      throw new RangeError("index is out of bounds");
    }
    if (beginInclusive === endExclusive) {
      return { bufs: [], length: 0 };
    }
    if (beginInclusive === 0 && endExclusive === this.length) {
      return { bufs: this.bufs, length: this.length };
    }
    const bufs = [];
    let offset = 0;
    for (let i2 = 0; i2 < this.bufs.length; i2++) {
      const buf = this.bufs[i2];
      const bufStart = offset;
      const bufEnd = bufStart + buf.byteLength;
      offset = bufEnd;
      if (beginInclusive >= bufEnd) {
        continue;
      }
      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;
      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;
      if (sliceStartInBuf && sliceEndsInBuf) {
        if (beginInclusive === bufStart && endExclusive === bufEnd) {
          bufs.push(buf);
          break;
        }
        const start2 = beginInclusive - bufStart;
        bufs.push(buf.subarray(start2, start2 + (endExclusive - beginInclusive)));
        break;
      }
      if (sliceStartInBuf) {
        if (beginInclusive === 0) {
          bufs.push(buf);
          continue;
        }
        bufs.push(buf.subarray(beginInclusive - bufStart));
        continue;
      }
      if (sliceEndsInBuf) {
        if (endExclusive === bufEnd) {
          bufs.push(buf);
          break;
        }
        bufs.push(buf.subarray(0, endExclusive - bufStart));
        break;
      }
      bufs.push(buf);
    }
    return { bufs, length: endExclusive - beginInclusive };
  }
  indexOf(search, offset = 0) {
    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {
      throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
    }
    const needle = search instanceof Uint8Array ? search : search.subarray();
    offset = Number(offset ?? 0);
    if (isNaN(offset)) {
      offset = 0;
    }
    if (offset < 0) {
      offset = this.length + offset;
    }
    if (offset < 0) {
      offset = 0;
    }
    if (search.length === 0) {
      return offset > this.length ? this.length : offset;
    }
    const M = needle.byteLength;
    if (M === 0) {
      throw new TypeError("search must be at least 1 byte long");
    }
    const radix = 256;
    const rightmostPositions = new Int32Array(radix);
    for (let c2 = 0; c2 < radix; c2++) {
      rightmostPositions[c2] = -1;
    }
    for (let j = 0; j < M; j++) {
      rightmostPositions[needle[j]] = j;
    }
    const right = rightmostPositions;
    const lastIndex = this.byteLength - needle.byteLength;
    const lastPatIndex = needle.byteLength - 1;
    let skip;
    for (let i2 = offset; i2 <= lastIndex; i2 += skip) {
      skip = 0;
      for (let j = lastPatIndex; j >= 0; j--) {
        const char = this.get(i2 + j);
        if (needle[j] !== char) {
          skip = Math.max(1, j - right[char]);
          break;
        }
      }
      if (skip === 0) {
        return i2;
      }
    }
    return -1;
  }
  getInt8(byteOffset) {
    const buf = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getInt8(0);
  }
  setInt8(byteOffset, value) {
    const buf = allocUnsafe(1);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setInt8(0, value);
    this.write(buf, byteOffset);
  }
  getInt16(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getInt16(0, littleEndian);
  }
  setInt16(byteOffset, value, littleEndian) {
    const buf = alloc(2);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setInt16(0, value, littleEndian);
    this.write(buf, byteOffset);
  }
  getInt32(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getInt32(0, littleEndian);
  }
  setInt32(byteOffset, value, littleEndian) {
    const buf = alloc(4);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setInt32(0, value, littleEndian);
    this.write(buf, byteOffset);
  }
  getBigInt64(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getBigInt64(0, littleEndian);
  }
  setBigInt64(byteOffset, value, littleEndian) {
    const buf = alloc(8);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setBigInt64(0, value, littleEndian);
    this.write(buf, byteOffset);
  }
  getUint8(byteOffset) {
    const buf = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getUint8(0);
  }
  setUint8(byteOffset, value) {
    const buf = allocUnsafe(1);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setUint8(0, value);
    this.write(buf, byteOffset);
  }
  getUint16(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getUint16(0, littleEndian);
  }
  setUint16(byteOffset, value, littleEndian) {
    const buf = alloc(2);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setUint16(0, value, littleEndian);
    this.write(buf, byteOffset);
  }
  getUint32(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getUint32(0, littleEndian);
  }
  setUint32(byteOffset, value, littleEndian) {
    const buf = alloc(4);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setUint32(0, value, littleEndian);
    this.write(buf, byteOffset);
  }
  getBigUint64(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getBigUint64(0, littleEndian);
  }
  setBigUint64(byteOffset, value, littleEndian) {
    const buf = alloc(8);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setBigUint64(0, value, littleEndian);
    this.write(buf, byteOffset);
  }
  getFloat32(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getFloat32(0, littleEndian);
  }
  setFloat32(byteOffset, value, littleEndian) {
    const buf = alloc(4);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setFloat32(0, value, littleEndian);
    this.write(buf, byteOffset);
  }
  getFloat64(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getFloat64(0, littleEndian);
  }
  setFloat64(byteOffset, value, littleEndian) {
    const buf = alloc(8);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setFloat64(0, value, littleEndian);
    this.write(buf, byteOffset);
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (!(other instanceof _Uint8ArrayList)) {
      return false;
    }
    if (other.bufs.length !== this.bufs.length) {
      return false;
    }
    for (let i2 = 0; i2 < this.bufs.length; i2++) {
      if (!equals3(this.bufs[i2], other.bufs[i2])) {
        return false;
      }
    }
    return true;
  }
  /**
   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this
   * method if you know the total size of all the Uint8Arrays ahead of time.
   */
  static fromUint8Arrays(bufs, length3) {
    const list = new _Uint8ArrayList();
    list.bufs = bufs;
    if (length3 == null) {
      length3 = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);
    }
    list.length = length3;
    return list;
  }
};

// node_modules/@waku/core/node_modules/it-length-prefixed/dist/src/utils.js
function isAsyncIterable2(thing) {
  return thing[Symbol.asyncIterator] != null;
}

// node_modules/@waku/core/node_modules/it-length-prefixed/dist/src/encode.js
var defaultEncoder = (length3) => {
  const lengthLength = encodingLength(length3);
  const lengthBuf = allocUnsafe(lengthLength);
  encode(length3, lengthBuf);
  defaultEncoder.bytes = lengthLength;
  return lengthBuf;
};
defaultEncoder.bytes = 0;
function encode6(source, options) {
  options = options ?? {};
  const encodeLength3 = options.lengthEncoder ?? defaultEncoder;
  function* maybeYield(chunk) {
    const length3 = encodeLength3(chunk.byteLength);
    if (length3 instanceof Uint8Array) {
      yield length3;
    } else {
      yield* length3;
    }
    if (chunk instanceof Uint8Array) {
      yield chunk;
    } else {
      yield* chunk;
    }
  }
  if (isAsyncIterable2(source)) {
    return async function* () {
      for await (const chunk of source) {
        yield* maybeYield(chunk);
      }
    }();
  }
  return function* () {
    for (const chunk of source) {
      yield* maybeYield(chunk);
    }
  }();
}
encode6.single = (chunk, options) => {
  options = options ?? {};
  const encodeLength3 = options.lengthEncoder ?? defaultEncoder;
  return new Uint8ArrayList(encodeLength3(chunk.byteLength), chunk);
};

// node_modules/@waku/core/node_modules/it-length-prefixed/dist/src/errors.js
var InvalidMessageLengthError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidMessageLengthError");
    __publicField(this, "code", "ERR_INVALID_MSG_LENGTH");
  }
};
var InvalidDataLengthError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthError");
    __publicField(this, "code", "ERR_MSG_DATA_TOO_LONG");
  }
};
var InvalidDataLengthLengthError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthLengthError");
    __publicField(this, "code", "ERR_MSG_LENGTH_TOO_LONG");
  }
};
var UnexpectedEOFError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UnexpectedEOFError");
    __publicField(this, "code", "ERR_UNEXPECTED_EOF");
  }
};

// node_modules/@waku/core/node_modules/it-length-prefixed/dist/src/decode.js
var MAX_LENGTH_LENGTH = 8;
var MAX_DATA_LENGTH = 1024 * 1024 * 4;
var ReadMode;
(function(ReadMode3) {
  ReadMode3[ReadMode3["LENGTH"] = 0] = "LENGTH";
  ReadMode3[ReadMode3["DATA"] = 1] = "DATA";
})(ReadMode || (ReadMode = {}));
var defaultDecoder = (buf) => {
  const length3 = decode(buf);
  defaultDecoder.bytes = encodingLength(length3);
  return length3;
};
defaultDecoder.bytes = 0;
function decode7(source, options) {
  const buffer = new Uint8ArrayList();
  let mode = ReadMode.LENGTH;
  let dataLength = -1;
  const lengthDecoder = (options == null ? void 0 : options.lengthDecoder) ?? defaultDecoder;
  const maxLengthLength = (options == null ? void 0 : options.maxLengthLength) ?? MAX_LENGTH_LENGTH;
  const maxDataLength = (options == null ? void 0 : options.maxDataLength) ?? MAX_DATA_LENGTH;
  function* maybeYield() {
    while (buffer.byteLength > 0) {
      if (mode === ReadMode.LENGTH) {
        try {
          dataLength = lengthDecoder(buffer);
          if (dataLength < 0) {
            throw new InvalidMessageLengthError("Invalid message length");
          }
          if (dataLength > maxDataLength) {
            throw new InvalidDataLengthError("Message length too long");
          }
          const dataLengthLength = lengthDecoder.bytes;
          buffer.consume(dataLengthLength);
          if ((options == null ? void 0 : options.onLength) != null) {
            options.onLength(dataLength);
          }
          mode = ReadMode.DATA;
        } catch (err) {
          if (err instanceof RangeError) {
            if (buffer.byteLength > maxLengthLength) {
              throw new InvalidDataLengthLengthError("Message length length too long");
            }
            break;
          }
          throw err;
        }
      }
      if (mode === ReadMode.DATA) {
        if (buffer.byteLength < dataLength) {
          break;
        }
        const data = buffer.sublist(0, dataLength);
        buffer.consume(dataLength);
        if ((options == null ? void 0 : options.onData) != null) {
          options.onData(data);
        }
        yield data;
        mode = ReadMode.LENGTH;
      }
    }
  }
  if (isAsyncIterable2(source)) {
    return async function* () {
      for await (const buf of source) {
        buffer.append(buf);
        yield* maybeYield();
      }
      if (buffer.byteLength > 0) {
        throw new UnexpectedEOFError("Unexpected end of input");
      }
    }();
  }
  return function* () {
    for (const buf of source) {
      buffer.append(buf);
      yield* maybeYield();
    }
    if (buffer.byteLength > 0) {
      throw new UnexpectedEOFError("Unexpected end of input");
    }
  }();
}
decode7.fromReader = (reader, options) => {
  let byteLength = 1;
  const varByteSource = async function* () {
    while (true) {
      try {
        const { done, value } = await reader.next(byteLength);
        if (done === true) {
          return;
        }
        if (value != null) {
          yield value;
        }
      } catch (err) {
        if (err.code === "ERR_UNDER_READ") {
          return { done: true, value: null };
        }
        throw err;
      } finally {
        byteLength = 1;
      }
    }
  }();
  const onLength = (l2) => {
    byteLength = l2;
  };
  return decode7(varByteSource, {
    ...options ?? {},
    onLength
  });
};

// node_modules/p-defer/index.js
function pDefer() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

// node_modules/it-pushable/dist/src/fifo.js
var FixedFIFO = class {
  constructor(hwm) {
    __publicField(this, "buffer");
    __publicField(this, "mask");
    __publicField(this, "top");
    __publicField(this, "btm");
    __publicField(this, "next");
    if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
      throw new Error("Max size for a FixedFIFO should be a power of two");
    }
    this.buffer = new Array(hwm);
    this.mask = hwm - 1;
    this.top = 0;
    this.btm = 0;
    this.next = null;
  }
  push(data) {
    if (this.buffer[this.top] !== void 0) {
      return false;
    }
    this.buffer[this.top] = data;
    this.top = this.top + 1 & this.mask;
    return true;
  }
  shift() {
    const last = this.buffer[this.btm];
    if (last === void 0) {
      return void 0;
    }
    this.buffer[this.btm] = void 0;
    this.btm = this.btm + 1 & this.mask;
    return last;
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
};
var FIFO = class {
  constructor(options = {}) {
    __publicField(this, "size");
    __publicField(this, "hwm");
    __publicField(this, "head");
    __publicField(this, "tail");
    this.hwm = options.splitLimit ?? 16;
    this.head = new FixedFIFO(this.hwm);
    this.tail = this.head;
    this.size = 0;
  }
  calculateSize(obj) {
    if ((obj == null ? void 0 : obj.byteLength) != null) {
      return obj.byteLength;
    }
    return 1;
  }
  push(val) {
    if ((val == null ? void 0 : val.value) != null) {
      this.size += this.calculateSize(val.value);
    }
    if (!this.head.push(val)) {
      const prev = this.head;
      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
      this.head.push(val);
    }
  }
  shift() {
    let val = this.tail.shift();
    if (val === void 0 && this.tail.next != null) {
      const next = this.tail.next;
      this.tail.next = null;
      this.tail = next;
      val = this.tail.shift();
    }
    if ((val == null ? void 0 : val.value) != null) {
      this.size -= this.calculateSize(val.value);
    }
    return val;
  }
  isEmpty() {
    return this.head.isEmpty();
  }
};

// node_modules/it-pushable/dist/src/index.js
var AbortError2 = class extends Error {
  constructor(message2, code2) {
    super(message2 ?? "The operation was aborted");
    __publicField(this, "type");
    __publicField(this, "code");
    this.type = "aborted";
    this.code = code2 ?? "ABORT_ERR";
  }
};
function pushable(options = {}) {
  const getNext = (buffer) => {
    const next = buffer.shift();
    if (next == null) {
      return { done: true };
    }
    if (next.error != null) {
      throw next.error;
    }
    return {
      done: next.done === true,
      // @ts-expect-error if done is false, value will be present
      value: next.value
    };
  };
  return _pushable(getNext, options);
}
function _pushable(getNext, options) {
  options = options ?? {};
  let onEnd = options.onEnd;
  let buffer = new FIFO();
  let pushable2;
  let onNext;
  let ended;
  let drain2 = pDefer();
  const waitNext = async () => {
    try {
      if (!buffer.isEmpty()) {
        return getNext(buffer);
      }
      if (ended) {
        return { done: true };
      }
      return await new Promise((resolve, reject) => {
        onNext = (next) => {
          onNext = null;
          buffer.push(next);
          try {
            resolve(getNext(buffer));
          } catch (err) {
            reject(err);
          }
          return pushable2;
        };
      });
    } finally {
      if (buffer.isEmpty()) {
        queueMicrotask(() => {
          drain2.resolve();
          drain2 = pDefer();
        });
      }
    }
  };
  const bufferNext = (next) => {
    if (onNext != null) {
      return onNext(next);
    }
    buffer.push(next);
    return pushable2;
  };
  const bufferError = (err) => {
    buffer = new FIFO();
    if (onNext != null) {
      return onNext({ error: err });
    }
    buffer.push({ error: err });
    return pushable2;
  };
  const push = (value) => {
    if (ended) {
      return pushable2;
    }
    if ((options == null ? void 0 : options.objectMode) !== true && (value == null ? void 0 : value.byteLength) == null) {
      throw new Error("objectMode was not true but tried to push non-Uint8Array value");
    }
    return bufferNext({ done: false, value });
  };
  const end = (err) => {
    if (ended)
      return pushable2;
    ended = true;
    return err != null ? bufferError(err) : bufferNext({ done: true });
  };
  const _return = () => {
    buffer = new FIFO();
    end();
    return { done: true };
  };
  const _throw = (err) => {
    end(err);
    return { done: true };
  };
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next: waitNext,
    return: _return,
    throw: _throw,
    push,
    end,
    get readableLength() {
      return buffer.size;
    },
    onEmpty: async (options2) => {
      const signal = options2 == null ? void 0 : options2.signal;
      signal == null ? void 0 : signal.throwIfAborted();
      if (buffer.isEmpty()) {
        return;
      }
      let cancel;
      let listener;
      if (signal != null) {
        cancel = new Promise((resolve, reject) => {
          listener = () => {
            reject(new AbortError2());
          };
          signal.addEventListener("abort", listener);
        });
      }
      try {
        await Promise.race([
          drain2.promise,
          cancel
        ]);
      } finally {
        if (listener != null && signal != null) {
          signal == null ? void 0 : signal.removeEventListener("abort", listener);
        }
      }
    }
  };
  if (onEnd == null) {
    return pushable2;
  }
  const _pushable2 = pushable2;
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      return _pushable2.next();
    },
    throw(err) {
      _pushable2.throw(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return { done: true };
    },
    return() {
      _pushable2.return();
      if (onEnd != null) {
        onEnd();
        onEnd = void 0;
      }
      return { done: true };
    },
    push,
    end(err) {
      _pushable2.end(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return pushable2;
    },
    get readableLength() {
      return _pushable2.readableLength;
    },
    onEmpty: (opts) => {
      return _pushable2.onEmpty(opts);
    }
  };
  return pushable2;
}

// node_modules/it-queueless-pushable/node_modules/race-signal/dist/src/index.js
function defaultTranslate(signal) {
  return signal.reason;
}
async function raceSignal(promise, signal, opts) {
  if (signal == null) {
    return promise;
  }
  const translateError = (opts == null ? void 0 : opts.translateError) ?? defaultTranslate;
  if (signal.aborted) {
    promise.catch(() => {
    });
    return Promise.reject(translateError(signal));
  }
  let listener;
  try {
    return await Promise.race([
      promise,
      new Promise((resolve, reject) => {
        listener = () => {
          reject(translateError(signal));
        };
        signal.addEventListener("abort", listener);
      })
    ]);
  } finally {
    if (listener != null) {
      signal.removeEventListener("abort", listener);
    }
  }
}

// node_modules/it-queueless-pushable/dist/src/index.js
var QueuelessPushable = class {
  constructor() {
    __publicField(this, "readNext");
    __publicField(this, "haveNext");
    __publicField(this, "ended");
    __publicField(this, "nextResult");
    __publicField(this, "error");
    this.ended = false;
    this.readNext = pDefer();
    this.haveNext = pDefer();
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async next() {
    if (this.nextResult == null) {
      await this.haveNext.promise;
    }
    if (this.nextResult == null) {
      throw new Error("HaveNext promise resolved but nextResult was undefined");
    }
    const nextResult = this.nextResult;
    this.nextResult = void 0;
    this.readNext.resolve();
    this.readNext = pDefer();
    return nextResult;
  }
  async throw(err) {
    this.ended = true;
    this.error = err;
    if (err != null) {
      this.haveNext.promise.catch(() => {
      });
      this.haveNext.reject(err);
    }
    const result = {
      done: true,
      value: void 0
    };
    return result;
  }
  async return() {
    const result = {
      done: true,
      value: void 0
    };
    this.ended = true;
    this.nextResult = result;
    this.haveNext.resolve();
    return result;
  }
  async push(value, options) {
    await this._push(value, options);
  }
  async end(err, options) {
    if (err != null) {
      await this.throw(err);
    } else {
      await this._push(void 0, options);
    }
  }
  async _push(value, options) {
    if (value != null && this.ended) {
      throw this.error ?? new Error("Cannot push value onto an ended pushable");
    }
    while (this.nextResult != null) {
      await this.readNext.promise;
    }
    if (value != null) {
      this.nextResult = { done: false, value };
    } else {
      this.ended = true;
      this.nextResult = { done: true, value: void 0 };
    }
    this.haveNext.resolve();
    this.haveNext = pDefer();
    await raceSignal(this.readNext.promise, options == null ? void 0 : options.signal, options);
  }
};
function queuelessPushable() {
  return new QueuelessPushable();
}

// node_modules/it-merge/dist/src/index.js
function isAsyncIterable3(thing) {
  return thing[Symbol.asyncIterator] != null;
}
async function addAllToPushable(sources, output, signal) {
  try {
    await Promise.all(sources.map(async (source) => {
      for await (const item of source) {
        await output.push(item, {
          signal
        });
        signal.throwIfAborted();
      }
    }));
    await output.end(void 0, {
      signal
    });
  } catch (err) {
    await output.end(err, {
      signal
    }).catch(() => {
    });
  }
}
async function* mergeSources(sources) {
  const controller = new AbortController();
  const output = queuelessPushable();
  addAllToPushable(sources, output, controller.signal).catch(() => {
  });
  try {
    yield* output;
  } finally {
    controller.abort();
  }
}
function* mergeSyncSources(syncSources) {
  for (const source of syncSources) {
    yield* source;
  }
}
function merge(...sources) {
  const syncSources = [];
  for (const source of sources) {
    if (!isAsyncIterable3(source)) {
      syncSources.push(source);
    }
  }
  if (syncSources.length === sources.length) {
    return mergeSyncSources(syncSources);
  }
  return mergeSources(sources);
}
var src_default2 = merge;

// node_modules/it-pipe/dist/src/index.js
function pipe(first, ...rest) {
  if (first == null) {
    throw new Error("Empty pipeline");
  }
  if (isDuplex(first)) {
    const duplex = first;
    first = () => duplex.source;
  } else if (isIterable(first) || isAsyncIterable4(first)) {
    const source = first;
    first = () => source;
  }
  const fns = [first, ...rest];
  if (fns.length > 1) {
    if (isDuplex(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
  }
  if (fns.length > 2) {
    for (let i2 = 1; i2 < fns.length - 1; i2++) {
      if (isDuplex(fns[i2])) {
        fns[i2] = duplexPipelineFn(fns[i2]);
      }
    }
  }
  return rawPipe(...fns);
}
var rawPipe = (...fns) => {
  let res;
  while (fns.length > 0) {
    res = fns.shift()(res);
  }
  return res;
};
var isAsyncIterable4 = (obj) => {
  return (obj == null ? void 0 : obj[Symbol.asyncIterator]) != null;
};
var isIterable = (obj) => {
  return (obj == null ? void 0 : obj[Symbol.iterator]) != null;
};
var isDuplex = (obj) => {
  if (obj == null) {
    return false;
  }
  return obj.sink != null && obj.source != null;
};
var duplexPipelineFn = (duplex) => {
  return (source) => {
    const p2 = duplex.sink(source);
    if ((p2 == null ? void 0 : p2.then) != null) {
      const stream = pushable({
        objectMode: true
      });
      p2.then(() => {
        stream.end();
      }, (err) => {
        stream.end(err);
      });
      let sourceWrap;
      const source2 = duplex.source;
      if (isAsyncIterable4(source2)) {
        sourceWrap = async function* () {
          yield* source2;
          stream.end();
        };
      } else if (isIterable(source2)) {
        sourceWrap = function* () {
          yield* source2;
          stream.end();
        };
      } else {
        throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");
      }
      return src_default2(stream, sourceWrap());
    }
    return duplex.source;
  };
};

// node_modules/@waku/core/dist/lib/stream_manager/utils.js
function selectOpenConnection(connections) {
  return connections.filter((c2) => c2.status === "open").sort((left, right) => right.timeline.open - left.timeline.open).at(0);
}

// node_modules/@waku/core/dist/lib/stream_manager/stream_manager.js
var STREAM_LOCK_KEY = "consumed";
var StreamManager = class {
  constructor(multicodec, libp2p) {
    __publicField(this, "multicodec");
    __publicField(this, "libp2p");
    __publicField(this, "log");
    __publicField(this, "ongoingCreation", /* @__PURE__ */ new Set());
    __publicField(this, "streamPool", /* @__PURE__ */ new Map());
    __publicField(this, "handlePeerUpdateStreamPool", (evt) => {
      const { peer } = evt.detail;
      if (!peer.protocols.includes(this.multicodec)) {
        return;
      }
      const stream = this.getOpenStreamForCodec(peer.id);
      if (stream) {
        return;
      }
      this.scheduleNewStream(peer);
    });
    this.multicodec = multicodec;
    this.libp2p = libp2p;
    this.log = new Logger(`stream-manager:${multicodec}`);
    this.libp2p.events.addEventListener("peer:update", this.handlePeerUpdateStreamPool);
  }
  async getStream(peerId2) {
    try {
      const peerIdStr = peerId2.toString();
      const scheduledStream = this.streamPool.get(peerIdStr);
      if (scheduledStream) {
        this.streamPool.delete(peerIdStr);
        await scheduledStream;
      }
      const stream = this.getOpenStreamForCodec(peerId2) || await this.createStream(peerId2);
      if (!stream) {
        return;
      }
      this.log.info(`Using stream for peerId=${peerIdStr} multicodec=${this.multicodec}`);
      this.lockStream(peerIdStr, stream);
      return stream;
    } catch (error) {
      this.log.error(`Failed to getStream:`, error);
      return;
    }
  }
  async createStream(peerId2, retries = 0) {
    const connections = this.libp2p.connectionManager.getConnections(peerId2);
    const connection = selectOpenConnection(connections);
    if (!connection) {
      this.log.error(`Failed to get a connection to the peer peerId=${peerId2.toString()} multicodec=${this.multicodec}`);
      return;
    }
    let lastError;
    let stream;
    for (let i2 = 0; i2 < retries + 1; i2++) {
      try {
        this.log.info(`Attempting to create a stream for peerId=${peerId2.toString()} multicodec=${this.multicodec}`);
        stream = await connection.newStream(this.multicodec);
        this.log.info(`Created stream for peerId=${peerId2.toString()} multicodec=${this.multicodec}`);
        break;
      } catch (error) {
        lastError = error;
      }
    }
    if (!stream) {
      this.log.error(`Failed to create a new stream for ${peerId2.toString()} -- ` + lastError);
      return;
    }
    return stream;
  }
  async createStreamWithLock(peer) {
    const peerId2 = peer.id.toString();
    if (this.ongoingCreation.has(peerId2)) {
      this.log.info(`Skipping creation of a stream due to lock for peerId=${peerId2} multicodec=${this.multicodec}`);
      return;
    }
    try {
      this.ongoingCreation.add(peerId2);
      await this.createStream(peer.id);
    } catch (error) {
      this.log.error(`Failed to createStreamWithLock:`, error);
    } finally {
      this.ongoingCreation.delete(peerId2);
    }
    return;
  }
  scheduleNewStream(peer) {
    this.log.info(`Scheduling creation of a stream for peerId=${peer.id.toString()} multicodec=${this.multicodec}`);
    if (this.streamPool.has(peer.id.toString())) {
      this.streamPool.delete(peer.id.toString());
    }
    this.streamPool.set(peer.id.toString(), this.createStreamWithLock(peer));
  }
  getOpenStreamForCodec(peerId2) {
    const connections = this.libp2p.connectionManager.getConnections(peerId2);
    const connection = selectOpenConnection(connections);
    if (!connection) {
      this.log.info(`No open connection found for peerId=${peerId2.toString()} multicodec=${this.multicodec}`);
      return;
    }
    const stream = connection.streams.find((s2) => s2.protocol === this.multicodec);
    if (!stream) {
      this.log.info(`No open stream found for peerId=${peerId2.toString()} multicodec=${this.multicodec}`);
      return;
    }
    const isStreamUnusable = ["done", "closed", "closing"].includes(stream.writeStatus || "");
    if (isStreamUnusable || this.isStreamLocked(stream)) {
      this.log.info(`Stream for peerId=${peerId2.toString()} multicodec=${this.multicodec} is unusable`);
      return;
    }
    this.log.info(`Found open stream for peerId=${peerId2.toString()} multicodec=${this.multicodec}`);
    return stream;
  }
  lockStream(peerId2, stream) {
    this.log.info(`Locking stream for peerId:${peerId2}	streamId:${stream.id}`);
    stream.metadata[STREAM_LOCK_KEY] = true;
  }
  isStreamLocked(stream) {
    return !!stream.metadata[STREAM_LOCK_KEY];
  }
};

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i2 = 0; i2 < str.length; ++i2) {
    bytes.push(str.charCodeAt(i2));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name3, version5, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version5;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i2 = 0; i2 < 16; ++i2) {
        buf[offset + i2] = bytes[i2];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name3;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (let i2 = 0; i2 < msg.length; ++i2) {
      bytes[i2] = msg.charCodeAt(i2);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i2 = 0; i2 < length32; i2 += 8) {
    const x = input[i2 >> 5] >>> i2 % 32 & 255;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a2 = 1732584193;
  let b = -271733879;
  let c2 = -1732584194;
  let d2 = 271733878;
  for (let i2 = 0; i2 < x.length; i2 += 16) {
    const olda = a2;
    const oldb = b;
    const oldc = c2;
    const oldd = d2;
    a2 = md5ff(a2, b, c2, d2, x[i2], 7, -680876936);
    d2 = md5ff(d2, a2, b, c2, x[i2 + 1], 12, -389564586);
    c2 = md5ff(c2, d2, a2, b, x[i2 + 2], 17, 606105819);
    b = md5ff(b, c2, d2, a2, x[i2 + 3], 22, -1044525330);
    a2 = md5ff(a2, b, c2, d2, x[i2 + 4], 7, -176418897);
    d2 = md5ff(d2, a2, b, c2, x[i2 + 5], 12, 1200080426);
    c2 = md5ff(c2, d2, a2, b, x[i2 + 6], 17, -1473231341);
    b = md5ff(b, c2, d2, a2, x[i2 + 7], 22, -45705983);
    a2 = md5ff(a2, b, c2, d2, x[i2 + 8], 7, 1770035416);
    d2 = md5ff(d2, a2, b, c2, x[i2 + 9], 12, -1958414417);
    c2 = md5ff(c2, d2, a2, b, x[i2 + 10], 17, -42063);
    b = md5ff(b, c2, d2, a2, x[i2 + 11], 22, -1990404162);
    a2 = md5ff(a2, b, c2, d2, x[i2 + 12], 7, 1804603682);
    d2 = md5ff(d2, a2, b, c2, x[i2 + 13], 12, -40341101);
    c2 = md5ff(c2, d2, a2, b, x[i2 + 14], 17, -1502002290);
    b = md5ff(b, c2, d2, a2, x[i2 + 15], 22, 1236535329);
    a2 = md5gg(a2, b, c2, d2, x[i2 + 1], 5, -165796510);
    d2 = md5gg(d2, a2, b, c2, x[i2 + 6], 9, -1069501632);
    c2 = md5gg(c2, d2, a2, b, x[i2 + 11], 14, 643717713);
    b = md5gg(b, c2, d2, a2, x[i2], 20, -373897302);
    a2 = md5gg(a2, b, c2, d2, x[i2 + 5], 5, -701558691);
    d2 = md5gg(d2, a2, b, c2, x[i2 + 10], 9, 38016083);
    c2 = md5gg(c2, d2, a2, b, x[i2 + 15], 14, -660478335);
    b = md5gg(b, c2, d2, a2, x[i2 + 4], 20, -405537848);
    a2 = md5gg(a2, b, c2, d2, x[i2 + 9], 5, 568446438);
    d2 = md5gg(d2, a2, b, c2, x[i2 + 14], 9, -1019803690);
    c2 = md5gg(c2, d2, a2, b, x[i2 + 3], 14, -187363961);
    b = md5gg(b, c2, d2, a2, x[i2 + 8], 20, 1163531501);
    a2 = md5gg(a2, b, c2, d2, x[i2 + 13], 5, -1444681467);
    d2 = md5gg(d2, a2, b, c2, x[i2 + 2], 9, -51403784);
    c2 = md5gg(c2, d2, a2, b, x[i2 + 7], 14, 1735328473);
    b = md5gg(b, c2, d2, a2, x[i2 + 12], 20, -1926607734);
    a2 = md5hh(a2, b, c2, d2, x[i2 + 5], 4, -378558);
    d2 = md5hh(d2, a2, b, c2, x[i2 + 8], 11, -2022574463);
    c2 = md5hh(c2, d2, a2, b, x[i2 + 11], 16, 1839030562);
    b = md5hh(b, c2, d2, a2, x[i2 + 14], 23, -35309556);
    a2 = md5hh(a2, b, c2, d2, x[i2 + 1], 4, -1530992060);
    d2 = md5hh(d2, a2, b, c2, x[i2 + 4], 11, 1272893353);
    c2 = md5hh(c2, d2, a2, b, x[i2 + 7], 16, -155497632);
    b = md5hh(b, c2, d2, a2, x[i2 + 10], 23, -1094730640);
    a2 = md5hh(a2, b, c2, d2, x[i2 + 13], 4, 681279174);
    d2 = md5hh(d2, a2, b, c2, x[i2], 11, -358537222);
    c2 = md5hh(c2, d2, a2, b, x[i2 + 3], 16, -722521979);
    b = md5hh(b, c2, d2, a2, x[i2 + 6], 23, 76029189);
    a2 = md5hh(a2, b, c2, d2, x[i2 + 9], 4, -640364487);
    d2 = md5hh(d2, a2, b, c2, x[i2 + 12], 11, -421815835);
    c2 = md5hh(c2, d2, a2, b, x[i2 + 15], 16, 530742520);
    b = md5hh(b, c2, d2, a2, x[i2 + 2], 23, -995338651);
    a2 = md5ii(a2, b, c2, d2, x[i2], 6, -198630844);
    d2 = md5ii(d2, a2, b, c2, x[i2 + 7], 10, 1126891415);
    c2 = md5ii(c2, d2, a2, b, x[i2 + 14], 15, -1416354905);
    b = md5ii(b, c2, d2, a2, x[i2 + 5], 21, -57434055);
    a2 = md5ii(a2, b, c2, d2, x[i2 + 12], 6, 1700485571);
    d2 = md5ii(d2, a2, b, c2, x[i2 + 3], 10, -1894986606);
    c2 = md5ii(c2, d2, a2, b, x[i2 + 10], 15, -1051523);
    b = md5ii(b, c2, d2, a2, x[i2 + 1], 21, -2054922799);
    a2 = md5ii(a2, b, c2, d2, x[i2 + 8], 6, 1873313359);
    d2 = md5ii(d2, a2, b, c2, x[i2 + 15], 10, -30611744);
    c2 = md5ii(c2, d2, a2, b, x[i2 + 6], 15, -1560198380);
    b = md5ii(b, c2, d2, a2, x[i2 + 13], 21, 1309151649);
    a2 = md5ii(a2, b, c2, d2, x[i2 + 4], 6, -145523070);
    d2 = md5ii(d2, a2, b, c2, x[i2 + 11], 10, -1120210379);
    c2 = md5ii(c2, d2, a2, b, x[i2 + 2], 15, 718787259);
    b = md5ii(b, c2, d2, a2, x[i2 + 9], 21, -343485551);
    a2 = safeAdd(a2, olda);
    b = safeAdd(b, oldb);
    c2 = safeAdd(c2, oldc);
    d2 = safeAdd(d2, oldd);
  }
  return [a2, b, c2, d2];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));
  for (let i2 = 0; i2 < length8; i2 += 8) {
    output[i2 >> 5] |= (input[i2 / 8] & 255) << i2 % 32;
  }
  return output;
}
function safeAdd(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num3, cnt) {
  return num3 << cnt | num3 >>> 32 - cnt;
}
function md5cmn(q, a2, b, x, s2, t2) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q), safeAdd(x, t2)), s2), b);
}
function md5ff(a2, b, c2, d2, x, s2, t2) {
  return md5cmn(b & c2 | ~b & d2, a2, b, x, s2, t2);
}
function md5gg(a2, b, c2, d2, x, s2, t2) {
  return md5cmn(b & d2 | c2 & ~d2, a2, b, x, s2, t2);
}
function md5hh(a2, b, c2, d2, x, s2, t2) {
  return md5cmn(b ^ c2 ^ d2, a2, b, x, s2, t2);
}
function md5ii(a2, b, c2, d2, x, s2, t2) {
  return md5cmn(c2 ^ (b | ~d2), a2, b, x, s2, t2);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s2, x, y, z) {
  switch (s2) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n2) {
  return x << n2 | x >>> 32 - n2;
}
function sha1(bytes) {
  const K2 = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i2 = 0; i2 < msg.length; ++i2) {
      bytes.push(msg.charCodeAt(i2));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l2 = bytes.length / 4 + 2;
  const N = Math.ceil(l2 / 16);
  const M = new Array(N);
  for (let i2 = 0; i2 < N; ++i2) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i2 * 64 + j * 4] << 24 | bytes[i2 * 64 + j * 4 + 1] << 16 | bytes[i2 * 64 + j * 4 + 2] << 8 | bytes[i2 * 64 + j * 4 + 3];
    }
    M[i2] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i2 = 0; i2 < N; ++i2) {
    const W = new Uint32Array(80);
    for (let t2 = 0; t2 < 16; ++t2) {
      W[t2] = M[i2][t2];
    }
    for (let t2 = 16; t2 < 80; ++t2) {
      W[t2] = ROTL(W[t2 - 3] ^ W[t2 - 8] ^ W[t2 - 14] ^ W[t2 - 16], 1);
    }
    let a2 = H[0];
    let b = H[1];
    let c2 = H[2];
    let d2 = H[3];
    let e2 = H[4];
    for (let t2 = 0; t2 < 80; ++t2) {
      const s2 = Math.floor(t2 / 20);
      const T = ROTL(a2, 5) + f(s2, b, c2, d2) + e2 + K2[s2] + W[t2] >>> 0;
      e2 = d2;
      d2 = c2;
      c2 = ROTL(b, 30) >>> 0;
      b = a2;
      a2 = T;
    }
    H[0] = H[0] + a2 >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c2 >>> 0;
    H[3] = H[3] + d2 >>> 0;
    H[4] = H[4] + e2 >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// node_modules/@waku/core/dist/lib/filter/filter_rpc.js
var FilterPushRpc = class _FilterPushRpc {
  constructor(proto) {
    __publicField(this, "proto");
    this.proto = proto;
  }
  static decode(bytes) {
    const res = filter_v2_exports.MessagePush.decode(bytes);
    return new _FilterPushRpc(res);
  }
  encode() {
    return filter_v2_exports.MessagePush.encode(this.proto);
  }
  get wakuMessage() {
    return this.proto.wakuMessage;
  }
  /**
   * Get the pubsub topic from the FilterPushRpc object.
   * @returns string
   */
  get pubsubTopic() {
    return this.proto.pubsubTopic;
  }
};
var FilterSubscribeRpc = class _FilterSubscribeRpc {
  constructor(proto) {
    __publicField(this, "proto");
    this.proto = proto;
  }
  static createSubscribeRequest(pubsubTopic, contentTopics) {
    return new _FilterSubscribeRpc({
      requestId: v4_default(),
      filterSubscribeType: filter_v2_exports.FilterSubscribeRequest.FilterSubscribeType.SUBSCRIBE,
      pubsubTopic,
      contentTopics
    });
  }
  static createUnsubscribeRequest(pubsubTopic, contentTopics) {
    return new _FilterSubscribeRpc({
      requestId: v4_default(),
      filterSubscribeType: filter_v2_exports.FilterSubscribeRequest.FilterSubscribeType.UNSUBSCRIBE,
      pubsubTopic,
      contentTopics
    });
  }
  static createUnsubscribeAllRequest(pubsubTopic) {
    return new _FilterSubscribeRpc({
      requestId: v4_default(),
      filterSubscribeType: filter_v2_exports.FilterSubscribeRequest.FilterSubscribeType.UNSUBSCRIBE_ALL,
      pubsubTopic,
      contentTopics: []
    });
  }
  static createSubscriberPingRequest() {
    return new _FilterSubscribeRpc({
      requestId: v4_default(),
      filterSubscribeType: filter_v2_exports.FilterSubscribeRequest.FilterSubscribeType.SUBSCRIBER_PING,
      pubsubTopic: "",
      contentTopics: []
    });
  }
  static decode(bytes) {
    const res = filter_v2_exports.FilterSubscribeRequest.decode(bytes);
    return new _FilterSubscribeRpc(res);
  }
  encode() {
    return filter_v2_exports.FilterSubscribeRequest.encode(this.proto);
  }
  get filterSubscribeType() {
    return this.proto.filterSubscribeType;
  }
  get requestId() {
    return this.proto.requestId;
  }
  get pubsubTopic() {
    return this.proto.pubsubTopic;
  }
  get contentTopics() {
    return this.proto.contentTopics;
  }
};
var FilterSubscribeResponse2 = class _FilterSubscribeResponse {
  constructor(proto) {
    __publicField(this, "proto");
    this.proto = proto;
  }
  static decode(bytes) {
    const res = filter_v2_exports.FilterSubscribeResponse.decode(bytes);
    return new _FilterSubscribeResponse(res);
  }
  encode() {
    return filter_v2_exports.FilterSubscribeResponse.encode(this.proto);
  }
  get statusCode() {
    return this.proto.statusCode;
  }
  get statusDesc() {
    return this.proto.statusDesc;
  }
  get requestId() {
    return this.proto.requestId;
  }
};

// node_modules/@waku/core/dist/lib/filter/filter.js
var log2 = new Logger("filter-core");
var FilterCodecs = {
  SUBSCRIBE: "/vac/waku/filter-subscribe/2.0.0-beta1",
  PUSH: "/vac/waku/filter-push/2.0.0-beta1"
};
var FilterCore = class {
  constructor(handleIncomingMessage, libp2p) {
    __publicField(this, "handleIncomingMessage");
    __publicField(this, "libp2p");
    __publicField(this, "streamManager");
    __publicField(this, "multicodec", FilterCodecs.SUBSCRIBE);
    this.handleIncomingMessage = handleIncomingMessage;
    this.libp2p = libp2p;
    this.streamManager = new StreamManager(FilterCodecs.SUBSCRIBE, libp2p.components);
  }
  async start() {
    try {
      await this.libp2p.handle(FilterCodecs.PUSH, this.onRequest.bind(this), {
        maxInboundStreams: 100
      });
    } catch (e2) {
      log2.error("Failed to register ", FilterCodecs.PUSH, e2);
    }
  }
  async stop() {
    try {
      await this.libp2p.unhandle(FilterCodecs.PUSH);
    } catch (e2) {
      log2.error("Failed to unregister ", FilterCodecs.PUSH, e2);
    }
  }
  async subscribe(pubsubTopic, peerId2, contentTopics) {
    const stream = await this.streamManager.getStream(peerId2);
    if (!stream) {
      return {
        success: null,
        failure: {
          error: FilterError.NO_STREAM_AVAILABLE,
          peerId: peerId2
        }
      };
    }
    const request2 = FilterSubscribeRpc.createSubscribeRequest(pubsubTopic, contentTopics);
    let res;
    try {
      res = await pipe([request2.encode()], encode6, stream, decode7, async (source) => await src_default(source));
      if (!(res == null ? void 0 : res.length)) {
        throw Error("Received no response from subscription request.");
      }
    } catch (error) {
      log2.error("Failed to send subscribe request", error);
      return {
        success: null,
        failure: {
          error: FilterError.GENERIC_FAIL,
          peerId: peerId2
        }
      };
    }
    const { statusCode, requestId, statusDesc } = FilterSubscribeResponse2.decode(res[0].slice());
    if (statusCode < 200 || statusCode >= 300) {
      log2.error(`Filter subscribe request ${requestId} failed with status code ${statusCode}: ${statusDesc}`);
      return {
        failure: {
          error: FilterError.REMOTE_PEER_REJECTED,
          peerId: peerId2
        },
        success: null
      };
    }
    return {
      failure: null,
      success: peerId2
    };
  }
  async unsubscribe(pubsubTopic, peerId2, contentTopics) {
    const stream = await this.streamManager.getStream(peerId2);
    if (!stream) {
      log2.error(`Failed to get a stream for remote peer:${peerId2.toString()}`);
      return {
        success: null,
        failure: {
          error: FilterError.NO_STREAM_AVAILABLE,
          peerId: peerId2
        }
      };
    }
    const unsubscribeRequest = FilterSubscribeRpc.createUnsubscribeRequest(pubsubTopic, contentTopics);
    try {
      await pipe([unsubscribeRequest.encode()], encode6, stream.sink);
    } catch (error) {
      log2.error("Failed to send unsubscribe request", error);
      return {
        success: null,
        failure: {
          error: FilterError.GENERIC_FAIL,
          peerId: peerId2
        }
      };
    }
    return {
      success: peerId2,
      failure: null
    };
  }
  async unsubscribeAll(pubsubTopic, peerId2) {
    const stream = await this.streamManager.getStream(peerId2);
    if (!stream) {
      log2.error(`Failed to get a stream for remote peer:${peerId2.toString()}`);
      return {
        success: null,
        failure: {
          error: FilterError.NO_STREAM_AVAILABLE,
          peerId: peerId2
        }
      };
    }
    const request2 = FilterSubscribeRpc.createUnsubscribeAllRequest(pubsubTopic);
    const res = await pipe([request2.encode()], encode6, stream, decode7, async (source) => await src_default(source));
    if (!res || !res.length) {
      return {
        failure: {
          error: FilterError.NO_RESPONSE,
          peerId: peerId2
        },
        success: null
      };
    }
    const { statusCode, requestId, statusDesc } = FilterSubscribeResponse2.decode(res[0].slice());
    if (statusCode < 200 || statusCode >= 300) {
      log2.error(`Filter unsubscribe all request ${requestId} failed with status code ${statusCode}: ${statusDesc}`);
      return {
        failure: {
          error: FilterError.REMOTE_PEER_REJECTED,
          peerId: peerId2
        },
        success: null
      };
    }
    return {
      failure: null,
      success: peerId2
    };
  }
  async ping(peerId2) {
    const stream = await this.streamManager.getStream(peerId2);
    if (!stream) {
      log2.error(`Failed to get a stream for remote peer:${peerId2.toString()}`);
      return {
        success: null,
        failure: {
          error: FilterError.NO_STREAM_AVAILABLE,
          peerId: peerId2
        }
      };
    }
    const request2 = FilterSubscribeRpc.createSubscriberPingRequest();
    let res;
    try {
      res = await pipe([request2.encode()], encode6, stream, decode7, async (source) => await src_default(source));
    } catch (error) {
      log2.error("Failed to send ping request", error);
      return {
        success: null,
        failure: {
          error: FilterError.GENERIC_FAIL,
          peerId: peerId2
        }
      };
    }
    if (!res || !res.length) {
      return {
        success: null,
        failure: {
          error: FilterError.NO_RESPONSE,
          peerId: peerId2
        }
      };
    }
    const { statusCode, requestId, statusDesc } = FilterSubscribeResponse2.decode(res[0].slice());
    if (statusCode < 200 || statusCode >= 300) {
      log2.error(`Filter ping request ${requestId} failed with status code ${statusCode}: ${statusDesc}`);
      return {
        success: null,
        failure: {
          error: FilterError.REMOTE_PEER_REJECTED,
          peerId: peerId2
        }
      };
    }
    return {
      success: peerId2,
      failure: null
    };
  }
  onRequest(streamData) {
    const { connection, stream } = streamData;
    const { remotePeer } = connection;
    log2.info(`Received message from ${remotePeer.toString()}`);
    try {
      pipe(stream, decode7, async (source) => {
        for await (const bytes of source) {
          const response = FilterPushRpc.decode(bytes.slice());
          const { pubsubTopic, wakuMessage } = response;
          if (!wakuMessage) {
            log2.error("Received empty message");
            return;
          }
          if (!pubsubTopic) {
            log2.error("Pubsub topic missing from push message");
            return;
          }
          await this.handleIncomingMessage(pubsubTopic, wakuMessage, connection.remotePeer.toString());
        }
      }).then(() => {
        log2.info("Receiving pipe closed.");
      }, async (e2) => {
        log2.error(`Error with receiving pipe on peer:${connection.remotePeer.toString()} -- stream:${stream.id} -- protocol:${stream.protocol}: `, e2);
      });
    } catch (e2) {
      log2.error("Error decoding message", e2);
    }
  }
};

// node_modules/@waku/core/dist/lib/light_push/index.js
var light_push_exports2 = {};
__export(light_push_exports2, {
  LightPushCodec: () => LightPushCodec,
  LightPushCodecV2: () => LightPushCodecV2,
  LightPushCore: () => LightPushCore
});

// node_modules/@waku/core/dist/lib/light_push/constants.js
var CODECS = {
  v2: "/vac/waku/lightpush/2.0.0-beta1",
  v3: "/vac/waku/lightpush/3.0.0"
};
var LightPushCodecV2 = CODECS.v2;
var LightPushCodec = CODECS.v3;

// node_modules/@waku/core/dist/lib/light_push/push_rpc.js
var PushRpcV2 = class _PushRpcV2 {
  constructor(proto) {
    __publicField(this, "proto");
    this.proto = proto;
  }
  static createRequest(message2, pubsubTopic) {
    return new _PushRpcV2({
      requestId: v4_default(),
      request: {
        message: message2,
        pubsubTopic
      },
      response: void 0
    });
  }
  static decode(bytes) {
    const res = light_push_exports.PushRpc.decode(bytes);
    return new _PushRpcV2(res);
  }
  encode() {
    return light_push_exports.PushRpc.encode(this.proto);
  }
  get query() {
    return this.proto.request;
  }
  get response() {
    return this.proto.response;
  }
};

// node_modules/@waku/core/dist/lib/light_push/push_rpc_v3.js
var PushRpc2 = class _PushRpc {
  constructor(proto) {
    __publicField(this, "proto");
    this.proto = proto;
  }
  /**
   * Create a v3 request message with proper field numbering
   */
  static createRequest(message2, pubsubTopic) {
    return new _PushRpc({
      requestId: v4_default(),
      pubsubTopic,
      message: message2
    });
  }
  /**
   * Create a v3 response message with status code handling
   */
  static createResponse(requestId, statusCode, statusDesc, relayPeerCount) {
    return new _PushRpc({
      requestId,
      statusCode,
      statusDesc,
      relayPeerCount
    });
  }
  /**
   * Decode v3 request message
   */
  static decodeRequest(bytes) {
    const res = light_push_exports.LightPushRequestV3.decode(bytes);
    return new _PushRpc(res);
  }
  /**
   * Decode v3 response message
   */
  static decodeResponse(bytes) {
    const res = light_push_exports.LightPushResponseV3.decode(bytes);
    return new _PushRpc(res);
  }
  /**
   * Encode message to bytes
   */
  encode() {
    if (this.isRequest()) {
      return light_push_exports.LightPushRequestV3.encode(this.proto);
    } else {
      return light_push_exports.LightPushResponseV3.encode(this.proto);
    }
  }
  /**
   * Get request data (if this is a request message)
   */
  get request() {
    return this.isRequest() ? this.proto : void 0;
  }
  /**
   * Get response data (if this is a response message)
   */
  get response() {
    return this.isResponse() ? this.proto : void 0;
  }
  /**
   * Get the request ID
   */
  get requestId() {
    return this.proto.requestId;
  }
  /**
   * Get the pubsub topic (only available in requests)
   */
  get pubsubTopic() {
    return this.isRequest() ? this.proto.pubsubTopic : void 0;
  }
  /**
   * Get the message (only available in requests)
   */
  get message() {
    return this.isRequest() ? this.proto.message : void 0;
  }
  /**
   * Get the status code (only available in responses)
   */
  get statusCode() {
    return this.isResponse() ? this.proto.statusCode : void 0;
  }
  /**
   * Get the status description (only available in responses)
   */
  get statusDesc() {
    return this.isResponse() ? this.proto.statusDesc : void 0;
  }
  /**
   * Get the relay peer count (only available in responses)
   */
  get relayPeerCount() {
    return this.isResponse() ? this.proto.relayPeerCount : void 0;
  }
  /**
   * Check if this is a request message
   */
  isRequest() {
    return "pubsubTopic" in this.proto && "message" in this.proto;
  }
  /**
   * Check if this is a response message
   */
  isResponse() {
    return "statusCode" in this.proto;
  }
};

// node_modules/@waku/core/dist/lib/light_push/utils.js
var RLN_GENERATION_PREFIX_ERROR = "could not generate rln proof";
var RLN_MESSAGE_ID_PREFIX_ERROR = "could not get new message id to generate an rln proof";
var RLN_REMOTE_VALIDATION = "RLN validation failed";
var isRLNResponseError = (info) => {
  if (!info) {
    return false;
  }
  return info.includes(RLN_GENERATION_PREFIX_ERROR) || info.includes(RLN_MESSAGE_ID_PREFIX_ERROR) || info.includes(RLN_REMOTE_VALIDATION);
};

// node_modules/@waku/core/dist/lib/light_push/protocol_handler.js
var log3 = new Logger("light-push:protocol-handler");
var ProtocolHandler = class _ProtocolHandler {
  static async preparePushMessage(encoder2, message2, protocol) {
    try {
      if (!message2.payload || message2.payload.length === 0) {
        log3.error("Failed to send waku light push: payload is empty");
        return { rpc: null, error: LightPushError.EMPTY_PAYLOAD };
      }
      if (!await isMessageSizeUnderCap(encoder2, message2)) {
        log3.error("Failed to send waku light push: message is bigger than 1MB");
        return { rpc: null, error: LightPushError.SIZE_TOO_BIG };
      }
      const protoMessage = await encoder2.toProtoObj(message2);
      if (!protoMessage) {
        log3.error("Failed to encode to protoMessage, aborting push");
        return { rpc: null, error: LightPushError.ENCODE_FAILED };
      }
      if (protocol === CODECS.v3) {
        log3.info("Creating v3 RPC message");
        return {
          rpc: _ProtocolHandler.createV3Rpc(protoMessage, encoder2.pubsubTopic),
          error: null
        };
      }
      log3.info("Creating v2 RPC message");
      return {
        rpc: _ProtocolHandler.createV2Rpc(protoMessage, encoder2.pubsubTopic),
        error: null
      };
    } catch (err) {
      log3.error("Failed to prepare push message", err);
      return { rpc: null, error: LightPushError.GENERIC_FAIL };
    }
  }
  /**
   * Decode and evaluate a LightPush response according to the protocol version
   */
  static handleResponse(bytes, protocol, peerId2) {
    if (protocol === CODECS.v3) {
      return _ProtocolHandler.handleV3Response(bytes, peerId2);
    }
    return _ProtocolHandler.handleV2Response(bytes, peerId2);
  }
  static handleV3Response(bytes, peerId2) {
    try {
      const decodedRpcV3 = PushRpc2.decodeResponse(bytes);
      const statusCode = decodedRpcV3.statusCode;
      const statusDesc = decodedRpcV3.statusDesc;
      if (statusCode !== LightPushStatusCode.SUCCESS) {
        const error = LightPushError.REMOTE_PEER_REJECTED;
        log3.error(`Remote peer rejected with v3 status code ${statusCode}: ${statusDesc}`);
        return {
          success: null,
          failure: {
            error,
            peerId: peerId2
          }
        };
      }
      if (decodedRpcV3.relayPeerCount !== void 0) {
        log3.info(`Message relayed to ${decodedRpcV3.relayPeerCount} peers`);
      }
      return { success: peerId2, failure: null };
    } catch (err) {
      return {
        success: null,
        failure: {
          error: LightPushError.DECODE_FAILED,
          peerId: peerId2
        }
      };
    }
  }
  static handleV2Response(bytes, peerId2) {
    let response;
    try {
      const decodedRpc = PushRpcV2.decode(bytes);
      response = decodedRpc.response;
    } catch (err) {
      return {
        success: null,
        failure: {
          error: LightPushError.DECODE_FAILED,
          peerId: peerId2
        }
      };
    }
    if (!response) {
      return {
        success: null,
        failure: {
          error: LightPushError.NO_RESPONSE,
          peerId: peerId2
        }
      };
    }
    if (isRLNResponseError(response.info)) {
      log3.error("Remote peer fault: RLN generation");
      return {
        success: null,
        failure: {
          error: LightPushError.RLN_PROOF_GENERATION,
          peerId: peerId2
        }
      };
    }
    if (!response.isSuccess) {
      log3.error("Remote peer rejected the message: ", response.info);
      return {
        success: null,
        failure: {
          error: LightPushError.REMOTE_PEER_REJECTED,
          peerId: peerId2
        }
      };
    }
    return { success: peerId2, failure: null };
  }
  static createV2Rpc(message2, pubsubTopic) {
    const v2Rpc = PushRpcV2.createRequest(message2, pubsubTopic);
    return Object.assign(v2Rpc, { version: "v2" });
  }
  static createV3Rpc(message2, pubsubTopic) {
    if (!message2.timestamp) {
      message2.timestamp = BigInt(Date.now()) * BigInt(1e6);
    }
    const v3Rpc = PushRpc2.createRequest(message2, pubsubTopic);
    return Object.assign(v3Rpc, { version: "v3" });
  }
};

// node_modules/@waku/core/dist/lib/light_push/light_push.js
var log4 = new Logger("light-push");
var LightPushCore = class {
  constructor(libp2p) {
    __publicField(this, "libp2p");
    __publicField(this, "streamManager");
    __publicField(this, "streamManagerV2");
    __publicField(this, "multicodec", [CODECS.v3, CODECS.v2]);
    this.libp2p = libp2p;
    this.streamManagerV2 = new StreamManager(CODECS.v2, libp2p.components);
    this.streamManager = new StreamManager(CODECS.v3, libp2p.components);
  }
  async send(encoder2, message2, peerId2, useLegacy = false) {
    const protocol = await this.getProtocol(peerId2, useLegacy);
    log4.info(`Sending light push request to peer:${peerId2.toString()}, protocol:${protocol}`);
    if (!protocol) {
      return {
        success: null,
        failure: {
          error: LightPushError.GENERIC_FAIL,
          peerId: peerId2
        }
      };
    }
    const { rpc, error: prepError } = await ProtocolHandler.preparePushMessage(encoder2, message2, protocol);
    if (prepError) {
      return {
        success: null,
        failure: {
          error: prepError,
          peerId: peerId2
        }
      };
    }
    const stream = await this.getStream(peerId2, protocol);
    if (!stream) {
      log4.error(`Failed to get a stream for remote peer:${peerId2.toString()}`);
      return {
        success: null,
        failure: {
          error: LightPushError.NO_STREAM_AVAILABLE,
          peerId: peerId2
        }
      };
    }
    let res;
    try {
      res = await pipe([rpc.encode()], encode6, stream, decode7, async (source) => await src_default(source));
    } catch (err) {
      log4.error("Failed to send waku light push request", err);
      return {
        success: null,
        failure: {
          error: LightPushError.STREAM_ABORTED,
          peerId: peerId2
        }
      };
    }
    const bytes = new Uint8ArrayList();
    res.forEach((chunk) => bytes.append(chunk));
    if (bytes.length === 0) {
      return {
        success: null,
        failure: {
          error: LightPushError.NO_RESPONSE,
          peerId: peerId2
        }
      };
    }
    return ProtocolHandler.handleResponse(bytes, protocol, peerId2);
  }
  async getProtocol(peerId2, useLegacy) {
    try {
      const peer = await this.libp2p.peerStore.get(peerId2);
      if (useLegacy || !peer.protocols.includes(CODECS.v3) && peer.protocols.includes(CODECS.v2)) {
        return CODECS.v2;
      } else if (peer.protocols.includes(CODECS.v3)) {
        return CODECS.v3;
      } else {
        throw new Error("No supported protocol found");
      }
    } catch (error) {
      log4.error("Failed to get protocol", error);
      return void 0;
    }
  }
  async getStream(peerId2, protocol) {
    switch (protocol) {
      case CODECS.v2:
        return this.streamManagerV2.getStream(peerId2);
      case CODECS.v3:
        return this.streamManager.getStream(peerId2);
      default:
        return void 0;
    }
  }
};

// node_modules/@waku/core/dist/lib/store/index.js
var store_exports = {};
__export(store_exports, {
  StoreCodec: () => StoreCodec,
  StoreCore: () => StoreCore
});

// node_modules/@waku/core/dist/lib/to_proto_message.js
var EmptyMessage = {
  payload: new Uint8Array(),
  contentTopic: "",
  version: void 0,
  timestamp: void 0,
  meta: void 0,
  rateLimitProof: void 0,
  ephemeral: void 0
};
function toProtoMessage(wire) {
  return { ...EmptyMessage, ...wire };
}

// node_modules/@waku/core/dist/lib/store/rpc.js
var DEFAULT_PAGE_SIZE = 20;
var MAX_PAGE_SIZE = 100;
var MAX_TIME_RANGE = 24 * 60 * 60 * 1e3;
var ONE_MILLION = 1e6;
var StoreQueryRequest2 = class _StoreQueryRequest {
  constructor(proto) {
    __publicField(this, "proto");
    this.proto = proto;
  }
  static create(params) {
    const request2 = new _StoreQueryRequest({
      ...params,
      contentTopics: params.contentTopics || [],
      requestId: v4_default(),
      timeStart: params.timeStart ? BigInt(params.timeStart.getTime() * ONE_MILLION) : void 0,
      timeEnd: params.timeEnd ? BigInt(params.timeEnd.getTime() * ONE_MILLION) : void 0,
      messageHashes: params.messageHashes || [],
      paginationLimit: params.paginationLimit ? BigInt(params.paginationLimit) : void 0
    });
    const isHashQuery = params.messageHashes && params.messageHashes.length > 0;
    const hasContentTopics = params.contentTopics && params.contentTopics.length > 0;
    const hasTimeFilter = params.timeStart || params.timeEnd;
    if (isHashQuery) {
      if (hasContentTopics || hasTimeFilter) {
        throw new Error("Message hash lookup queries cannot include content filter criteria (contentTopics, timeStart, or timeEnd)");
      }
    } else {
      if (params.pubsubTopic && (!params.contentTopics || params.contentTopics.length === 0) || !params.pubsubTopic && params.contentTopics && params.contentTopics.length > 0) {
        throw new Error("Both pubsubTopic and contentTopics must be set together for content-filtered queries");
      }
    }
    return request2;
  }
  static decode(bytes) {
    const res = store_v3_exports.StoreQueryRequest.decode(bytes);
    return new _StoreQueryRequest(res);
  }
  encode() {
    return store_v3_exports.StoreQueryRequest.encode(this.proto);
  }
};
var StoreQueryResponse2 = class _StoreQueryResponse {
  constructor(proto) {
    __publicField(this, "proto");
    this.proto = proto;
  }
  static decode(bytes) {
    const res = store_v3_exports.StoreQueryResponse.decode(bytes);
    return new _StoreQueryResponse(res);
  }
  encode() {
    return store_v3_exports.StoreQueryResponse.encode(this.proto);
  }
  get statusCode() {
    return this.proto.statusCode;
  }
  get statusDesc() {
    return this.proto.statusDesc;
  }
  get messages() {
    return this.proto.messages;
  }
  get paginationCursor() {
    return this.proto.paginationCursor;
  }
};

// node_modules/@waku/core/dist/lib/store/store.js
var log5 = new Logger("store");
var StoreCodec = "/vac/waku/store-query/3.0.0";
var StoreCore = class {
  constructor(libp2p) {
    __publicField(this, "streamManager");
    __publicField(this, "multicodec", StoreCodec);
    this.streamManager = new StreamManager(StoreCodec, libp2p.components);
  }
  get maxTimeLimit() {
    return MAX_TIME_RANGE;
  }
  async *queryPerPage(queryOpts, decoders4, peerId2) {
    var _a27, _b14;
    if (queryOpts.timeStart && queryOpts.timeEnd) {
      const timeDiff = queryOpts.timeEnd.getTime() - queryOpts.timeStart.getTime();
      if (timeDiff > MAX_TIME_RANGE) {
        throw new Error("Time range bigger than 24h");
      }
    }
    const isHashQuery = queryOpts.messageHashes && queryOpts.messageHashes.length > 0;
    if (!isHashQuery && queryOpts.contentTopics && queryOpts.contentTopics.toString() !== Array.from(decoders4.keys()).toString()) {
      throw new Error("Internal error, the decoders should match the query's content topics");
    }
    let currentCursor = queryOpts.paginationCursor;
    while (true) {
      const storeQueryRequest = StoreQueryRequest2.create({
        ...queryOpts,
        paginationCursor: currentCursor
      });
      log5.info("Sending store query request:", {
        hasMessageHashes: !!((_a27 = queryOpts.messageHashes) == null ? void 0 : _a27.length),
        messageHashCount: (_b14 = queryOpts.messageHashes) == null ? void 0 : _b14.length,
        pubsubTopic: queryOpts.pubsubTopic,
        contentTopics: queryOpts.contentTopics
      });
      const stream = await this.streamManager.getStream(peerId2);
      if (!stream) {
        log5.error(`Failed to get a stream for remote peer:${peerId2.toString()}`);
        break;
      }
      const res = await pipe([storeQueryRequest.encode()], encode6, stream, decode7, async (source) => await src_default(source));
      const bytes = new Uint8ArrayList();
      res.forEach((chunk) => {
        bytes.append(chunk);
      });
      const storeQueryResponse = StoreQueryResponse2.decode(bytes);
      if (!storeQueryResponse.statusCode || storeQueryResponse.statusCode >= 300) {
        const errorMessage = `Store query failed with status code: ${storeQueryResponse.statusCode}, description: ${storeQueryResponse.statusDesc}`;
        log5.error(errorMessage);
        throw new Error(errorMessage);
      }
      if (!storeQueryResponse.messages || !storeQueryResponse.messages.length) {
        log5.warn("Stopping pagination due to empty messages in response");
        break;
      }
      log5.info(`${storeQueryResponse.messages.length} messages retrieved from store`);
      const decodedMessages = storeQueryResponse.messages.map((protoMsg) => {
        if (!protoMsg.message) {
          return Promise.resolve(void 0);
        }
        const contentTopic = protoMsg.message.contentTopic;
        if (contentTopic) {
          const decoder = decoders4.get(contentTopic);
          if (decoder) {
            return decoder.fromProtoObj(protoMsg.pubsubTopic || "", toProtoMessage(protoMsg.message));
          }
        }
        return Promise.resolve(void 0);
      });
      yield decodedMessages;
      if (queryOpts.paginationForward) {
        currentCursor = storeQueryResponse.messages[storeQueryResponse.messages.length - 1].messageHash;
      } else {
        currentCursor = storeQueryResponse.messages[0].messageHash;
      }
      if (storeQueryResponse.messages.length > MAX_PAGE_SIZE && storeQueryResponse.messages.length < (queryOpts.paginationLimit || DEFAULT_PAGE_SIZE)) {
        break;
      }
    }
  }
};

// node_modules/@libp2p/crypto/node_modules/@libp2p/interface/dist/src/connection.js
var connectionSymbol2 = Symbol.for("@libp2p/connection");

// node_modules/@libp2p/crypto/node_modules/@libp2p/interface/dist/src/content-routing.js
var contentRoutingSymbol2 = Symbol.for("@libp2p/content-routing");

// node_modules/@libp2p/crypto/node_modules/@libp2p/interface/dist/src/errors.js
var InvalidParametersError2 = class extends Error {
  constructor(message2 = "Invalid parameters") {
    super(message2);
    this.name = "InvalidParametersError";
  }
};
__publicField(InvalidParametersError2, "name", "InvalidParametersError");
var InvalidPublicKeyError2 = class extends Error {
  constructor(message2 = "Invalid public key") {
    super(message2);
    this.name = "InvalidPublicKeyError";
  }
};
__publicField(InvalidPublicKeyError2, "name", "InvalidPublicKeyError");
var InvalidPrivateKeyError = class extends Error {
  constructor(message2 = "Invalid private key") {
    super(message2);
    this.name = "InvalidPrivateKeyError";
  }
};
__publicField(InvalidPrivateKeyError, "name", "InvalidPrivateKeyError");
var UnsupportedKeyTypeError2 = class extends Error {
  constructor(message2 = "Unsupported key type") {
    super(message2);
    this.name = "UnsupportedKeyTypeError";
  }
};
__publicField(UnsupportedKeyTypeError2, "name", "UnsupportedKeyTypeError");

// node_modules/@libp2p/crypto/node_modules/@libp2p/interface/dist/src/peer-discovery.js
var peerDiscoverySymbol2 = Symbol.for("@libp2p/peer-discovery");

// node_modules/@libp2p/crypto/node_modules/@libp2p/interface/dist/src/peer-id.js
var peerIdSymbol2 = Symbol.for("@libp2p/peer-id");

// node_modules/@libp2p/crypto/node_modules/@libp2p/interface/dist/src/peer-routing.js
var peerRoutingSymbol2 = Symbol.for("@libp2p/peer-routing");

// node_modules/@libp2p/crypto/node_modules/@libp2p/interface/dist/src/transport.js
var transportSymbol2 = Symbol.for("@libp2p/transport");
var FaultTolerance2;
(function(FaultTolerance4) {
  FaultTolerance4[FaultTolerance4["FATAL_ALL"] = 0] = "FATAL_ALL";
  FaultTolerance4[FaultTolerance4["NO_FATAL"] = 1] = "NO_FATAL";
})(FaultTolerance2 || (FaultTolerance2 = {}));

// node_modules/@libp2p/crypto/node_modules/@libp2p/interface/dist/src/index.js
var serviceCapabilities2 = Symbol.for("@libp2p/service-capabilities");
var serviceDependencies2 = Symbol.for("@libp2p/service-dependencies");

// node_modules/@libp2p/crypto/dist/src/keys/rsa/der.js
var TAG_MASK = parseInt("11111", 2);
var LONG_LENGTH_MASK = parseInt("10000000", 2);
var LONG_LENGTH_BYTES_MASK = parseInt("01111111", 2);
var decoders = {
  0: readSequence,
  1: readSequence,
  2: readInteger,
  3: readBitString,
  4: readOctetString,
  5: readNull,
  6: readObjectIdentifier,
  16: readSequence,
  22: readSequence,
  48: readSequence
};
function decodeDer(buf, context = { offset: 0 }) {
  const tag = buf[context.offset] & TAG_MASK;
  context.offset++;
  if (decoders[tag] != null) {
    return decoders[tag](buf, context);
  }
  throw new Error("No decoder for tag " + tag);
}
function readLength(buf, context) {
  let length3 = 0;
  if ((buf[context.offset] & LONG_LENGTH_MASK) === LONG_LENGTH_MASK) {
    const count = buf[context.offset] & LONG_LENGTH_BYTES_MASK;
    let str = "0x";
    context.offset++;
    for (let i2 = 0; i2 < count; i2++, context.offset++) {
      str += buf[context.offset].toString(16).padStart(2, "0");
    }
    length3 = parseInt(str, 16);
  } else {
    length3 = buf[context.offset];
    context.offset++;
  }
  return length3;
}
function readSequence(buf, context) {
  readLength(buf, context);
  const entries = [];
  while (true) {
    if (context.offset >= buf.byteLength) {
      break;
    }
    const result = decodeDer(buf, context);
    if (result === null) {
      break;
    }
    entries.push(result);
  }
  return entries;
}
function readInteger(buf, context) {
  const length3 = readLength(buf, context);
  const start2 = context.offset;
  const end = context.offset + length3;
  const vals = [];
  for (let i2 = start2; i2 < end; i2++) {
    if (i2 === start2 && buf[i2] === 0) {
      continue;
    }
    vals.push(buf[i2]);
  }
  context.offset += length3;
  return Uint8Array.from(vals);
}
function readObjectIdentifier(buf, context) {
  const count = readLength(buf, context);
  const finalOffset = context.offset + count;
  const byte = buf[context.offset];
  context.offset++;
  let val1 = 0;
  let val2 = 0;
  if (byte < 40) {
    val1 = 0;
    val2 = byte;
  } else if (byte < 80) {
    val1 = 1;
    val2 = byte - 40;
  } else {
    val1 = 2;
    val2 = byte - 80;
  }
  let oid = `${val1}.${val2}`;
  let num3 = [];
  while (context.offset < finalOffset) {
    const byte2 = buf[context.offset];
    context.offset++;
    num3.push(byte2 & 127);
    if (byte2 < 128) {
      num3.reverse();
      let val = 0;
      for (let i2 = 0; i2 < num3.length; i2++) {
        val += num3[i2] << i2 * 7;
      }
      oid += `.${val}`;
      num3 = [];
    }
  }
  return oid;
}
function readNull(buf, context) {
  context.offset++;
  return null;
}
function readBitString(buf, context) {
  const length3 = readLength(buf, context);
  const unusedBits = buf[context.offset];
  context.offset++;
  const bytes = buf.subarray(context.offset, context.offset + length3 - 1);
  context.offset += length3;
  if (unusedBits !== 0) {
    throw new Error("Unused bits in bit string is unimplemented");
  }
  return bytes;
}
function readOctetString(buf, context) {
  const length3 = readLength(buf, context);
  const bytes = buf.subarray(context.offset, context.offset + length3);
  context.offset += length3;
  return bytes;
}
function encodeNumber(value) {
  let number2 = value.toString(16);
  if (number2.length % 2 === 1) {
    number2 = "0" + number2;
  }
  const array = new Uint8ArrayList();
  for (let i2 = 0; i2 < number2.length; i2 += 2) {
    array.append(Uint8Array.from([parseInt(`${number2[i2]}${number2[i2 + 1]}`, 16)]));
  }
  return array;
}
function encodeLength(bytes) {
  if (bytes.byteLength < 128) {
    return Uint8Array.from([bytes.byteLength]);
  }
  const length3 = encodeNumber(bytes.byteLength);
  return new Uint8ArrayList(Uint8Array.from([
    length3.byteLength | LONG_LENGTH_MASK
  ]), length3);
}
function encodeInteger(value) {
  const contents = new Uint8ArrayList();
  const mask = 128;
  const positive2 = (value.subarray()[0] & mask) === mask;
  if (positive2) {
    contents.append(Uint8Array.from([0]));
  }
  contents.append(value);
  return new Uint8ArrayList(Uint8Array.from([2]), encodeLength(contents), contents);
}
function encodeBitString(value) {
  const unusedBits = Uint8Array.from([0]);
  const contents = new Uint8ArrayList(unusedBits, value);
  return new Uint8ArrayList(Uint8Array.from([3]), encodeLength(contents), contents);
}
function encodeOctetString(value) {
  return new Uint8ArrayList(Uint8Array.from([4]), encodeLength(value), value);
}
function encodeSequence(values, tag = 48) {
  const output = new Uint8ArrayList();
  for (const buf of values) {
    output.append(buf);
  }
  return new Uint8ArrayList(Uint8Array.from([tag]), encodeLength(output), output);
}

// node_modules/@libp2p/crypto/dist/src/keys/ecdsa/index.js
async function generateECDSAKey(curve = "P-256") {
  const keyPair = await crypto.subtle.generateKey({
    name: "ECDSA",
    namedCurve: curve
  }, true, ["sign", "verify"]);
  return {
    publicKey: await crypto.subtle.exportKey("jwk", keyPair.publicKey),
    privateKey: await crypto.subtle.exportKey("jwk", keyPair.privateKey)
  };
}
async function hashAndSign(key, msg, options) {
  var _a27, _b14;
  const privateKey = await crypto.subtle.importKey("jwk", key, {
    name: "ECDSA",
    namedCurve: key.crv ?? "P-256"
  }, false, ["sign"]);
  (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
  const signature = await crypto.subtle.sign({
    name: "ECDSA",
    hash: {
      name: "SHA-256"
    }
  }, privateKey, msg.subarray());
  (_b14 = options == null ? void 0 : options.signal) == null ? void 0 : _b14.throwIfAborted();
  return new Uint8Array(signature, 0, signature.byteLength);
}
async function hashAndVerify(key, sig, msg, options) {
  var _a27, _b14;
  const publicKey = await crypto.subtle.importKey("jwk", key, {
    name: "ECDSA",
    namedCurve: key.crv ?? "P-256"
  }, false, ["verify"]);
  (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
  const result = await crypto.subtle.verify({
    name: "ECDSA",
    hash: {
      name: "SHA-256"
    }
  }, publicKey, sig, msg.subarray());
  (_b14 = options == null ? void 0 : options.signal) == null ? void 0 : _b14.throwIfAborted();
  return result;
}

// node_modules/@libp2p/crypto/dist/src/keys/ecdsa/utils.js
var OID_256 = Uint8Array.from([6, 8, 42, 134, 72, 206, 61, 3, 1, 7]);
var OID_384 = Uint8Array.from([6, 5, 43, 129, 4, 0, 34]);
var OID_521 = Uint8Array.from([6, 5, 43, 129, 4, 0, 35]);
var P_256_KEY_JWK = {
  ext: true,
  kty: "EC",
  crv: "P-256"
};
var P_384_KEY_JWK = {
  ext: true,
  kty: "EC",
  crv: "P-384"
};
var P_521_KEY_JWK = {
  ext: true,
  kty: "EC",
  crv: "P-521"
};
var P_256_KEY_LENGTH = 32;
var P_384_KEY_LENGTH = 48;
var P_521_KEY_LENGTH = 66;
function unmarshalECDSAPublicKey(bytes) {
  const message2 = decodeDer(bytes);
  return pkiMessageToECDSAPublicKey(message2);
}
function pkiMessageToECDSAPublicKey(message2) {
  const coordinates = message2[1][1][0];
  const offset = 1;
  let x;
  let y;
  if (coordinates.byteLength === P_256_KEY_LENGTH * 2 + 1) {
    x = toString2(coordinates.subarray(offset, offset + P_256_KEY_LENGTH), "base64url");
    y = toString2(coordinates.subarray(offset + P_256_KEY_LENGTH), "base64url");
    return new ECDSAPublicKey({
      ...P_256_KEY_JWK,
      key_ops: ["verify"],
      x,
      y
    });
  }
  if (coordinates.byteLength === P_384_KEY_LENGTH * 2 + 1) {
    x = toString2(coordinates.subarray(offset, offset + P_384_KEY_LENGTH), "base64url");
    y = toString2(coordinates.subarray(offset + P_384_KEY_LENGTH), "base64url");
    return new ECDSAPublicKey({
      ...P_384_KEY_JWK,
      key_ops: ["verify"],
      x,
      y
    });
  }
  if (coordinates.byteLength === P_521_KEY_LENGTH * 2 + 1) {
    x = toString2(coordinates.subarray(offset, offset + P_521_KEY_LENGTH), "base64url");
    y = toString2(coordinates.subarray(offset + P_521_KEY_LENGTH), "base64url");
    return new ECDSAPublicKey({
      ...P_521_KEY_JWK,
      key_ops: ["verify"],
      x,
      y
    });
  }
  throw new InvalidParametersError2(`coordinates were wrong length, got ${coordinates.byteLength}, expected 65, 97 or 133`);
}
function privateKeyToPKIMessage(privateKey) {
  return encodeSequence([
    encodeInteger(Uint8Array.from([1])),
    // header
    encodeOctetString(fromString2(privateKey.d ?? "", "base64url")),
    // body
    encodeSequence([
      getOID(privateKey.crv)
    ], 160),
    encodeSequence([
      encodeBitString(new Uint8ArrayList(Uint8Array.from([4]), fromString2(privateKey.x ?? "", "base64url"), fromString2(privateKey.y ?? "", "base64url")))
    ], 161)
  ]).subarray();
}
function publicKeyToPKIMessage(publicKey) {
  return encodeSequence([
    encodeInteger(Uint8Array.from([1])),
    // header
    encodeSequence([
      getOID(publicKey.crv)
    ], 160),
    encodeSequence([
      encodeBitString(new Uint8ArrayList(Uint8Array.from([4]), fromString2(publicKey.x ?? "", "base64url"), fromString2(publicKey.y ?? "", "base64url")))
    ], 161)
  ]).subarray();
}
function getOID(curve) {
  if (curve === "P-256") {
    return OID_256;
  }
  if (curve === "P-384") {
    return OID_384;
  }
  if (curve === "P-521") {
    return OID_521;
  }
  throw new InvalidParametersError2(`Invalid curve ${curve}`);
}
async function generateECDSAKeyPair(curve = "P-256") {
  const key = await generateECDSAKey(curve);
  return new ECDSAPrivateKey(key.privateKey);
}

// node_modules/@libp2p/crypto/dist/src/keys/ecdsa/ecdsa.js
var ECDSAPublicKey = class {
  constructor(jwk) {
    __publicField(this, "type", "ECDSA");
    __publicField(this, "jwk");
    __publicField(this, "_raw");
    this.jwk = jwk;
  }
  get raw() {
    if (this._raw == null) {
      this._raw = publicKeyToPKIMessage(this.jwk);
    }
    return this._raw;
  }
  toMultihash() {
    return identity2.digest(publicKeyToProtobuf(this));
  }
  toCID() {
    return CID.createV1(114, this.toMultihash());
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.raw, key.raw);
  }
  async verify(data, sig, options) {
    return hashAndVerify(this.jwk, sig, data, options);
  }
};
var ECDSAPrivateKey = class {
  constructor(jwk) {
    __publicField(this, "type", "ECDSA");
    __publicField(this, "jwk");
    __publicField(this, "publicKey");
    __publicField(this, "_raw");
    this.jwk = jwk;
    this.publicKey = new ECDSAPublicKey({
      crv: jwk.crv,
      ext: jwk.ext,
      key_ops: ["verify"],
      kty: "EC",
      x: jwk.x,
      y: jwk.y
    });
  }
  get raw() {
    if (this._raw == null) {
      this._raw = privateKeyToPKIMessage(this.jwk);
    }
    return this._raw;
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.raw, key.raw);
  }
  async sign(message2, options) {
    return hashAndSign(this.jwk, message2, options);
  }
};

// node_modules/@libp2p/crypto/node_modules/@noble/hashes/utils.js
function isBytes2(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
function anumber2(n2, title = "") {
  if (!Number.isSafeInteger(n2) || n2 < 0) {
    const prefix = title && `"${title}" `;
    throw new Error(`${prefix}expected integer >= 0, got ${n2}`);
  }
}
function abytes2(value, length3, title = "") {
  const bytes = isBytes2(value);
  const len = value == null ? void 0 : value.length;
  const needsLen = length3 !== void 0;
  if (!bytes || needsLen && len !== length3) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length3}` : "";
    const got = bytes ? `length=${len}` : `type=${typeof value}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value;
}
function ahash2(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  anumber2(h.outputLen);
  anumber2(h.blockLen);
}
function aexists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput2(out, instance) {
  abytes2(out, void 0, "digestInto() output");
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error('"digestInto() output" expected to be of length >=' + min);
  }
}
function clean2(...arrays) {
  for (let i2 = 0; i2 < arrays.length; i2++) {
    arrays[i2].fill(0);
  }
}
function createView2(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr2(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function rotl(word, shift) {
  return word << shift | word >>> 32 - shift >>> 0;
}
var isLE2 = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
var hasHexBuiltin2 = (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes2 = Array.from({ length: 256 }, (_2, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex3(bytes) {
  abytes2(bytes);
  if (hasHexBuiltin2)
    return bytes.toHex();
  let hex = "";
  for (let i2 = 0; i2 < bytes.length; i2++) {
    hex += hexes2[bytes[i2]];
  }
  return hex;
}
var asciis2 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase162(ch) {
  if (ch >= asciis2._0 && ch <= asciis2._9)
    return ch - asciis2._0;
  if (ch >= asciis2.A && ch <= asciis2.F)
    return ch - (asciis2.A - 10);
  if (ch >= asciis2.a && ch <= asciis2.f)
    return ch - (asciis2.a - 10);
  return;
}
function hexToBytes3(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin2)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase162(hex.charCodeAt(hi));
    const n2 = asciiToBase162(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    abytes2(a2);
    sum += a2.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    res.set(a2, pad);
    pad += a2.length;
  }
  return res;
}
function createHasher2(hashCons, info = {}) {
  const hashC = (msg, opts) => hashCons(opts).update(msg).digest();
  const tmp = hashCons(void 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  Object.assign(hashC, info);
  return Object.freeze(hashC);
}
function randomBytes2(bytesLength = 32) {
  const cr = typeof globalThis === "object" ? globalThis.crypto : null;
  if (typeof (cr == null ? void 0 : cr.getRandomValues) !== "function")
    throw new Error("crypto.getRandomValues must be defined");
  return cr.getRandomValues(new Uint8Array(bytesLength));
}
var oidNist = (suffix) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, suffix])
});

// node_modules/@libp2p/crypto/node_modules/@noble/hashes/_md.js
function Chi2(a2, b, c2) {
  return a2 & b ^ ~a2 & c2;
}
function Maj2(a2, b, c2) {
  return a2 & b ^ a2 & c2 ^ b & c2;
}
var HashMD2 = class {
  constructor(blockLen, outputLen, padOffset, isLE4) {
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "padOffset");
    __publicField(this, "isLE");
    // For partial updates less than block size
    __publicField(this, "buffer");
    __publicField(this, "view");
    __publicField(this, "finished", false);
    __publicField(this, "length", 0);
    __publicField(this, "pos", 0);
    __publicField(this, "destroyed", false);
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE4;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView2(this.buffer);
  }
  update(data) {
    aexists2(this);
    abytes2(data);
    const { view, buffer, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take2 = Math.min(blockLen - this.pos, len - pos);
      if (take2 === blockLen) {
        const dataView = createView2(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take2), this.pos);
      this.pos += take2;
      pos += take2;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists2(this);
    aoutput2(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE4 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    clean2(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer[i2] = 0;
    view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE4);
    this.process(view, 0);
    const oview = createView2(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE4);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length: length3, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length3;
    to.pos = pos;
    if (length3 % blockLen)
      to.buffer.set(buffer);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var SHA256_IV2 = Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA224_IV2 = Uint32Array.from([
  3238371032,
  914150663,
  812702999,
  4144912697,
  4290775857,
  1750603025,
  1694076839,
  3204075428
]);
var SHA384_IV2 = Uint32Array.from([
  3418070365,
  3238371032,
  1654270250,
  914150663,
  2438529370,
  812702999,
  355462360,
  4144912697,
  1731405415,
  4290775857,
  2394180231,
  1750603025,
  3675008525,
  1694076839,
  1203062813,
  3204075428
]);
var SHA512_IV2 = Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);

// node_modules/@libp2p/crypto/node_modules/@noble/hashes/_u64.js
var U32_MASK642 = BigInt(2 ** 32 - 1);
var _32n2 = BigInt(32);
function fromBig2(n2, le = false) {
  if (le)
    return { h: Number(n2 & U32_MASK642), l: Number(n2 >> _32n2 & U32_MASK642) };
  return { h: Number(n2 >> _32n2 & U32_MASK642) | 0, l: Number(n2 & U32_MASK642) | 0 };
}
function split2(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i2 = 0; i2 < len; i2++) {
    const { h, l: l2 } = fromBig2(lst[i2], le);
    [Ah[i2], Al[i2]] = [h, l2];
  }
  return [Ah, Al];
}
var shrSH2 = (h, _l, s2) => h >>> s2;
var shrSL2 = (h, l2, s2) => h << 32 - s2 | l2 >>> s2;
var rotrSH2 = (h, l2, s2) => h >>> s2 | l2 << 32 - s2;
var rotrSL2 = (h, l2, s2) => h << 32 - s2 | l2 >>> s2;
var rotrBH2 = (h, l2, s2) => h << 64 - s2 | l2 >>> s2 - 32;
var rotrBL2 = (h, l2, s2) => h >>> s2 - 32 | l2 << 64 - s2;
function add2(Ah, Al, Bh, Bl) {
  const l2 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
}
var add3L2 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L2 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H2 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L2 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H2 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

// node_modules/@libp2p/crypto/node_modules/@noble/hashes/sha2.js
var SHA256_K2 = Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W2 = new Uint32Array(64);
var SHA2_32B = class extends HashMD2 {
  constructor(outputLen) {
    super(64, outputLen, 8, false);
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W2[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W2[i2 - 15];
      const W2 = SHA256_W2[i2 - 2];
      const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
      const s1 = rotr2(W2, 17) ^ rotr2(W2, 19) ^ W2 >>> 10;
      SHA256_W2[i2] = s1 + SHA256_W2[i2 - 7] + s0 + SHA256_W2[i2 - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr2(E, 6) ^ rotr2(E, 11) ^ rotr2(E, 25);
      const T1 = H + sigma1 + Chi2(E, F, G) + SHA256_K2[i2] + SHA256_W2[i2] | 0;
      const sigma0 = rotr2(A, 2) ^ rotr2(A, 13) ^ rotr2(A, 22);
      const T2 = sigma0 + Maj2(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    clean2(SHA256_W2);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean2(this.buffer);
  }
};
var _SHA256 = class extends SHA2_32B {
  constructor() {
    super(32);
    // We cannot use array here since array allows indexing by variable
    // which means optimizer/compiler cannot use registers.
    __publicField(this, "A", SHA256_IV2[0] | 0);
    __publicField(this, "B", SHA256_IV2[1] | 0);
    __publicField(this, "C", SHA256_IV2[2] | 0);
    __publicField(this, "D", SHA256_IV2[3] | 0);
    __publicField(this, "E", SHA256_IV2[4] | 0);
    __publicField(this, "F", SHA256_IV2[5] | 0);
    __publicField(this, "G", SHA256_IV2[6] | 0);
    __publicField(this, "H", SHA256_IV2[7] | 0);
  }
};
var _SHA224 = class extends SHA2_32B {
  constructor() {
    super(28);
    __publicField(this, "A", SHA224_IV2[0] | 0);
    __publicField(this, "B", SHA224_IV2[1] | 0);
    __publicField(this, "C", SHA224_IV2[2] | 0);
    __publicField(this, "D", SHA224_IV2[3] | 0);
    __publicField(this, "E", SHA224_IV2[4] | 0);
    __publicField(this, "F", SHA224_IV2[5] | 0);
    __publicField(this, "G", SHA224_IV2[6] | 0);
    __publicField(this, "H", SHA224_IV2[7] | 0);
  }
};
var K5122 = (() => split2([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
var SHA512_Kh2 = (() => K5122[0])();
var SHA512_Kl2 = (() => K5122[1])();
var SHA512_W_H2 = new Uint32Array(80);
var SHA512_W_L2 = new Uint32Array(80);
var SHA2_64B = class extends HashMD2 {
  constructor(outputLen) {
    super(128, outputLen, 16, false);
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4) {
      SHA512_W_H2[i2] = view.getUint32(offset);
      SHA512_W_L2[i2] = view.getUint32(offset += 4);
    }
    for (let i2 = 16; i2 < 80; i2++) {
      const W15h = SHA512_W_H2[i2 - 15] | 0;
      const W15l = SHA512_W_L2[i2 - 15] | 0;
      const s0h = rotrSH2(W15h, W15l, 1) ^ rotrSH2(W15h, W15l, 8) ^ shrSH2(W15h, W15l, 7);
      const s0l = rotrSL2(W15h, W15l, 1) ^ rotrSL2(W15h, W15l, 8) ^ shrSL2(W15h, W15l, 7);
      const W2h = SHA512_W_H2[i2 - 2] | 0;
      const W2l = SHA512_W_L2[i2 - 2] | 0;
      const s1h = rotrSH2(W2h, W2l, 19) ^ rotrBH2(W2h, W2l, 61) ^ shrSH2(W2h, W2l, 6);
      const s1l = rotrSL2(W2h, W2l, 19) ^ rotrBL2(W2h, W2l, 61) ^ shrSL2(W2h, W2l, 6);
      const SUMl = add4L2(s0l, s1l, SHA512_W_L2[i2 - 7], SHA512_W_L2[i2 - 16]);
      const SUMh = add4H2(SUMl, s0h, s1h, SHA512_W_H2[i2 - 7], SHA512_W_H2[i2 - 16]);
      SHA512_W_H2[i2] = SUMh | 0;
      SHA512_W_L2[i2] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      const sigma1h = rotrSH2(Eh, El, 14) ^ rotrSH2(Eh, El, 18) ^ rotrBH2(Eh, El, 41);
      const sigma1l = rotrSL2(Eh, El, 14) ^ rotrSL2(Eh, El, 18) ^ rotrBL2(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L2(Hl, sigma1l, CHIl, SHA512_Kl2[i2], SHA512_W_L2[i2]);
      const T1h = add5H2(T1ll, Hh, sigma1h, CHIh, SHA512_Kh2[i2], SHA512_W_H2[i2]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH2(Ah, Al, 28) ^ rotrBH2(Ah, Al, 34) ^ rotrBH2(Ah, Al, 39);
      const sigma0l = rotrSL2(Ah, Al, 28) ^ rotrBL2(Ah, Al, 34) ^ rotrBL2(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add2(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = add3L2(T1l, sigma0l, MAJl);
      Ah = add3H2(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add2(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = add2(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = add2(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add2(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add2(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add2(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add2(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add2(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean2(SHA512_W_H2, SHA512_W_L2);
  }
  destroy() {
    clean2(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var _SHA512 = class extends SHA2_64B {
  constructor() {
    super(64);
    __publicField(this, "Ah", SHA512_IV2[0] | 0);
    __publicField(this, "Al", SHA512_IV2[1] | 0);
    __publicField(this, "Bh", SHA512_IV2[2] | 0);
    __publicField(this, "Bl", SHA512_IV2[3] | 0);
    __publicField(this, "Ch", SHA512_IV2[4] | 0);
    __publicField(this, "Cl", SHA512_IV2[5] | 0);
    __publicField(this, "Dh", SHA512_IV2[6] | 0);
    __publicField(this, "Dl", SHA512_IV2[7] | 0);
    __publicField(this, "Eh", SHA512_IV2[8] | 0);
    __publicField(this, "El", SHA512_IV2[9] | 0);
    __publicField(this, "Fh", SHA512_IV2[10] | 0);
    __publicField(this, "Fl", SHA512_IV2[11] | 0);
    __publicField(this, "Gh", SHA512_IV2[12] | 0);
    __publicField(this, "Gl", SHA512_IV2[13] | 0);
    __publicField(this, "Hh", SHA512_IV2[14] | 0);
    __publicField(this, "Hl", SHA512_IV2[15] | 0);
  }
};
var _SHA384 = class extends SHA2_64B {
  constructor() {
    super(48);
    __publicField(this, "Ah", SHA384_IV2[0] | 0);
    __publicField(this, "Al", SHA384_IV2[1] | 0);
    __publicField(this, "Bh", SHA384_IV2[2] | 0);
    __publicField(this, "Bl", SHA384_IV2[3] | 0);
    __publicField(this, "Ch", SHA384_IV2[4] | 0);
    __publicField(this, "Cl", SHA384_IV2[5] | 0);
    __publicField(this, "Dh", SHA384_IV2[6] | 0);
    __publicField(this, "Dl", SHA384_IV2[7] | 0);
    __publicField(this, "Eh", SHA384_IV2[8] | 0);
    __publicField(this, "El", SHA384_IV2[9] | 0);
    __publicField(this, "Fh", SHA384_IV2[10] | 0);
    __publicField(this, "Fl", SHA384_IV2[11] | 0);
    __publicField(this, "Gh", SHA384_IV2[12] | 0);
    __publicField(this, "Gl", SHA384_IV2[13] | 0);
    __publicField(this, "Hh", SHA384_IV2[14] | 0);
    __publicField(this, "Hl", SHA384_IV2[15] | 0);
  }
};
var T224_IV2 = Uint32Array.from([
  2352822216,
  424955298,
  1944164710,
  2312950998,
  502970286,
  855612546,
  1738396948,
  1479516111,
  258812777,
  2077511080,
  2011393907,
  79989058,
  1067287976,
  1780299464,
  286451373,
  2446758561
]);
var T256_IV2 = Uint32Array.from([
  573645204,
  4230739756,
  2673172387,
  3360449730,
  596883563,
  1867755857,
  2520282905,
  1497426621,
  2519219938,
  2827943907,
  3193839141,
  1401305490,
  721525244,
  746961066,
  246885852,
  2177182882
]);
var _SHA512_224 = class extends SHA2_64B {
  constructor() {
    super(28);
    __publicField(this, "Ah", T224_IV2[0] | 0);
    __publicField(this, "Al", T224_IV2[1] | 0);
    __publicField(this, "Bh", T224_IV2[2] | 0);
    __publicField(this, "Bl", T224_IV2[3] | 0);
    __publicField(this, "Ch", T224_IV2[4] | 0);
    __publicField(this, "Cl", T224_IV2[5] | 0);
    __publicField(this, "Dh", T224_IV2[6] | 0);
    __publicField(this, "Dl", T224_IV2[7] | 0);
    __publicField(this, "Eh", T224_IV2[8] | 0);
    __publicField(this, "El", T224_IV2[9] | 0);
    __publicField(this, "Fh", T224_IV2[10] | 0);
    __publicField(this, "Fl", T224_IV2[11] | 0);
    __publicField(this, "Gh", T224_IV2[12] | 0);
    __publicField(this, "Gl", T224_IV2[13] | 0);
    __publicField(this, "Hh", T224_IV2[14] | 0);
    __publicField(this, "Hl", T224_IV2[15] | 0);
  }
};
var _SHA512_256 = class extends SHA2_64B {
  constructor() {
    super(32);
    __publicField(this, "Ah", T256_IV2[0] | 0);
    __publicField(this, "Al", T256_IV2[1] | 0);
    __publicField(this, "Bh", T256_IV2[2] | 0);
    __publicField(this, "Bl", T256_IV2[3] | 0);
    __publicField(this, "Ch", T256_IV2[4] | 0);
    __publicField(this, "Cl", T256_IV2[5] | 0);
    __publicField(this, "Dh", T256_IV2[6] | 0);
    __publicField(this, "Dl", T256_IV2[7] | 0);
    __publicField(this, "Eh", T256_IV2[8] | 0);
    __publicField(this, "El", T256_IV2[9] | 0);
    __publicField(this, "Fh", T256_IV2[10] | 0);
    __publicField(this, "Fl", T256_IV2[11] | 0);
    __publicField(this, "Gh", T256_IV2[12] | 0);
    __publicField(this, "Gl", T256_IV2[13] | 0);
    __publicField(this, "Hh", T256_IV2[14] | 0);
    __publicField(this, "Hl", T256_IV2[15] | 0);
  }
};
var sha2564 = createHasher2(
  () => new _SHA256(),
  oidNist(1)
);
var sha2242 = createHasher2(
  () => new _SHA224(),
  oidNist(4)
);
var sha5123 = createHasher2(
  () => new _SHA512(),
  oidNist(3)
);
var sha3842 = createHasher2(
  () => new _SHA384(),
  oidNist(2)
);
var sha512_2562 = createHasher2(
  () => new _SHA512_256(),
  oidNist(6)
);
var sha512_2242 = createHasher2(
  () => new _SHA512_224(),
  oidNist(5)
);

// node_modules/@libp2p/crypto/node_modules/@noble/curves/utils.js
var _0n = BigInt(0);
var _1n = BigInt(1);
function abool(value, title = "") {
  if (typeof value !== "boolean") {
    const prefix = title && `"${title}" `;
    throw new Error(prefix + "expected boolean, got type=" + typeof value);
  }
  return value;
}
function abignumber(n2) {
  if (typeof n2 === "bigint") {
    if (!isPosBig(n2))
      throw new Error("positive bigint expected, got " + n2);
  } else
    anumber2(n2);
  return n2;
}
function asafenumber(value, title = "") {
  if (!Number.isSafeInteger(value)) {
    const prefix = title && `"${title}" `;
    throw new Error(prefix + "expected safe integer, got type=" + typeof value);
  }
}
function numberToHexUnpadded(num3) {
  const hex = abignumber(num3).toString(16);
  return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n : BigInt("0x" + hex);
}
function bytesToNumberBE(bytes) {
  return hexToNumber(bytesToHex3(bytes));
}
function bytesToNumberLE(bytes) {
  return hexToNumber(bytesToHex3(copyBytes(abytes2(bytes)).reverse()));
}
function numberToBytesBE(n2, len) {
  anumber2(len);
  n2 = abignumber(n2);
  const res = hexToBytes3(n2.toString(16).padStart(len * 2, "0"));
  if (res.length !== len)
    throw new Error("number too large");
  return res;
}
function numberToBytesLE(n2, len) {
  return numberToBytesBE(n2, len).reverse();
}
function equalBytes(a2, b) {
  if (a2.length !== b.length)
    return false;
  let diff = 0;
  for (let i2 = 0; i2 < a2.length; i2++)
    diff |= a2[i2] ^ b[i2];
  return diff === 0;
}
function copyBytes(bytes) {
  return Uint8Array.from(bytes);
}
function asciiToBytes(ascii2) {
  return Uint8Array.from(ascii2, (c2, i2) => {
    const charCode = c2.charCodeAt(0);
    if (c2.length !== 1 || charCode > 127) {
      throw new Error(`string contains non-ASCII character "${ascii2[i2]}" with code ${charCode} at position ${i2}`);
    }
    return charCode;
  });
}
var isPosBig = (n2) => typeof n2 === "bigint" && _0n <= n2;
function inRange(n2, min, max) {
  return isPosBig(n2) && isPosBig(min) && isPosBig(max) && min <= n2 && n2 < max;
}
function aInRange(title, n2, min, max) {
  if (!inRange(n2, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n2);
}
function bitLen(n2) {
  let len;
  for (len = 0; n2 > _0n; n2 >>= _1n, len += 1)
    ;
  return len;
}
var bitMask = (n2) => (_1n << BigInt(n2)) - _1n;
function createHmacDrbg(hashLen2, qByteLen, hmacFn) {
  anumber2(hashLen2, "hashLen");
  anumber2(qByteLen, "qByteLen");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  const u8n = (len) => new Uint8Array(len);
  const NULL = Uint8Array.of();
  const byte0 = Uint8Array.of(0);
  const byte1 = Uint8Array.of(1);
  const _maxDrbgIters = 1e3;
  let v = u8n(hashLen2);
  let k = u8n(hashLen2);
  let i2 = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i2 = 0;
  };
  const h = (...msgs) => hmacFn(k, concatBytes2(v, ...msgs));
  const reseed = (seed = NULL) => {
    k = h(byte0, seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(byte1, seed);
    v = h();
  };
  const gen = () => {
    if (i2++ >= _maxDrbgIters)
      throw new Error("drbg: tried max amount of iterations");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function validateObject(object, fields = {}, optFields = {}) {
  if (!object || typeof object !== "object")
    throw new Error("expected valid options object");
  function checkField(fieldName, expectedType, isOpt) {
    const val = object[fieldName];
    if (isOpt && val === void 0)
      return;
    const current = typeof val;
    if (current !== expectedType || val === null)
      throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
  }
  const iter = (f3, isOpt) => Object.entries(f3).forEach(([k, v]) => checkField(k, v, isOpt));
  iter(fields, false);
  iter(optFields, true);
}
var notImplemented = () => {
  throw new Error("not implemented");
};
function memoized(fn) {
  const map2 = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map2.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn(arg, ...args);
    map2.set(arg, computed);
    return computed;
  };
}

// node_modules/@libp2p/crypto/node_modules/@noble/curves/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _7n = BigInt(7);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a2, b) {
  const result = a2 % b;
  return result >= _0n2 ? result : b + result;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n2)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n2)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a2 = mod(number2, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a2 !== _0n2) {
    const q = b / a2;
    const r2 = b % a2;
    const m2 = x - u * q;
    const n2 = y - v * q;
    b = a2, a2 = r2, x = u, y = v, u = m2, v = n2;
  }
  const gcd = b;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function assertIsSquare(Fp3, root, n2) {
  if (!Fp3.eql(Fp3.sqr(root), n2))
    throw new Error("Cannot find square root");
}
function sqrt3mod4(Fp3, n2) {
  const p1div4 = (Fp3.ORDER + _1n2) / _4n;
  const root = Fp3.pow(n2, p1div4);
  assertIsSquare(Fp3, root, n2);
  return root;
}
function sqrt5mod8(Fp3, n2) {
  const p5div8 = (Fp3.ORDER - _5n) / _8n;
  const n22 = Fp3.mul(n2, _2n);
  const v = Fp3.pow(n22, p5div8);
  const nv = Fp3.mul(n2, v);
  const i2 = Fp3.mul(Fp3.mul(nv, _2n), v);
  const root = Fp3.mul(nv, Fp3.sub(i2, Fp3.ONE));
  assertIsSquare(Fp3, root, n2);
  return root;
}
function sqrt9mod16(P) {
  const Fp_ = Field(P);
  const tn = tonelliShanks(P);
  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
  const c2 = tn(Fp_, c1);
  const c3 = tn(Fp_, Fp_.neg(c1));
  const c4 = (P + _7n) / _16n;
  return (Fp3, n2) => {
    let tv1 = Fp3.pow(n2, c4);
    let tv2 = Fp3.mul(tv1, c1);
    const tv3 = Fp3.mul(tv1, c2);
    const tv4 = Fp3.mul(tv1, c3);
    const e1 = Fp3.eql(Fp3.sqr(tv2), n2);
    const e2 = Fp3.eql(Fp3.sqr(tv3), n2);
    tv1 = Fp3.cmov(tv1, tv2, e1);
    tv2 = Fp3.cmov(tv4, tv3, e2);
    const e3 = Fp3.eql(Fp3.sqr(tv2), n2);
    const root = Fp3.cmov(tv1, tv2, e3);
    assertIsSquare(Fp3, root, n2);
    return root;
  };
}
function tonelliShanks(P) {
  if (P < _3n)
    throw new Error("sqrt is not defined for small field");
  let Q = P - _1n2;
  let S = 0;
  while (Q % _2n === _0n2) {
    Q /= _2n;
    S++;
  }
  let Z = _2n;
  const _Fp = Field(P);
  while (FpLegendre(_Fp, Z) === 1) {
    if (Z++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S === 1)
    return sqrt3mod4;
  let cc = _Fp.pow(Z, Q);
  const Q1div2 = (Q + _1n2) / _2n;
  return function tonelliSlow(Fp3, n2) {
    if (Fp3.is0(n2))
      return n2;
    if (FpLegendre(Fp3, n2) !== 1)
      throw new Error("Cannot find square root");
    let M = S;
    let c2 = Fp3.mul(Fp3.ONE, cc);
    let t2 = Fp3.pow(n2, Q);
    let R = Fp3.pow(n2, Q1div2);
    while (!Fp3.eql(t2, Fp3.ONE)) {
      if (Fp3.is0(t2))
        return Fp3.ZERO;
      let i2 = 1;
      let t_tmp = Fp3.sqr(t2);
      while (!Fp3.eql(t_tmp, Fp3.ONE)) {
        i2++;
        t_tmp = Fp3.sqr(t_tmp);
        if (i2 === M)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n2 << BigInt(M - i2 - 1);
      const b = Fp3.pow(c2, exponent);
      M = i2;
      c2 = Fp3.sqr(b);
      t2 = Fp3.mul(t2, c2);
      R = Fp3.mul(R, b);
    }
    return R;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n)
    return sqrt3mod4;
  if (P % _8n === _5n)
    return sqrt5mod8;
  if (P % _16n === _9n)
    return sqrt9mod16(P);
  return tonelliShanks(P);
}
var isNegativeLE = (num3, modulo) => (mod(num3, modulo) & _1n2) === _1n2;
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts = FIELD_FIELDS.reduce((map2, val) => {
    map2[val] = "function";
    return map2;
  }, initial);
  validateObject(field, opts);
  return field;
}
function FpPow(Fp3, num3, power) {
  if (power < _0n2)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n2)
    return Fp3.ONE;
  if (power === _1n2)
    return num3;
  let p2 = Fp3.ONE;
  let d2 = num3;
  while (power > _0n2) {
    if (power & _1n2)
      p2 = Fp3.mul(p2, d2);
    d2 = Fp3.sqr(d2);
    power >>= _1n2;
  }
  return p2;
}
function FpInvertBatch(Fp3, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp3.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num3, i2) => {
    if (Fp3.is0(num3))
      return acc;
    inverted[i2] = acc;
    return Fp3.mul(acc, num3);
  }, Fp3.ONE);
  const invertedAcc = Fp3.inv(multipliedAcc);
  nums.reduceRight((acc, num3, i2) => {
    if (Fp3.is0(num3))
      return acc;
    inverted[i2] = Fp3.mul(acc, inverted[i2]);
    return Fp3.mul(acc, num3);
  }, invertedAcc);
  return inverted;
}
function FpLegendre(Fp3, n2) {
  const p1mod2 = (Fp3.ORDER - _1n2) / _2n;
  const powered = Fp3.pow(n2, p1mod2);
  const yes = Fp3.eql(powered, Fp3.ONE);
  const zero2 = Fp3.eql(powered, Fp3.ZERO);
  const no = Fp3.eql(powered, Fp3.neg(Fp3.ONE));
  if (!yes && !zero2 && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero2 ? 0 : -1;
}
function nLength(n2, nBitLength) {
  if (nBitLength !== void 0)
    anumber2(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
var _Field = class {
  constructor(ORDER, opts = {}) {
    __publicField(this, "ORDER");
    __publicField(this, "BITS");
    __publicField(this, "BYTES");
    __publicField(this, "isLE");
    __publicField(this, "ZERO", _0n2);
    __publicField(this, "ONE", _1n2);
    __publicField(this, "_lengths");
    __publicField(this, "_sqrt");
    // cached sqrt
    __publicField(this, "_mod");
    var _a27;
    if (ORDER <= _0n2)
      throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
    let _nbitLength = void 0;
    this.isLE = false;
    if (opts != null && typeof opts === "object") {
      if (typeof opts.BITS === "number")
        _nbitLength = opts.BITS;
      if (typeof opts.sqrt === "function")
        this.sqrt = opts.sqrt;
      if (typeof opts.isLE === "boolean")
        this.isLE = opts.isLE;
      if (opts.allowedLengths)
        this._lengths = (_a27 = opts.allowedLengths) == null ? void 0 : _a27.slice();
      if (typeof opts.modFromBytes === "boolean")
        this._mod = opts.modFromBytes;
    }
    const { nBitLength, nByteLength } = nLength(ORDER, _nbitLength);
    if (nByteLength > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    this.ORDER = ORDER;
    this.BITS = nBitLength;
    this.BYTES = nByteLength;
    this._sqrt = void 0;
    Object.preventExtensions(this);
  }
  create(num3) {
    return mod(num3, this.ORDER);
  }
  isValid(num3) {
    if (typeof num3 !== "bigint")
      throw new Error("invalid field element: expected bigint, got " + typeof num3);
    return _0n2 <= num3 && num3 < this.ORDER;
  }
  is0(num3) {
    return num3 === _0n2;
  }
  // is valid and invertible
  isValidNot0(num3) {
    return !this.is0(num3) && this.isValid(num3);
  }
  isOdd(num3) {
    return (num3 & _1n2) === _1n2;
  }
  neg(num3) {
    return mod(-num3, this.ORDER);
  }
  eql(lhs, rhs) {
    return lhs === rhs;
  }
  sqr(num3) {
    return mod(num3 * num3, this.ORDER);
  }
  add(lhs, rhs) {
    return mod(lhs + rhs, this.ORDER);
  }
  sub(lhs, rhs) {
    return mod(lhs - rhs, this.ORDER);
  }
  mul(lhs, rhs) {
    return mod(lhs * rhs, this.ORDER);
  }
  pow(num3, power) {
    return FpPow(this, num3, power);
  }
  div(lhs, rhs) {
    return mod(lhs * invert(rhs, this.ORDER), this.ORDER);
  }
  // Same as above, but doesn't normalize
  sqrN(num3) {
    return num3 * num3;
  }
  addN(lhs, rhs) {
    return lhs + rhs;
  }
  subN(lhs, rhs) {
    return lhs - rhs;
  }
  mulN(lhs, rhs) {
    return lhs * rhs;
  }
  inv(num3) {
    return invert(num3, this.ORDER);
  }
  sqrt(num3) {
    if (!this._sqrt)
      this._sqrt = FpSqrt(this.ORDER);
    return this._sqrt(this, num3);
  }
  toBytes(num3) {
    return this.isLE ? numberToBytesLE(num3, this.BYTES) : numberToBytesBE(num3, this.BYTES);
  }
  fromBytes(bytes, skipValidation = false) {
    abytes2(bytes);
    const { _lengths: allowedLengths, BYTES, isLE: isLE4, ORDER, _mod: modFromBytes } = this;
    if (allowedLengths) {
      if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
        throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
      }
      const padded = new Uint8Array(BYTES);
      padded.set(bytes, isLE4 ? 0 : padded.length - bytes.length);
      bytes = padded;
    }
    if (bytes.length !== BYTES)
      throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
    let scalar = isLE4 ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
    if (modFromBytes)
      scalar = mod(scalar, ORDER);
    if (!skipValidation) {
      if (!this.isValid(scalar))
        throw new Error("invalid field element: outside of range 0..ORDER");
    }
    return scalar;
  }
  // TODO: we don't need it here, move out to separate fn
  invertBatch(lst) {
    return FpInvertBatch(this, lst);
  }
  // We can't move this out because Fp6, Fp12 implement it
  // and it's unclear what to return in there.
  cmov(a2, b, condition) {
    return condition ? b : a2;
  }
};
function Field(ORDER, opts = {}) {
  return new _Field(ORDER, opts);
}
function FpSqrtEven(Fp3, elm) {
  if (!Fp3.isOdd)
    throw new Error("Field doesn't have isOdd");
  const root = Fp3.sqrt(elm);
  return Fp3.isOdd(root) ? Fp3.neg(root) : root;
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length3 = getFieldBytesLength(fieldOrder);
  return length3 + Math.ceil(length3 / 2);
}
function mapHashToField(key, fieldOrder, isLE4 = false) {
  abytes2(key);
  const len = key.length;
  const fieldLen2 = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num3 = isLE4 ? bytesToNumberLE(key) : bytesToNumberBE(key);
  const reduced = mod(num3, fieldOrder - _1n2) + _1n2;
  return isLE4 ? numberToBytesLE(reduced, fieldLen2) : numberToBytesBE(reduced, fieldLen2);
}

// node_modules/@libp2p/crypto/node_modules/@noble/curves/abstract/curve.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function negateCt(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function normalizeZ(c2, points) {
  const invertedZs = FpInvertBatch(c2.Fp, points.map((p2) => p2.Z));
  return points.map((p2, i2) => c2.fromAffine(p2.toAffine(invertedZs[i2])));
}
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, scalarBits) {
  validateW(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask = bitMask(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n2, window2, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n2 & mask);
  let nextN = n2 >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n3;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c2) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p2, i2) => {
    if (!(p2 instanceof c2))
      throw new Error("invalid point at index " + i2);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s2, i2) => {
    if (!field.isValid(s2))
      throw new Error("invalid scalar at index " + i2);
  });
}
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(P) {
  return pointWindowSizes.get(P) || 1;
}
function assert0(n2) {
  if (n2 !== _0n3)
    throw new Error("invalid wNAF");
}
var wNAF = class {
  // Parametrized with a given Point class (not individual point)
  constructor(Point2, bits) {
    __publicField(this, "BASE");
    __publicField(this, "ZERO");
    __publicField(this, "Fn");
    __publicField(this, "bits");
    this.BASE = Point2.BASE;
    this.ZERO = Point2.ZERO;
    this.Fn = Point2.Fn;
    this.bits = bits;
  }
  // non-const time multiplication ladder
  _unsafeLadder(elm, n2, p2 = this.ZERO) {
    let d2 = elm;
    while (n2 > _0n3) {
      if (n2 & _1n3)
        p2 = p2.add(d2);
      d2 = d2.double();
      n2 >>= _1n3;
    }
    return p2;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(1) * (Math.ceil( / ) + 1), where:
   * -  is the window size
   * -  is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(point, W) {
    const { windows, windowSize } = calcWOpts(W, this.bits);
    const points = [];
    let p2 = point;
    let base4 = p2;
    for (let window2 = 0; window2 < windows; window2++) {
      base4 = p2;
      points.push(base4);
      for (let i2 = 1; i2 < windowSize; i2++) {
        base4 = base4.add(p2);
        points.push(base4);
      }
      p2 = base4.double();
    }
    return points;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(W, precomputes, n2) {
    if (!this.Fn.isValid(n2))
      throw new Error("invalid scalar");
    let p2 = this.ZERO;
    let f3 = this.BASE;
    const wo = calcWOpts(W, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n2, window2, wo);
      n2 = nextN;
      if (isZero) {
        f3 = f3.add(negateCt(isNegF, precomputes[offsetF]));
      } else {
        p2 = p2.add(negateCt(isNeg, precomputes[offset]));
      }
    }
    assert0(n2);
    return { p: p2, f: f3 };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(W, precomputes, n2, acc = this.ZERO) {
    const wo = calcWOpts(W, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      if (n2 === _0n3)
        break;
      const { nextN, offset, isZero, isNeg } = calcOffsets(n2, window2, wo);
      n2 = nextN;
      if (isZero) {
        continue;
      } else {
        const item = precomputes[offset];
        acc = acc.add(isNeg ? item.negate() : item);
      }
    }
    assert0(n2);
    return acc;
  }
  getPrecomputes(W, point, transform) {
    let comp = pointPrecomputes.get(point);
    if (!comp) {
      comp = this.precomputeWindow(point, W);
      if (W !== 1) {
        if (typeof transform === "function")
          comp = transform(comp);
        pointPrecomputes.set(point, comp);
      }
    }
    return comp;
  }
  cached(point, scalar, transform) {
    const W = getW(point);
    return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
  }
  unsafe(point, scalar, transform, prev) {
    const W = getW(point);
    if (W === 1)
      return this._unsafeLadder(point, scalar, prev);
    return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(P, W) {
    validateW(W, this.bits);
    pointWindowSizes.set(P, W);
    pointPrecomputes.delete(P);
  }
  hasCache(elm) {
    return getW(elm) !== 1;
  }
};
function mulEndoUnsafe(Point2, point, k1, k2) {
  let acc = point;
  let p1 = Point2.ZERO;
  let p2 = Point2.ZERO;
  while (k1 > _0n3 || k2 > _0n3) {
    if (k1 & _1n3)
      p1 = p1.add(acc);
    if (k2 & _1n3)
      p2 = p2.add(acc);
    acc = acc.double();
    k1 >>= _1n3;
    k2 >>= _1n3;
  }
  return { p1, p2 };
}
function pippenger(c2, points, scalars) {
  const fieldN = c2.Fn;
  validateMSMPoints(points, c2);
  validateMSMScalars(scalars, fieldN);
  const plength = points.length;
  const slength = scalars.length;
  if (plength !== slength)
    throw new Error("arrays of points and scalars must have equal length");
  const zero2 = c2.ZERO;
  const wbits = bitLen(BigInt(plength));
  let windowSize = 1;
  if (wbits > 12)
    windowSize = wbits - 3;
  else if (wbits > 4)
    windowSize = wbits - 2;
  else if (wbits > 0)
    windowSize = 2;
  const MASK = bitMask(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero2);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero2;
  for (let i2 = lastBits; i2 >= 0; i2 -= windowSize) {
    buckets.fill(zero2);
    for (let j = 0; j < slength; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i2) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero2;
    for (let j = buckets.length - 1, sumI = zero2; j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i2 !== 0)
      for (let j = 0; j < windowSize; j++)
        sum = sum.double();
  }
  return sum;
}
function createField(order, field, isLE4) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField(field);
    return field;
  } else {
    return Field(order, { isLE: isLE4 });
  }
}
function createCurveFields(type, CURVE2, curveOpts = {}, FpFnLE) {
  if (FpFnLE === void 0)
    FpFnLE = type === "edwards";
  if (!CURVE2 || typeof CURVE2 !== "object")
    throw new Error(`expected valid ${type} CURVE object`);
  for (const p2 of ["p", "n", "h"]) {
    const val = CURVE2[p2];
    if (!(typeof val === "bigint" && val > _0n3))
      throw new Error(`CURVE.${p2} must be positive bigint`);
  }
  const Fp3 = createField(CURVE2.p, curveOpts.Fp, FpFnLE);
  const Fn3 = createField(CURVE2.n, curveOpts.Fn, FpFnLE);
  const _b14 = type === "weierstrass" ? "b" : "d";
  const params = ["Gx", "Gy", "a", _b14];
  for (const p2 of params) {
    if (!Fp3.isValid(CURVE2[p2]))
      throw new Error(`CURVE.${p2} must be valid field element of CURVE.Fp`);
  }
  CURVE2 = Object.freeze(Object.assign({}, CURVE2));
  return { CURVE: CURVE2, Fp: Fp3, Fn: Fn3 };
}
function createKeygen(randomSecretKey, getPublicKey) {
  return function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: getPublicKey(secretKey) };
  };
}

// node_modules/@libp2p/crypto/node_modules/@noble/curves/abstract/edwards.js
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n2 = BigInt(2);
var _8n2 = BigInt(8);
function isEdValidXY(Fp3, CURVE2, x, y) {
  const x2 = Fp3.sqr(x);
  const y2 = Fp3.sqr(y);
  const left = Fp3.add(Fp3.mul(CURVE2.a, x2), y2);
  const right = Fp3.add(Fp3.ONE, Fp3.mul(CURVE2.d, Fp3.mul(x2, y2)));
  return Fp3.eql(left, right);
}
function edwards(params, extraOpts = {}) {
  const validated = createCurveFields("edwards", params, extraOpts, extraOpts.FpFnLE);
  const { Fp: Fp3, Fn: Fn3 } = validated;
  let CURVE2 = validated.CURVE;
  const { h: cofactor } = CURVE2;
  validateObject(extraOpts, {}, { uvRatio: "function" });
  const MASK = _2n2 << BigInt(Fn3.BYTES * 8) - _1n4;
  const modP = (n2) => Fp3.create(n2);
  const uvRatio3 = extraOpts.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp3.sqrt(Fp3.div(u, v)) };
    } catch (e2) {
      return { isValid: false, value: _0n4 };
    }
  });
  if (!isEdValidXY(Fp3, CURVE2, CURVE2.Gx, CURVE2.Gy))
    throw new Error("bad curve params: generator point");
  function acoord(title, n2, banZero = false) {
    const min = banZero ? _1n4 : _0n4;
    aInRange("coordinate " + title, n2, min, MASK);
    return n2;
  }
  function aedpoint(other) {
    if (!(other instanceof Point2))
      throw new Error("EdwardsPoint expected");
  }
  const toAffineMemo = memoized((p2, iz) => {
    const { X, Y, Z } = p2;
    const is0 = p2.is0();
    if (iz == null)
      iz = is0 ? _8n2 : Fp3.inv(Z);
    const x = modP(X * iz);
    const y = modP(Y * iz);
    const zz = Fp3.mul(Z, iz);
    if (is0)
      return { x: _0n4, y: _1n4 };
    if (zz !== _1n4)
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized((p2) => {
    const { a: a2, d: d2 } = CURVE2;
    if (p2.is0())
      throw new Error("bad point: ZERO");
    const { X, Y, Z, T } = p2;
    const X2 = modP(X * X);
    const Y2 = modP(Y * Y);
    const Z2 = modP(Z * Z);
    const Z4 = modP(Z2 * Z2);
    const aX2 = modP(X2 * a2);
    const left = modP(Z2 * modP(aX2 + Y2));
    const right = modP(Z4 + modP(d2 * modP(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT = modP(Z * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  const _Point = class _Point {
    constructor(X, Y, Z, T) {
      __publicField(this, "X");
      __publicField(this, "Y");
      __publicField(this, "Z");
      __publicField(this, "T");
      this.X = acoord("x", X);
      this.Y = acoord("y", Y);
      this.Z = acoord("z", Z, true);
      this.T = acoord("t", T);
      Object.freeze(this);
    }
    static CURVE() {
      return CURVE2;
    }
    static fromAffine(p2) {
      if (p2 instanceof _Point)
        throw new Error("extended point not allowed");
      const { x, y } = p2 || {};
      acoord("x", x);
      acoord("y", y);
      return new _Point(x, y, _1n4, modP(x * y));
    }
    // Uses algo from RFC8032 5.1.3.
    static fromBytes(bytes, zip215 = false) {
      const len = Fp3.BYTES;
      const { a: a2, d: d2 } = CURVE2;
      bytes = copyBytes(abytes2(bytes, len, "point"));
      abool(zip215, "zip215");
      const normed = copyBytes(bytes);
      const lastByte = bytes[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y = bytesToNumberLE(normed);
      const max = zip215 ? MASK : Fp3.ORDER;
      aInRange("point.y", y, _0n4, max);
      const y2 = modP(y * y);
      const u = modP(y2 - _1n4);
      const v = modP(d2 * y2 - a2);
      let { isValid, value: x } = uvRatio3(u, v);
      if (!isValid)
        throw new Error("bad point: invalid y coordinate");
      const isXOdd = (x & _1n4) === _1n4;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x === _0n4 && isLastByteOdd)
        throw new Error("bad point: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x = modP(-x);
      return _Point.fromAffine({ x, y });
    }
    static fromHex(hex, zip215 = false) {
      return _Point.fromBytes(hexToBytes3(hex), zip215);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_2n2);
      return this;
    }
    // Useful in fromAffine() - not for fromBytes(), which always created valid points.
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      aedpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(_Point.ZERO);
    }
    negate() {
      return new _Point(modP(-this.X), this.Y, this.Z, modP(-this.T));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a: a2 } = CURVE2;
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const A = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C = modP(_2n2 * modP(Z1 * Z1));
      const D = modP(a2 * A);
      const x1y1 = X1 + Y1;
      const E = modP(modP(x1y1 * x1y1) - A - B);
      const G = D + B;
      const F = G - C;
      const H = D - B;
      const X3 = modP(E * F);
      const Y3 = modP(G * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G);
      return new _Point(X3, Y3, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      aedpoint(other);
      const { a: a2, d: d2 } = CURVE2;
      const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
      const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
      const A = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C = modP(T1 * d2 * T2);
      const D = modP(Z1 * Z2);
      const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D - C;
      const G = D + C;
      const H = modP(B - a2 * A);
      const X3 = modP(E * F);
      const Y3 = modP(G * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G);
      return new _Point(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    // Constant-time multiplication.
    multiply(scalar) {
      if (!Fn3.isValidNot0(scalar))
        throw new Error("invalid scalar: expected 1 <= sc < curve.n");
      const { p: p2, f: f3 } = wnaf.cached(this, scalar, (p3) => normalizeZ(_Point, p3));
      return normalizeZ(_Point, [p2, f3])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    // Accepts optional accumulator to merge with multiply (important for sparse scalars)
    multiplyUnsafe(scalar, acc = _Point.ZERO) {
      if (!Fn3.isValid(scalar))
        throw new Error("invalid scalar: expected 0 <= sc < curve.n");
      if (scalar === _0n4)
        return _Point.ZERO;
      if (this.is0() || scalar === _1n4)
        return this;
      return wnaf.unsafe(this, scalar, (p2) => normalizeZ(_Point, p2), acc);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafe(this, CURVE2.n).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    clearCofactor() {
      if (cofactor === _1n4)
        return this;
      return this.multiplyUnsafe(cofactor);
    }
    toBytes() {
      const { x, y } = this.toAffine();
      const bytes = Fp3.toBytes(y);
      bytes[bytes.length - 1] |= x & _1n4 ? 128 : 0;
      return bytes;
    }
    toHex() {
      return bytesToHex3(this.toBytes());
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  };
  // base / generator point
  __publicField(_Point, "BASE", new _Point(CURVE2.Gx, CURVE2.Gy, _1n4, modP(CURVE2.Gx * CURVE2.Gy)));
  // zero / infinity / identity point
  __publicField(_Point, "ZERO", new _Point(_0n4, _1n4, _1n4, _0n4));
  // 0, 1, 1, 0
  // math field
  __publicField(_Point, "Fp", Fp3);
  // scalar field
  __publicField(_Point, "Fn", Fn3);
  let Point2 = _Point;
  const wnaf = new wNAF(Point2, Fn3.BITS);
  Point2.BASE.precompute(8);
  return Point2;
}
var PrimeEdwardsPoint = class {
  constructor(ep) {
    __publicField(this, "ep");
    this.ep = ep;
  }
  // Static methods that must be implemented by subclasses
  static fromBytes(_bytes2) {
    notImplemented();
  }
  static fromHex(_hex) {
    notImplemented();
  }
  get x() {
    return this.toAffine().x;
  }
  get y() {
    return this.toAffine().y;
  }
  // Common implementations
  clearCofactor() {
    return this;
  }
  assertValidity() {
    this.ep.assertValidity();
  }
  toAffine(invertedZ) {
    return this.ep.toAffine(invertedZ);
  }
  toHex() {
    return bytesToHex3(this.toBytes());
  }
  toString() {
    return this.toHex();
  }
  isTorsionFree() {
    return true;
  }
  isSmallOrder() {
    return false;
  }
  add(other) {
    this.assertSame(other);
    return this.init(this.ep.add(other.ep));
  }
  subtract(other) {
    this.assertSame(other);
    return this.init(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return this.init(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return this.init(this.ep.multiplyUnsafe(scalar));
  }
  double() {
    return this.init(this.ep.double());
  }
  negate() {
    return this.init(this.ep.negate());
  }
  precompute(windowSize, isLazy) {
    return this.init(this.ep.precompute(windowSize, isLazy));
  }
};
__publicField(PrimeEdwardsPoint, "BASE");
__publicField(PrimeEdwardsPoint, "ZERO");
__publicField(PrimeEdwardsPoint, "Fp");
__publicField(PrimeEdwardsPoint, "Fn");
function eddsa(Point2, cHash, eddsaOpts = {}) {
  if (typeof cHash !== "function")
    throw new Error('"hash" function param is required');
  validateObject(eddsaOpts, {}, {
    adjustScalarBytes: "function",
    randomBytes: "function",
    domain: "function",
    prehash: "function",
    mapToCurve: "function"
  });
  const { prehash } = eddsaOpts;
  const { BASE, Fp: Fp3, Fn: Fn3 } = Point2;
  const randomBytes5 = eddsaOpts.randomBytes || randomBytes2;
  const adjustScalarBytes3 = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
  const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
    abool(phflag, "phflag");
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function modN_LE(hash) {
    return Fn3.create(bytesToNumberLE(hash));
  }
  function getPrivateScalar(key) {
    const len = lengths.secretKey;
    abytes2(key, lengths.secretKey, "secretKey");
    const hashed = abytes2(cHash(key), 2 * len, "hashedSecretKey");
    const head = adjustScalarBytes3(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    return { head, prefix, scalar };
  }
  function getExtendedPublicKey(secretKey) {
    const { head, prefix, scalar } = getPrivateScalar(secretKey);
    const point = BASE.multiply(scalar);
    const pointBytes = point.toBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey(secretKey) {
    return getExtendedPublicKey(secretKey).pointBytes;
  }
  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
    const msg = concatBytes2(...msgs);
    return modN_LE(cHash(domain(msg, abytes2(context, void 0, "context"), !!prehash)));
  }
  function sign3(msg, secretKey, options = {}) {
    msg = abytes2(msg, void 0, "message");
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
    const r2 = hashDomainToScalar(options.context, prefix, msg);
    const R = BASE.multiply(r2).toBytes();
    const k = hashDomainToScalar(options.context, R, pointBytes, msg);
    const s2 = Fn3.create(r2 + k * scalar);
    if (!Fn3.isValid(s2))
      throw new Error("sign failed: invalid s");
    const rs = concatBytes2(R, Fn3.toBytes(s2));
    return abytes2(rs, lengths.signature, "result");
  }
  const verifyOpts = { zip215: true };
  function verify2(sig, msg, publicKey, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = lengths.signature;
    sig = abytes2(sig, len, "signature");
    msg = abytes2(msg, void 0, "message");
    publicKey = abytes2(publicKey, lengths.publicKey, "publicKey");
    if (zip215 !== void 0)
      abool(zip215, "zip215");
    if (prehash)
      msg = prehash(msg);
    const mid = len / 2;
    const r2 = sig.subarray(0, mid);
    const s2 = bytesToNumberLE(sig.subarray(mid, len));
    let A, R, SB;
    try {
      A = Point2.fromBytes(publicKey, zip215);
      R = Point2.fromBytes(r2, zip215);
      SB = BASE.multiplyUnsafe(s2);
    } catch (error) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
    const RkA = R.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().is0();
  }
  const _size2 = Fp3.BYTES;
  const lengths = {
    secretKey: _size2,
    publicKey: _size2,
    signature: 2 * _size2,
    seed: _size2
  };
  function randomSecretKey(seed = randomBytes5(lengths.seed)) {
    return abytes2(seed, lengths.seed, "seed");
  }
  function isValidSecretKey(key) {
    return isBytes2(key) && key.length === Fn3.BYTES;
  }
  function isValidPublicKey(key, zip215) {
    try {
      return !!Point2.fromBytes(key, zip215);
    } catch (error) {
      return false;
    }
  }
  const utils2 = {
    getExtendedPublicKey,
    randomSecretKey,
    isValidSecretKey,
    isValidPublicKey,
    /**
     * Converts ed public key to x public key. Uses formula:
     * - ed25519:
     *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
     *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
     * - ed448:
     *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
     *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
     */
    toMontgomery(publicKey) {
      const { y } = Point2.fromBytes(publicKey);
      const size = lengths.publicKey;
      const is25519 = size === 32;
      if (!is25519 && size !== 57)
        throw new Error("only defined for 25519 and 448");
      const u = is25519 ? Fp3.div(_1n4 + y, _1n4 - y) : Fp3.div(y - _1n4, y + _1n4);
      return Fp3.toBytes(u);
    },
    toMontgomerySecret(secretKey) {
      const size = lengths.secretKey;
      abytes2(secretKey, size);
      const hashed = cHash(secretKey.subarray(0, size));
      return adjustScalarBytes3(hashed).subarray(0, size);
    }
  };
  return Object.freeze({
    keygen: createKeygen(randomSecretKey, getPublicKey),
    getPublicKey,
    sign: sign3,
    verify: verify2,
    utils: utils2,
    Point: Point2,
    lengths
  });
}

// node_modules/@libp2p/crypto/node_modules/@noble/curves/abstract/hash-to-curve.js
var os2ip = bytesToNumberBE;
function i2osp(value, length3) {
  asafenumber(value);
  asafenumber(length3);
  if (value < 0 || value >= 1 << 8 * length3)
    throw new Error("invalid I2OSP input: " + value);
  const res = Array.from({ length: length3 }).fill(0);
  for (let i2 = length3 - 1; i2 >= 0; i2--) {
    res[i2] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a2, b) {
  const arr = new Uint8Array(a2.length);
  for (let i2 = 0; i2 < a2.length; i2++) {
    arr[i2] = a2[i2] ^ b[i2];
  }
  return arr;
}
function normDST(DST) {
  if (!isBytes2(DST) && typeof DST !== "string")
    throw new Error("DST must be Uint8Array or ascii string");
  return typeof DST === "string" ? asciiToBytes(DST) : DST;
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  abytes2(msg);
  asafenumber(lenInBytes);
  DST = normDST(DST);
  if (DST.length > 255)
    DST = H(concatBytes2(asciiToBytes("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (lenInBytes > 65535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes2(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H(concatBytes2(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H(concatBytes2(b_0, i2osp(1, 1), DST_prime));
  for (let i2 = 1; i2 <= ell; i2++) {
    const args = [strxor(b_0, b[i2 - 1]), i2osp(i2 + 1, 1), DST_prime];
    b[i2] = H(concatBytes2(...args));
  }
  const pseudo_random_bytes = concatBytes2(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  abytes2(msg);
  asafenumber(lenInBytes);
  DST = normDST(DST);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(asciiToBytes("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  validateObject(options, {
    p: "bigint",
    m: "number",
    k: "number",
    hash: "function"
  });
  const { p: p2, k, m: m2, hash, expand: expand2, DST } = options;
  asafenumber(hash.outputLen, "valid hash");
  abytes2(msg);
  asafenumber(count);
  const log2p = p2.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m2 * L;
  let prb;
  if (expand2 === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
  } else if (expand2 === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
  } else if (expand2 === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i2 = 0; i2 < count; i2++) {
    const e2 = new Array(m2);
    for (let j = 0; j < m2; j++) {
      const elm_offset = L * (j + i2 * m2);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e2[j] = mod(os2ip(tv), p2);
    }
    u[i2] = e2;
  }
  return u;
}
function isogenyMap(field, map2) {
  const coeff = map2.map((i2) => Array.from(i2).reverse());
  return (x, y) => {
    const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i2) => field.add(field.mul(acc, x), i2)));
    const [xd_inv, yd_inv] = FpInvertBatch(field, [xd, yd], true);
    x = field.mul(xn, xd_inv);
    y = field.mul(y, field.mul(yn, yd_inv));
    return { x, y };
  };
}
var _DST_scalar = asciiToBytes("HashToScalar-");
function createHasher3(Point2, mapToCurve, defaults) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  function map2(num3) {
    return Point2.fromAffine(mapToCurve(num3));
  }
  function clear(initial) {
    const P = initial.clearCofactor();
    if (P.equals(Point2.ZERO))
      return Point2.ZERO;
    P.assertValidity();
    return P;
  }
  return {
    defaults: Object.freeze(defaults),
    Point: Point2,
    hashToCurve(msg, options) {
      const opts = Object.assign({}, defaults, options);
      const u = hash_to_field(msg, 2, opts);
      const u0 = map2(u[0]);
      const u1 = map2(u[1]);
      return clear(u0.add(u1));
    },
    encodeToCurve(msg, options) {
      const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
      const opts = Object.assign({}, defaults, optsDst, options);
      const u = hash_to_field(msg, 1, opts);
      const u0 = map2(u[0]);
      return clear(u0);
    },
    /** See {@link H2CHasher} */
    mapToCurve(scalars) {
      if (defaults.m === 1) {
        if (typeof scalars !== "bigint")
          throw new Error("expected bigint (m=1)");
        return clear(map2([scalars]));
      }
      if (!Array.isArray(scalars))
        throw new Error("expected array of bigints");
      for (const i2 of scalars)
        if (typeof i2 !== "bigint")
          throw new Error("expected array of bigints");
      return clear(map2(scalars));
    },
    // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
    // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
    hashToScalar(msg, options) {
      const N = Point2.Fn.ORDER;
      const opts = Object.assign({}, defaults, { p: N, m: 1, DST: _DST_scalar }, options);
      return hash_to_field(msg, 1, opts)[0][0];
    }
  };
}

// node_modules/@libp2p/crypto/node_modules/@noble/curves/abstract/montgomery.js
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n3 = BigInt(2);
function validateOpts(curve) {
  validateObject(curve, {
    adjustScalarBytes: "function",
    powPminus2: "function"
  });
  return Object.freeze({ ...curve });
}
function montgomery(curveDef) {
  const CURVE2 = validateOpts(curveDef);
  const { P, type, adjustScalarBytes: adjustScalarBytes3, powPminus2, randomBytes: rand } = CURVE2;
  const is25519 = type === "x25519";
  if (!is25519 && type !== "x448")
    throw new Error("invalid type");
  const randomBytes_ = rand || randomBytes2;
  const montgomeryBits = is25519 ? 255 : 448;
  const fieldLen2 = is25519 ? 32 : 56;
  const Gu = is25519 ? BigInt(9) : BigInt(5);
  const a24 = is25519 ? BigInt(121665) : BigInt(39081);
  const minScalar = is25519 ? _2n3 ** BigInt(254) : _2n3 ** BigInt(447);
  const maxAdded = is25519 ? BigInt(8) * _2n3 ** BigInt(251) - _1n5 : BigInt(4) * _2n3 ** BigInt(445) - _1n5;
  const maxScalar = minScalar + maxAdded + _1n5;
  const modP = (n2) => mod(n2, P);
  const GuBytes = encodeU(Gu);
  function encodeU(u) {
    return numberToBytesLE(modP(u), fieldLen2);
  }
  function decodeU(u) {
    const _u = copyBytes(abytes2(u, fieldLen2, "uCoordinate"));
    if (is25519)
      _u[31] &= 127;
    return modP(bytesToNumberLE(_u));
  }
  function decodeScalar(scalar) {
    return bytesToNumberLE(adjustScalarBytes3(copyBytes(abytes2(scalar, fieldLen2, "scalar"))));
  }
  function scalarMult(scalar, u) {
    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
    if (pu === _0n5)
      throw new Error("invalid private or public key received");
    return encodeU(pu);
  }
  function scalarMultBase(scalar) {
    return scalarMult(scalar, GuBytes);
  }
  const getPublicKey = scalarMultBase;
  const getSharedSecret = scalarMult;
  function cswap(swap, x_2, x_3) {
    const dummy = modP(swap * (x_2 - x_3));
    x_2 = modP(x_2 - dummy);
    x_3 = modP(x_3 + dummy);
    return { x_2, x_3 };
  }
  function montgomeryLadder(u, scalar) {
    aInRange("u", u, _0n5, P);
    aInRange("scalar", scalar, minScalar, maxScalar);
    const k = scalar;
    const x_1 = u;
    let x_2 = _1n5;
    let z_2 = _0n5;
    let x_3 = u;
    let z_3 = _1n5;
    let swap = _0n5;
    for (let t2 = BigInt(montgomeryBits - 1); t2 >= _0n5; t2--) {
      const k_t = k >> t2 & _1n5;
      swap ^= k_t;
      ({ x_2, x_3 } = cswap(swap, x_2, x_3));
      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
      swap = k_t;
      const A = x_2 + z_2;
      const AA = modP(A * A);
      const B = x_2 - z_2;
      const BB = modP(B * B);
      const E = AA - BB;
      const C = x_3 + z_3;
      const D = x_3 - z_3;
      const DA = modP(D * A);
      const CB = modP(C * B);
      const dacb = DA + CB;
      const da_cb = DA - CB;
      x_3 = modP(dacb * dacb);
      z_3 = modP(x_1 * modP(da_cb * da_cb));
      x_2 = modP(AA * BB);
      z_2 = modP(E * (AA + modP(a24 * E)));
    }
    ({ x_2, x_3 } = cswap(swap, x_2, x_3));
    ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
    const z2 = powPminus2(z_2);
    return modP(x_2 * z2);
  }
  const lengths = {
    secretKey: fieldLen2,
    publicKey: fieldLen2,
    seed: fieldLen2
  };
  const randomSecretKey = (seed = randomBytes_(fieldLen2)) => {
    abytes2(seed, lengths.seed, "seed");
    return seed;
  };
  const utils2 = { randomSecretKey };
  return Object.freeze({
    keygen: createKeygen(randomSecretKey, getPublicKey),
    getSharedSecret,
    getPublicKey,
    scalarMult,
    scalarMultBase,
    utils: utils2,
    GuBytes: GuBytes.slice(),
    lengths
  });
}

// node_modules/@libp2p/crypto/node_modules/@noble/curves/abstract/oprf.js
function createORPF(opts) {
  validateObject(opts, {
    name: "string",
    hash: "function",
    hashToScalar: "function",
    hashToGroup: "function"
  });
  const { name: name3, Point: Point2, hash } = opts;
  const { Fn: Fn3 } = Point2;
  const hashToGroup = (msg, ctx) => opts.hashToGroup(msg, {
    DST: concatBytes2(asciiToBytes("HashToGroup-"), ctx)
  });
  const hashToScalarPrefixed = (msg, ctx) => opts.hashToScalar(msg, { DST: concatBytes2(_DST_scalar, ctx) });
  const randomScalar = (rng2 = randomBytes2) => {
    const t2 = mapHashToField(rng2(getMinHashLength(Fn3.ORDER)), Fn3.ORDER, Fn3.isLE);
    return Fn3.isLE ? bytesToNumberLE(t2) : bytesToNumberBE(t2);
  };
  const msm = (points, scalars) => pippenger(Point2, points, scalars);
  const getCtx = (mode) => concatBytes2(asciiToBytes("OPRFV1-"), new Uint8Array([mode]), asciiToBytes("-" + name3));
  const ctxOPRF = getCtx(0);
  const ctxVOPRF = getCtx(1);
  const ctxPOPRF = getCtx(2);
  function encode10(...args) {
    const res = [];
    for (const a2 of args) {
      if (typeof a2 === "number")
        res.push(numberToBytesBE(a2, 2));
      else if (typeof a2 === "string")
        res.push(asciiToBytes(a2));
      else {
        abytes2(a2);
        res.push(numberToBytesBE(a2.length, 2), a2);
      }
    }
    return concatBytes2(...res);
  }
  const hashInput = (...bytes) => hash(encode10(...bytes, "Finalize"));
  function getTranscripts(B, C, D, ctx) {
    const Bm = B.toBytes();
    const seed = hash(encode10(Bm, concatBytes2(asciiToBytes("Seed-"), ctx)));
    const res = [];
    for (let i2 = 0; i2 < C.length; i2++) {
      const Ci = C[i2].toBytes();
      const Di = D[i2].toBytes();
      const di = hashToScalarPrefixed(encode10(seed, i2, Ci, Di, "Composite"), ctx);
      res.push(di);
    }
    return res;
  }
  function computeComposites(B, C, D, ctx) {
    const T = getTranscripts(B, C, D, ctx);
    const M = msm(C, T);
    const Z = msm(D, T);
    return { M, Z };
  }
  function computeCompositesFast(k, B, C, D, ctx) {
    const T = getTranscripts(B, C, D, ctx);
    const M = msm(C, T);
    const Z = M.multiply(k);
    return { M, Z };
  }
  function challengeTranscript(B, M, Z, t2, t3, ctx) {
    const [Bm, a0, a1, a2, a3] = [B, M, Z, t2, t3].map((i2) => i2.toBytes());
    return hashToScalarPrefixed(encode10(Bm, a0, a1, a2, a3, "Challenge"), ctx);
  }
  function generateProof(ctx, k, B, C, D, rng2) {
    const { M, Z } = computeCompositesFast(k, B, C, D, ctx);
    const r2 = randomScalar(rng2);
    const t2 = Point2.BASE.multiply(r2);
    const t3 = M.multiply(r2);
    const c2 = challengeTranscript(B, M, Z, t2, t3, ctx);
    const s2 = Fn3.sub(r2, Fn3.mul(c2, k));
    return concatBytes2(...[c2, s2].map((i2) => Fn3.toBytes(i2)));
  }
  function verifyProof(ctx, B, C, D, proof) {
    abytes2(proof, 2 * Fn3.BYTES);
    const { M, Z } = computeComposites(B, C, D, ctx);
    const [c2, s2] = [proof.subarray(0, Fn3.BYTES), proof.subarray(Fn3.BYTES)].map((f3) => Fn3.fromBytes(f3));
    const t2 = Point2.BASE.multiply(s2).add(B.multiply(c2));
    const t3 = M.multiply(s2).add(Z.multiply(c2));
    const expectedC = challengeTranscript(B, M, Z, t2, t3, ctx);
    if (!Fn3.eql(c2, expectedC))
      throw new Error("proof verification failed");
  }
  function generateKeyPair2() {
    const skS = randomScalar();
    const pkS = Point2.BASE.multiply(skS);
    return { secretKey: Fn3.toBytes(skS), publicKey: pkS.toBytes() };
  }
  function deriveKeyPair(ctx, seed, info) {
    const dst = concatBytes2(asciiToBytes("DeriveKeyPair"), ctx);
    const msg = concatBytes2(seed, encode10(info), Uint8Array.of(0));
    for (let counter = 0; counter <= 255; counter++) {
      msg[msg.length - 1] = counter;
      const skS = opts.hashToScalar(msg, { DST: dst });
      if (Fn3.is0(skS))
        continue;
      return { secretKey: Fn3.toBytes(skS), publicKey: Point2.BASE.multiply(skS).toBytes() };
    }
    throw new Error("Cannot derive key");
  }
  function blind(ctx, input, rng2 = randomBytes2) {
    const blind2 = randomScalar(rng2);
    const inputPoint = hashToGroup(input, ctx);
    if (inputPoint.equals(Point2.ZERO))
      throw new Error("Input point at infinity");
    const blinded = inputPoint.multiply(blind2);
    return { blind: Fn3.toBytes(blind2), blinded: blinded.toBytes() };
  }
  function evaluate(ctx, secretKey, input) {
    const skS = Fn3.fromBytes(secretKey);
    const inputPoint = hashToGroup(input, ctx);
    if (inputPoint.equals(Point2.ZERO))
      throw new Error("Input point at infinity");
    const unblinded = inputPoint.multiply(skS).toBytes();
    return hashInput(input, unblinded);
  }
  const oprf = {
    generateKeyPair: generateKeyPair2,
    deriveKeyPair: (seed, keyInfo) => deriveKeyPair(ctxOPRF, seed, keyInfo),
    blind: (input, rng2 = randomBytes2) => blind(ctxOPRF, input, rng2),
    blindEvaluate(secretKey, blindedPoint) {
      const skS = Fn3.fromBytes(secretKey);
      const elm = Point2.fromBytes(blindedPoint);
      return elm.multiply(skS).toBytes();
    },
    finalize(input, blindBytes, evaluatedBytes) {
      const blind2 = Fn3.fromBytes(blindBytes);
      const evalPoint = Point2.fromBytes(evaluatedBytes);
      const unblinded = evalPoint.multiply(Fn3.inv(blind2)).toBytes();
      return hashInput(input, unblinded);
    },
    evaluate: (secretKey, input) => evaluate(ctxOPRF, secretKey, input)
  };
  const voprf = {
    generateKeyPair: generateKeyPair2,
    deriveKeyPair: (seed, keyInfo) => deriveKeyPair(ctxVOPRF, seed, keyInfo),
    blind: (input, rng2 = randomBytes2) => blind(ctxVOPRF, input, rng2),
    blindEvaluateBatch(secretKey, publicKey, blinded, rng2 = randomBytes2) {
      if (!Array.isArray(blinded))
        throw new Error("expected array");
      const skS = Fn3.fromBytes(secretKey);
      const pkS = Point2.fromBytes(publicKey);
      const blindedPoints = blinded.map(Point2.fromBytes);
      const evaluated = blindedPoints.map((i2) => i2.multiply(skS));
      const proof = generateProof(ctxVOPRF, skS, pkS, blindedPoints, evaluated, rng2);
      return { evaluated: evaluated.map((i2) => i2.toBytes()), proof };
    },
    blindEvaluate(secretKey, publicKey, blinded, rng2 = randomBytes2) {
      const res = this.blindEvaluateBatch(secretKey, publicKey, [blinded], rng2);
      return { evaluated: res.evaluated[0], proof: res.proof };
    },
    finalizeBatch(items, publicKey, proof) {
      if (!Array.isArray(items))
        throw new Error("expected array");
      const pkS = Point2.fromBytes(publicKey);
      const blindedPoints = items.map((i2) => i2.blinded).map(Point2.fromBytes);
      const evalPoints = items.map((i2) => i2.evaluated).map(Point2.fromBytes);
      verifyProof(ctxVOPRF, pkS, blindedPoints, evalPoints, proof);
      return items.map((i2) => oprf.finalize(i2.input, i2.blind, i2.evaluated));
    },
    finalize(input, blind2, evaluated, blinded, publicKey, proof) {
      return this.finalizeBatch([{ input, blind: blind2, evaluated, blinded }], publicKey, proof)[0];
    },
    evaluate: (secretKey, input) => evaluate(ctxVOPRF, secretKey, input)
  };
  const poprf = (info) => {
    const m2 = hashToScalarPrefixed(encode10("Info", info), ctxPOPRF);
    const T = Point2.BASE.multiply(m2);
    return {
      generateKeyPair: generateKeyPair2,
      deriveKeyPair: (seed, keyInfo) => deriveKeyPair(ctxPOPRF, seed, keyInfo),
      blind(input, publicKey, rng2 = randomBytes2) {
        const pkS = Point2.fromBytes(publicKey);
        const tweakedKey = T.add(pkS);
        if (tweakedKey.equals(Point2.ZERO))
          throw new Error("tweakedKey point at infinity");
        const blind2 = randomScalar(rng2);
        const inputPoint = hashToGroup(input, ctxPOPRF);
        if (inputPoint.equals(Point2.ZERO))
          throw new Error("Input point at infinity");
        const blindedPoint = inputPoint.multiply(blind2);
        return {
          blind: Fn3.toBytes(blind2),
          blinded: blindedPoint.toBytes(),
          tweakedKey: tweakedKey.toBytes()
        };
      },
      blindEvaluateBatch(secretKey, blinded, rng2 = randomBytes2) {
        if (!Array.isArray(blinded))
          throw new Error("expected array");
        const skS = Fn3.fromBytes(secretKey);
        const t2 = Fn3.add(skS, m2);
        const invT = Fn3.inv(t2);
        const blindedPoints = blinded.map(Point2.fromBytes);
        const evalPoints = blindedPoints.map((i2) => i2.multiply(invT));
        const tweakedKey = Point2.BASE.multiply(t2);
        const proof = generateProof(ctxPOPRF, t2, tweakedKey, evalPoints, blindedPoints, rng2);
        return { evaluated: evalPoints.map((i2) => i2.toBytes()), proof };
      },
      blindEvaluate(secretKey, blinded, rng2 = randomBytes2) {
        const res = this.blindEvaluateBatch(secretKey, [blinded], rng2);
        return { evaluated: res.evaluated[0], proof: res.proof };
      },
      finalizeBatch(items, proof, tweakedKey) {
        if (!Array.isArray(items))
          throw new Error("expected array");
        const evalPoints = items.map((i2) => i2.evaluated).map(Point2.fromBytes);
        verifyProof(ctxPOPRF, Point2.fromBytes(tweakedKey), evalPoints, items.map((i2) => i2.blinded).map(Point2.fromBytes), proof);
        return items.map((i2, j) => {
          const blind2 = Fn3.fromBytes(i2.blind);
          const point = evalPoints[j].multiply(Fn3.inv(blind2)).toBytes();
          return hashInput(i2.input, info, point);
        });
      },
      finalize(input, blind2, evaluated, blinded, proof, tweakedKey) {
        return this.finalizeBatch([{ input, blind: blind2, evaluated, blinded }], proof, tweakedKey)[0];
      },
      evaluate(secretKey, input) {
        const skS = Fn3.fromBytes(secretKey);
        const inputPoint = hashToGroup(input, ctxPOPRF);
        if (inputPoint.equals(Point2.ZERO))
          throw new Error("Input point at infinity");
        const t2 = Fn3.add(skS, m2);
        const invT = Fn3.inv(t2);
        const unblinded = inputPoint.multiply(invT).toBytes();
        return hashInput(input, info, unblinded);
      }
    };
  };
  return Object.freeze({ name: name3, oprf, voprf, poprf, __tests: { Fn: Fn3 } });
}

// node_modules/@libp2p/crypto/node_modules/@noble/curves/ed25519.js
var _0n6 = BigInt(0);
var _1n6 = BigInt(1);
var _2n4 = BigInt(2);
var _3n2 = BigInt(3);
var _5n2 = BigInt(5);
var _8n3 = BigInt(8);
var ed25519_CURVE_p = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
var ed25519_CURVE = (() => ({
  p: ed25519_CURVE_p,
  n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
  h: _8n3,
  a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
  d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
  Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
  Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
}))();
function ed25519_pow_2_252_3(x) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P = ed25519_CURVE_p;
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, _2n4, P) * b2 % P;
  const b5 = pow2(b4, _1n6, P) * x % P;
  const b10 = pow2(b5, _5n2, P) * b5 % P;
  const b20 = pow2(b10, _10n, P) * b10 % P;
  const b40 = pow2(b20, _20n, P) * b20 % P;
  const b80 = pow2(b40, _40n, P) * b40 % P;
  const b160 = pow2(b80, _80n, P) * b80 % P;
  const b240 = pow2(b160, _80n, P) * b80 % P;
  const b250 = pow2(b240, _10n, P) * b10 % P;
  const pow_p_5_8 = pow2(b250, _2n4, P) * x % P;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes) {
  bytes[0] &= 248;
  bytes[31] &= 127;
  bytes[31] |= 64;
  return bytes;
}
var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
function uvRatio(u, v) {
  const P = ed25519_CURVE_p;
  const v32 = mod(v * v * v, P);
  const v7 = mod(v32 * v32 * v, P);
  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod(u * v32 * pow, P);
  const vx2 = mod(v * x * x, P);
  const root1 = x;
  const root2 = mod(x * ED25519_SQRT_M1, P);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u, P);
  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (isNegativeLE(x, P))
    x = mod(-x, P);
  return { isValid: useRoot1 || useRoot2, value: x };
}
var ed25519_Point = edwards(ed25519_CURVE, { uvRatio });
var Fp = (() => ed25519_Point.Fp)();
var Fn = (() => ed25519_Point.Fn)();
function ed25519_domain(data, ctx, phflag) {
  if (ctx.length > 255)
    throw new Error("Context is too big");
  return concatBytes2(asciiToBytes("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
}
function ed(opts) {
  return eddsa(ed25519_Point, sha5123, Object.assign({ adjustScalarBytes }, opts));
}
var ed25519 = ed({});
var ed25519ctx = ed({ domain: ed25519_domain });
var ed25519ph = ed({ domain: ed25519_domain, prehash: sha5123 });
var x25519 = (() => {
  const P = ed25519_CURVE_p;
  return montgomery({
    P,
    type: "x25519",
    powPminus2: (x) => {
      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
      return mod(pow2(pow_p_5_8, _3n2, P) * b2, P);
    },
    adjustScalarBytes
  });
})();
var ELL2_C1 = (() => (ed25519_CURVE_p + _3n2) / _8n3)();
var ELL2_C2 = (() => Fp.pow(_2n4, ELL2_C1))();
var ELL2_C3 = (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
function _map_to_curve_elligator2_curve25519(u) {
  const ELL2_C4 = (ed25519_CURVE_p - _5n2) / _8n3;
  const ELL2_J = BigInt(486662);
  let tv1 = Fp.sqr(u);
  tv1 = Fp.mul(tv1, _2n4);
  let xd = Fp.add(tv1, Fp.ONE);
  let x1n = Fp.neg(ELL2_J);
  let tv2 = Fp.sqr(xd);
  let gxd = Fp.mul(tv2, xd);
  let gx1 = Fp.mul(tv1, ELL2_J);
  gx1 = Fp.mul(gx1, x1n);
  gx1 = Fp.add(gx1, tv2);
  gx1 = Fp.mul(gx1, x1n);
  let tv3 = Fp.sqr(gxd);
  tv2 = Fp.sqr(tv3);
  tv3 = Fp.mul(tv3, gxd);
  tv3 = Fp.mul(tv3, gx1);
  tv2 = Fp.mul(tv2, tv3);
  let y11 = Fp.pow(tv2, ELL2_C4);
  y11 = Fp.mul(y11, tv3);
  let y12 = Fp.mul(y11, ELL2_C3);
  tv2 = Fp.sqr(y11);
  tv2 = Fp.mul(tv2, gxd);
  let e1 = Fp.eql(tv2, gx1);
  let y1 = Fp.cmov(y12, y11, e1);
  let x2n = Fp.mul(x1n, tv1);
  let y21 = Fp.mul(y11, u);
  y21 = Fp.mul(y21, ELL2_C2);
  let y22 = Fp.mul(y21, ELL2_C3);
  let gx2 = Fp.mul(gx1, tv1);
  tv2 = Fp.sqr(y21);
  tv2 = Fp.mul(tv2, gxd);
  let e2 = Fp.eql(tv2, gx2);
  let y2 = Fp.cmov(y22, y21, e2);
  tv2 = Fp.sqr(y1);
  tv2 = Fp.mul(tv2, gxd);
  let e3 = Fp.eql(tv2, gx1);
  let xn = Fp.cmov(x2n, x1n, e3);
  let y = Fp.cmov(y2, y1, e3);
  let e4 = Fp.isOdd(y);
  y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n6 };
}
var ELL2_C1_EDWARDS = (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))();
function map_to_curve_elligator2_edwards25519(u) {
  const { xMn, xMd, yMn, yMd } = _map_to_curve_elligator2_curve25519(u);
  let xn = Fp.mul(xMn, yMd);
  xn = Fp.mul(xn, ELL2_C1_EDWARDS);
  let xd = Fp.mul(xMd, yMn);
  let yn = Fp.sub(xMn, xMd);
  let yd = Fp.add(xMn, xMd);
  let tv1 = Fp.mul(xd, yd);
  let e2 = Fp.eql(tv1, Fp.ZERO);
  xn = Fp.cmov(xn, Fp.ZERO, e2);
  xd = Fp.cmov(xd, Fp.ONE, e2);
  yn = Fp.cmov(yn, Fp.ONE, e2);
  yd = Fp.cmov(yd, Fp.ONE, e2);
  const [xd_inv, yd_inv] = FpInvertBatch(Fp, [xd, yd], true);
  return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) };
}
var ed25519_hasher = (() => createHasher3(ed25519_Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
  DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
  encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
  p: ed25519_CURVE_p,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha5123
}))();
var SQRT_M1 = ED25519_SQRT_M1;
var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var invertSqrt = (number2) => uvRatio(_1n6, number2);
var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var bytes255ToNumberLE = (bytes) => Fp.create(bytesToNumberLE(bytes) & MAX_255B);
function calcElligatorRistrettoMap(r0) {
  const { d: d2 } = ed25519_CURVE;
  const P = ed25519_CURVE_p;
  const mod4 = (n2) => Fp.create(n2);
  const r2 = mod4(SQRT_M1 * r0 * r0);
  const Ns = mod4((r2 + _1n6) * ONE_MINUS_D_SQ);
  let c2 = BigInt(-1);
  const D = mod4((c2 - d2 * r2) * mod4(r2 + d2));
  let { isValid: Ns_D_is_sq, value: s2 } = uvRatio(Ns, D);
  let s_ = mod4(s2 * r0);
  if (!isNegativeLE(s_, P))
    s_ = mod4(-s_);
  if (!Ns_D_is_sq)
    s2 = s_;
  if (!Ns_D_is_sq)
    c2 = r2;
  const Nt = mod4(c2 * (r2 - _1n6) * D_MINUS_ONE_SQ - D);
  const s22 = s2 * s2;
  const W0 = mod4((s2 + s2) * D);
  const W1 = mod4(Nt * SQRT_AD_MINUS_ONE);
  const W2 = mod4(_1n6 - s22);
  const W3 = mod4(_1n6 + s22);
  return new ed25519_Point(mod4(W0 * W3), mod4(W2 * W1), mod4(W1 * W3), mod4(W0 * W2));
}
var __RistrettoPoint = class __RistrettoPoint extends PrimeEdwardsPoint {
  constructor(ep) {
    super(ep);
  }
  static fromAffine(ap) {
    return new __RistrettoPoint(ed25519_Point.fromAffine(ap));
  }
  assertSame(other) {
    if (!(other instanceof __RistrettoPoint))
      throw new Error("RistrettoPoint expected");
  }
  init(ep) {
    return new __RistrettoPoint(ep);
  }
  static fromBytes(bytes) {
    abytes2(bytes, 32);
    const { a: a2, d: d2 } = ed25519_CURVE;
    const P = ed25519_CURVE_p;
    const mod4 = (n2) => Fp.create(n2);
    const s2 = bytes255ToNumberLE(bytes);
    if (!equalBytes(Fp.toBytes(s2), bytes) || isNegativeLE(s2, P))
      throw new Error("invalid ristretto255 encoding 1");
    const s22 = mod4(s2 * s2);
    const u1 = mod4(_1n6 + a2 * s22);
    const u2 = mod4(_1n6 - a2 * s22);
    const u1_2 = mod4(u1 * u1);
    const u2_2 = mod4(u2 * u2);
    const v = mod4(a2 * d2 * u1_2 - u2_2);
    const { isValid, value: I } = invertSqrt(mod4(v * u2_2));
    const Dx = mod4(I * u2);
    const Dy = mod4(I * Dx * v);
    let x = mod4((s2 + s2) * Dx);
    if (isNegativeLE(x, P))
      x = mod4(-x);
    const y = mod4(u1 * Dy);
    const t2 = mod4(x * y);
    if (!isValid || isNegativeLE(t2, P) || y === _0n6)
      throw new Error("invalid ristretto255 encoding 2");
    return new __RistrettoPoint(new ed25519_Point(x, y, _1n6, t2));
  }
  /**
   * Converts ristretto-encoded string to ristretto point.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
   */
  static fromHex(hex) {
    return __RistrettoPoint.fromBytes(hexToBytes3(hex));
  }
  /**
   * Encodes ristretto point to Uint8Array.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
   */
  toBytes() {
    let { X, Y, Z, T } = this.ep;
    const P = ed25519_CURVE_p;
    const mod4 = (n2) => Fp.create(n2);
    const u1 = mod4(mod4(Z + Y) * mod4(Z - Y));
    const u2 = mod4(X * Y);
    const u2sq = mod4(u2 * u2);
    const { value: invsqrt } = invertSqrt(mod4(u1 * u2sq));
    const D1 = mod4(invsqrt * u1);
    const D2 = mod4(invsqrt * u2);
    const zInv = mod4(D1 * D2 * T);
    let D;
    if (isNegativeLE(T * zInv, P)) {
      let _x = mod4(Y * SQRT_M1);
      let _y = mod4(X * SQRT_M1);
      X = _x;
      Y = _y;
      D = mod4(D1 * INVSQRT_A_MINUS_D);
    } else {
      D = D2;
    }
    if (isNegativeLE(X * zInv, P))
      Y = mod4(-Y);
    let s2 = mod4((Z - Y) * D);
    if (isNegativeLE(s2, P))
      s2 = mod4(-s2);
    return Fp.toBytes(s2);
  }
  /**
   * Compares two Ristretto points.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
   */
  equals(other) {
    this.assertSame(other);
    const { X: X1, Y: Y1 } = this.ep;
    const { X: X2, Y: Y2 } = other.ep;
    const mod4 = (n2) => Fp.create(n2);
    const one = mod4(X1 * Y2) === mod4(Y1 * X2);
    const two = mod4(Y1 * Y2) === mod4(X1 * X2);
    return one || two;
  }
  is0() {
    return this.equals(__RistrettoPoint.ZERO);
  }
};
// Do NOT change syntax: the following gymnastics is done,
// because typescript strips comments, which makes bundlers disable tree-shaking.
// prettier-ignore
__publicField(__RistrettoPoint, "BASE", (() => new __RistrettoPoint(ed25519_Point.BASE))());
// prettier-ignore
__publicField(__RistrettoPoint, "ZERO", (() => new __RistrettoPoint(ed25519_Point.ZERO))());
// prettier-ignore
__publicField(__RistrettoPoint, "Fp", /* @__PURE__ */ (() => Fp)());
// prettier-ignore
__publicField(__RistrettoPoint, "Fn", /* @__PURE__ */ (() => Fn)());
var _RistrettoPoint = __RistrettoPoint;
var ristretto255_hasher = {
  Point: _RistrettoPoint,
  /**
  * Spec: https://www.rfc-editor.org/rfc/rfc9380.html#name-hashing-to-ristretto255. Caveats:
  * * There are no test vectors
  * * encodeToCurve / mapToCurve is undefined
  * * mapToCurve would be `calcElligatorRistrettoMap(scalars[0])`, not ristretto255_map!
  * * hashToScalar is undefined too, so we just use OPRF implementation
  * * We cannot re-use 'createHasher', because ristretto255_map is different algorithm/RFC
    (os2ip -> bytes255ToNumberLE)
  * * mapToCurve == calcElligatorRistrettoMap, hashToCurve == ristretto255_map
  * * hashToScalar is undefined in RFC9380 for ristretto, we are using version from OPRF here, using bytes255ToNumblerLE will create different result if we use bytes255ToNumberLE as os2ip
  * * current version is closest to spec.
  */
  hashToCurve(msg, options) {
    const DST = (options == null ? void 0 : options.DST) || "ristretto255_XMD:SHA-512_R255MAP_RO_";
    const xmd = expand_message_xmd(msg, DST, 64, sha5123);
    return ristretto255_hasher.deriveToCurve(xmd);
  },
  hashToScalar(msg, options = { DST: _DST_scalar }) {
    const xmd = expand_message_xmd(msg, options.DST, 64, sha5123);
    return Fn.create(bytesToNumberLE(xmd));
  },
  /**
   * HashToCurve-like construction based on RFC 9496 (Element Derivation).
   * Converts 64 uniform random bytes into a curve point.
   *
   * WARNING: This represents an older hash-to-curve construction, preceding the finalization of RFC 9380.
   * It was later reused as a component in the newer `hash_to_ristretto255` function defined in RFC 9380.
   */
  deriveToCurve(bytes) {
    abytes2(bytes, 64);
    const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));
    const R1 = calcElligatorRistrettoMap(r1);
    const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));
    const R2 = calcElligatorRistrettoMap(r2);
    return new _RistrettoPoint(R1.add(R2));
  }
};
var ristretto255_oprf = (() => createORPF({
  name: "ristretto255-SHA512",
  Point: _RistrettoPoint,
  hash: sha5123,
  hashToGroup: ristretto255_hasher.hashToCurve,
  hashToScalar: ristretto255_hasher.hashToScalar
}))();

// node_modules/@libp2p/crypto/dist/src/errors.js
var SigningError = class extends Error {
  constructor(message2 = "An error occurred while signing a message") {
    super(message2);
    this.name = "SigningError";
  }
};
var VerificationError = class extends Error {
  constructor(message2 = "An error occurred while verifying a message") {
    super(message2);
    this.name = "VerificationError";
  }
};
var WebCryptoMissingError = class extends Error {
  constructor(message2 = "Missing Web Crypto API") {
    super(message2);
    this.name = "WebCryptoMissingError";
  }
};

// node_modules/@libp2p/crypto/dist/src/webcrypto/webcrypto.browser.js
var webcrypto_browser_default = {
  get(win = globalThis) {
    const nativeCrypto = win.crypto;
    if ((nativeCrypto == null ? void 0 : nativeCrypto.subtle) == null) {
      throw new WebCryptoMissingError("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");
    }
    return nativeCrypto;
  }
};

// node_modules/@libp2p/crypto/dist/src/webcrypto/index.js
var webcrypto_default = webcrypto_browser_default;

// node_modules/@libp2p/crypto/dist/src/keys/ed25519/index.browser.js
var PUBLIC_KEY_BYTE_LENGTH = 32;
var PRIVATE_KEY_BYTE_LENGTH = 64;
var KEYS_BYTE_LENGTH = 32;
var ed25519Supported;
var webCryptoEd25519SupportedPromise = (async () => {
  try {
    await webcrypto_default.get().subtle.generateKey({ name: "Ed25519" }, true, ["sign", "verify"]);
    return true;
  } catch {
    return false;
  }
})();
function generateKey() {
  const privateKeyRaw = ed25519.utils.randomSecretKey();
  const publicKey = ed25519.getPublicKey(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
async function hashAndSignWebCrypto(privateKey, msg) {
  let privateKeyRaw;
  if (privateKey.length === PRIVATE_KEY_BYTE_LENGTH) {
    privateKeyRaw = privateKey.subarray(0, 32);
  } else {
    privateKeyRaw = privateKey;
  }
  const jwk = {
    crv: "Ed25519",
    kty: "OKP",
    x: toString2(privateKey.subarray(32), "base64url"),
    d: toString2(privateKeyRaw, "base64url"),
    ext: true,
    key_ops: ["sign"]
  };
  const key = await webcrypto_default.get().subtle.importKey("jwk", jwk, { name: "Ed25519" }, true, ["sign"]);
  const sig = await webcrypto_default.get().subtle.sign({ name: "Ed25519" }, key, msg instanceof Uint8Array ? msg : msg.subarray());
  return new Uint8Array(sig, 0, sig.byteLength);
}
function hashAndSignNoble(privateKey, msg) {
  const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);
  return ed25519.sign(msg instanceof Uint8Array ? msg : msg.subarray(), privateKeyRaw);
}
async function hashAndSign2(privateKey, msg) {
  if (ed25519Supported == null) {
    ed25519Supported = await webCryptoEd25519SupportedPromise;
  }
  if (ed25519Supported) {
    return hashAndSignWebCrypto(privateKey, msg);
  }
  return hashAndSignNoble(privateKey, msg);
}
async function hashAndVerifyWebCrypto(publicKey, sig, msg) {
  if (publicKey.buffer instanceof ArrayBuffer) {
    const key = await webcrypto_default.get().subtle.importKey("raw", publicKey.buffer, { name: "Ed25519" }, false, ["verify"]);
    const isValid = await webcrypto_default.get().subtle.verify({ name: "Ed25519" }, key, sig, msg instanceof Uint8Array ? msg : msg.subarray());
    return isValid;
  }
  throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys");
}
function hashAndVerifyNoble(publicKey, sig, msg) {
  return ed25519.verify(sig, msg instanceof Uint8Array ? msg : msg.subarray(), publicKey);
}
async function hashAndVerify2(publicKey, sig, msg) {
  if (ed25519Supported == null) {
    ed25519Supported = await webCryptoEd25519SupportedPromise;
  }
  if (ed25519Supported) {
    return hashAndVerifyWebCrypto(publicKey, sig, msg);
  }
  return hashAndVerifyNoble(publicKey, sig, msg);
}
function concatKeys(privateKeyRaw, publicKey) {
  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);
  for (let i2 = 0; i2 < KEYS_BYTE_LENGTH; i2++) {
    privateKey[i2] = privateKeyRaw[i2];
    privateKey[KEYS_BYTE_LENGTH + i2] = publicKey[i2];
  }
  return privateKey;
}

// node_modules/@libp2p/crypto/dist/src/util.js
function isPromise(thing) {
  if (thing == null) {
    return false;
  }
  return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}

// node_modules/@libp2p/crypto/dist/src/keys/ed25519/ed25519.js
var Ed25519PublicKey = class {
  constructor(key) {
    __publicField(this, "type", "Ed25519");
    __publicField(this, "raw");
    this.raw = ensureEd25519Key(key, PUBLIC_KEY_BYTE_LENGTH);
  }
  toMultihash() {
    return identity2.digest(publicKeyToProtobuf(this));
  }
  toCID() {
    return CID.createV1(114, this.toMultihash());
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.raw, key.raw);
  }
  verify(data, sig, options) {
    var _a27;
    (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
    const result = hashAndVerify2(this.raw, sig, data);
    if (isPromise(result)) {
      return result.then((res) => {
        var _a28;
        (_a28 = options == null ? void 0 : options.signal) == null ? void 0 : _a28.throwIfAborted();
        return res;
      });
    }
    return result;
  }
};
var Ed25519PrivateKey = class {
  // key       - 64 byte Uint8Array containing private key
  // publicKey - 32 byte Uint8Array containing public key
  constructor(key, publicKey) {
    __publicField(this, "type", "Ed25519");
    __publicField(this, "raw");
    __publicField(this, "publicKey");
    this.raw = ensureEd25519Key(key, PRIVATE_KEY_BYTE_LENGTH);
    this.publicKey = new Ed25519PublicKey(publicKey);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.raw, key.raw);
  }
  sign(message2, options) {
    var _a27, _b14;
    (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
    const sig = hashAndSign2(this.raw, message2);
    if (isPromise(sig)) {
      return sig.then((res) => {
        var _a28;
        (_a28 = options == null ? void 0 : options.signal) == null ? void 0 : _a28.throwIfAborted();
        return res;
      });
    }
    (_b14 = options == null ? void 0 : options.signal) == null ? void 0 : _b14.throwIfAborted();
    return sig;
  }
};

// node_modules/@libp2p/crypto/dist/src/keys/ed25519/utils.js
function unmarshalEd25519PublicKey(bytes) {
  bytes = ensureEd25519Key(bytes, PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PublicKey(bytes);
}
async function generateEd25519KeyPair() {
  const { privateKey, publicKey } = generateKey();
  return new Ed25519PrivateKey(privateKey, publicKey);
}
function ensureEd25519Key(key, length3) {
  key = Uint8Array.from(key ?? []);
  if (key.length !== length3) {
    throw new InvalidParametersError2(`Key must be a Uint8Array of length ${length3}, got ${key.length}`);
  }
  return key;
}

// node_modules/@libp2p/crypto/dist/src/keys/keys.js
var KeyType;
(function(KeyType3) {
  KeyType3["RSA"] = "RSA";
  KeyType3["Ed25519"] = "Ed25519";
  KeyType3["secp256k1"] = "secp256k1";
  KeyType3["ECDSA"] = "ECDSA";
})(KeyType || (KeyType = {}));
var __KeyTypeValues;
(function(__KeyTypeValues3) {
  __KeyTypeValues3[__KeyTypeValues3["RSA"] = 0] = "RSA";
  __KeyTypeValues3[__KeyTypeValues3["Ed25519"] = 1] = "Ed25519";
  __KeyTypeValues3[__KeyTypeValues3["secp256k1"] = 2] = "secp256k1";
  __KeyTypeValues3[__KeyTypeValues3["ECDSA"] = 3] = "ECDSA";
})(__KeyTypeValues || (__KeyTypeValues = {}));
(function(KeyType3) {
  KeyType3.codec = () => {
    return enumeration(__KeyTypeValues);
  };
})(KeyType || (KeyType = {}));
var PublicKey;
(function(PublicKey3) {
  let _codec;
  PublicKey3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {};
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.Type = KeyType.codec().decode(reader);
              break;
            }
            case 2: {
              obj.Data = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PublicKey3.encode = (obj) => {
    return encodeMessage(obj, PublicKey3.codec());
  };
  PublicKey3.decode = (buf, opts) => {
    return decodeMessage(buf, PublicKey3.codec(), opts);
  };
})(PublicKey || (PublicKey = {}));
var PrivateKey;
(function(PrivateKey3) {
  let _codec;
  PrivateKey3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {};
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.Type = KeyType.codec().decode(reader);
              break;
            }
            case 2: {
              obj.Data = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PrivateKey3.encode = (obj) => {
    return encodeMessage(obj, PrivateKey3.codec());
  };
  PrivateKey3.decode = (buf, opts) => {
    return decodeMessage(buf, PrivateKey3.codec(), opts);
  };
})(PrivateKey || (PrivateKey = {}));

// node_modules/@libp2p/crypto/dist/src/random-bytes.js
function randomBytes3(length3) {
  if (isNaN(length3) || length3 <= 0) {
    throw new InvalidParametersError2("random bytes length must be a Number bigger than 0");
  }
  return randomBytes2(length3);
}

// node_modules/@libp2p/crypto/dist/src/keys/rsa/utils.js
var utils_exports = {};
__export(utils_exports, {
  MAX_RSA_KEY_SIZE: () => MAX_RSA_KEY_SIZE,
  generateRSAKeyPair: () => generateRSAKeyPair,
  jwkToJWKKeyPair: () => jwkToJWKKeyPair,
  jwkToPkcs1: () => jwkToPkcs1,
  jwkToPkix: () => jwkToPkix,
  jwkToRSAPrivateKey: () => jwkToRSAPrivateKey,
  pkcs1MessageToJwk: () => pkcs1MessageToJwk,
  pkcs1MessageToRSAPrivateKey: () => pkcs1MessageToRSAPrivateKey,
  pkcs1ToJwk: () => pkcs1ToJwk,
  pkcs1ToRSAPrivateKey: () => pkcs1ToRSAPrivateKey,
  pkixMessageToJwk: () => pkixMessageToJwk,
  pkixMessageToRSAPublicKey: () => pkixMessageToRSAPublicKey,
  pkixToJwk: () => pkixToJwk,
  pkixToRSAPublicKey: () => pkixToRSAPublicKey
});

// node_modules/@libp2p/crypto/dist/src/keys/rsa/rsa.js
var RSAPublicKey = class {
  constructor(jwk, digest2) {
    __publicField(this, "type", "RSA");
    __publicField(this, "jwk");
    __publicField(this, "_raw");
    __publicField(this, "_multihash");
    this.jwk = jwk;
    this._multihash = digest2;
  }
  get raw() {
    if (this._raw == null) {
      this._raw = utils_exports.jwkToPkix(this.jwk);
    }
    return this._raw;
  }
  toMultihash() {
    return this._multihash;
  }
  toCID() {
    return CID.createV1(114, this._multihash);
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.raw, key.raw);
  }
  verify(data, sig, options) {
    return hashAndVerify3(this.jwk, sig, data, options);
  }
};
var RSAPrivateKey = class {
  constructor(jwk, publicKey) {
    __publicField(this, "type", "RSA");
    __publicField(this, "jwk");
    __publicField(this, "_raw");
    __publicField(this, "publicKey");
    this.jwk = jwk;
    this.publicKey = publicKey;
  }
  get raw() {
    if (this._raw == null) {
      this._raw = utils_exports.jwkToPkcs1(this.jwk);
    }
    return this._raw;
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.raw, key.raw);
  }
  sign(message2, options) {
    return hashAndSign3(this.jwk, message2, options);
  }
};

// node_modules/@libp2p/crypto/dist/src/keys/rsa/utils.js
var MAX_RSA_KEY_SIZE = 8192;
var SHA2_256_CODE = 18;
var MAX_RSA_JWK_SIZE = 1062;
var RSA_ALGORITHM_IDENTIFIER = Uint8Array.from([
  48,
  13,
  6,
  9,
  42,
  134,
  72,
  134,
  247,
  13,
  1,
  1,
  1,
  5,
  0
]);
function pkcs1ToJwk(bytes) {
  const message2 = decodeDer(bytes);
  return pkcs1MessageToJwk(message2);
}
function pkcs1MessageToJwk(message2) {
  return {
    n: toString2(message2[1], "base64url"),
    e: toString2(message2[2], "base64url"),
    d: toString2(message2[3], "base64url"),
    p: toString2(message2[4], "base64url"),
    q: toString2(message2[5], "base64url"),
    dp: toString2(message2[6], "base64url"),
    dq: toString2(message2[7], "base64url"),
    qi: toString2(message2[8], "base64url"),
    kty: "RSA"
  };
}
function jwkToPkcs1(jwk) {
  if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
    throw new InvalidParametersError2("JWK was missing components");
  }
  return encodeSequence([
    encodeInteger(Uint8Array.from([0])),
    encodeInteger(fromString2(jwk.n, "base64url")),
    encodeInteger(fromString2(jwk.e, "base64url")),
    encodeInteger(fromString2(jwk.d, "base64url")),
    encodeInteger(fromString2(jwk.p, "base64url")),
    encodeInteger(fromString2(jwk.q, "base64url")),
    encodeInteger(fromString2(jwk.dp, "base64url")),
    encodeInteger(fromString2(jwk.dq, "base64url")),
    encodeInteger(fromString2(jwk.qi, "base64url"))
  ]).subarray();
}
function pkixToJwk(bytes) {
  const message2 = decodeDer(bytes, {
    offset: 0
  });
  return pkixMessageToJwk(message2);
}
function pkixMessageToJwk(message2) {
  const keys = decodeDer(message2[1], {
    offset: 0
  });
  return {
    kty: "RSA",
    n: toString2(keys[0], "base64url"),
    e: toString2(keys[1], "base64url")
  };
}
function jwkToPkix(jwk) {
  if (jwk.n == null || jwk.e == null) {
    throw new InvalidParametersError2("JWK was missing components");
  }
  const subjectPublicKeyInfo = encodeSequence([
    RSA_ALGORITHM_IDENTIFIER,
    encodeBitString(encodeSequence([
      encodeInteger(fromString2(jwk.n, "base64url")),
      encodeInteger(fromString2(jwk.e, "base64url"))
    ]))
  ]);
  return subjectPublicKeyInfo.subarray();
}
function pkcs1ToRSAPrivateKey(bytes) {
  const message2 = decodeDer(bytes);
  return pkcs1MessageToRSAPrivateKey(message2);
}
function pkcs1MessageToRSAPrivateKey(message2) {
  const jwk = pkcs1MessageToJwk(message2);
  return jwkToRSAPrivateKey(jwk);
}
function pkixToRSAPublicKey(bytes, digest2) {
  if (bytes.byteLength >= MAX_RSA_JWK_SIZE) {
    throw new InvalidPublicKeyError2("Key size is too large");
  }
  const message2 = decodeDer(bytes, {
    offset: 0
  });
  return pkixMessageToRSAPublicKey(message2, bytes, digest2);
}
function pkixMessageToRSAPublicKey(message2, bytes, digest2) {
  const jwk = pkixMessageToJwk(message2);
  if (digest2 == null) {
    const hash = sha2564(PublicKey.encode({
      Type: KeyType.RSA,
      Data: bytes
    }));
    digest2 = create(SHA2_256_CODE, hash);
  }
  return new RSAPublicKey(jwk, digest2);
}
function jwkToRSAPrivateKey(jwk) {
  if (rsaKeySize(jwk) > MAX_RSA_KEY_SIZE) {
    throw new InvalidParametersError2("Key size is too large");
  }
  const keys = jwkToJWKKeyPair(jwk);
  const hash = sha2564(PublicKey.encode({
    Type: KeyType.RSA,
    Data: jwkToPkix(keys.publicKey)
  }));
  const digest2 = create(SHA2_256_CODE, hash);
  return new RSAPrivateKey(keys.privateKey, new RSAPublicKey(keys.publicKey, digest2));
}
async function generateRSAKeyPair(bits) {
  if (bits > MAX_RSA_KEY_SIZE) {
    throw new InvalidParametersError2("Key size is too large");
  }
  const keys = await generateRSAKey(bits);
  const hash = sha2564(PublicKey.encode({
    Type: KeyType.RSA,
    Data: jwkToPkix(keys.publicKey)
  }));
  const digest2 = create(SHA2_256_CODE, hash);
  return new RSAPrivateKey(keys.privateKey, new RSAPublicKey(keys.publicKey, digest2));
}
function jwkToJWKKeyPair(key) {
  if (key == null) {
    throw new InvalidParametersError2("Missing key parameter");
  }
  return {
    privateKey: key,
    publicKey: {
      kty: key.kty,
      n: key.n,
      e: key.e
    }
  };
}

// node_modules/@libp2p/crypto/dist/src/keys/rsa/index.browser.js
async function generateRSAKey(bits, options) {
  var _a27;
  const pair2 = await webcrypto_default.get().subtle.generateKey({
    name: "RSASSA-PKCS1-v1_5",
    modulusLength: bits,
    publicExponent: new Uint8Array([1, 0, 1]),
    hash: { name: "SHA-256" }
  }, true, ["sign", "verify"]);
  (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
  const keys = await exportKey(pair2, options);
  return {
    privateKey: keys[0],
    publicKey: keys[1]
  };
}
async function hashAndSign3(key, msg, options) {
  var _a27, _b14;
  const privateKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["sign"]);
  (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
  const sig = await webcrypto_default.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, msg instanceof Uint8Array ? msg : msg.subarray());
  (_b14 = options == null ? void 0 : options.signal) == null ? void 0 : _b14.throwIfAborted();
  return new Uint8Array(sig, 0, sig.byteLength);
}
async function hashAndVerify3(key, sig, msg, options) {
  var _a27, _b14;
  const publicKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["verify"]);
  (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
  const result = await webcrypto_default.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg instanceof Uint8Array ? msg : msg.subarray());
  (_b14 = options == null ? void 0 : options.signal) == null ? void 0 : _b14.throwIfAborted();
  return result;
}
async function exportKey(pair2, options) {
  var _a27;
  if (pair2.privateKey == null || pair2.publicKey == null) {
    throw new InvalidParametersError2("Private and public key are required");
  }
  const result = await Promise.all([
    webcrypto_default.get().subtle.exportKey("jwk", pair2.privateKey),
    webcrypto_default.get().subtle.exportKey("jwk", pair2.publicKey)
  ]);
  (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
  return result;
}
function rsaKeySize(jwk) {
  if (jwk.kty !== "RSA") {
    throw new InvalidParametersError2("invalid key type");
  } else if (jwk.n == null) {
    throw new InvalidParametersError2("invalid key modulus");
  }
  const bytes = fromString2(jwk.n, "base64url");
  return bytes.length * 8;
}

// node_modules/@libp2p/crypto/node_modules/@noble/hashes/hmac.js
var _HMAC = class {
  constructor(hash, key) {
    __publicField(this, "oHash");
    __publicField(this, "iHash");
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "finished", false);
    __publicField(this, "destroyed", false);
    ahash2(hash);
    abytes2(key, void 0, "key");
    this.iHash = hash.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
    for (let i2 = 0; i2 < pad.length; i2++)
      pad[i2] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash.create();
    for (let i2 = 0; i2 < pad.length; i2++)
      pad[i2] ^= 54 ^ 92;
    this.oHash.update(pad);
    clean2(pad);
  }
  update(buf) {
    aexists2(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists2(this);
    abytes2(out, this.outputLen, "output");
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash, key, message2) => new _HMAC(hash, key).update(message2).digest();
hmac.create = (hash, key) => new _HMAC(hash, key);

// node_modules/@libp2p/crypto/node_modules/@noble/curves/abstract/weierstrass.js
var divNearest = (num3, den) => (num3 + (num3 >= 0 ? den : -den) / _2n5) / den;
function _splitEndoScalar(k, basis, n2) {
  const [[a1, b1], [a2, b2]] = basis;
  const c1 = divNearest(b2 * k, n2);
  const c2 = divNearest(-b1 * k, n2);
  let k1 = k - c1 * a1 - c2 * a2;
  let k2 = -c1 * b1 - c2 * b2;
  const k1neg = k1 < _0n7;
  const k2neg = k2 < _0n7;
  if (k1neg)
    k1 = -k1;
  if (k2neg)
    k2 = -k2;
  const MAX_NUM = bitMask(Math.ceil(bitLen(n2) / 2)) + _1n7;
  if (k1 < _0n7 || k1 >= MAX_NUM || k2 < _0n7 || k2 >= MAX_NUM) {
    throw new Error("splitScalar (endomorphism): failed, k=" + k);
  }
  return { k1neg, k1, k2neg, k2 };
}
function validateSigFormat(format2) {
  if (!["compact", "recovered", "der"].includes(format2))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return format2;
}
function validateSigOpts(opts, def) {
  const optsn = {};
  for (let optName of Object.keys(def)) {
    optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
  }
  abool(optsn.lowS, "lowS");
  abool(optsn.prehash, "prehash");
  if (optsn.format !== void 0)
    validateSigFormat(optsn.format);
  return optsn;
}
var DERErr = class extends Error {
  constructor(m2 = "") {
    super(m2);
  }
};
var DER = {
  // asn.1 DER encoding utils
  Err: DERErr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data) => {
      const { Err: E } = DER;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded(dataLen);
      if (len.length / 2 & 128)
        throw new E("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
      const t2 = numberToHexUnpadded(tag);
      return t2 + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data) {
      const { Err: E } = DER;
      let pos = 0;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag)
        throw new E("tlv.decode: wrong tlv");
      const first = data[pos++];
      const isLong = !!(first & 128);
      let length3 = 0;
      if (!isLong)
        length3 = first;
      else {
        const lenLen = first & 127;
        if (!lenLen)
          throw new E("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E("tlv.decode(long): zero leftmost byte");
        for (const b of lengthBytes)
          length3 = length3 << 8 | b;
        pos += lenLen;
        if (length3 < 128)
          throw new E("tlv.decode(long): not minimal encoding");
      }
      const v = data.subarray(pos, pos + length3);
      if (v.length !== length3)
        throw new E("tlv.decode: wrong value length");
      return { v, l: data.subarray(pos + length3) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num3) {
      const { Err: E } = DER;
      if (num3 < _0n7)
        throw new E("integer: negative integers are not allowed");
      let hex = numberToHexUnpadded(num3);
      if (Number.parseInt(hex[0], 16) & 8)
        hex = "00" + hex;
      if (hex.length & 1)
        throw new E("unexpected DER parsing assertion: unpadded hex");
      return hex;
    },
    decode(data) {
      const { Err: E } = DER;
      if (data[0] & 128)
        throw new E("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE(data);
    }
  },
  toSig(bytes) {
    const { Err: E, _int: int, _tlv: tlv } = DER;
    const data = abytes2(bytes, void 0, "signature");
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER;
    const rs = tlv.encode(2, int.encode(sig.r));
    const ss = tlv.encode(2, int.encode(sig.s));
    const seq = rs + ss;
    return tlv.encode(48, seq);
  }
};
var _0n7 = BigInt(0);
var _1n7 = BigInt(1);
var _2n5 = BigInt(2);
var _3n3 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrass(params, extraOpts = {}) {
  const validated = createCurveFields("weierstrass", params, extraOpts);
  const { Fp: Fp3, Fn: Fn3 } = validated;
  let CURVE2 = validated.CURVE;
  const { h: cofactor, n: CURVE_ORDER } = CURVE2;
  validateObject(extraOpts, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object"
  });
  const { endo: endo2 } = extraOpts;
  if (endo2) {
    if (!Fp3.is0(CURVE2.a) || typeof endo2.beta !== "bigint" || !Array.isArray(endo2.basises)) {
      throw new Error('invalid endo: expected "beta": bigint and "basises": array');
    }
  }
  const lengths = getWLengths(Fp3, Fn3);
  function assertCompressionIsSupported() {
    if (!Fp3.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function pointToBytes3(_c3, point, isCompressed) {
    const { x, y } = point.toAffine();
    const bx = Fp3.toBytes(x);
    abool(isCompressed, "isCompressed");
    if (isCompressed) {
      assertCompressionIsSupported();
      const hasEvenY = !Fp3.isOdd(y);
      return concatBytes2(pprefix(hasEvenY), bx);
    } else {
      return concatBytes2(Uint8Array.of(4), bx, Fp3.toBytes(y));
    }
  }
  function pointFromBytes(bytes) {
    abytes2(bytes, void 0, "Point");
    const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
    const length3 = bytes.length;
    const head = bytes[0];
    const tail = bytes.subarray(1);
    if (length3 === comp && (head === 2 || head === 3)) {
      const x = Fp3.fromBytes(tail);
      if (!Fp3.isValid(x))
        throw new Error("bad point: is not on curve, wrong x");
      const y2 = weierstrassEquation(x);
      let y;
      try {
        y = Fp3.sqrt(y2);
      } catch (sqrtError) {
        const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + err);
      }
      assertCompressionIsSupported();
      const evenY = Fp3.isOdd(y);
      const evenH = (head & 1) === 1;
      if (evenH !== evenY)
        y = Fp3.neg(y);
      return { x, y };
    } else if (length3 === uncomp && head === 4) {
      const L = Fp3.BYTES;
      const x = Fp3.fromBytes(tail.subarray(0, L));
      const y = Fp3.fromBytes(tail.subarray(L, L * 2));
      if (!isValidXY(x, y))
        throw new Error("bad point: is not on curve");
      return { x, y };
    } else {
      throw new Error(`bad point: got length ${length3}, expected compressed=${comp} or uncompressed=${uncomp}`);
    }
  }
  const encodePoint = extraOpts.toBytes || pointToBytes3;
  const decodePoint = extraOpts.fromBytes || pointFromBytes;
  function weierstrassEquation(x) {
    const x2 = Fp3.sqr(x);
    const x3 = Fp3.mul(x2, x);
    return Fp3.add(Fp3.add(x3, Fp3.mul(x, CURVE2.a)), CURVE2.b);
  }
  function isValidXY(x, y) {
    const left = Fp3.sqr(y);
    const right = weierstrassEquation(x);
    return Fp3.eql(left, right);
  }
  if (!isValidXY(CURVE2.Gx, CURVE2.Gy))
    throw new Error("bad curve params: generator point");
  const _4a3 = Fp3.mul(Fp3.pow(CURVE2.a, _3n3), _4n2);
  const _27b2 = Fp3.mul(Fp3.sqr(CURVE2.b), BigInt(27));
  if (Fp3.is0(Fp3.add(_4a3, _27b2)))
    throw new Error("bad curve params: a or b");
  function acoord(title, n2, banZero = false) {
    if (!Fp3.isValid(n2) || banZero && Fp3.is0(n2))
      throw new Error(`bad point coordinate ${title}`);
    return n2;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point2))
      throw new Error("Weierstrass Point expected");
  }
  function splitEndoScalarN(k) {
    if (!endo2 || !endo2.basises)
      throw new Error("no endo");
    return _splitEndoScalar(k, endo2.basises, Fn3.ORDER);
  }
  const toAffineMemo = memoized((p2, iz) => {
    const { X, Y, Z } = p2;
    if (Fp3.eql(Z, Fp3.ONE))
      return { x: X, y: Y };
    const is0 = p2.is0();
    if (iz == null)
      iz = is0 ? Fp3.ONE : Fp3.inv(Z);
    const x = Fp3.mul(X, iz);
    const y = Fp3.mul(Y, iz);
    const zz = Fp3.mul(Z, iz);
    if (is0)
      return { x: Fp3.ZERO, y: Fp3.ZERO };
    if (!Fp3.eql(zz, Fp3.ONE))
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized((p2) => {
    if (p2.is0()) {
      if (extraOpts.allowInfinityPoint && !Fp3.is0(p2.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y } = p2.toAffine();
    if (!Fp3.isValid(x) || !Fp3.isValid(y))
      throw new Error("bad point: x or y not field elements");
    if (!isValidXY(x, y))
      throw new Error("bad point: equation left != right");
    if (!p2.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
    k2p = new Point2(Fp3.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
    k1p = negateCt(k1neg, k1p);
    k2p = negateCt(k2neg, k2p);
    return k1p.add(k2p);
  }
  const _Point = class _Point {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(X, Y, Z) {
      __publicField(this, "X");
      __publicField(this, "Y");
      __publicField(this, "Z");
      this.X = acoord("x", X);
      this.Y = acoord("y", Y, true);
      this.Z = acoord("z", Z);
      Object.freeze(this);
    }
    static CURVE() {
      return CURVE2;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(p2) {
      const { x, y } = p2 || {};
      if (!p2 || !Fp3.isValid(x) || !Fp3.isValid(y))
        throw new Error("invalid affine point");
      if (p2 instanceof _Point)
        throw new Error("projective point not allowed");
      if (Fp3.is0(x) && Fp3.is0(y))
        return _Point.ZERO;
      return new _Point(x, y, Fp3.ONE);
    }
    static fromBytes(bytes) {
      const P = _Point.fromAffine(decodePoint(abytes2(bytes, void 0, "point")));
      P.assertValidity();
      return P;
    }
    static fromHex(hex) {
      return _Point.fromBytes(hexToBytes3(hex));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_3n3);
      return this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (!Fp3.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !Fp3.isOdd(y);
    }
    /** Compare one point to another. */
    equals(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const U1 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X2, Z1));
      const U2 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y2, Z1));
      return U1 && U2;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new _Point(this.X, Fp3.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a2, b } = CURVE2;
      const b3 = Fp3.mul(b, _3n3);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      let t0 = Fp3.mul(X1, X1);
      let t1 = Fp3.mul(Y1, Y1);
      let t2 = Fp3.mul(Z1, Z1);
      let t3 = Fp3.mul(X1, Y1);
      t3 = Fp3.add(t3, t3);
      Z3 = Fp3.mul(X1, Z1);
      Z3 = Fp3.add(Z3, Z3);
      X3 = Fp3.mul(a2, Z3);
      Y3 = Fp3.mul(b3, t2);
      Y3 = Fp3.add(X3, Y3);
      X3 = Fp3.sub(t1, Y3);
      Y3 = Fp3.add(t1, Y3);
      Y3 = Fp3.mul(X3, Y3);
      X3 = Fp3.mul(t3, X3);
      Z3 = Fp3.mul(b3, Z3);
      t2 = Fp3.mul(a2, t2);
      t3 = Fp3.sub(t0, t2);
      t3 = Fp3.mul(a2, t3);
      t3 = Fp3.add(t3, Z3);
      Z3 = Fp3.add(t0, t0);
      t0 = Fp3.add(Z3, t0);
      t0 = Fp3.add(t0, t2);
      t0 = Fp3.mul(t0, t3);
      Y3 = Fp3.add(Y3, t0);
      t2 = Fp3.mul(Y1, Z1);
      t2 = Fp3.add(t2, t2);
      t0 = Fp3.mul(t2, t3);
      X3 = Fp3.sub(X3, t0);
      Z3 = Fp3.mul(t2, t1);
      Z3 = Fp3.add(Z3, Z3);
      Z3 = Fp3.add(Z3, Z3);
      return new _Point(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      const a2 = CURVE2.a;
      const b3 = Fp3.mul(CURVE2.b, _3n3);
      let t0 = Fp3.mul(X1, X2);
      let t1 = Fp3.mul(Y1, Y2);
      let t2 = Fp3.mul(Z1, Z2);
      let t3 = Fp3.add(X1, Y1);
      let t4 = Fp3.add(X2, Y2);
      t3 = Fp3.mul(t3, t4);
      t4 = Fp3.add(t0, t1);
      t3 = Fp3.sub(t3, t4);
      t4 = Fp3.add(X1, Z1);
      let t5 = Fp3.add(X2, Z2);
      t4 = Fp3.mul(t4, t5);
      t5 = Fp3.add(t0, t2);
      t4 = Fp3.sub(t4, t5);
      t5 = Fp3.add(Y1, Z1);
      X3 = Fp3.add(Y2, Z2);
      t5 = Fp3.mul(t5, X3);
      X3 = Fp3.add(t1, t2);
      t5 = Fp3.sub(t5, X3);
      Z3 = Fp3.mul(a2, t4);
      X3 = Fp3.mul(b3, t2);
      Z3 = Fp3.add(X3, Z3);
      X3 = Fp3.sub(t1, Z3);
      Z3 = Fp3.add(t1, Z3);
      Y3 = Fp3.mul(X3, Z3);
      t1 = Fp3.add(t0, t0);
      t1 = Fp3.add(t1, t0);
      t2 = Fp3.mul(a2, t2);
      t4 = Fp3.mul(b3, t4);
      t1 = Fp3.add(t1, t2);
      t2 = Fp3.sub(t0, t2);
      t2 = Fp3.mul(a2, t2);
      t4 = Fp3.add(t4, t2);
      t0 = Fp3.mul(t1, t4);
      Y3 = Fp3.add(Y3, t0);
      t0 = Fp3.mul(t5, t4);
      X3 = Fp3.mul(t3, X3);
      X3 = Fp3.sub(X3, t0);
      t0 = Fp3.mul(t3, t1);
      Z3 = Fp3.mul(t5, Z3);
      Z3 = Fp3.add(Z3, t0);
      return new _Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(_Point.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo: endo3 } = extraOpts;
      if (!Fn3.isValidNot0(scalar))
        throw new Error("invalid scalar: out of range");
      let point, fake;
      const mul = (n2) => wnaf.cached(this, n2, (p2) => normalizeZ(_Point, p2));
      if (endo3) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
        const { p: k1p, f: k1f } = mul(k1);
        const { p: k2p, f: k2f } = mul(k2);
        fake = k1f.add(k2f);
        point = finishEndo(endo3.beta, k1p, k2p, k1neg, k2neg);
      } else {
        const { p: p2, f: f3 } = mul(scalar);
        point = p2;
        fake = f3;
      }
      return normalizeZ(_Point, [point, fake])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo: endo3 } = extraOpts;
      const p2 = this;
      if (!Fn3.isValid(sc))
        throw new Error("invalid scalar: out of range");
      if (sc === _0n7 || p2.is0())
        return _Point.ZERO;
      if (sc === _1n7)
        return p2;
      if (wnaf.hasCache(this))
        return this.multiply(sc);
      if (endo3) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
        const { p1, p2: p22 } = mulEndoUnsafe(_Point, p2, k1, k2);
        return finishEndo(endo3.beta, p1, p22, k1neg, k2neg);
      } else {
        return wnaf.unsafe(p2, sc);
      }
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree } = extraOpts;
      if (cofactor === _1n7)
        return true;
      if (isTorsionFree)
        return isTorsionFree(_Point, this);
      return wnaf.unsafe(this, CURVE_ORDER).is0();
    }
    clearCofactor() {
      const { clearCofactor } = extraOpts;
      if (cofactor === _1n7)
        return this;
      if (clearCofactor)
        return clearCofactor(_Point, this);
      return this.multiplyUnsafe(cofactor);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    toBytes(isCompressed = true) {
      abool(isCompressed, "isCompressed");
      this.assertValidity();
      return encodePoint(_Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex3(this.toBytes(isCompressed));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  };
  // base / generator point
  __publicField(_Point, "BASE", new _Point(CURVE2.Gx, CURVE2.Gy, Fp3.ONE));
  // zero / infinity / identity point
  __publicField(_Point, "ZERO", new _Point(Fp3.ZERO, Fp3.ONE, Fp3.ZERO));
  // 0, 1, 0
  // math field
  __publicField(_Point, "Fp", Fp3);
  // scalar field
  __publicField(_Point, "Fn", Fn3);
  let Point2 = _Point;
  const bits = Fn3.BITS;
  const wnaf = new wNAF(Point2, extraOpts.endo ? Math.ceil(bits / 2) : bits);
  Point2.BASE.precompute(8);
  return Point2;
}
function pprefix(hasEvenY) {
  return Uint8Array.of(hasEvenY ? 2 : 3);
}
function SWUFpSqrtRatio(Fp3, Z) {
  const q = Fp3.ORDER;
  let l2 = _0n7;
  for (let o2 = q - _1n7; o2 % _2n5 === _0n7; o2 /= _2n5)
    l2 += _1n7;
  const c1 = l2;
  const _2n_pow_c1_1 = _2n5 << c1 - _1n7 - _1n7;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n5;
  const c2 = (q - _1n7) / _2n_pow_c1;
  const c3 = (c2 - _1n7) / _2n5;
  const c4 = _2n_pow_c1 - _1n7;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp3.pow(Z, c2);
  const c7 = Fp3.pow(Z, (c2 + _1n7) / _2n5);
  let sqrtRatio = (u, v) => {
    let tv1 = c6;
    let tv2 = Fp3.pow(v, c4);
    let tv3 = Fp3.sqr(tv2);
    tv3 = Fp3.mul(tv3, v);
    let tv5 = Fp3.mul(u, tv3);
    tv5 = Fp3.pow(tv5, c3);
    tv5 = Fp3.mul(tv5, tv2);
    tv2 = Fp3.mul(tv5, v);
    tv3 = Fp3.mul(tv5, u);
    let tv4 = Fp3.mul(tv3, tv2);
    tv5 = Fp3.pow(tv4, c5);
    let isQR = Fp3.eql(tv5, Fp3.ONE);
    tv2 = Fp3.mul(tv3, c7);
    tv5 = Fp3.mul(tv4, tv1);
    tv3 = Fp3.cmov(tv2, tv3, isQR);
    tv4 = Fp3.cmov(tv5, tv4, isQR);
    for (let i2 = c1; i2 > _1n7; i2--) {
      let tv52 = i2 - _2n5;
      tv52 = _2n5 << tv52 - _1n7;
      let tvv5 = Fp3.pow(tv4, tv52);
      const e1 = Fp3.eql(tvv5, Fp3.ONE);
      tv2 = Fp3.mul(tv3, tv1);
      tv1 = Fp3.mul(tv1, tv1);
      tvv5 = Fp3.mul(tv4, tv1);
      tv3 = Fp3.cmov(tv2, tv3, e1);
      tv4 = Fp3.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp3.ORDER % _4n2 === _3n3) {
    const c12 = (Fp3.ORDER - _3n3) / _4n2;
    const c22 = Fp3.sqrt(Fp3.neg(Z));
    sqrtRatio = (u, v) => {
      let tv1 = Fp3.sqr(v);
      const tv2 = Fp3.mul(u, v);
      tv1 = Fp3.mul(tv1, tv2);
      let y1 = Fp3.pow(tv1, c12);
      y1 = Fp3.mul(y1, tv2);
      const y2 = Fp3.mul(y1, c22);
      const tv3 = Fp3.mul(Fp3.sqr(y1), v);
      const isQR = Fp3.eql(tv3, u);
      let y = Fp3.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp3, opts) {
  validateField(Fp3);
  const { A, B, Z } = opts;
  if (!Fp3.isValid(A) || !Fp3.isValid(B) || !Fp3.isValid(Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp3, Z);
  if (!Fp3.isOdd)
    throw new Error("Field does not have .isOdd()");
  return (u) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp3.sqr(u);
    tv1 = Fp3.mul(tv1, Z);
    tv2 = Fp3.sqr(tv1);
    tv2 = Fp3.add(tv2, tv1);
    tv3 = Fp3.add(tv2, Fp3.ONE);
    tv3 = Fp3.mul(tv3, B);
    tv4 = Fp3.cmov(Z, Fp3.neg(tv2), !Fp3.eql(tv2, Fp3.ZERO));
    tv4 = Fp3.mul(tv4, A);
    tv2 = Fp3.sqr(tv3);
    tv6 = Fp3.sqr(tv4);
    tv5 = Fp3.mul(tv6, A);
    tv2 = Fp3.add(tv2, tv5);
    tv2 = Fp3.mul(tv2, tv3);
    tv6 = Fp3.mul(tv6, tv4);
    tv5 = Fp3.mul(tv6, B);
    tv2 = Fp3.add(tv2, tv5);
    x = Fp3.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y = Fp3.mul(tv1, u);
    y = Fp3.mul(y, value);
    x = Fp3.cmov(x, tv3, isValid);
    y = Fp3.cmov(y, value, isValid);
    const e1 = Fp3.isOdd(u) === Fp3.isOdd(y);
    y = Fp3.cmov(Fp3.neg(y), y, e1);
    const tv4_inv = FpInvertBatch(Fp3, [tv4], true)[0];
    x = Fp3.mul(x, tv4_inv);
    return { x, y };
  };
}
function getWLengths(Fp3, Fn3) {
  return {
    secretKey: Fn3.BYTES,
    publicKey: 1 + Fp3.BYTES,
    publicKeyUncompressed: 1 + 2 * Fp3.BYTES,
    publicKeyHasPrefix: true,
    signature: 2 * Fn3.BYTES
  };
}
function ecdh(Point2, ecdhOpts = {}) {
  const { Fn: Fn3 } = Point2;
  const randomBytes_ = ecdhOpts.randomBytes || randomBytes2;
  const lengths = Object.assign(getWLengths(Point2.Fp, Fn3), { seed: getMinHashLength(Fn3.ORDER) });
  function isValidSecretKey(secretKey) {
    try {
      const num3 = Fn3.fromBytes(secretKey);
      return Fn3.isValidNot0(num3);
    } catch (error) {
      return false;
    }
  }
  function isValidPublicKey(publicKey, isCompressed) {
    const { publicKey: comp, publicKeyUncompressed } = lengths;
    try {
      const l2 = publicKey.length;
      if (isCompressed === true && l2 !== comp)
        return false;
      if (isCompressed === false && l2 !== publicKeyUncompressed)
        return false;
      return !!Point2.fromBytes(publicKey);
    } catch (error) {
      return false;
    }
  }
  function randomSecretKey(seed = randomBytes_(lengths.seed)) {
    return mapHashToField(abytes2(seed, lengths.seed, "seed"), Fn3.ORDER);
  }
  function getPublicKey(secretKey, isCompressed = true) {
    return Point2.BASE.multiply(Fn3.fromBytes(secretKey)).toBytes(isCompressed);
  }
  function isProbPub(item) {
    const { secretKey, publicKey, publicKeyUncompressed } = lengths;
    if (!isBytes2(item))
      return void 0;
    if ("_lengths" in Fn3 && Fn3._lengths || secretKey === publicKey)
      return void 0;
    const l2 = abytes2(item, void 0, "key").length;
    return l2 === publicKey || l2 === publicKeyUncompressed;
  }
  function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
    if (isProbPub(secretKeyA) === true)
      throw new Error("first arg must be private key");
    if (isProbPub(publicKeyB) === false)
      throw new Error("second arg must be public key");
    const s2 = Fn3.fromBytes(secretKeyA);
    const b = Point2.fromBytes(publicKeyB);
    return b.multiply(s2).toBytes(isCompressed);
  }
  const utils2 = {
    isValidSecretKey,
    isValidPublicKey,
    randomSecretKey
  };
  const keygen = createKeygen(randomSecretKey, getPublicKey);
  return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point: Point2, utils: utils2, lengths });
}
function ecdsa(Point2, hash, ecdsaOpts = {}) {
  ahash2(hash);
  validateObject(ecdsaOpts, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  ecdsaOpts = Object.assign({}, ecdsaOpts);
  const randomBytes5 = ecdsaOpts.randomBytes || randomBytes2;
  const hmac3 = ecdsaOpts.hmac || ((key, msg) => hmac(hash, key, msg));
  const { Fp: Fp3, Fn: Fn3 } = Point2;
  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn3;
  const { keygen, getPublicKey, getSharedSecret, utils: utils2, lengths } = ecdh(Point2, ecdsaOpts);
  const defaultSigOpts = {
    prehash: true,
    lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : true,
    format: "compact",
    extraEntropy: false
  };
  const hasLargeCofactor = CURVE_ORDER * _2n5 < Fp3.ORDER;
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n7;
    return number2 > HALF;
  }
  function validateRS(title, num3) {
    if (!Fn3.isValidNot0(num3))
      throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
    return num3;
  }
  function assertSmallCofactor() {
    if (hasLargeCofactor)
      throw new Error('"recovered" sig type is not supported for cofactor >2 curves');
  }
  function validateSigLength(bytes, format2) {
    validateSigFormat(format2);
    const size = lengths.signature;
    const sizer = format2 === "compact" ? size : format2 === "recovered" ? size + 1 : void 0;
    return abytes2(bytes, sizer);
  }
  class Signature2 {
    constructor(r2, s2, recovery) {
      __publicField(this, "r");
      __publicField(this, "s");
      __publicField(this, "recovery");
      this.r = validateRS("r", r2);
      this.s = validateRS("s", s2);
      if (recovery != null) {
        assertSmallCofactor();
        if (![0, 1, 2, 3].includes(recovery))
          throw new Error("invalid recovery id");
        this.recovery = recovery;
      }
      Object.freeze(this);
    }
    static fromBytes(bytes, format2 = defaultSigOpts.format) {
      validateSigLength(bytes, format2);
      let recid;
      if (format2 === "der") {
        const { r: r3, s: s3 } = DER.toSig(abytes2(bytes));
        return new Signature2(r3, s3);
      }
      if (format2 === "recovered") {
        recid = bytes[0];
        format2 = "compact";
        bytes = bytes.subarray(1);
      }
      const L = lengths.signature / 2;
      const r2 = bytes.subarray(0, L);
      const s2 = bytes.subarray(L, L * 2);
      return new Signature2(Fn3.fromBytes(r2), Fn3.fromBytes(s2), recid);
    }
    static fromHex(hex, format2) {
      return this.fromBytes(hexToBytes3(hex), format2);
    }
    assertRecovery() {
      const { recovery } = this;
      if (recovery == null)
        throw new Error("invalid recovery id: must be present");
      return recovery;
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(messageHash2) {
      const { r: r2, s: s2 } = this;
      const recovery = this.assertRecovery();
      const radj = recovery === 2 || recovery === 3 ? r2 + CURVE_ORDER : r2;
      if (!Fp3.isValid(radj))
        throw new Error("invalid recovery id: sig.r+curve.n != R.x");
      const x = Fp3.toBytes(radj);
      const R = Point2.fromBytes(concatBytes2(pprefix((recovery & 1) === 0), x));
      const ir = Fn3.inv(radj);
      const h = bits2int_modN(abytes2(messageHash2, void 0, "msgHash"));
      const u1 = Fn3.create(-h * ir);
      const u2 = Fn3.create(s2 * ir);
      const Q = Point2.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
      if (Q.is0())
        throw new Error("invalid recovery: point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    toBytes(format2 = defaultSigOpts.format) {
      validateSigFormat(format2);
      if (format2 === "der")
        return hexToBytes3(DER.hexFromSig(this));
      const { r: r2, s: s2 } = this;
      const rb = Fn3.toBytes(r2);
      const sb = Fn3.toBytes(s2);
      if (format2 === "recovered") {
        assertSmallCofactor();
        return concatBytes2(Uint8Array.of(this.assertRecovery()), rb, sb);
      }
      return concatBytes2(rb, sb);
    }
    toHex(format2) {
      return bytesToHex3(this.toBytes(format2));
    }
  }
  const bits2int2 = ecdsaOpts.bits2int || function bits2int_def(bytes) {
    if (bytes.length > 8192)
      throw new Error("input is too large");
    const num3 = bytesToNumberBE(bytes);
    const delta = bytes.length * 8 - fnBits;
    return delta > 0 ? num3 >> BigInt(delta) : num3;
  };
  const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {
    return Fn3.create(bits2int2(bytes));
  };
  const ORDER_MASK = bitMask(fnBits);
  function int2octets2(num3) {
    aInRange("num < 2^" + fnBits, num3, _0n7, ORDER_MASK);
    return Fn3.toBytes(num3);
  }
  function validateMsgAndHash(message2, prehash) {
    abytes2(message2, void 0, "message");
    return prehash ? abytes2(hash(message2), void 0, "prehashed message") : message2;
  }
  function prepSig(message2, secretKey, opts) {
    const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
    message2 = validateMsgAndHash(message2, prehash);
    const h1int = bits2int_modN(message2);
    const d2 = Fn3.fromBytes(secretKey);
    if (!Fn3.isValidNot0(d2))
      throw new Error("invalid private key");
    const seedArgs = [int2octets2(d2), int2octets2(h1int)];
    if (extraEntropy != null && extraEntropy !== false) {
      const e2 = extraEntropy === true ? randomBytes5(lengths.secretKey) : extraEntropy;
      seedArgs.push(abytes2(e2, void 0, "extraEntropy"));
    }
    const seed = concatBytes2(...seedArgs);
    const m2 = h1int;
    function k2sig(kBytes) {
      const k = bits2int2(kBytes);
      if (!Fn3.isValidNot0(k))
        return;
      const ik = Fn3.inv(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r2 = Fn3.create(q.x);
      if (r2 === _0n7)
        return;
      const s2 = Fn3.create(ik * Fn3.create(m2 + r2 * d2));
      if (s2 === _0n7)
        return;
      let recovery = (q.x === r2 ? 0 : 2) | Number(q.y & _1n7);
      let normS = s2;
      if (lowS && isBiggerThanHalfOrder(s2)) {
        normS = Fn3.neg(s2);
        recovery ^= 1;
      }
      return new Signature2(r2, normS, hasLargeCofactor ? void 0 : recovery);
    }
    return { seed, k2sig };
  }
  function sign3(message2, secretKey, opts = {}) {
    const { seed, k2sig } = prepSig(message2, secretKey, opts);
    const drbg = createHmacDrbg(hash.outputLen, Fn3.BYTES, hmac3);
    const sig = drbg(seed, k2sig);
    return sig.toBytes(opts.format);
  }
  function verify2(signature, message2, publicKey, opts = {}) {
    const { lowS, prehash, format: format2 } = validateSigOpts(opts, defaultSigOpts);
    publicKey = abytes2(publicKey, void 0, "publicKey");
    message2 = validateMsgAndHash(message2, prehash);
    if (!isBytes2(signature)) {
      const end = signature instanceof Signature2 ? ", use sig.toBytes()" : "";
      throw new Error("verify expects Uint8Array signature" + end);
    }
    validateSigLength(signature, format2);
    try {
      const sig = Signature2.fromBytes(signature, format2);
      const P = Point2.fromBytes(publicKey);
      if (lowS && sig.hasHighS())
        return false;
      const { r: r2, s: s2 } = sig;
      const h = bits2int_modN(message2);
      const is = Fn3.inv(s2);
      const u1 = Fn3.create(h * is);
      const u2 = Fn3.create(r2 * is);
      const R = Point2.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
      if (R.is0())
        return false;
      const v = Fn3.create(R.x);
      return v === r2;
    } catch (e2) {
      return false;
    }
  }
  function recoverPublicKey(signature, message2, opts = {}) {
    const { prehash } = validateSigOpts(opts, defaultSigOpts);
    message2 = validateMsgAndHash(message2, prehash);
    return Signature2.fromBytes(signature, "recovered").recoverPublicKey(message2).toBytes();
  }
  return Object.freeze({
    keygen,
    getPublicKey,
    getSharedSecret,
    utils: utils2,
    lengths,
    Point: Point2,
    sign: sign3,
    verify: verify2,
    recoverPublicKey,
    Signature: Signature2,
    hash
  });
}

// node_modules/@libp2p/crypto/node_modules/@noble/curves/secp256k1.js
var secp256k1_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var secp256k1_ENDO = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
};
var _0n8 = BigInt(0);
var _2n6 = BigInt(2);
function sqrtMod(y) {
  const P = secp256k1_CURVE.p;
  const _3n8 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n8, P) * b3 % P;
  const b9 = pow2(b6, _3n8, P) * b3 % P;
  const b11 = pow2(b9, _2n6, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n8, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n6, P);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });
var Pointk1 = weierstrass(secp256k1_CURVE, {
  Fp: Fpk1,
  endo: secp256k1_ENDO
});
var secp256k1 = ecdsa(Pointk1, sha2564);
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages2) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha2564(asciiToBytes(tag));
    tagP = concatBytes2(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha2564(concatBytes2(tagP, ...messages2));
}
var pointToBytes = (point) => point.toBytes(true).slice(1);
var hasEven = (y) => y % _2n6 === _0n8;
function schnorrGetExtPubKey(priv) {
  const { Fn: Fn3, BASE } = Pointk1;
  const d_ = Fn3.fromBytes(priv);
  const p2 = BASE.multiply(d_);
  const scalar = hasEven(p2.y) ? d_ : Fn3.neg(d_);
  return { scalar, bytes: pointToBytes(p2) };
}
function lift_x(x) {
  const Fp3 = Fpk1;
  if (!Fp3.isValidNot0(x))
    throw new Error("invalid x: Fail if x  p");
  const xx = Fp3.create(x * x);
  const c2 = Fp3.create(xx * x + BigInt(7));
  let y = Fp3.sqrt(c2);
  if (!hasEven(y))
    y = Fp3.neg(y);
  const p2 = Pointk1.fromAffine({ x, y });
  p2.assertValidity();
  return p2;
}
var num = bytesToNumberBE;
function challenge(...args) {
  return Pointk1.Fn.create(num(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(secretKey) {
  return schnorrGetExtPubKey(secretKey).bytes;
}
function schnorrSign(message2, secretKey, auxRand = randomBytes2(32)) {
  const { Fn: Fn3 } = Pointk1;
  const m2 = abytes2(message2, void 0, "message");
  const { bytes: px, scalar: d2 } = schnorrGetExtPubKey(secretKey);
  const a2 = abytes2(auxRand, 32, "auxRand");
  const t2 = Fn3.toBytes(d2 ^ num(taggedHash("BIP0340/aux", a2)));
  const rand = taggedHash("BIP0340/nonce", t2, px, m2);
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);
  const e2 = challenge(rx, px, m2);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(Fn3.toBytes(Fn3.create(k + e2 * d2)), 32);
  if (!schnorrVerify(sig, m2, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message2, publicKey) {
  const { Fp: Fp3, Fn: Fn3, BASE } = Pointk1;
  const sig = abytes2(signature, 64, "signature");
  const m2 = abytes2(message2, void 0, "message");
  const pub = abytes2(publicKey, 32, "publicKey");
  try {
    const P = lift_x(num(pub));
    const r2 = num(sig.subarray(0, 32));
    if (!Fp3.isValidNot0(r2))
      return false;
    const s2 = num(sig.subarray(32, 64));
    if (!Fn3.isValidNot0(s2))
      return false;
    const e2 = challenge(Fn3.toBytes(r2), pointToBytes(P), m2);
    const R = BASE.multiplyUnsafe(s2).add(P.multiplyUnsafe(Fn3.neg(e2)));
    const { x, y } = R.toAffine();
    if (R.is0() || !hasEven(y) || x !== r2)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = (() => {
  const size = 32;
  const seedLength = 48;
  const randomSecretKey = (seed = randomBytes2(seedLength)) => {
    return mapHashToField(seed, secp256k1_CURVE.n);
  };
  return {
    keygen: createKeygen(randomSecretKey, schnorrGetPublicKey),
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    Point: Pointk1,
    utils: {
      randomSecretKey,
      taggedHash,
      lift_x,
      pointToBytes
    },
    lengths: {
      secretKey: size,
      publicKey: size,
      publicKeyHasPrefix: false,
      signature: size * 2,
      seed: seedLength
    }
  };
})();
var isoMap = (() => isogenyMap(Fpk1, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i2) => i2.map((j) => BigInt(j)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fpk1, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fpk1.create(BigInt("-11"))
}))();
var secp256k1_hasher = (() => createHasher3(Pointk1, (scalars) => {
  const { x, y } = mapSWU(Fpk1.create(scalars[0]));
  return isoMap(x, y);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fpk1.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha2564
}))();

// node_modules/@libp2p/crypto/dist/src/keys/secp256k1/index.browser.js
function hashAndSign4(key, msg, options) {
  const p2 = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray());
  if (isPromise(p2)) {
    return p2.then(({ digest: digest2 }) => {
      var _a27;
      (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
      return secp256k1.sign(digest2, key, {
        prehash: false,
        format: "der"
      });
    }).catch((err) => {
      if (err.name === "AbortError") {
        throw err;
      }
      throw new SigningError(String(err));
    });
  }
  try {
    return secp256k1.sign(p2.digest, key, {
      prehash: false,
      format: "der"
    });
  } catch (err) {
    throw new SigningError(String(err));
  }
}
function hashAndVerify4(key, sig, msg, options) {
  var _a27;
  const p2 = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray());
  if (isPromise(p2)) {
    return p2.then(({ digest: digest2 }) => {
      var _a28;
      (_a28 = options == null ? void 0 : options.signal) == null ? void 0 : _a28.throwIfAborted();
      return secp256k1.verify(sig, digest2, key, {
        prehash: false,
        format: "der"
      });
    }).catch((err) => {
      if (err.name === "AbortError") {
        throw err;
      }
      throw new VerificationError(String(err));
    });
  }
  try {
    (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
    return secp256k1.verify(sig, p2.digest, key, {
      prehash: false,
      format: "der"
    });
  } catch (err) {
    throw new VerificationError(String(err));
  }
}

// node_modules/@libp2p/crypto/dist/src/keys/secp256k1/secp256k1.js
var Secp256k1PublicKey = class {
  constructor(key) {
    __publicField(this, "type", "secp256k1");
    __publicField(this, "raw");
    __publicField(this, "_key");
    this._key = validateSecp256k1PublicKey(key);
    this.raw = compressSecp256k1PublicKey(this._key);
  }
  toMultihash() {
    return identity2.digest(publicKeyToProtobuf(this));
  }
  toCID() {
    return CID.createV1(114, this.toMultihash());
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.raw, key.raw);
  }
  verify(data, sig, options) {
    return hashAndVerify4(this._key, sig, data, options);
  }
};
var Secp256k1PrivateKey = class {
  constructor(key, publicKey) {
    __publicField(this, "type", "secp256k1");
    __publicField(this, "raw");
    __publicField(this, "publicKey");
    this.raw = validateSecp256k1PrivateKey(key);
    this.publicKey = new Secp256k1PublicKey(publicKey ?? computeSecp256k1PublicKey(key));
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.raw, key.raw);
  }
  sign(message2, options) {
    return hashAndSign4(this.raw, message2, options);
  }
};

// node_modules/@libp2p/crypto/dist/src/keys/secp256k1/utils.js
function unmarshalSecp256k1PublicKey(bytes) {
  return new Secp256k1PublicKey(bytes);
}
async function generateSecp256k1KeyPair() {
  const privateKeyBytes = generateSecp256k1PrivateKey();
  return new Secp256k1PrivateKey(privateKeyBytes);
}
function compressSecp256k1PublicKey(key) {
  return secp256k1.Point.fromBytes(key).toBytes();
}
function validateSecp256k1PrivateKey(key) {
  try {
    secp256k1.getPublicKey(key, true);
    return key;
  } catch (err) {
    throw new InvalidPrivateKeyError(String(err));
  }
}
function validateSecp256k1PublicKey(key) {
  try {
    secp256k1.Point.fromBytes(key);
    return key;
  } catch (err) {
    throw new InvalidPublicKeyError2(String(err));
  }
}
function computeSecp256k1PublicKey(privateKey) {
  try {
    return secp256k1.getPublicKey(privateKey, true);
  } catch (err) {
    throw new InvalidPrivateKeyError(String(err));
  }
}
function generateSecp256k1PrivateKey() {
  return secp256k1.utils.randomSecretKey();
}

// node_modules/@libp2p/crypto/dist/src/keys/ecdh/index.browser.js
var curveLengths = {
  "P-256": 32,
  "P-384": 48,
  "P-521": 66
};
var curveTypes = Object.keys(curveLengths);
var names = curveTypes.join(" / ");

// node_modules/@libp2p/crypto/dist/src/keys/index.js
async function generateKeyPair(type, bits) {
  if (type === "Ed25519") {
    return generateEd25519KeyPair();
  }
  if (type === "secp256k1") {
    return generateSecp256k1KeyPair();
  }
  if (type === "RSA") {
    return generateRSAKeyPair(toBits(bits));
  }
  if (type === "ECDSA") {
    return generateECDSAKeyPair(toCurve(bits));
  }
  throw new UnsupportedKeyTypeError2();
}
function publicKeyFromProtobuf(buf, digest2) {
  const { Type, Data } = PublicKey.decode(buf);
  const data = Data ?? new Uint8Array();
  switch (Type) {
    case KeyType.RSA:
      return pkixToRSAPublicKey(data, digest2);
    case KeyType.Ed25519:
      return unmarshalEd25519PublicKey(data);
    case KeyType.secp256k1:
      return unmarshalSecp256k1PublicKey(data);
    case KeyType.ECDSA:
      return unmarshalECDSAPublicKey(data);
    default:
      throw new UnsupportedKeyTypeError2();
  }
}
function publicKeyFromMultihash(digest2) {
  const { Type, Data } = PublicKey.decode(digest2.digest);
  const data = Data ?? new Uint8Array();
  switch (Type) {
    case KeyType.Ed25519:
      return unmarshalEd25519PublicKey(data);
    case KeyType.secp256k1:
      return unmarshalSecp256k1PublicKey(data);
    case KeyType.ECDSA:
      return unmarshalECDSAPublicKey(data);
    default:
      throw new UnsupportedKeyTypeError2();
  }
}
function publicKeyToProtobuf(key) {
  return PublicKey.encode({
    Type: KeyType[key.type],
    Data: key.raw
  });
}
function toBits(bits) {
  if (bits == null) {
    return 2048;
  }
  return parseInt(bits, 10);
}
function toCurve(curve) {
  if (curve === "P-256" || curve == null) {
    return "P-256";
  }
  if (curve === "P-384") {
    return "P-384";
  }
  if (curve === "P-521") {
    return "P-521";
  }
  throw new InvalidParametersError2("Unsupported curve, should be P-256, P-384 or P-521");
}

// node_modules/@libp2p/peer-id/dist/src/peer-id.js
var inspect = Symbol.for("nodejs.util.inspect.custom");
var LIBP2P_KEY_CODE = 114;
var _a3;
var PeerIdImpl = class {
  constructor(init) {
    __publicField(this, "type");
    __publicField(this, "multihash");
    __publicField(this, "publicKey");
    __publicField(this, "string");
    __publicField(this, _a3, true);
    this.type = init.type;
    this.multihash = init.multihash;
    Object.defineProperty(this, "string", {
      enumerable: false,
      writable: true
    });
  }
  get [Symbol.toStringTag]() {
    return `PeerId(${this.toString()})`;
  }
  toString() {
    if (this.string == null) {
      this.string = base58btc.encode(this.multihash.bytes).slice(1);
    }
    return this.string;
  }
  toMultihash() {
    return this.multihash;
  }
  // return self-describing String representation
  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
  toCID() {
    return CID.createV1(LIBP2P_KEY_CODE, this.multihash);
  }
  toJSON() {
    return this.toString();
  }
  /**
   * Checks the equality of `this` peer against a given PeerId
   */
  equals(id) {
    var _a27;
    if (id == null) {
      return false;
    }
    if (id instanceof Uint8Array) {
      return equals3(this.multihash.bytes, id);
    } else if (typeof id === "string") {
      return this.toString() === id;
    } else if (((_a27 = id == null ? void 0 : id.toMultihash()) == null ? void 0 : _a27.bytes) != null) {
      return equals3(this.multihash.bytes, id.toMultihash().bytes);
    } else {
      throw new Error("not valid Id");
    }
  }
  /**
   * Returns PeerId as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```TypeScript
   * import { peerIdFromString } from '@libp2p/peer-id'
   *
   * console.info(peerIdFromString('QmFoo'))
   * // 'PeerId(QmFoo)'
   * ```
   */
  [(_a3 = peerIdSymbol, inspect)]() {
    return `PeerId(${this.toString()})`;
  }
};
var RSAPeerId = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "RSA" });
    __publicField(this, "type", "RSA");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var Ed25519PeerId = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "Ed25519" });
    __publicField(this, "type", "Ed25519");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var Secp256k1PeerId = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "secp256k1" });
    __publicField(this, "type", "secp256k1");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var TRANSPORT_IPFS_GATEWAY_HTTP_CODE = 2336;
var _a4, _b;
var URLPeerId = class {
  constructor(url) {
    __publicField(this, "type", "url");
    __publicField(this, "multihash");
    __publicField(this, "publicKey");
    __publicField(this, "url");
    __publicField(this, _a4, true);
    this.url = url.toString();
    this.multihash = identity2.digest(fromString2(this.url));
  }
  [(_b = inspect, _a4 = peerIdSymbol, _b)]() {
    return `PeerId(${this.url})`;
  }
  toString() {
    return this.toCID().toString();
  }
  toMultihash() {
    return this.multihash;
  }
  toCID() {
    return CID.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE, this.toMultihash());
  }
  toJSON() {
    return this.toString();
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (other instanceof Uint8Array) {
      other = toString2(other);
    }
    return other.toString() === this.toString();
  }
};

// node_modules/@libp2p/peer-id/dist/src/index.js
var LIBP2P_KEY_CODE2 = 114;
var TRANSPORT_IPFS_GATEWAY_HTTP_CODE2 = 2336;
function peerIdFromString(str, decoder) {
  let multihash;
  if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
    multihash = decode6(base58btc.decode(`z${str}`));
  } else if (str.startsWith("k51qzi5uqu5") || str.startsWith("kzwfwjn5ji4") || str.startsWith("k2k4r8") || str.startsWith("bafz")) {
    return peerIdFromCID(CID.parse(str));
  } else {
    if (decoder == null) {
      throw new InvalidParametersError('Please pass a multibase decoder for strings that do not start with "1" or "Q"');
    }
    multihash = decode6(decoder.decode(str));
  }
  return peerIdFromMultihash(multihash);
}
function peerIdFromPublicKey(publicKey) {
  if (publicKey.type === "Ed25519") {
    return new Ed25519PeerId({
      multihash: publicKey.toCID().multihash,
      publicKey
    });
  } else if (publicKey.type === "secp256k1") {
    return new Secp256k1PeerId({
      multihash: publicKey.toCID().multihash,
      publicKey
    });
  } else if (publicKey.type === "RSA") {
    return new RSAPeerId({
      multihash: publicKey.toCID().multihash,
      publicKey
    });
  }
  throw new UnsupportedKeyTypeError();
}
function peerIdFromPrivateKey(privateKey) {
  return peerIdFromPublicKey(privateKey.publicKey);
}
function peerIdFromMultihash(multihash) {
  if (isSha256Multihash(multihash)) {
    return new RSAPeerId({ multihash });
  } else if (isIdentityMultihash(multihash)) {
    try {
      const publicKey = publicKeyFromMultihash(multihash);
      if (publicKey.type === "Ed25519") {
        return new Ed25519PeerId({ multihash, publicKey });
      } else if (publicKey.type === "secp256k1") {
        return new Secp256k1PeerId({ multihash, publicKey });
      }
    } catch (err) {
      const url = toString2(multihash.digest);
      return new URLPeerId(new URL(url));
    }
  }
  throw new InvalidMultihashError("Supplied PeerID Multihash is invalid");
}
function peerIdFromCID(cid) {
  if ((cid == null ? void 0 : cid.multihash) == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE2 && cid.code !== TRANSPORT_IPFS_GATEWAY_HTTP_CODE2) {
    throw new InvalidCIDError("Supplied PeerID CID is invalid");
  }
  if (cid.code === TRANSPORT_IPFS_GATEWAY_HTTP_CODE2) {
    const url = toString2(cid.multihash.digest);
    return new URLPeerId(new URL(url));
  }
  return peerIdFromMultihash(cid.multihash);
}
function isIdentityMultihash(multihash) {
  return multihash.code === identity2.code;
}
function isSha256Multihash(multihash) {
  return multihash.code === sha256.code;
}

// node_modules/@multiformats/multiaddr/dist/src/errors.js
var InvalidMultiaddrError2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidMultiaddrError");
  }
};
__publicField(InvalidMultiaddrError2, "name", "InvalidMultiaddrError");
var ValidationError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "ValidationError");
  }
};
__publicField(ValidationError, "name", "ValidationError");
var InvalidParametersError3 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidParametersError");
  }
};
__publicField(InvalidParametersError3, "name", "InvalidParametersError");
var UnknownProtocolError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UnknownProtocolError");
  }
};
__publicField(UnknownProtocolError, "name", "UnknownProtocolError");

// node_modules/@chainsafe/is-ip/lib/parser.js
var Parser = class {
  constructor() {
    __publicField(this, "index", 0);
    __publicField(this, "input", "");
  }
  new(input) {
    this.index = 0;
    this.input = input;
    return this;
  }
  /** Run a parser, and restore the pre-parse state if it fails. */
  readAtomically(fn) {
    const index = this.index;
    const result = fn();
    if (result === void 0) {
      this.index = index;
    }
    return result;
  }
  /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */
  parseWith(fn) {
    const result = fn();
    if (this.index !== this.input.length) {
      return void 0;
    }
    return result;
  }
  /** Peek the next character from the input */
  peekChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index];
  }
  /** Read the next character from the input */
  readChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index++];
  }
  /** Read the next character from the input if it matches the target. */
  readGivenChar(target) {
    return this.readAtomically(() => {
      const char = this.readChar();
      if (char !== target) {
        return void 0;
      }
      return char;
    });
  }
  /**
   * Helper for reading separators in an indexed loop. Reads the separator
   * character iff index > 0, then runs the parser. When used in a loop,
   * the separator character will only be read on index > 0 (see
   * readIPv4Addr for an example)
   */
  readSeparator(sep, index, inner) {
    return this.readAtomically(() => {
      if (index > 0) {
        if (this.readGivenChar(sep) === void 0) {
          return void 0;
        }
      }
      return inner();
    });
  }
  /**
   * Read a number off the front of the input in the given radix, stopping
   * at the first non-digit character or eof. Fails if the number has more
   * digits than max_digits or if there is no number.
   */
  readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {
    return this.readAtomically(() => {
      let result = 0;
      let digitCount = 0;
      const leadingChar = this.peekChar();
      if (leadingChar === void 0) {
        return void 0;
      }
      const hasLeadingZero = leadingChar === "0";
      const maxValue2 = 2 ** (8 * maxBytes) - 1;
      while (true) {
        const digit = this.readAtomically(() => {
          const char = this.readChar();
          if (char === void 0) {
            return void 0;
          }
          const num3 = Number.parseInt(char, radix);
          if (Number.isNaN(num3)) {
            return void 0;
          }
          return num3;
        });
        if (digit === void 0) {
          break;
        }
        result *= radix;
        result += digit;
        if (result > maxValue2) {
          return void 0;
        }
        digitCount += 1;
        if (maxDigits !== void 0) {
          if (digitCount > maxDigits) {
            return void 0;
          }
        }
      }
      if (digitCount === 0) {
        return void 0;
      } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {
        return void 0;
      } else {
        return result;
      }
    });
  }
  /** Read an IPv4 address. */
  readIPv4Addr() {
    return this.readAtomically(() => {
      const out = new Uint8Array(4);
      for (let i2 = 0; i2 < out.length; i2++) {
        const ix = this.readSeparator(".", i2, () => this.readNumber(10, 3, false, 1));
        if (ix === void 0) {
          return void 0;
        }
        out[i2] = ix;
      }
      return out;
    });
  }
  /** Read an IPv6 Address. */
  readIPv6Addr() {
    const readGroups = (groups) => {
      for (let i2 = 0; i2 < groups.length / 2; i2++) {
        const ix = i2 * 2;
        if (i2 < groups.length - 3) {
          const ipv4 = this.readSeparator(":", i2, () => this.readIPv4Addr());
          if (ipv4 !== void 0) {
            groups[ix] = ipv4[0];
            groups[ix + 1] = ipv4[1];
            groups[ix + 2] = ipv4[2];
            groups[ix + 3] = ipv4[3];
            return [ix + 4, true];
          }
        }
        const group = this.readSeparator(":", i2, () => this.readNumber(16, 4, true, 2));
        if (group === void 0) {
          return [ix, false];
        }
        groups[ix] = group >> 8;
        groups[ix + 1] = group & 255;
      }
      return [groups.length, false];
    };
    return this.readAtomically(() => {
      const head = new Uint8Array(16);
      const [headSize, headIp4] = readGroups(head);
      if (headSize === 16) {
        return head;
      }
      if (headIp4) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      const tail = new Uint8Array(14);
      const limit = 16 - (headSize + 2);
      const [tailSize] = readGroups(tail.subarray(0, limit));
      head.set(tail.subarray(0, tailSize), 16 - tailSize);
      return head;
    });
  }
  /** Read an IP Address, either IPv4 or IPv6. */
  readIPAddr() {
    return this.readIPv4Addr() ?? this.readIPv6Addr();
  }
};

// node_modules/@chainsafe/is-ip/lib/parse.js
var MAX_IPV6_LENGTH = 45;
var MAX_IPV4_LENGTH = 15;
var parser = new Parser();
function parseIPv4(input) {
  if (input.length > MAX_IPV4_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv4Addr());
}
function parseIPv6(input) {
  if (input.includes("%")) {
    input = input.split("%")[0];
  }
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv6Addr());
}
function parseIP(input, mapIPv4ToIPv6 = false) {
  if (input.includes("%")) {
    input = input.split("%")[0];
  }
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  const addr = parser.new(input).parseWith(() => parser.readIPAddr());
  if (!addr) {
    return void 0;
  }
  if (mapIPv4ToIPv6 && addr.length === 4) {
    return Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, addr[0], addr[1], addr[2], addr[3]]);
  }
  return addr;
}

// node_modules/@chainsafe/is-ip/lib/is-ip.js
function isIPv4(input) {
  return Boolean(parseIPv4(input));
}
function isIPv6(input) {
  return Boolean(parseIPv6(input));
}

// node_modules/@multiformats/multiaddr/dist/src/constants.js
var CODE_IP4 = 4;
var CODE_TCP = 6;
var CODE_UDP = 273;
var CODE_DCCP = 33;
var CODE_IP6 = 41;
var CODE_IP6ZONE = 42;
var CODE_IPCIDR = 43;
var CODE_DNS = 53;
var CODE_DNS4 = 54;
var CODE_DNS6 = 55;
var CODE_DNSADDR = 56;
var CODE_SCTP = 132;
var CODE_UDT = 301;
var CODE_UTP = 302;
var CODE_UNIX = 400;
var CODE_P2P = 421;
var CODE_ONION = 444;
var CODE_ONION3 = 445;
var CODE_GARLIC64 = 446;
var CODE_GARLIC32 = 447;
var CODE_TLS = 448;
var CODE_SNI = 449;
var CODE_NOISE = 454;
var CODE_QUIC = 460;
var CODE_QUIC_V1 = 461;
var CODE_WEBTRANSPORT = 465;
var CODE_CERTHASH = 466;
var CODE_HTTP = 480;
var CODE_HTTP_PATH = 481;
var CODE_HTTPS = 443;
var CODE_WS = 477;
var CODE_WSS = 478;
var CODE_P2P_WEBSOCKET_STAR = 479;
var CODE_P2P_STARDUST = 277;
var CODE_P2P_WEBRTC_STAR = 275;
var CODE_P2P_WEBRTC_DIRECT = 276;
var CODE_WEBRTC_DIRECT = 280;
var CODE_WEBRTC = 281;
var CODE_P2P_CIRCUIT = 290;
var CODE_MEMORY = 777;

// node_modules/@multiformats/multiaddr/dist/src/utils.js
function bytesToString(base4) {
  return (buf) => {
    return toString2(buf, base4);
  };
}
function stringToBytes2(base4) {
  return (buf) => {
    return fromString2(buf, base4);
  };
}
function bytes2port(buf) {
  const view = new DataView(buf.buffer);
  return view.getUint16(buf.byteOffset).toString();
}
function port2bytes(port) {
  const buf = new ArrayBuffer(2);
  const view = new DataView(buf);
  view.setUint16(0, typeof port === "string" ? parseInt(port) : port);
  return new Uint8Array(buf);
}
function onion2bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 16) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
  }
  const buf = fromString2(addr[0], "base32");
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat2([buf, portBuf], buf.length + portBuf.length);
}
function onion32bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 56) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
  }
  const buf = base32.decode(`b${addr[0]}`);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat2([buf, portBuf], buf.length + portBuf.length);
}
function bytes2onion(buf) {
  const addrBytes = buf.subarray(0, buf.length - 2);
  const portBytes = buf.subarray(buf.length - 2);
  const addr = toString2(addrBytes, "base32");
  const port = bytes2port(portBytes);
  return `${addr}:${port}`;
}
var ip4ToBytes = function(ip) {
  ip = ip.toString().trim();
  const bytes = new Uint8Array(4);
  ip.split(/\./g).forEach((byte, index) => {
    const value = parseInt(byte, 10);
    if (isNaN(value) || value < 0 || value > 255) {
      throw new InvalidMultiaddrError2("Invalid byte value in IP address");
    }
    bytes[index] = value;
  });
  return bytes;
};
var ip6ToBytes = function(ip) {
  let offset = 0;
  ip = ip.toString().trim();
  const sections = ip.split(":", 8);
  let i2;
  for (i2 = 0; i2 < sections.length; i2++) {
    const isv4 = isIPv4(sections[i2]);
    let v4Buffer;
    if (isv4) {
      v4Buffer = ip4ToBytes(sections[i2]);
      sections[i2] = toString2(v4Buffer.subarray(0, 2), "base16");
    }
    if (v4Buffer != null && ++i2 < 8) {
      sections.splice(i2, 0, toString2(v4Buffer.subarray(2, 4), "base16"));
    }
  }
  if (sections[0] === "") {
    while (sections.length < 8) {
      sections.unshift("0");
    }
  } else if (sections[sections.length - 1] === "") {
    while (sections.length < 8) {
      sections.push("0");
    }
  } else if (sections.length < 8) {
    for (i2 = 0; i2 < sections.length && sections[i2] !== ""; i2++) {
    }
    const argv = [i2, 1];
    for (i2 = 9 - sections.length; i2 > 0; i2--) {
      argv.push("0");
    }
    sections.splice.apply(sections, argv);
  }
  const bytes = new Uint8Array(offset + 16);
  for (i2 = 0; i2 < sections.length; i2++) {
    if (sections[i2] === "") {
      sections[i2] = "0";
    }
    const word = parseInt(sections[i2], 16);
    if (isNaN(word) || word < 0 || word > 65535) {
      throw new InvalidMultiaddrError2("Invalid byte value in IP address");
    }
    bytes[offset++] = word >> 8 & 255;
    bytes[offset++] = word & 255;
  }
  return bytes;
};
var ip4ToString = function(buf) {
  if (buf.byteLength !== 4) {
    throw new InvalidMultiaddrError2("IPv4 address was incorrect length");
  }
  const result = [];
  for (let i2 = 0; i2 < buf.byteLength; i2++) {
    result.push(buf[i2]);
  }
  return result.join(".");
};
var ip6ToString = function(buf) {
  if (buf.byteLength !== 16) {
    throw new InvalidMultiaddrError2("IPv6 address was incorrect length");
  }
  const result = [];
  for (let i2 = 0; i2 < buf.byteLength; i2 += 2) {
    const byte1 = buf[i2];
    const byte2 = buf[i2 + 1];
    const tuple = `${byte1.toString(16).padStart(2, "0")}${byte2.toString(16).padStart(2, "0")}`;
    result.push(tuple);
  }
  const ip = result.join(":");
  try {
    const url = new URL(`http://[${ip}]`);
    return url.hostname.substring(1, url.hostname.length - 1);
  } catch {
    throw new InvalidMultiaddrError2(`Invalid IPv6 address "${ip}"`);
  }
};
function ip6StringToValue(str) {
  try {
    const url = new URL(`http://[${str}]`);
    return url.hostname.substring(1, url.hostname.length - 1);
  } catch {
    throw new InvalidMultiaddrError2(`Invalid IPv6 address "${str}"`);
  }
}
var decoders2 = Object.values(bases).map((c2) => c2.decoder);
var anybaseDecoder = function() {
  let acc = decoders2[0].or(decoders2[1]);
  decoders2.slice(2).forEach((d2) => acc = acc.or(d2));
  return acc;
}();
function mb2bytes(mbstr) {
  return anybaseDecoder.decode(mbstr);
}
function bytes2mb(base4) {
  return (buf) => {
    return base4.encoder.encode(buf);
  };
}

// node_modules/@multiformats/multiaddr/dist/src/validation.js
function integer(value) {
  const int = parseInt(value);
  if (int.toString() !== value) {
    throw new ValidationError("Value must be an integer");
  }
}
function positive(value) {
  if (value < 0) {
    throw new ValidationError("Value must be a positive integer, or zero");
  }
}
function maxValue(max) {
  return (value) => {
    if (value > max) {
      throw new ValidationError(`Value must be smaller than or equal to ${max}`);
    }
  };
}
function validate2(...funcs) {
  return (value) => {
    for (const fn of funcs) {
      fn(value);
    }
  };
}
var validatePort = validate2(integer, positive, maxValue(65535));

// node_modules/@multiformats/multiaddr/dist/src/registry.js
var V = -1;
var Registry = class {
  constructor() {
    __publicField(this, "protocolsByCode", /* @__PURE__ */ new Map());
    __publicField(this, "protocolsByName", /* @__PURE__ */ new Map());
  }
  getProtocol(key) {
    let codec;
    if (typeof key === "string") {
      codec = this.protocolsByName.get(key);
    } else {
      codec = this.protocolsByCode.get(key);
    }
    if (codec == null) {
      throw new UnknownProtocolError(`Protocol ${key} was unknown`);
    }
    return codec;
  }
  addProtocol(codec) {
    var _a27;
    this.protocolsByCode.set(codec.code, codec);
    this.protocolsByName.set(codec.name, codec);
    (_a27 = codec.aliases) == null ? void 0 : _a27.forEach((alias) => {
      this.protocolsByName.set(alias, codec);
    });
  }
  removeProtocol(code2) {
    var _a27;
    const codec = this.protocolsByCode.get(code2);
    if (codec == null) {
      return;
    }
    this.protocolsByCode.delete(codec.code);
    this.protocolsByName.delete(codec.name);
    (_a27 = codec.aliases) == null ? void 0 : _a27.forEach((alias) => {
      this.protocolsByName.delete(alias);
    });
  }
};
var registry = new Registry();
var codecs = [{
  code: CODE_IP4,
  name: "ip4",
  size: 32,
  valueToBytes: ip4ToBytes,
  bytesToValue: ip4ToString,
  validate: (value) => {
    if (!isIPv4(value)) {
      throw new ValidationError(`Invalid IPv4 address "${value}"`);
    }
  }
}, {
  code: CODE_TCP,
  name: "tcp",
  size: 16,
  valueToBytes: port2bytes,
  bytesToValue: bytes2port,
  validate: validatePort
}, {
  code: CODE_UDP,
  name: "udp",
  size: 16,
  valueToBytes: port2bytes,
  bytesToValue: bytes2port,
  validate: validatePort
}, {
  code: CODE_DCCP,
  name: "dccp",
  size: 16,
  valueToBytes: port2bytes,
  bytesToValue: bytes2port,
  validate: validatePort
}, {
  code: CODE_IP6,
  name: "ip6",
  size: 128,
  valueToBytes: ip6ToBytes,
  bytesToValue: ip6ToString,
  stringToValue: ip6StringToValue,
  validate: (value) => {
    if (!isIPv6(value)) {
      throw new ValidationError(`Invalid IPv6 address "${value}"`);
    }
  }
}, {
  code: CODE_IP6ZONE,
  name: "ip6zone",
  size: V
}, {
  code: CODE_IPCIDR,
  name: "ipcidr",
  size: 8,
  bytesToValue: bytesToString("base10"),
  valueToBytes: stringToBytes2("base10")
}, {
  code: CODE_DNS,
  name: "dns",
  size: V,
  resolvable: true
}, {
  code: CODE_DNS4,
  name: "dns4",
  size: V,
  resolvable: true
}, {
  code: CODE_DNS6,
  name: "dns6",
  size: V,
  resolvable: true
}, {
  code: CODE_DNSADDR,
  name: "dnsaddr",
  size: V,
  resolvable: true
}, {
  code: CODE_SCTP,
  name: "sctp",
  size: 16,
  valueToBytes: port2bytes,
  bytesToValue: bytes2port,
  validate: validatePort
}, {
  code: CODE_UDT,
  name: "udt"
}, {
  code: CODE_UTP,
  name: "utp"
}, {
  code: CODE_UNIX,
  name: "unix",
  size: V,
  path: true,
  stringToValue: (str) => decodeURIComponent(str),
  valueToString: (val) => encodeURIComponent(val)
}, {
  code: CODE_P2P,
  name: "p2p",
  aliases: ["ipfs"],
  size: V,
  bytesToValue: bytesToString("base58btc"),
  valueToBytes: (val) => {
    if (val.startsWith("Q") || val.startsWith("1")) {
      return stringToBytes2("base58btc")(val);
    }
    return CID.parse(val).multihash.bytes;
  }
}, {
  code: CODE_ONION,
  name: "onion",
  size: 96,
  bytesToValue: bytes2onion,
  valueToBytes: onion2bytes
}, {
  code: CODE_ONION3,
  name: "onion3",
  size: 296,
  bytesToValue: bytes2onion,
  valueToBytes: onion32bytes
}, {
  code: CODE_GARLIC64,
  name: "garlic64",
  size: V
}, {
  code: CODE_GARLIC32,
  name: "garlic32",
  size: V
}, {
  code: CODE_TLS,
  name: "tls"
}, {
  code: CODE_SNI,
  name: "sni",
  size: V
}, {
  code: CODE_NOISE,
  name: "noise"
}, {
  code: CODE_QUIC,
  name: "quic"
}, {
  code: CODE_QUIC_V1,
  name: "quic-v1"
}, {
  code: CODE_WEBTRANSPORT,
  name: "webtransport"
}, {
  code: CODE_CERTHASH,
  name: "certhash",
  size: V,
  bytesToValue: bytes2mb(base64url),
  valueToBytes: mb2bytes
}, {
  code: CODE_HTTP,
  name: "http"
}, {
  code: CODE_HTTP_PATH,
  name: "http-path",
  size: V,
  stringToValue: (str) => `/${decodeURIComponent(str)}`,
  valueToString: (val) => encodeURIComponent(val.substring(1))
}, {
  code: CODE_HTTPS,
  name: "https"
}, {
  code: CODE_WS,
  name: "ws"
}, {
  code: CODE_WSS,
  name: "wss"
}, {
  code: CODE_P2P_WEBSOCKET_STAR,
  name: "p2p-websocket-star"
}, {
  code: CODE_P2P_STARDUST,
  name: "p2p-stardust"
}, {
  code: CODE_P2P_WEBRTC_STAR,
  name: "p2p-webrtc-star"
}, {
  code: CODE_P2P_WEBRTC_DIRECT,
  name: "p2p-webrtc-direct"
}, {
  code: CODE_WEBRTC_DIRECT,
  name: "webrtc-direct"
}, {
  code: CODE_WEBRTC,
  name: "webrtc"
}, {
  code: CODE_P2P_CIRCUIT,
  name: "p2p-circuit"
}, {
  code: CODE_MEMORY,
  name: "memory",
  size: V
}];
codecs.forEach((codec) => {
  registry.addProtocol(codec);
});

// node_modules/@multiformats/multiaddr/dist/src/components.js
function bytesToComponents(bytes) {
  var _a27;
  const components = [];
  let i2 = 0;
  while (i2 < bytes.length) {
    const code2 = decode(bytes, i2);
    const codec = registry.getProtocol(code2);
    const codeLength = encodingLength(code2);
    const size = sizeForAddr(codec, bytes, i2 + codeLength);
    let sizeLength = 0;
    if (size > 0 && codec.size === V) {
      sizeLength = encodingLength(size);
    }
    const componentLength = codeLength + sizeLength + size;
    const component = {
      code: code2,
      name: codec.name,
      bytes: bytes.subarray(i2, i2 + componentLength)
    };
    if (size > 0) {
      const valueOffset = i2 + codeLength + sizeLength;
      const valueBytes = bytes.subarray(valueOffset, valueOffset + size);
      component.value = ((_a27 = codec.bytesToValue) == null ? void 0 : _a27.call(codec, valueBytes)) ?? toString2(valueBytes);
    }
    components.push(component);
    i2 += componentLength;
  }
  return components;
}
function componentsToBytes(components) {
  var _a27;
  let length3 = 0;
  const bytes = [];
  for (const component of components) {
    if (component.bytes == null) {
      const codec = registry.getProtocol(component.code);
      const codecLength = encodingLength(component.code);
      let valueBytes;
      let valueLength = 0;
      let valueLengthLength = 0;
      if (component.value != null) {
        valueBytes = ((_a27 = codec.valueToBytes) == null ? void 0 : _a27.call(codec, component.value)) ?? fromString2(component.value);
        valueLength = valueBytes.byteLength;
        if (codec.size === V) {
          valueLengthLength = encodingLength(valueLength);
        }
      }
      const bytes2 = new Uint8Array(codecLength + valueLengthLength + valueLength);
      let offset = 0;
      encodeUint8Array(component.code, bytes2, offset);
      offset += codecLength;
      if (valueBytes != null) {
        if (codec.size === V) {
          encodeUint8Array(valueLength, bytes2, offset);
          offset += valueLengthLength;
        }
        bytes2.set(valueBytes, offset);
      }
      component.bytes = bytes2;
    }
    bytes.push(component.bytes);
    length3 += component.bytes.byteLength;
  }
  return concat2(bytes, length3);
}
function stringToComponents(string3) {
  var _a27;
  if (string3.charAt(0) !== "/") {
    throw new InvalidMultiaddrError2('String multiaddr must start with "/"');
  }
  const components = [];
  let collecting = "protocol";
  let value = "";
  let protocol = "";
  for (let i2 = 1; i2 < string3.length; i2++) {
    const char = string3.charAt(i2);
    if (char !== "/") {
      if (collecting === "protocol") {
        protocol += string3.charAt(i2);
      } else {
        value += string3.charAt(i2);
      }
    }
    const ended = i2 === string3.length - 1;
    if (char === "/" || ended) {
      const codec = registry.getProtocol(protocol);
      if (collecting === "protocol") {
        if (codec.size == null || codec.size === 0) {
          components.push({
            code: codec.code,
            name: codec.name
          });
          value = "";
          protocol = "";
          collecting = "protocol";
          continue;
        } else if (ended) {
          throw new InvalidMultiaddrError2(`Component ${protocol} was missing value`);
        }
        collecting = "value";
      } else if (collecting === "value") {
        const component = {
          code: codec.code,
          name: codec.name
        };
        if (codec.size != null && codec.size !== 0) {
          if (value === "") {
            throw new InvalidMultiaddrError2(`Component ${protocol} was missing value`);
          }
          component.value = ((_a27 = codec.stringToValue) == null ? void 0 : _a27.call(codec, value)) ?? value;
        }
        components.push(component);
        value = "";
        protocol = "";
        collecting = "protocol";
      }
    }
  }
  if (protocol !== "" && value !== "") {
    throw new InvalidMultiaddrError2("Incomplete multiaddr");
  }
  return components;
}
function componentsToString(components) {
  return `/${components.flatMap((component) => {
    var _a27;
    if (component.value == null) {
      return component.name;
    }
    const codec = registry.getProtocol(component.code);
    if (codec == null) {
      throw new InvalidMultiaddrError2(`Unknown protocol code ${component.code}`);
    }
    return [
      component.name,
      ((_a27 = codec.valueToString) == null ? void 0 : _a27.call(codec, component.value)) ?? component.value
    ];
  }).join("/")}`;
}
function sizeForAddr(codec, bytes, offset) {
  if (codec.size == null || codec.size === 0) {
    return 0;
  }
  if (codec.size > 0) {
    return codec.size / 8;
  }
  return decode(bytes, offset);
}

// node_modules/@multiformats/multiaddr/dist/src/multiaddr.js
var inspect2 = Symbol.for("nodejs.util.inspect.custom");
var symbol2 = Symbol.for("@multiformats/multiaddr");
var DNS_CODES = [
  CODE_DNS,
  CODE_DNS4,
  CODE_DNS6,
  CODE_DNSADDR
];
var NoAvailableResolverError = class extends Error {
  constructor(message2 = "No available resolver") {
    super(message2);
    this.name = "NoAvailableResolverError";
  }
};
function toComponents(addr) {
  if (addr == null) {
    addr = "/";
  }
  if (isMultiaddr(addr)) {
    return addr.getComponents();
  }
  if (addr instanceof Uint8Array) {
    return bytesToComponents(addr);
  }
  if (typeof addr === "string") {
    addr = addr.replace(/\/(\/)+/, "/").replace(/(\/)+$/, "");
    if (addr === "") {
      addr = "/";
    }
    return stringToComponents(addr);
  }
  if (Array.isArray(addr)) {
    return addr;
  }
  throw new InvalidMultiaddrError2("Must be a string, Uint8Array, Component[], or another Multiaddr");
}
var _a5, _components, _string, _bytes;
var _Multiaddr = class _Multiaddr {
  constructor(addr = "/", options = {}) {
    __publicField(this, _a5, true);
    __privateAdd(this, _components);
    // cache string representation
    __privateAdd(this, _string);
    // cache byte representation
    __privateAdd(this, _bytes);
    __privateSet(this, _components, toComponents(addr));
    if (options.validate !== false) {
      validate3(this);
    }
  }
  get bytes() {
    if (__privateGet(this, _bytes) == null) {
      __privateSet(this, _bytes, componentsToBytes(__privateGet(this, _components)));
    }
    return __privateGet(this, _bytes);
  }
  toString() {
    if (__privateGet(this, _string) == null) {
      __privateSet(this, _string, componentsToString(__privateGet(this, _components)));
    }
    return __privateGet(this, _string);
  }
  toJSON() {
    return this.toString();
  }
  toOptions() {
    let family;
    let transport;
    let host;
    let port;
    let zone = "";
    for (const { code: code2, name: name3, value } of __privateGet(this, _components)) {
      if (code2 === CODE_IP6ZONE) {
        zone = `%${value ?? ""}`;
      }
      if (DNS_CODES.includes(code2)) {
        transport = "tcp";
        port = 443;
        host = `${value ?? ""}${zone}`;
        family = code2 === CODE_DNS6 ? 6 : 4;
      }
      if (code2 === CODE_TCP || code2 === CODE_UDP) {
        transport = name3 === "tcp" ? "tcp" : "udp";
        port = parseInt(value ?? "");
      }
      if (code2 === CODE_IP4 || code2 === CODE_IP6) {
        transport = "tcp";
        host = `${value ?? ""}${zone}`;
        family = code2 === CODE_IP6 ? 6 : 4;
      }
    }
    if (family == null || transport == null || host == null || port == null) {
      throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
    }
    const opts = {
      family,
      host,
      transport,
      port
    };
    return opts;
  }
  getComponents() {
    return [
      ...__privateGet(this, _components)
    ];
  }
  protos() {
    return __privateGet(this, _components).map(({ code: code2, value }) => {
      const codec = registry.getProtocol(code2);
      return {
        code: code2,
        size: codec.size ?? 0,
        name: codec.name,
        resolvable: Boolean(codec.resolvable),
        path: Boolean(codec.path)
      };
    });
  }
  protoCodes() {
    return __privateGet(this, _components).map(({ code: code2 }) => code2);
  }
  protoNames() {
    return __privateGet(this, _components).map(({ name: name3 }) => name3);
  }
  tuples() {
    return __privateGet(this, _components).map(({ code: code2, value }) => {
      var _a27;
      if (value == null) {
        return [code2];
      }
      const codec = registry.getProtocol(code2);
      const output = [code2];
      if (value != null) {
        output.push(((_a27 = codec.valueToBytes) == null ? void 0 : _a27.call(codec, value)) ?? fromString2(value));
      }
      return output;
    });
  }
  stringTuples() {
    return __privateGet(this, _components).map(({ code: code2, value }) => {
      if (value == null) {
        return [code2];
      }
      return [code2, value];
    });
  }
  encapsulate(addr) {
    const ma = new _Multiaddr(addr);
    return new _Multiaddr([
      ...__privateGet(this, _components),
      ...ma.getComponents()
    ], {
      validate: false
    });
  }
  decapsulate(addr) {
    const addrString = addr.toString();
    const s2 = this.toString();
    const i2 = s2.lastIndexOf(addrString);
    if (i2 < 0) {
      throw new InvalidParametersError3(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
    }
    return new _Multiaddr(s2.slice(0, i2), {
      validate: false
    });
  }
  decapsulateCode(code2) {
    let index;
    for (let i2 = __privateGet(this, _components).length - 1; i2 > -1; i2--) {
      if (__privateGet(this, _components)[i2].code === code2) {
        index = i2;
        break;
      }
    }
    return new _Multiaddr(__privateGet(this, _components).slice(0, index), {
      validate: false
    });
  }
  getPeerId() {
    try {
      let tuples = [];
      __privateGet(this, _components).forEach(({ code: code2, value }) => {
        if (code2 === CODE_P2P) {
          tuples.push([code2, value]);
        }
        if (code2 === CODE_P2P_CIRCUIT) {
          tuples = [];
        }
      });
      const tuple = tuples.pop();
      if ((tuple == null ? void 0 : tuple[1]) != null) {
        const peerIdStr = tuple[1];
        if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
          return toString2(base58btc.decode(`z${peerIdStr}`), "base58btc");
        }
        return toString2(CID.parse(peerIdStr).multihash.bytes, "base58btc");
      }
      return null;
    } catch (e2) {
      return null;
    }
  }
  getPath() {
    for (const component of __privateGet(this, _components)) {
      const codec = registry.getProtocol(component.code);
      if (!codec.path) {
        continue;
      }
      return component.value ?? null;
    }
    return null;
  }
  equals(addr) {
    return equals3(this.bytes, addr.bytes);
  }
  async resolve(options) {
    const resolvableProto = this.protos().find((p2) => p2.resolvable);
    if (resolvableProto == null) {
      return [this];
    }
    const resolver = resolvers.get(resolvableProto.name);
    if (resolver == null) {
      throw new NoAvailableResolverError(`no available resolver for ${resolvableProto.name}`);
    }
    const result = await resolver(this, options);
    return result.map((str) => multiaddr(str));
  }
  nodeAddress() {
    const options = this.toOptions();
    if (options.transport !== "tcp" && options.transport !== "udp") {
      throw new Error(`multiaddr must have a valid format - no protocol with name: "${options.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
    }
    return {
      family: options.family,
      address: options.host,
      port: options.port
    };
  }
  isThinWaistAddress() {
    if (__privateGet(this, _components).length !== 2) {
      return false;
    }
    if (__privateGet(this, _components)[0].code !== CODE_IP4 && __privateGet(this, _components)[0].code !== CODE_IP6) {
      return false;
    }
    if (__privateGet(this, _components)[1].code !== CODE_TCP && __privateGet(this, _components)[1].code !== CODE_UDP) {
      return false;
    }
    return true;
  }
  /**
   * Returns Multiaddr as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```js
   * import { multiaddr } from '@multiformats/multiaddr'
   *
   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
   * ```
   */
  [(_a5 = symbol2, inspect2)]() {
    return `Multiaddr(${this.toString()})`;
  }
};
_components = new WeakMap();
_string = new WeakMap();
_bytes = new WeakMap();
var Multiaddr = _Multiaddr;
function validate3(addr) {
  addr.getComponents().forEach((component) => {
    var _a27;
    const codec = registry.getProtocol(component.code);
    if (component.value == null) {
      return;
    }
    (_a27 = codec.validate) == null ? void 0 : _a27.call(codec, component.value);
  });
}

// node_modules/@chainsafe/netmask/dist/src/util.js
function allFF(a2, from3, to) {
  let i2 = 0;
  for (const e2 of a2) {
    if (i2 < from3)
      continue;
    if (i2 > to)
      break;
    if (e2 !== 255)
      return false;
    i2++;
  }
  return true;
}
function deepEqual(a2, b, from3, to) {
  let i2 = 0;
  for (const e2 of a2) {
    if (i2 < from3)
      continue;
    if (i2 > to)
      break;
    if (e2 !== b[i2])
      return false;
    i2++;
  }
  return true;
}
function ipToString(ip) {
  switch (ip.length) {
    case IPv4Len: {
      return ip.join(".");
    }
    case IPv6Len: {
      const result = [];
      for (let i2 = 0; i2 < ip.length; i2++) {
        if (i2 % 2 === 0) {
          result.push(ip[i2].toString(16).padStart(2, "0") + ip[i2 + 1].toString(16).padStart(2, "0"));
        }
      }
      return result.join(":");
    }
    default: {
      throw new Error("Invalid ip length");
    }
  }
}
function simpleMaskLength(mask) {
  let ones = 0;
  for (let [index, byte] of mask.entries()) {
    if (byte === 255) {
      ones += 8;
      continue;
    }
    while ((byte & 128) != 0) {
      ones++;
      byte = byte << 1;
    }
    if ((byte & 128) != 0) {
      return -1;
    }
    for (let i2 = index + 1; i2 < mask.length; i2++) {
      if (mask[i2] != 0) {
        return -1;
      }
    }
    break;
  }
  return ones;
}
function maskToHex(mask) {
  let hex = "0x";
  for (const byte of mask) {
    hex += (byte >> 4).toString(16) + (byte & 15).toString(16);
  }
  return hex;
}

// node_modules/@chainsafe/netmask/dist/src/ip.js
var IPv4Len = 4;
var IPv6Len = 16;
var maxIPv6Octet = parseInt("0xFFFF", 16);
var ipv4Prefix = new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  255,
  255
]);
function maskIp(ip, mask) {
  if (mask.length === IPv6Len && ip.length === IPv4Len && allFF(mask, 0, 11)) {
    mask = mask.slice(12);
  }
  if (mask.length === IPv4Len && ip.length === IPv6Len && deepEqual(ip, ipv4Prefix, 0, 11)) {
    ip = ip.slice(12);
  }
  const n2 = ip.length;
  if (n2 != mask.length) {
    throw new Error("Failed to mask ip");
  }
  const out = new Uint8Array(n2);
  for (let i2 = 0; i2 < n2; i2++) {
    out[i2] = ip[i2] & mask[i2];
  }
  return out;
}
function containsIp(net, ip) {
  if (typeof ip === "string") {
    ip = parseIP(ip);
  }
  if (ip == null)
    throw new Error("Invalid ip");
  if (ip.length !== net.network.length) {
    return false;
  }
  for (let i2 = 0; i2 < ip.length; i2++) {
    if ((net.network[i2] & net.mask[i2]) !== (ip[i2] & net.mask[i2])) {
      return false;
    }
  }
  return true;
}

// node_modules/@chainsafe/netmask/dist/src/cidr.js
function parseCidr(s2) {
  const [address, maskString] = s2.split("/");
  if (!address || !maskString)
    throw new Error("Failed to parse given CIDR: " + s2);
  let ipLength = IPv4Len;
  let ip = parseIPv4(address);
  if (ip == null) {
    ipLength = IPv6Len;
    ip = parseIPv6(address);
    if (ip == null)
      throw new Error("Failed to parse given CIDR: " + s2);
  }
  const m2 = parseInt(maskString, 10);
  if (Number.isNaN(m2) || String(m2).length !== maskString.length || m2 < 0 || m2 > ipLength * 8) {
    throw new Error("Failed to parse given CIDR: " + s2);
  }
  const mask = cidrMask(m2, 8 * ipLength);
  return {
    network: maskIp(ip, mask),
    mask
  };
}
function cidrMask(ones, bits) {
  if (bits !== 8 * IPv4Len && bits !== 8 * IPv6Len)
    throw new Error("Invalid CIDR mask");
  if (ones < 0 || ones > bits)
    throw new Error("Invalid CIDR mask");
  const l2 = bits / 8;
  const m2 = new Uint8Array(l2);
  for (let i2 = 0; i2 < l2; i2++) {
    if (ones >= 8) {
      m2[i2] = 255;
      ones -= 8;
      continue;
    }
    m2[i2] = 255 - (255 >> ones);
    ones = 0;
  }
  return m2;
}

// node_modules/@chainsafe/netmask/dist/src/ipnet.js
var IpNet = class {
  /**
   *
   * @param ipOrCidr either network ip or full cidr address
   * @param mask in case ipOrCidr is network this can be either mask in decimal format or as ip address
   */
  constructor(ipOrCidr, mask) {
    if (mask == null) {
      ({ network: this.network, mask: this.mask } = parseCidr(ipOrCidr));
    } else {
      const ipResult = parseIP(ipOrCidr);
      if (ipResult == null) {
        throw new Error("Failed to parse network");
      }
      mask = String(mask);
      const m2 = parseInt(mask, 10);
      if (Number.isNaN(m2) || String(m2).length !== mask.length || m2 < 0 || m2 > ipResult.length * 8) {
        const maskResult = parseIP(mask);
        if (maskResult == null) {
          throw new Error("Failed to parse mask");
        }
        this.mask = maskResult;
      } else {
        this.mask = cidrMask(m2, 8 * ipResult.length);
      }
      this.network = maskIp(ipResult, this.mask);
    }
  }
  /**
   * Checks if netmask contains ip address
   * @param ip
   * @returns
   */
  contains(ip) {
    return containsIp({ network: this.network, mask: this.mask }, ip);
  }
  /**Serializes back to string format */
  toString() {
    const l2 = simpleMaskLength(this.mask);
    const mask = l2 !== -1 ? String(l2) : maskToHex(this.mask);
    return ipToString(this.network) + "/" + mask;
  }
};

// node_modules/@chainsafe/netmask/dist/src/index.js
function cidrContains(cidr, ip) {
  const ipnet = new IpNet(cidr);
  return ipnet.contains(ip);
}

// node_modules/@multiformats/multiaddr/dist/src/convert.js
function convertToIpNet(multiaddr2) {
  let mask;
  let addr;
  multiaddr2.getComponents().forEach((component) => {
    if (component.name === "ip4" || component.name === "ip6") {
      addr = component.value;
    }
    if (component.name === "ipcidr") {
      mask = component.value;
    }
  });
  if (mask == null || addr == null) {
    throw new Error("Invalid multiaddr");
  }
  return new IpNet(addr, mask);
}
function convertToString(proto, buf) {
  var _a27;
  const protocol = registry.getProtocol(proto);
  return ((_a27 = protocol.bytesToValue) == null ? void 0 : _a27.call(protocol, buf)) ?? toString2(buf, "base16");
}
function convertToBytes(proto, str) {
  var _a27;
  const protocol = registry.getProtocol(proto);
  return ((_a27 = protocol.valueToBytes) == null ? void 0 : _a27.call(protocol, str)) ?? fromString2(str, "base16");
}

// node_modules/@multiformats/multiaddr/dist/src/index.js
var resolvers = /* @__PURE__ */ new Map();
function isMultiaddr(value) {
  return Boolean(value == null ? void 0 : value[symbol2]);
}
function multiaddr(addr) {
  return new Multiaddr(addr);
}
function protocols(proto) {
  const codec = registry.getProtocol(proto);
  return {
    code: codec.code,
    size: codec.size ?? 0,
    name: codec.name,
    resolvable: Boolean(codec.resolvable),
    path: Boolean(codec.path)
  };
}

// node_modules/@waku/core/dist/lib/connection_manager/utils.js
var getPeerPing = (peer) => {
  if (!peer) {
    return -1;
  }
  try {
    const bytes = peer.metadata.get("ping");
    if (!bytes) {
      return -1;
    }
    return Number(bytesToUtf8(bytes));
  } catch (e2) {
    return -1;
  }
};
var mapToPeerIdOrMultiaddr = (input) => {
  return isPeerId(input) ? input : multiaddr(input);
};
var mapToPeerId = (input) => {
  return isPeerId(input) ? input : peerIdFromString(multiaddr(input).getPeerId());
};
var isAddressesSupported = (libp2p, addresses) => {
  var _a27, _b14;
  const transports = ((_b14 = (_a27 = libp2p == null ? void 0 : libp2p.components) == null ? void 0 : _a27.transportManager) == null ? void 0 : _b14.getTransports()) || [];
  if (transports.length === 0) {
    return false;
  }
  return transports.map((transport) => transport.dialFilter(addresses)).some((supportedAddresses) => supportedAddresses.length > 0);
};

// node_modules/@waku/core/dist/lib/connection_manager/connection_limiter.js
var log6 = new Logger("connection-limiter");
var DEFAULT_CONNECTION_MONITOR_INTERVAL = 5 * 1e3;
var ConnectionLimiter = class {
  constructor(options) {
    __publicField(this, "libp2p");
    __publicField(this, "events");
    __publicField(this, "networkMonitor");
    __publicField(this, "dialer");
    __publicField(this, "connectionMonitorInterval", null);
    __publicField(this, "options");
    this.libp2p = options.libp2p;
    this.events = options.events;
    this.networkMonitor = options.networkMonitor;
    this.dialer = options.dialer;
    this.options = options.options;
    this.onWakuConnectionEvent = this.onWakuConnectionEvent.bind(this);
    this.onDisconnectedEvent = this.onDisconnectedEvent.bind(this);
  }
  start() {
    void this.dialPeersFromStore();
    if (this.options.enableAutoRecovery && this.connectionMonitorInterval === null) {
      this.connectionMonitorInterval = setInterval(() => void this.maintainConnections(), DEFAULT_CONNECTION_MONITOR_INTERVAL);
    }
    this.events.addEventListener(WakuEvent.Connection, this.onWakuConnectionEvent);
    this.libp2p.addEventListener("peer:disconnect", this.onDisconnectedEvent);
  }
  stop() {
    this.events.removeEventListener(WakuEvent.Connection, this.onWakuConnectionEvent);
    this.libp2p.removeEventListener("peer:disconnect", this.onDisconnectedEvent);
    if (this.connectionMonitorInterval) {
      clearInterval(this.connectionMonitorInterval);
      this.connectionMonitorInterval = null;
    }
  }
  onWakuConnectionEvent() {
    if (!this.options.enableAutoRecovery) {
      log6.info(`Auto recovery is disabled, skipping`);
      return;
    }
    if (this.networkMonitor.isBrowserConnected()) {
      void this.dialPeersFromStore();
    }
  }
  async maintainConnections() {
    await this.maintainConnectionsCount();
    await this.maintainBootstrapConnections();
  }
  async onDisconnectedEvent() {
    if (this.libp2p.getConnections().length === 0) {
      log6.info(`No connections, dialing peers from store`);
      await this.dialPeersFromStore();
    }
  }
  async maintainConnectionsCount() {
    log6.info(`Maintaining connections count`);
    const connections = this.libp2p.getConnections();
    if (connections.length <= this.options.maxConnections) {
      log6.info(`Node has less than max connections ${this.options.maxConnections}, trying to dial more peers`);
      const peers = await this.getPrioritizedPeers();
      if (peers.length === 0) {
        log6.info(`No peers to dial, skipping`);
        await this.triggerBootstrap();
        return;
      }
      const promises = peers.slice(0, this.options.maxConnections - connections.length).map((p2) => this.dialer.dial(p2.id));
      await Promise.all(promises);
      return;
    }
    log6.info(`Node has more than max connections ${this.options.maxConnections}, dropping connections`);
    try {
      const connectionsToDrop = connections.filter((c2) => !c2.tags.includes(CONNECTION_LOCKED_TAG)).slice(this.options.maxConnections);
      if (connectionsToDrop.length === 0) {
        log6.info(`No connections to drop, skipping`);
        return;
      }
      const promises = connectionsToDrop.map((c2) => this.libp2p.hangUp(c2.remotePeer));
      await Promise.all(promises);
      log6.info(`Dropped ${connectionsToDrop.length} connections`);
    } catch (error) {
      log6.error(`Unexpected error while maintaining connections`, error);
    }
  }
  async maintainBootstrapConnections() {
    log6.info(`Maintaining bootstrap connections`);
    const bootstrapPeers = await this.getBootstrapPeers();
    if (bootstrapPeers.length <= this.options.maxBootstrapPeers) {
      return;
    }
    try {
      const peersToDrop = bootstrapPeers.slice(this.options.maxBootstrapPeers);
      log6.info(`Dropping ${peersToDrop.length} bootstrap connections because node has more than max bootstrap connections ${this.options.maxBootstrapPeers}`);
      const promises = peersToDrop.map((p2) => this.libp2p.hangUp(p2.id));
      await Promise.all(promises);
      log6.info(`Dropped ${peersToDrop.length} bootstrap connections`);
    } catch (error) {
      log6.error(`Unexpected error while maintaining bootstrap connections`, error);
    }
  }
  async dialPeersFromStore() {
    log6.info(`Dialing peers from store`);
    try {
      const peers = await this.getPrioritizedPeers();
      if (peers.length === 0) {
        log6.info(`No peers to dial, skipping`);
        await this.triggerBootstrap();
        return;
      }
      const promises = peers.map((p2) => this.dialer.dial(p2.id));
      log6.info(`Dialing ${peers.length} peers from store`);
      await Promise.all(promises);
      log6.info(`Dialed ${promises.length} peers from store`);
    } catch (error) {
      log6.error(`Unexpected error while dialing peer store peers`, error);
    }
  }
  /**
   * Returns a list of peers ordered by priority:
   * - bootstrap peers
   * - peers from peer exchange
   * - peers from peer cache (last because we are not sure that locally stored information is up to date)
   */
  async getPrioritizedPeers() {
    const allPeers = await this.libp2p.peerStore.all();
    const allConnections = this.libp2p.getConnections();
    const allConnectionsSet = new Set(allConnections.map((c2) => c2.remotePeer.toString()));
    log6.info(`Found ${allPeers.length} peers in store, and found ${allConnections.length} connections`);
    const notConnectedPeers = allPeers.filter((p2) => !allConnectionsSet.has(p2.id.toString()) && isAddressesSupported(this.libp2p, p2.addresses.map((a2) => a2.multiaddr)));
    const bootstrapPeers = notConnectedPeers.filter((p2) => p2.tags.has(Tags.BOOTSTRAP));
    const peerExchangePeers = notConnectedPeers.filter((p2) => p2.tags.has(Tags.PEER_EXCHANGE));
    const localStorePeers = notConnectedPeers.filter((p2) => p2.tags.has(Tags.PEER_CACHE));
    const restPeers = notConnectedPeers.filter((p2) => !p2.tags.has(Tags.BOOTSTRAP) && !p2.tags.has(Tags.PEER_EXCHANGE) && !p2.tags.has(Tags.PEER_CACHE));
    return [
      ...bootstrapPeers,
      ...peerExchangePeers,
      ...localStorePeers,
      ...restPeers
    ];
  }
  async getBootstrapPeers() {
    const peers = await Promise.all(this.libp2p.getConnections().map((conn) => conn.remotePeer).map((id) => this.getPeer(id)));
    return peers.filter((peer) => peer && peer.tags.has(Tags.BOOTSTRAP));
  }
  async getPeer(peerId2) {
    try {
      return await this.libp2p.peerStore.get(peerId2);
    } catch (error) {
      log6.error(`Failed to get peer ${peerId2}, error: ${error}`);
      return null;
    }
  }
  /**
   * Triggers the bootstrap or peer cache discovery if they are mounted.
   * @returns void
   */
  async triggerBootstrap() {
    log6.info("Triggering bootstrap discovery");
    const bootstrapComponents = Object.values(this.libp2p.components.components).filter((c2) => !!c2).filter((c2) => [`@waku/${Tags.BOOTSTRAP}`, `@waku/${Tags.PEER_CACHE}`].includes(c2 == null ? void 0 : c2[Symbol.toStringTag]));
    if (bootstrapComponents.length === 0) {
      log6.warn("No bootstrap components found to trigger");
      return;
    }
    log6.info(`Found ${bootstrapComponents.length} bootstrap components, starting them`);
    const promises = bootstrapComponents.map(async (component) => {
      var _a27, _b14;
      try {
        await ((_a27 = component == null ? void 0 : component.stop) == null ? void 0 : _a27.call(component));
        await ((_b14 = component == null ? void 0 : component.start) == null ? void 0 : _b14.call(component));
        log6.info("Successfully started bootstrap component");
      } catch (error) {
        log6.error("Failed to start bootstrap component", error);
      }
    });
    await Promise.all(promises);
  }
};

// node_modules/@waku/core/dist/lib/connection_manager/dialer.js
var log7 = new Logger("dialer");
var Dialer = class {
  constructor(options) {
    __publicField(this, "libp2p");
    __publicField(this, "shardReader");
    __publicField(this, "options");
    __publicField(this, "dialingQueue", []);
    __publicField(this, "dialHistory", /* @__PURE__ */ new Map());
    __publicField(this, "failedDials", /* @__PURE__ */ new Map());
    __publicField(this, "dialingInterval", null);
    __publicField(this, "isProcessing", false);
    __publicField(this, "isImmediateDialing", false);
    this.libp2p = options.libp2p;
    this.shardReader = options.shardReader;
    this.options = options.options;
  }
  start() {
    log7.info("Starting dialer");
    if (!this.dialingInterval) {
      this.dialingInterval = setInterval(() => {
        void this.processQueue();
      }, 500);
    }
    this.dialHistory.clear();
    this.failedDials.clear();
  }
  stop() {
    log7.info("Stopping dialer");
    if (this.dialingInterval) {
      clearInterval(this.dialingInterval);
      this.dialingInterval = null;
    }
    this.dialHistory.clear();
    this.failedDials.clear();
  }
  async dial(peerId2) {
    const shouldSkip = await this.shouldSkipPeer(peerId2);
    if (shouldSkip) {
      log7.info(`Skipping peer: ${peerId2}`);
      return;
    }
    const isEmptyQueue = this.dialingQueue.length === 0;
    const isNotDialing = !this.isProcessing && !this.isImmediateDialing;
    if (isEmptyQueue && isNotDialing) {
      this.isImmediateDialing = true;
      log7.info("Dialed peer immediately");
      await this.dialPeer(peerId2);
      this.isImmediateDialing = false;
      log7.info("Released immediate dial lock");
    } else {
      this.dialingQueue.push(peerId2);
      log7.info(`Added peer to dialing queue, queue size: ${this.dialingQueue.length}`);
    }
  }
  async processQueue() {
    if (this.dialingQueue.length === 0 || this.isProcessing) {
      return;
    }
    this.isProcessing = true;
    try {
      const peersToDial = this.dialingQueue.slice(0, this.options.maxDialingPeers);
      this.dialingQueue = this.dialingQueue.slice(peersToDial.length);
      log7.info(`Processing dial queue: dialing ${peersToDial.length} peers, ${this.dialingQueue.length} remaining in queue`);
      await Promise.all(peersToDial.map((peerId2) => this.dialPeer(peerId2)));
    } finally {
      this.isProcessing = false;
    }
  }
  async dialPeer(peerId2) {
    try {
      log7.info(`Dialing peer from queue: ${peerId2}`);
      await this.libp2p.dial(peerId2);
      this.dialHistory.set(peerId2.toString(), Date.now());
      this.failedDials.delete(peerId2.toString());
      log7.info(`Successfully dialed peer from queue: ${peerId2}`);
    } catch (error) {
      log7.error(`Error dialing peer ${peerId2}`, error);
      this.failedDials.set(peerId2.toString(), Date.now());
    }
  }
  async shouldSkipPeer(peerId2) {
    const hasConnection = this.libp2p.getPeers().some((p2) => p2.equals(peerId2));
    if (hasConnection) {
      log7.info(`Skipping peer ${peerId2} - already connected`);
      return true;
    }
    if (this.isRecentlyDialed(peerId2)) {
      log7.info(`Skipping peer ${peerId2} - already dialed in the last 10 seconds`);
      return true;
    }
    if (this.isRecentlyFailed(peerId2)) {
      log7.info(`Skipping peer ${peerId2} - recently failed to dial`);
      return true;
    }
    try {
      const hasShardInfo = await this.shardReader.hasShardInfo(peerId2);
      if (!hasShardInfo) {
        log7.info(`Skipping peer ${peerId2} - no shard info`);
        return false;
      }
      const isOnSameCluster = await this.shardReader.isPeerOnCluster(peerId2);
      if (!isOnSameCluster) {
        log7.info(`Skipping peer ${peerId2} - not on same cluster`);
        return true;
      }
      return false;
    } catch (error) {
      log7.error(`Error checking shard info for peer ${peerId2}`, error);
      return true;
    }
  }
  isRecentlyDialed(peerId2) {
    const lastDialed = this.dialHistory.get(peerId2.toString());
    if (lastDialed && Date.now() - lastDialed < this.options.dialCooldown * 1e3) {
      return true;
    }
    return false;
  }
  isRecentlyFailed(peerId2) {
    const lastFailed = this.failedDials.get(peerId2.toString());
    if (lastFailed && Date.now() - lastFailed < this.options.failedDialCooldown * 1e3) {
      return true;
    }
    return false;
  }
};

// node_modules/@waku/core/dist/lib/connection_manager/discovery_dialer.js
var log8 = new Logger("discovery-dialer");
var DiscoveryDialer = class {
  constructor(options) {
    __publicField(this, "libp2p");
    __publicField(this, "dialer");
    this.libp2p = options.libp2p;
    this.dialer = options.dialer;
    this.onPeerDiscovery = this.onPeerDiscovery.bind(this);
  }
  start() {
    this.libp2p.addEventListener("peer:discovery", this.onPeerDiscovery);
  }
  stop() {
    this.libp2p.removeEventListener("peer:discovery", this.onPeerDiscovery);
  }
  async onPeerDiscovery(event) {
    const peerId2 = event.detail.id;
    log8.info(`Discovered new peer: ${peerId2}`);
    try {
      await this.updatePeerStore(peerId2, event.detail.multiaddrs);
      await this.dialer.dial(peerId2);
    } catch (error) {
      log8.error(`Error dialing peer ${peerId2}`, error);
    }
  }
  async updatePeerStore(peerId2, multiaddrs) {
    try {
      log8.info(`Updating peer store for ${peerId2}`);
      const peer = await this.getPeer(peerId2);
      if (!peer) {
        log8.info(`Peer ${peerId2} not found in store, saving`);
        await this.libp2p.peerStore.save(peerId2, {
          multiaddrs
        });
        return;
      }
      const hasSameAddr = multiaddrs.every((addr) => peer.addresses.some((a2) => a2.multiaddr.equals(addr)));
      if (hasSameAddr) {
        log8.info(`Peer ${peerId2} has same addresses in peer store, skipping`);
        return;
      }
      log8.info(`Merging peer ${peerId2} addresses in peer store`);
      await this.libp2p.peerStore.merge(peerId2, {
        multiaddrs
      });
    } catch (error) {
      log8.error(`Error updating peer store for ${peerId2}`, error);
    }
  }
  async getPeer(peerId2) {
    try {
      return await this.libp2p.peerStore.get(peerId2);
    } catch (error) {
      log8.error(`Error getting peer info for ${peerId2}`, error);
      return void 0;
    }
  }
};

// node_modules/@waku/core/dist/lib/connection_manager/keep_alive_manager.js
var RelayPingContentTopic = "/relay-ping/1/ping/null";
var log9 = new Logger("keep-alive");
var KeepAliveManager = class {
  constructor({ options, relay, networkConfig, libp2p }) {
    __publicField(this, "relay");
    __publicField(this, "networkConfig");
    __publicField(this, "libp2p");
    __publicField(this, "options");
    __publicField(this, "pingKeepAliveTimers", /* @__PURE__ */ new Map());
    __publicField(this, "relayKeepAliveTimers", /* @__PURE__ */ new Map());
    this.options = options;
    this.relay = relay;
    this.networkConfig = networkConfig;
    this.libp2p = libp2p;
    this.onPeerConnect = this.onPeerConnect.bind(this);
    this.onPeerDisconnect = this.onPeerDisconnect.bind(this);
  }
  start() {
    this.libp2p.addEventListener("peer:connect", this.onPeerConnect);
    this.libp2p.addEventListener("peer:disconnect", this.onPeerDisconnect);
  }
  stop() {
    this.libp2p.removeEventListener("peer:connect", this.onPeerConnect);
    this.libp2p.removeEventListener("peer:disconnect", this.onPeerDisconnect);
    for (const timer of this.pingKeepAliveTimers.values()) {
      clearInterval(timer);
    }
    for (const timerArray of this.relayKeepAliveTimers.values()) {
      for (const timer of timerArray) {
        clearInterval(timer);
      }
    }
    this.pingKeepAliveTimers.clear();
    this.relayKeepAliveTimers.clear();
  }
  onPeerConnect(evt) {
    const peerId2 = evt.detail;
    this.startPingForPeer(peerId2);
  }
  onPeerDisconnect(evt) {
    const peerId2 = evt.detail;
    this.stopPingForPeer(peerId2);
  }
  startPingForPeer(peerId2) {
    this.stopPingForPeer(peerId2);
    this.startLibp2pPing(peerId2);
    this.startRelayPing(peerId2);
  }
  stopPingForPeer(peerId2) {
    this.stopLibp2pPing(peerId2);
    this.stopRelayPing(peerId2);
  }
  startLibp2pPing(peerId2) {
    if (this.options.pingKeepAlive === 0) {
      log9.warn(`Ping keep alive is disabled pingKeepAlive:${this.options.pingKeepAlive}, skipping start for libp2p ping`);
      return;
    }
    const peerIdStr = peerId2.toString();
    if (this.pingKeepAliveTimers.has(peerIdStr)) {
      log9.warn(`Ping already started for peer: ${peerIdStr}, skipping start for libp2p ping`);
      return;
    }
    const interval = setInterval(() => {
      void this.pingLibp2p(peerId2);
    }, this.options.pingKeepAlive * 1e3);
    this.pingKeepAliveTimers.set(peerIdStr, interval);
  }
  stopLibp2pPing(peerId2) {
    const peerIdStr = peerId2.toString();
    if (!this.pingKeepAliveTimers.has(peerIdStr)) {
      log9.warn(`Ping not started for peer: ${peerIdStr}, skipping stop for ping`);
      return;
    }
    clearInterval(this.pingKeepAliveTimers.get(peerIdStr));
    this.pingKeepAliveTimers.delete(peerIdStr);
  }
  startRelayPing(peerId2) {
    if (!this.relay) {
      return;
    }
    if (this.options.relayKeepAlive === 0) {
      log9.warn(`Relay keep alive is disabled relayKeepAlive:${this.options.relayKeepAlive}, skipping start for relay ping`);
      return;
    }
    if (this.relayKeepAliveTimers.has(peerId2.toString())) {
      log9.warn(`Relay ping already started for peer: ${peerId2.toString()}, skipping start for relay ping`);
      return;
    }
    const intervals = [];
    for (const topic of this.relay.pubsubTopics) {
      const meshPeers = this.relay.getMeshPeers(topic);
      if (!meshPeers.includes(peerId2.toString())) {
        log9.warn(`Peer: ${peerId2.toString()} is not in the mesh for topic: ${topic}, skipping start for relay ping`);
        continue;
      }
      const routingInfo = createRoutingInfo(this.networkConfig, {
        contentTopic: RelayPingContentTopic,
        pubsubTopic: topic
      });
      const encoder2 = createEncoder({
        routingInfo,
        contentTopic: RelayPingContentTopic,
        ephemeral: true
      });
      const interval = setInterval(() => {
        void this.pingRelay(encoder2);
      }, this.options.relayKeepAlive * 1e3);
      intervals.push(interval);
    }
    this.relayKeepAliveTimers.set(peerId2.toString(), intervals);
  }
  stopRelayPing(peerId2) {
    var _a27;
    if (!this.relay) {
      return;
    }
    const peerIdStr = peerId2.toString();
    if (!this.relayKeepAliveTimers.has(peerIdStr)) {
      log9.warn(`Relay ping not started for peer: ${peerIdStr}, skipping stop for relay ping`);
      return;
    }
    (_a27 = this.relayKeepAliveTimers.get(peerIdStr)) == null ? void 0 : _a27.map(clearInterval);
    this.relayKeepAliveTimers.delete(peerIdStr);
  }
  async pingRelay(encoder2) {
    try {
      log9.info("Sending Waku Relay ping message");
      await this.relay.send(encoder2, { payload: new Uint8Array([1]) });
    } catch (e2) {
      log9.error("Failed to send relay ping", e2);
    }
  }
  async pingLibp2p(peerId2) {
    try {
      log9.info(`Pinging libp2p peer (${peerId2.toString()})`);
      const ping2 = await this.libp2p.services.ping.ping(peerId2);
      log9.info(`Ping succeeded (${peerId2.toString()})`, ping2);
      await this.libp2p.peerStore.merge(peerId2, {
        metadata: {
          ping: utf8ToBytes2(ping2.toString())
        }
      });
      log9.info(`Ping updated for peer (${peerId2.toString()})`);
    } catch (e2) {
      log9.error(`Ping failed for peer (${peerId2.toString()})`, e2);
    }
  }
};

// node_modules/@waku/core/dist/lib/connection_manager/network_monitor.js
var NetworkMonitor = class {
  constructor(options) {
    __publicField(this, "libp2p");
    __publicField(this, "events");
    __publicField(this, "isNetworkConnected", false);
    this.libp2p = options.libp2p;
    this.events = options.events;
    this.onConnectedEvent = this.onConnectedEvent.bind(this);
    this.onDisconnectedEvent = this.onDisconnectedEvent.bind(this);
    this.dispatchNetworkEvent = this.dispatchNetworkEvent.bind(this);
  }
  start() {
    this.libp2p.addEventListener("peer:connect", this.onConnectedEvent);
    this.libp2p.addEventListener("peer:disconnect", this.onDisconnectedEvent);
    try {
      globalThis.addEventListener("online", this.dispatchNetworkEvent);
      globalThis.addEventListener("offline", this.dispatchNetworkEvent);
    } catch (err) {
    }
  }
  stop() {
    this.libp2p.removeEventListener("peer:connect", this.onConnectedEvent);
    this.libp2p.removeEventListener("peer:disconnect", this.onDisconnectedEvent);
    try {
      globalThis.removeEventListener("online", this.dispatchNetworkEvent);
      globalThis.removeEventListener("offline", this.dispatchNetworkEvent);
    } catch (err) {
    }
  }
  /**
   * Returns true if the node is connected to the network via libp2p and browser.
   */
  isConnected() {
    if (!this.isBrowserConnected()) {
      return false;
    }
    return this.isP2PConnected();
  }
  /**
   * Returns true if the node is connected to the network via libp2p.
   */
  isP2PConnected() {
    return this.isNetworkConnected;
  }
  /**
   * Returns true if the node is connected to the network via browser.
   */
  isBrowserConnected() {
    var _a27;
    try {
      if ((globalThis == null ? void 0 : globalThis.navigator) && !((_a27 = globalThis == null ? void 0 : globalThis.navigator) == null ? void 0 : _a27.onLine)) {
        return false;
      }
    } catch (err) {
    }
    return true;
  }
  onConnectedEvent() {
    if (!this.isNetworkConnected) {
      this.isNetworkConnected = true;
      this.dispatchNetworkEvent();
    }
  }
  onDisconnectedEvent() {
    if (this.isNetworkConnected && this.libp2p.getConnections().length === 0) {
      this.isNetworkConnected = false;
      this.dispatchNetworkEvent();
    }
  }
  dispatchNetworkEvent() {
    this.events.dispatchEvent(new CustomEvent(WakuEvent.Connection, {
      detail: this.isConnected()
    }));
  }
};

// node_modules/@waku/core/dist/lib/connection_manager/shard_reader.js
var log10 = new Logger("shard-reader");
var ShardReader = class {
  constructor(options) {
    __publicField(this, "libp2p");
    __publicField(this, "clusterId");
    this.libp2p = options.libp2p;
    this.clusterId = options.networkConfig.clusterId;
  }
  async isPeerOnCluster(id) {
    const peerRelayShards = await this.getRelayShards(id);
    if (!peerRelayShards) {
      return false;
    }
    return peerRelayShards.clusterId === this.clusterId;
  }
  async hasShardInfo(id) {
    const shardInfo = await this.getRelayShards(id);
    return !!shardInfo;
  }
  async isPeerOnTopic(id, pubsubTopic) {
    try {
      const { clusterId, shard } = pubsubTopicToSingleShardInfo(pubsubTopic);
      if (clusterId !== this.clusterId)
        return false;
      return await this.isPeerOnShard(id, shard);
    } catch (error) {
      log10.error(`Error comparing pubsub topic ${pubsubTopic} with shard info for ${id}`, error);
      return false;
    }
  }
  async isPeerOnShard(id, shard) {
    const peerShardInfo = await this.getRelayShards(id);
    log10.info(`Checking if peer on same shard: this { clusterId: ${this.clusterId}, shardId: ${shard} },${id} { clusterId: ${peerShardInfo == null ? void 0 : peerShardInfo.clusterId}, shards: ${peerShardInfo == null ? void 0 : peerShardInfo.shards} }`);
    if (!peerShardInfo) {
      return false;
    }
    return peerShardInfo.clusterId === this.clusterId && peerShardInfo.shards.includes(shard);
  }
  async getRelayShards(id) {
    try {
      const peer = await this.libp2p.peerStore.get(id);
      const shardInfoBytes = peer.metadata.get("shardInfo");
      if (!shardInfoBytes) {
        return void 0;
      }
      return decodeRelayShard(shardInfoBytes);
    } catch (error) {
      log10.error(`Error getting shard info for ${id}`, error);
      return void 0;
    }
  }
};

// node_modules/@waku/core/dist/lib/connection_manager/connection_manager.js
var log11 = new Logger("connection-manager");
var DEFAULT_MAX_BOOTSTRAP_PEERS_ALLOWED = 3;
var DEFAULT_PING_KEEP_ALIVE_SEC = 5 * 60;
var DEFAULT_RELAY_KEEP_ALIVE_SEC = 5 * 60;
var DEFAULT_ENABLE_AUTO_RECOVERY = true;
var DEFAULT_MAX_CONNECTIONS = 10;
var DEFAULT_MAX_DIALING_PEERS = 3;
var DEFAULT_FAILED_DIAL_COOLDOWN_SEC = 60;
var DEFAULT_DIAL_COOLDOWN_SEC = 10;
var ConnectionManager = class {
  constructor(options) {
    __publicField(this, "keepAliveManager");
    __publicField(this, "discoveryDialer");
    __publicField(this, "dialer");
    __publicField(this, "shardReader");
    __publicField(this, "networkMonitor");
    __publicField(this, "connectionLimiter");
    __publicField(this, "options");
    __publicField(this, "libp2p");
    this.libp2p = options.libp2p;
    this.options = {
      maxBootstrapPeers: DEFAULT_MAX_BOOTSTRAP_PEERS_ALLOWED,
      maxConnections: DEFAULT_MAX_CONNECTIONS,
      pingKeepAlive: DEFAULT_PING_KEEP_ALIVE_SEC,
      relayKeepAlive: DEFAULT_RELAY_KEEP_ALIVE_SEC,
      enableAutoRecovery: DEFAULT_ENABLE_AUTO_RECOVERY,
      maxDialingPeers: DEFAULT_MAX_DIALING_PEERS,
      failedDialCooldown: DEFAULT_FAILED_DIAL_COOLDOWN_SEC,
      dialCooldown: DEFAULT_DIAL_COOLDOWN_SEC,
      ...options.config
    };
    this.keepAliveManager = new KeepAliveManager({
      relay: options.relay,
      libp2p: options.libp2p,
      networkConfig: options.networkConfig,
      options: {
        pingKeepAlive: this.options.pingKeepAlive,
        relayKeepAlive: this.options.relayKeepAlive
      }
    });
    this.shardReader = new ShardReader({
      libp2p: options.libp2p,
      networkConfig: options.networkConfig
    });
    this.dialer = new Dialer({
      libp2p: options.libp2p,
      shardReader: this.shardReader,
      options: this.options
    });
    this.discoveryDialer = new DiscoveryDialer({
      libp2p: options.libp2p,
      dialer: this.dialer
    });
    this.networkMonitor = new NetworkMonitor({
      libp2p: options.libp2p,
      events: options.events
    });
    this.connectionLimiter = new ConnectionLimiter({
      libp2p: options.libp2p,
      events: options.events,
      networkMonitor: this.networkMonitor,
      dialer: this.dialer,
      options: this.options
    });
  }
  start() {
    this.dialer.start();
    this.networkMonitor.start();
    this.discoveryDialer.start();
    this.keepAliveManager.start();
    this.connectionLimiter.start();
  }
  stop() {
    this.dialer.stop();
    this.networkMonitor.stop();
    this.discoveryDialer.stop();
    this.keepAliveManager.stop();
    this.connectionLimiter.stop();
  }
  isConnected() {
    return this.networkMonitor.isConnected();
  }
  async dial(peer, protocolCodecs) {
    const ma = mapToPeerIdOrMultiaddr(peer);
    log11.info(`Dialing peer ${ma.toString()} with protocols ${protocolCodecs}`);
    const stream = await this.libp2p.dialProtocol(ma, protocolCodecs);
    log11.info(`Dialed peer ${ma.toString()} with protocols ${protocolCodecs}`);
    return stream;
  }
  async hangUp(peer) {
    const peerId2 = mapToPeerId(peer);
    try {
      log11.info(`Dropping connection with peer ${peerId2.toString()}`);
      await this.libp2p.hangUp(peerId2);
      log11.info(`Dropped connection with peer ${peerId2.toString()}`);
      return true;
    } catch (error) {
      log11.error(`Error dropping connection with peer ${peerId2.toString()} - ${error}`);
      return false;
    }
  }
  async getConnectedPeers(codec) {
    const peerIDs = this.libp2p.getPeers();
    log11.info(`Getting connected peers for codec ${codec}`);
    if (peerIDs.length === 0) {
      log11.info(`No connected peers`);
      return [];
    }
    const peers = await Promise.all(peerIDs.map(async (id) => {
      try {
        return await this.libp2p.peerStore.get(id);
      } catch (e2) {
        return null;
      }
    }));
    const result = peers.filter((p2) => !!p2).filter((p2) => codec ? p2.protocols.includes(codec) : true).sort((left, right) => getPeerPing(left) - getPeerPing(right));
    log11.info(`Found ${result.length} connected peers for codec ${codec}`);
    return result;
  }
  async hasShardInfo(peerId2) {
    return this.shardReader.hasShardInfo(peerId2);
  }
  async isPeerOnTopic(peerId2, pubsubTopic) {
    return this.shardReader.isPeerOnTopic(peerId2, pubsubTopic);
  }
  async isPeerOnShard(peerId2, shardId) {
    return this.shardReader.isPeerOnShard(peerId2, shardId);
  }
};

// node_modules/@waku/core/dist/lib/metadata/metadata.js
var log12 = new Logger("metadata");
var MetadataCodec = "/vac/waku/metadata/1.0.0";
var Metadata = class {
  constructor(clusterId, libp2p) {
    __publicField(this, "clusterId");
    __publicField(this, "streamManager");
    __publicField(this, "libp2pComponents");
    __publicField(this, "handshakesConfirmed", /* @__PURE__ */ new Map());
    __publicField(this, "multicodec", MetadataCodec);
    this.clusterId = clusterId;
    this.streamManager = new StreamManager(MetadataCodec, libp2p);
    this.libp2pComponents = libp2p;
    void libp2p.registrar.handle(MetadataCodec, (streamData) => {
      void this.onRequest(streamData);
    });
  }
  /**
   * Make a metadata query to a peer
   */
  async query(peerId2) {
    const request2 = metadata_exports.WakuMetadataRequest.encode({
      clusterId: this.clusterId,
      shards: []
      // Only services node need to provide shards
    });
    const peer = await this.libp2pComponents.peerStore.get(peerId2);
    if (!peer) {
      return {
        shardInfo: null,
        error: ProtocolError2.NO_PEER_AVAILABLE
      };
    }
    const stream = await this.streamManager.getStream(peerId2);
    if (!stream) {
      log12.error(`Failed to get a stream for remote peer:${peerId2.toString()}`);
      return {
        shardInfo: null,
        error: ProtocolError2.NO_STREAM_AVAILABLE
      };
    }
    const encodedResponse = await pipe([request2], encode6, stream, decode7, async (source) => await src_default(source));
    const { error, shardInfo } = this.decodeMetadataResponse(encodedResponse);
    if (error) {
      return {
        shardInfo: null,
        error
      };
    }
    await this.savePeerShardInfo(peerId2, shardInfo);
    return {
      shardInfo,
      error: null
    };
  }
  async confirmOrAttemptHandshake(peerId2) {
    const shardInfo = this.handshakesConfirmed.get(peerId2.toString());
    if (shardInfo) {
      return {
        shardInfo,
        error: null
      };
    }
    return await this.query(peerId2);
  }
  /**
   * Handle an incoming metadata request
   */
  async onRequest(streamData) {
    try {
      const { stream, connection } = streamData;
      const encodedShardInfo = metadata_exports.WakuMetadataResponse.encode({
        clusterId: this.clusterId,
        shards: []
        // Only service nodes need to provide shards
      });
      const encodedResponse = await pipe([encodedShardInfo], encode6, stream, decode7, async (source) => await src_default(source));
      const { error, shardInfo } = this.decodeMetadataResponse(encodedResponse);
      if (error) {
        return;
      }
      await this.savePeerShardInfo(connection.remotePeer, shardInfo);
    } catch (error) {
      log12.error("Error handling metadata request", error);
    }
  }
  decodeMetadataResponse(encodedResponse) {
    const bytes = new Uint8ArrayList();
    encodedResponse.forEach((chunk) => {
      bytes.append(chunk);
    });
    const response = metadata_exports.WakuMetadataResponse.decode(bytes);
    if (!response) {
      log12.error("Error decoding metadata response");
      return {
        shardInfo: null,
        error: ProtocolError2.DECODE_FAILED
      };
    }
    return {
      shardInfo: response,
      error: null
    };
  }
  async savePeerShardInfo(peerId2, shardInfo) {
    await this.libp2pComponents.peerStore.merge(peerId2, {
      metadata: {
        shardInfo: encodeRelayShard(shardInfo)
      }
    });
    this.handshakesConfirmed.set(peerId2.toString(), shardInfo);
  }
};
function wakuMetadata(clusterId) {
  return (components) => new Metadata(clusterId, components);
}

// node_modules/@waku/sdk/dist/peer_manager/peer_manager.js
var log13 = new Logger("peer-manager");
var DEFAULT_NUM_PEERS_TO_USE = 2;
var PeerManagerEventNames;
(function(PeerManagerEventNames2) {
  PeerManagerEventNames2["FilterConnect"] = "filter:connect";
  PeerManagerEventNames2["FilterDisconnect"] = "filter:disconnect";
  PeerManagerEventNames2["StoreConnect"] = "store:connect";
})(PeerManagerEventNames || (PeerManagerEventNames = {}));
var PeerManager = class {
  constructor(params) {
    __publicField(this, "events", new TypedEventEmitter());
    __publicField(this, "numPeersToUse");
    __publicField(this, "libp2p");
    __publicField(this, "connectionManager");
    __publicField(this, "lockedPeers", /* @__PURE__ */ new Set());
    __publicField(this, "unlockedPeers", /* @__PURE__ */ new Map());
    var _a27;
    this.onConnected = this.onConnected.bind(this);
    this.onDisconnected = this.onDisconnected.bind(this);
    this.numPeersToUse = ((_a27 = params == null ? void 0 : params.config) == null ? void 0 : _a27.numPeersToUse) || DEFAULT_NUM_PEERS_TO_USE;
    this.libp2p = params.libp2p;
    this.connectionManager = params.connectionManager;
  }
  start() {
    this.libp2p.addEventListener("peer:identify", this.onConnected);
    this.libp2p.addEventListener("peer:disconnect", this.onDisconnected);
  }
  stop() {
    this.libp2p.removeEventListener("peer:identify", this.onConnected);
    this.libp2p.removeEventListener("peer:disconnect", this.onDisconnected);
  }
  async getPeers(params) {
    log13.info(`Getting peers for protocol: ${params.protocol}, pubsubTopic: ${params.pubsubTopic}`);
    const connectedPeers = await this.connectionManager.getConnectedPeers();
    log13.info(`Found ${connectedPeers.length} connected peers`);
    let results = [];
    for (const peer of connectedPeers) {
      const hasProtocol = this.hasPeerProtocol(peer, params.protocol);
      const hasSamePubsub = await this.isPeerOnPubsub(peer.id, params.pubsubTopic);
      const isPeerAvailableForUse = this.isPeerAvailableForUse(peer.id);
      if (hasProtocol && hasSamePubsub && isPeerAvailableForUse) {
        results.push(peer);
        log13.info(`Peer ${peer.id} qualifies for protocol ${params.protocol}`);
      }
    }
    const lockedPeers = results.filter((p2) => this.isPeerLocked(p2.id));
    log13.info(`Found ${lockedPeers.length} locked peers out of ${results.length} qualifying peers`);
    if (lockedPeers.length >= this.numPeersToUse) {
      const selectedPeers = lockedPeers.slice(0, this.numPeersToUse).map((p2) => p2.id);
      log13.info(`Using ${selectedPeers.length} locked peers: ${selectedPeers.map((p2) => p2.toString())}`);
      return selectedPeers;
    }
    const notLockedPeers = results.filter((p2) => !this.isPeerLocked(p2.id));
    log13.info(`Found ${notLockedPeers.length} unlocked peers, need ${this.numPeersToUse - lockedPeers.length} more`);
    results = [...lockedPeers, ...notLockedPeers].slice(0, this.numPeersToUse).map((p2) => {
      this.lockPeer(p2.id);
      return p2;
    });
    const finalPeers = results.map((p2) => p2.id);
    log13.info(`Selected ${finalPeers.length} peers: ${finalPeers.map((p2) => p2.toString())}`);
    return finalPeers;
  }
  async renewPeer(id, params) {
    log13.info(`Renewing peer ${id} for protocol: ${params.protocol}, pubsubTopic: ${params.pubsubTopic}`);
    const connectedPeers = await this.connectionManager.getConnectedPeers();
    const renewedPeer = connectedPeers.find((p2) => p2.id.equals(id));
    if (!renewedPeer) {
      log13.warn(`Cannot renew peer:${id}, no connection to the peer.`);
      return;
    }
    log13.info(`Found peer ${id} in connected peers, unlocking and getting new peers`);
    this.unlockPeer(renewedPeer.id);
    await this.getPeers(params);
  }
  async isPeerOnPubsub(id, pubsubTopic) {
    const hasShardInfo = await this.connectionManager.hasShardInfo(id);
    if (!hasShardInfo) {
      return true;
    }
    return this.connectionManager.isPeerOnTopic(id, pubsubTopic);
  }
  async onConnected(event) {
    const result = event.detail;
    const isFilterPeer = result.protocols.includes(this.getProtocolCodecs(Protocols.Filter));
    const isStorePeer = result.protocols.includes(this.getProtocolCodecs(Protocols.Store));
    if (isFilterPeer) {
      this.dispatchFilterPeerConnect(result.peerId);
    }
    if (isStorePeer) {
      this.dispatchStorePeerConnect(result.peerId);
    }
  }
  async onDisconnected(event) {
    const peerId2 = event.detail;
    try {
      const peer = await this.libp2p.peerStore.get(peerId2);
      const isFilterPeer = this.hasPeerProtocol(peer, Protocols.Filter);
      if (isFilterPeer) {
        this.dispatchFilterPeerDisconnect(peer.id);
      }
    } catch (error) {
      log13.error(`Failed to dispatch Filter disconnect event:${error}`);
    }
  }
  hasPeerProtocol(peer, protocol) {
    return peer.protocols.includes(this.getProtocolCodecs(protocol));
  }
  lockPeer(id) {
    log13.info(`Locking peer ${id}`);
    this.lockedPeers.add(id.toString());
    this.libp2p.getConnections().filter((c2) => c2.remotePeer.equals(id)).forEach((c2) => c2.tags.push(CONNECTION_LOCKED_TAG));
    this.unlockedPeers.delete(id.toString());
  }
  isPeerLocked(id) {
    return this.lockedPeers.has(id.toString());
  }
  unlockPeer(id) {
    log13.info(`Unlocking peer ${id}`);
    this.lockedPeers.delete(id.toString());
    this.libp2p.getConnections().filter((c2) => c2.remotePeer.equals(id)).forEach((c2) => {
      c2.tags = c2.tags.filter((t2) => t2 !== CONNECTION_LOCKED_TAG);
    });
    this.unlockedPeers.set(id.toString(), Date.now());
  }
  isPeerAvailableForUse(id) {
    const value = this.unlockedPeers.get(id.toString());
    if (!value) {
      return true;
    }
    const wasUnlocked = new Date(value).getTime();
    return Date.now() - wasUnlocked >= 1e4;
  }
  dispatchFilterPeerConnect(id) {
    this.events.dispatchEvent(new CustomEvent(PeerManagerEventNames.FilterConnect, { detail: id }));
  }
  dispatchStorePeerConnect(id) {
    this.events.dispatchEvent(new CustomEvent(PeerManagerEventNames.StoreConnect, { detail: id }));
  }
  dispatchFilterPeerDisconnect(id) {
    this.events.dispatchEvent(new CustomEvent(PeerManagerEventNames.FilterDisconnect, { detail: id }));
  }
  getProtocolCodecs(protocol) {
    if (protocol === Protocols.Relay) {
      throw new Error("Relay protocol is not supported");
    }
    const protocolToCodecs = {
      [Protocols.Filter]: FilterCodecs.SUBSCRIBE,
      [Protocols.LightPush]: LightPushCodec,
      [Protocols.Store]: StoreCodec,
      "light-push-v2": LightPushCodecV2
    };
    return protocolToCodecs[protocol];
  }
};

// node_modules/@waku/sdk/dist/filter/utils.js
var TTLSet = class {
  /**
   * Creates a new CustomSet with TTL functionality.
   * @param ttlMs - The time-to-live in milliseconds for each entry.
   * @param cleanupIntervalMs - Optional interval between cleanup operations (default: 5000ms).
   */
  constructor(ttlMs, cleanupIntervalMs = 5e3) {
    __publicField(this, "ttlMs");
    __publicField(this, "cleanupIntervalId", null);
    __publicField(this, "entryTimestamps", /* @__PURE__ */ new Map());
    this.ttlMs = ttlMs;
    this.startCleanupInterval(cleanupIntervalMs);
  }
  dispose() {
    if (this.cleanupIntervalId !== null) {
      clearInterval(this.cleanupIntervalId);
      this.cleanupIntervalId = null;
    }
    this.entryTimestamps.clear();
  }
  add(entry) {
    this.entryTimestamps.set(entry, Date.now());
    return this;
  }
  has(entry) {
    return this.entryTimestamps.has(entry);
  }
  startCleanupInterval(intervalMs) {
    this.cleanupIntervalId = setInterval(() => {
      this.removeExpiredEntries();
    }, intervalMs);
  }
  removeExpiredEntries() {
    const now = Date.now();
    for (const [entry, timestamp] of this.entryTimestamps.entries()) {
      if (now - timestamp > this.ttlMs) {
        this.entryTimestamps.delete(entry);
      }
    }
  }
};

// node_modules/@waku/sdk/dist/filter/subscription.js
var log14 = new Logger("sdk:filter-subscription");
var Subscription = class {
  constructor(params) {
    __publicField(this, "pubsubTopic");
    __publicField(this, "protocol");
    __publicField(this, "peerManager");
    __publicField(this, "config");
    __publicField(this, "isStarted", false);
    __publicField(this, "inProgress", false);
    // Map and Set cannot reliably use PeerId type as a key
    __publicField(this, "peers", /* @__PURE__ */ new Map());
    __publicField(this, "peerFailures", /* @__PURE__ */ new Map());
    __publicField(this, "receivedMessages", new TTLSet(6e4));
    __publicField(this, "callbacks", /* @__PURE__ */ new Map());
    __publicField(this, "messageEmitter", new TypedEventEmitter());
    __publicField(this, "toSubscribeContentTopics", /* @__PURE__ */ new Set());
    __publicField(this, "toUnsubscribeContentTopics", /* @__PURE__ */ new Set());
    __publicField(this, "subscribeIntervalId", null);
    __publicField(this, "keepAliveIntervalId", null);
    this.config = params.config;
    this.pubsubTopic = params.pubsubTopic;
    this.protocol = params.protocol;
    this.peerManager = params.peerManager;
    this.onPeerConnected = this.onPeerConnected.bind(this);
    this.onPeerDisconnected = this.onPeerDisconnected.bind(this);
  }
  get contentTopics() {
    const allTopics = Array.from(this.callbacks.keys()).map((k) => k.contentTopic);
    const uniqueTopics = new Set(allTopics).values();
    return Array.from(uniqueTopics);
  }
  start() {
    log14.info(`Starting subscription for pubsubTopic: ${this.pubsubTopic}`);
    if (this.isStarted || this.inProgress) {
      log14.info("Subscription already started or in progress, skipping start");
      return;
    }
    this.inProgress = true;
    void this.attemptSubscribe({
      useNewContentTopics: false
    });
    this.setupSubscriptionInterval();
    this.setupKeepAliveInterval();
    this.setupEventListeners();
    this.isStarted = true;
    this.inProgress = false;
    log14.info(`Subscription started for pubsubTopic: ${this.pubsubTopic}`);
  }
  stop() {
    log14.info(`Stopping subscription for pubsubTopic: ${this.pubsubTopic}`);
    if (!this.isStarted || this.inProgress) {
      log14.info("Subscription not started or stop in progress, skipping stop");
      return;
    }
    this.inProgress = true;
    this.disposeEventListeners();
    this.disposeIntervals();
    void this.disposePeers();
    this.disposeHandlers();
    this.receivedMessages.dispose();
    this.inProgress = false;
    this.isStarted = false;
    log14.info(`Subscription stopped for pubsubTopic: ${this.pubsubTopic}`);
  }
  isEmpty() {
    return this.callbacks.size === 0;
  }
  async add(decoder, callback) {
    const decoders4 = Array.isArray(decoder) ? decoder : [decoder];
    for (const decoder2 of decoders4) {
      this.addSingle(decoder2, callback);
    }
    return this.toSubscribeContentTopics.size > 0 ? await this.attemptSubscribe({ useNewContentTopics: true }) : true;
  }
  async remove(decoder) {
    const decoders4 = Array.isArray(decoder) ? decoder : [decoder];
    for (const decoder2 of decoders4) {
      this.removeSingle(decoder2);
    }
    return this.toUnsubscribeContentTopics.size > 0 ? await this.attemptUnsubscribe({ useNewContentTopics: true }) : true;
  }
  invoke(message2, _peerId) {
    if (this.isMessageReceived(message2)) {
      log14.info(`Skipping invoking callbacks for already received message: pubsubTopic:${this.pubsubTopic}, peerId:${_peerId.toString()}, contentTopic:${message2.contentTopic}`);
      return;
    }
    log14.info(`Invoking message for contentTopic: ${message2.contentTopic}`);
    this.messageEmitter.dispatchEvent(new CustomEvent(message2.contentTopic, {
      detail: message2
    }));
  }
  addSingle(decoder, callback) {
    log14.info(`Adding subscription for contentTopic: ${decoder.contentTopic}`);
    const isNewContentTopic = !this.contentTopics.includes(decoder.contentTopic);
    if (isNewContentTopic) {
      this.toSubscribeContentTopics.add(decoder.contentTopic);
    }
    if (this.callbacks.has(decoder)) {
      log14.warn(`Replacing callback associated associated with decoder with pubsubTopic:${decoder.pubsubTopic} and contentTopic:${decoder.contentTopic}`);
      const callback2 = this.callbacks.get(decoder);
      this.callbacks.delete(decoder);
      this.messageEmitter.removeEventListener(decoder.contentTopic, callback2);
    }
    const eventHandler = (event) => {
      void (async () => {
        try {
          const message2 = await decoder.fromProtoObj(decoder.pubsubTopic, event.detail);
          void callback(message2);
        } catch (err) {
          log14.error("Error decoding message", err);
        }
      })();
    };
    this.callbacks.set(decoder, eventHandler);
    this.messageEmitter.addEventListener(decoder.contentTopic, eventHandler);
    log14.info(`Subscription added for contentTopic: ${decoder.contentTopic}, isNewContentTopic: ${isNewContentTopic}`);
  }
  removeSingle(decoder) {
    log14.info(`Removing subscription for contentTopic: ${decoder.contentTopic}`);
    const callback = this.callbacks.get(decoder);
    if (!callback) {
      log14.warn(`No callback associated with decoder with pubsubTopic:${decoder.pubsubTopic} and contentTopic:${decoder.contentTopic}`);
    }
    this.callbacks.delete(decoder);
    this.messageEmitter.removeEventListener(decoder.contentTopic, callback);
    const isCompletelyRemoved = !this.contentTopics.includes(decoder.contentTopic);
    if (isCompletelyRemoved) {
      this.toUnsubscribeContentTopics.add(decoder.contentTopic);
    }
    log14.info(`Subscription removed for contentTopic: ${decoder.contentTopic}, isCompletelyRemoved: ${isCompletelyRemoved}`);
  }
  isMessageReceived(message2) {
    try {
      const messageHash2 = messageHashStr(this.pubsubTopic, message2);
      if (this.receivedMessages.has(messageHash2)) {
        return true;
      }
      this.receivedMessages.add(messageHash2);
    } catch (e2) {
    }
    return false;
  }
  setupSubscriptionInterval() {
    const subscriptionRefreshIntervalMs = 1e3;
    log14.info(`Setting up subscription interval with period ${subscriptionRefreshIntervalMs}ms`);
    this.subscribeIntervalId = setInterval(() => {
      const run = async () => {
        if (this.toSubscribeContentTopics.size > 0) {
          log14.info(`Subscription interval: ${this.toSubscribeContentTopics.size} topics to subscribe`);
          void await this.attemptSubscribe({ useNewContentTopics: true });
        }
        if (this.toUnsubscribeContentTopics.size > 0) {
          log14.info(`Subscription interval: ${this.toUnsubscribeContentTopics.size} topics to unsubscribe`);
          void await this.attemptUnsubscribe({ useNewContentTopics: true });
        }
      };
      void run();
    }, subscriptionRefreshIntervalMs);
  }
  setupKeepAliveInterval() {
    log14.info(`Setting up keep-alive interval with period ${this.config.keepAliveIntervalMs}ms`);
    this.keepAliveIntervalId = setInterval(() => {
      const run = async () => {
        log14.info(`Keep-alive interval running for ${this.peers.size} peers`);
        let peersToReplace = await Promise.all(Array.from(this.peers.values()).map(async (peer) => {
          const response = await this.protocol.ping(peer);
          if (response.success) {
            log14.info(`Ping successful for peer: ${peer.toString()}`);
            this.peerFailures.set(peer.toString(), 0);
            return;
          }
          let failures = this.peerFailures.get(peer.toString()) || 0;
          failures += 1;
          this.peerFailures.set(peer.toString(), failures);
          log14.warn(`Ping failed for peer: ${peer.toString()}, failures: ${failures}/${this.config.pingsBeforePeerRenewed}`);
          if (failures < this.config.pingsBeforePeerRenewed) {
            return;
          }
          log14.info(`Peer ${peer.toString()} exceeded max failures (${this.config.pingsBeforePeerRenewed}), will be replaced`);
          return peer;
        }));
        peersToReplace = peersToReplace.filter((p2) => !!p2);
        await Promise.all(peersToReplace.map((p2) => {
          this.peers.delete(p2 == null ? void 0 : p2.toString());
          this.peerFailures.delete(p2 == null ? void 0 : p2.toString());
          return this.requestUnsubscribe(p2, this.contentTopics);
        }));
        if (peersToReplace.length > 0) {
          log14.info(`Replacing ${peersToReplace.length} failed peers`);
          void await this.attemptSubscribe({
            useNewContentTopics: false,
            useOnlyNewPeers: true
          });
        }
      };
      void run();
    }, this.config.keepAliveIntervalMs);
  }
  setupEventListeners() {
    this.peerManager.events.addEventListener(PeerManagerEventNames.FilterConnect, this.onPeerConnected);
    this.peerManager.events.addEventListener(PeerManagerEventNames.FilterDisconnect, this.onPeerDisconnected);
  }
  disposeIntervals() {
    if (this.subscribeIntervalId) {
      clearInterval(this.subscribeIntervalId);
    }
    if (this.keepAliveIntervalId) {
      clearInterval(this.keepAliveIntervalId);
    }
  }
  disposeHandlers() {
    for (const [decoder, handler] of this.callbacks.entries()) {
      this.messageEmitter.removeEventListener(decoder.contentTopic, handler);
    }
    this.callbacks.clear();
  }
  async disposePeers() {
    await this.attemptUnsubscribe({ useNewContentTopics: false });
    this.peers.clear();
    this.peerFailures = /* @__PURE__ */ new Map();
  }
  disposeEventListeners() {
    this.peerManager.events.removeEventListener(PeerManagerEventNames.FilterConnect, this.onPeerConnected);
    this.peerManager.events.removeEventListener(PeerManagerEventNames.FilterDisconnect, this.onPeerDisconnected);
  }
  async onPeerConnected(event) {
    var _a27;
    const id = (_a27 = event.detail) == null ? void 0 : _a27.toString();
    log14.info(`Peer connected: ${id}`);
    const usablePeer = await this.peerManager.isPeerOnPubsub(event.detail, this.pubsubTopic);
    if (!usablePeer) {
      log14.info(`Peer ${id} doesn't support pubsubTopic:${this.pubsubTopic}`);
      return;
    }
    if (this.peers.has(id)) {
      log14.info(`Peer ${id} already subscribed, skipping`);
      return;
    }
    await this.attemptSubscribe({
      useNewContentTopics: false,
      useOnlyNewPeers: true
    });
  }
  async onPeerDisconnected(event) {
    var _a27;
    const id = (_a27 = event.detail) == null ? void 0 : _a27.toString();
    log14.info(`Peer disconnected: ${id}`);
    const usablePeer = await this.peerManager.isPeerOnPubsub(event.detail, this.pubsubTopic);
    if (!usablePeer) {
      log14.info(`Peer ${id} doesn't support pubsubTopic:${this.pubsubTopic}`);
      return;
    }
    if (!this.peers.has(id)) {
      log14.info(`Disconnected peer ${id} not in use, ignoring`);
      return;
    }
    log14.info(`Active peer ${id} disconnected, removing from peers list`);
    this.peers.delete(id);
    void this.attemptSubscribe({
      useNewContentTopics: false,
      useOnlyNewPeers: true
    });
  }
  async attemptSubscribe(params) {
    const { useNewContentTopics, useOnlyNewPeers = false } = params;
    const contentTopics = useNewContentTopics ? Array.from(this.toSubscribeContentTopics) : this.contentTopics;
    log14.info(`Attempting to subscribe: useNewContentTopics=${useNewContentTopics}, useOnlyNewPeers=${useOnlyNewPeers}, contentTopics=${contentTopics.length}`);
    if (!contentTopics.length) {
      log14.warn("Requested content topics is an empty array, skipping");
      return false;
    }
    const prevPeers = new Set(this.peers.keys());
    const peersToAdd = await this.peerManager.getPeers({
      protocol: Protocols.Filter,
      pubsubTopic: this.pubsubTopic
    });
    for (const peer of peersToAdd) {
      if (this.peers.size >= this.config.numPeersToUse) {
        break;
      }
      this.peers.set(peer.toString(), peer);
    }
    const peersToUse = useOnlyNewPeers ? Array.from(this.peers.values()).filter((p2) => !prevPeers.has(p2.toString())) : Array.from(this.peers.values());
    log14.info(`Subscribing with ${peersToUse.length} peers for ${contentTopics.length} content topics`);
    if (useOnlyNewPeers && peersToUse.length === 0) {
      log14.warn(`Requested to use only new peers, but no peers found, skipping`);
      return false;
    }
    const results = await Promise.all(peersToUse.map((p2) => this.requestSubscribe(p2, contentTopics)));
    const successCount = results.filter((r2) => r2).length;
    log14.info(`Subscribe attempts completed: ${successCount}/${results.length} successful`);
    if (useNewContentTopics) {
      this.toSubscribeContentTopics = /* @__PURE__ */ new Set();
    }
    return results.some((v) => v);
  }
  async requestSubscribe(peerId2, contentTopics) {
    log14.info(`requestSubscribe: pubsubTopic:${this.pubsubTopic}	contentTopics:${contentTopics.join(",")}`);
    if (!contentTopics.length || !this.pubsubTopic) {
      log14.warn(`requestSubscribe: no contentTopics or pubsubTopic provided, not sending subscribe request`);
      return false;
    }
    const response = await this.protocol.subscribe(this.pubsubTopic, peerId2, contentTopics);
    if (response.failure) {
      log14.warn(`requestSubscribe: Failed to subscribe ${this.pubsubTopic} to ${peerId2.toString()} with error:${response.failure.error} for contentTopics:${contentTopics}`);
      return false;
    }
    log14.info(`requestSubscribe: Subscribed ${this.pubsubTopic} to ${peerId2.toString()} for contentTopics:${contentTopics}`);
    return true;
  }
  async attemptUnsubscribe(params) {
    const { useNewContentTopics } = params;
    const contentTopics = useNewContentTopics ? Array.from(this.toUnsubscribeContentTopics) : this.contentTopics;
    log14.info(`Attempting to unsubscribe: useNewContentTopics=${useNewContentTopics}, contentTopics=${contentTopics.length}`);
    if (!contentTopics.length) {
      log14.warn("Requested content topics is an empty array, skipping");
      return false;
    }
    const peersToUse = Array.from(this.peers.values());
    const result = await Promise.all(peersToUse.map((p2) => this.requestUnsubscribe(p2, useNewContentTopics ? contentTopics : void 0)));
    const successCount = result.filter((r2) => r2).length;
    log14.info(`Unsubscribe attempts completed: ${successCount}/${result.length} successful`);
    if (useNewContentTopics) {
      this.toUnsubscribeContentTopics = /* @__PURE__ */ new Set();
    }
    return result.some((v) => v);
  }
  async requestUnsubscribe(peerId2, contentTopics) {
    var _a27;
    const response = contentTopics ? await this.protocol.unsubscribe(this.pubsubTopic, peerId2, contentTopics) : await this.protocol.unsubscribeAll(this.pubsubTopic, peerId2);
    if (response.failure) {
      log14.warn(`requestUnsubscribe: Failed to unsubscribe for pubsubTopic:${this.pubsubTopic} from peerId:${peerId2.toString()} with error:${(_a27 = response.failure) == null ? void 0 : _a27.error} for contentTopics:${contentTopics}`);
      return false;
    }
    log14.info(`requestUnsubscribe: Unsubscribed pubsubTopic:${this.pubsubTopic} from peerId:${peerId2.toString()} for contentTopics:${contentTopics}`);
    return true;
  }
};

// node_modules/@waku/sdk/dist/filter/filter.js
var log15 = new Logger("sdk:filter");
var Filter = class {
  constructor(params) {
    __publicField(this, "protocol");
    __publicField(this, "peerManager");
    __publicField(this, "config");
    __publicField(this, "subscriptions", /* @__PURE__ */ new Map());
    this.config = {
      numPeersToUse: 2,
      pingsBeforePeerRenewed: 3,
      keepAliveIntervalMs: 6e4,
      ...params.options
    };
    this.peerManager = params.peerManager;
    this.protocol = new FilterCore(this.onIncomingMessage.bind(this), params.libp2p);
  }
  get multicodec() {
    return this.protocol.multicodec;
  }
  async start() {
    await this.protocol.start();
  }
  async stop() {
    await this.protocol.stop();
  }
  unsubscribeAll() {
    for (const subscription of this.subscriptions.values()) {
      subscription.stop();
    }
    this.subscriptions.clear();
  }
  async subscribe(decoder, callback) {
    const decoders4 = Array.isArray(decoder) ? decoder : [decoder];
    if (decoders4.length === 0) {
      throw Error("Cannot subscribe with 0 decoders.");
    }
    const pubsubTopics = decoders4.map((v) => v.pubsubTopic);
    const singlePubsubTopic = pubsubTopics[0];
    const contentTopics = decoders4.map((v) => v.contentTopic);
    log15.info(`Subscribing to contentTopics: ${contentTopics}, pubsubTopic: ${singlePubsubTopic}`);
    this.throwIfTopicNotSame(pubsubTopics);
    let subscription = this.subscriptions.get(singlePubsubTopic);
    if (!subscription) {
      subscription = new Subscription({
        pubsubTopic: singlePubsubTopic,
        protocol: this.protocol,
        config: this.config,
        peerManager: this.peerManager
      });
      subscription.start();
    }
    const result = await subscription.add(decoders4, callback);
    this.subscriptions.set(singlePubsubTopic, subscription);
    log15.info(`Subscription ${result ? "successful" : "failed"} for content topic: ${contentTopics}`);
    return result;
  }
  async unsubscribe(decoder) {
    const decoders4 = Array.isArray(decoder) ? decoder : [decoder];
    if (decoders4.length === 0) {
      throw Error("Cannot unsubscribe with 0 decoders.");
    }
    const pubsubTopics = decoders4.map((v) => v.pubsubTopic);
    const singlePubsubTopic = pubsubTopics[0];
    const contentTopics = decoders4.map((v) => v.contentTopic);
    log15.info(`Unsubscribing from contentTopics: ${contentTopics}, pubsubTopic: ${singlePubsubTopic}`);
    this.throwIfTopicNotSame(pubsubTopics);
    const subscription = this.subscriptions.get(singlePubsubTopic);
    if (!subscription) {
      log15.warn("No subscriptions associated with the decoder.");
      return false;
    }
    const result = await subscription.remove(decoders4);
    if (subscription.isEmpty()) {
      log15.warn("Subscription has no decoders anymore, terminating it.");
      subscription.stop();
      this.subscriptions.delete(singlePubsubTopic);
    }
    log15.info(`Unsubscribing ${result ? "successful" : "failed"} for content topic: ${contentTopics}`);
    return result;
  }
  async onIncomingMessage(pubsubTopic, message2, peerId2) {
    log15.info(`Received message for pubsubTopic:${pubsubTopic}, contentTopic:${message2.contentTopic}, peerId:${peerId2.toString()}`);
    const subscription = this.subscriptions.get(pubsubTopic);
    if (!subscription) {
      log15.error(`No subscription locally registered for topic ${pubsubTopic}`);
      return;
    }
    subscription.invoke(message2, peerId2);
  }
  // Limiting to one pubsubTopic for simplicity reasons, we can enable subscription for more than one PubsubTopic at once later when requested
  throwIfTopicNotSame(pubsubTopics) {
    const first = pubsubTopics[0];
    const isSameTopic = pubsubTopics.every((t2) => t2 === first);
    if (!isSameTopic) {
      throw Error(`Cannot subscribe to more than one pubsub topic at the same time, got pubsubTopics:${pubsubTopics}`);
    }
  }
};

// node_modules/@waku/sdk/dist/health_indicator/health_indicator.js
var import_lodash = __toESM(require_lodash(), 1);
var log16 = new Logger("health-indicator");
var HealthIndicator = class {
  constructor(params) {
    __publicField(this, "isStarted", false);
    __publicField(this, "libp2p");
    __publicField(this, "events");
    __publicField(this, "value", HealthStatus.Unhealthy);
    __publicField(this, "debouncedAssessHealth");
    this.libp2p = params.libp2p;
    this.events = params.events;
    this.onPeerIdentify = this.onPeerIdentify.bind(this);
    this.onPeerDisconnected = this.onPeerDisconnected.bind(this);
    this.debouncedAssessHealth = (0, import_lodash.default)(() => {
      void this.assessHealth();
    }, 100);
  }
  start() {
    if (this.isStarted) {
      return;
    }
    this.isStarted = true;
    log16.info("start: adding listeners to libp2p");
    this.libp2p.addEventListener("peer:identify", this.onPeerIdentify);
    this.libp2p.addEventListener("peer:disconnect", this.onPeerDisconnected);
    this.debouncedAssessHealth();
  }
  stop() {
    if (!this.isStarted) {
      return;
    }
    this.isStarted = false;
    log16.info("stop: removing listeners to libp2p");
    this.libp2p.removeEventListener("peer:identify", this.onPeerIdentify);
    this.libp2p.removeEventListener("peer:disconnect", this.onPeerDisconnected);
    this.debouncedAssessHealth.cancel();
  }
  toValue() {
    return this.value;
  }
  onPeerDisconnected(_event) {
    log16.info(`onPeerDisconnected: received libp2p event`);
    this.debouncedAssessHealth();
  }
  onPeerIdentify(_event) {
    log16.info(`onPeerIdentify: received libp2p event`);
    this.debouncedAssessHealth();
  }
  async assessHealth() {
    const connections = this.libp2p.getConnections();
    if (connections.length === 0) {
      log16.info("assessHealth: no connections, setting to Unhealthy");
      this.updateAndDispatchHealthEvent(HealthStatus.Unhealthy);
      return;
    }
    const peers = await Promise.all(connections.map(async (c2) => {
      try {
        return await this.libp2p.peerStore.get(c2.remotePeer);
      } catch (e2) {
        log16.warn(`assessHealth: failed to get peer ${c2.remotePeer}, skipping`);
        return null;
      }
    }));
    const filterPeers = peers.filter((p2) => p2 == null ? void 0 : p2.protocols.includes(FilterCodecs.SUBSCRIBE)).length;
    const lightPushPeers = peers.filter((p2) => p2 == null ? void 0 : p2.protocols.includes(LightPushCodec)).length;
    let newValue;
    if (filterPeers === 0 || lightPushPeers === 0) {
      newValue = HealthStatus.Unhealthy;
    } else if (filterPeers >= 2 && lightPushPeers >= 2) {
      newValue = HealthStatus.SufficientlyHealthy;
    } else if (filterPeers === 1 && lightPushPeers === 1) {
      newValue = HealthStatus.MinimallyHealthy;
    } else {
      log16.error(`assessHealth: unexpected state, cannot identify health status of the node: Filter:${filterPeers}; LightPush:${lightPushPeers}`);
      newValue = this.value;
    }
    log16.info(`assessHealth: node identified as ${newValue} Filter:${filterPeers}; LightPush:${lightPushPeers}`);
    this.updateAndDispatchHealthEvent(newValue);
  }
  updateAndDispatchHealthEvent(newValue) {
    if (this.value !== newValue) {
      this.value = newValue;
      this.events.dispatchEvent(new CustomEvent(WakuEvent.Health, {
        detail: this.value
      }));
    }
  }
};

// node_modules/@waku/sdk/dist/light_push/utils.js
var shouldPeerBeChanged = (failure) => {
  const toBeChanged = failure === LightPushError.REMOTE_PEER_REJECTED || failure === LightPushError.NO_RESPONSE || failure === LightPushError.RLN_PROOF_GENERATION || failure === LightPushError.NO_PEER_AVAILABLE;
  if (toBeChanged) {
    return true;
  }
  return false;
};
var timeout = (timeout2) => {
  return new Promise((_2, reject) => setTimeout(() => reject(new Error("Task timeout")), timeout2));
};

// node_modules/@waku/sdk/dist/light_push/retry_manager.js
var MAX_CONCURRENT_TASKS = 5;
var TASK_TIMEOUT_MS = 1e4;
var log17 = new Logger("sdk:retry-manager");
var RetryManager = class {
  constructor(config) {
    __publicField(this, "intervalID", null);
    __publicField(this, "retryIntervalMs");
    __publicField(this, "inProgress", 0);
    __publicField(this, "queue", []);
    __publicField(this, "peerManager");
    this.peerManager = config.peerManager;
    this.retryIntervalMs = config.retryIntervalMs || 1e3;
  }
  start() {
    this.intervalID = setInterval(() => {
      this.processQueue();
    }, this.retryIntervalMs);
  }
  stop() {
    if (this.intervalID) {
      clearInterval(this.intervalID);
      this.intervalID = null;
    }
  }
  push(callback, maxAttempts, routingInfo) {
    this.queue.push({
      maxAttempts,
      callback,
      routingInfo
    });
  }
  processQueue() {
    if (this.queue.length === 0) {
      return;
    }
    while (this.queue.length && this.inProgress < MAX_CONCURRENT_TASKS) {
      const task = this.queue.shift();
      if (task) {
        this.scheduleTask(task);
      }
    }
  }
  scheduleTask(task) {
    const delayedTask = async () => {
      return this.taskExecutor(task);
    };
    setTimeout(delayedTask, 100);
  }
  async taskExecutor(task) {
    if (task.maxAttempts <= 0) {
      log17.warn("scheduleTask: max attempts has reached, removing from queue");
      return;
    }
    const peerId2 = (await this.peerManager.getPeers({
      protocol: Protocols.LightPush,
      pubsubTopic: task.routingInfo.pubsubTopic
    }))[0];
    if (!peerId2) {
      log17.warn("scheduleTask: no peers, putting back to queue");
      this.queue.push({
        ...task,
        maxAttempts: task.maxAttempts - 1
      });
      return;
    }
    try {
      this.inProgress += 1;
      const response = await Promise.race([
        timeout(TASK_TIMEOUT_MS),
        task.callback(peerId2)
      ]);
      if (response === void 0) {
        throw new Error("Task timeout");
      }
      if (response.failure) {
        throw Error(response.failure.error);
      }
      log17.info("scheduleTask: executed successfully");
      if (task.maxAttempts === 0) {
        log17.warn("scheduleTask: discarded a task due to limit of max attempts");
        return;
      }
      this.queue.push({
        ...task,
        maxAttempts: task.maxAttempts - 1
      });
    } catch (_err) {
      const error = _err;
      log17.error("scheduleTask: task execution failed with error:", error);
      if (shouldPeerBeChanged(error.message)) {
        await this.peerManager.renewPeer(peerId2, {
          protocol: Protocols.LightPush,
          pubsubTopic: task.routingInfo.pubsubTopic
        });
      }
      if (task.maxAttempts === 0) {
        log17.warn("scheduleTask: discarded a task due to limit of max attempts");
        return;
      }
      this.queue.push({
        ...task,
        maxAttempts: task.maxAttempts - 1
      });
    } finally {
      this.inProgress -= 1;
    }
  }
};

// node_modules/@waku/sdk/dist/light_push/light_push.js
var log18 = new Logger("sdk:light-push");
var DEFAULT_MAX_ATTEMPTS = 3;
var DEFAULT_SEND_OPTIONS = {
  autoRetry: true,
  retryIntervalMs: 1e3,
  maxAttempts: DEFAULT_MAX_ATTEMPTS,
  numPeersToUse: 1
};
var LightPush = class {
  constructor(params) {
    __publicField(this, "config");
    __publicField(this, "retryManager");
    __publicField(this, "peerManager");
    __publicField(this, "protocol");
    this.config = {
      ...DEFAULT_SEND_OPTIONS,
      ...params.options || {}
    };
    this.peerManager = params.peerManager;
    this.protocol = new LightPushCore(params.libp2p);
    this.retryManager = new RetryManager({
      peerManager: params.peerManager,
      retryIntervalMs: this.config.retryIntervalMs
    });
  }
  get multicodec() {
    return this.protocol.multicodec;
  }
  start() {
    this.retryManager.start();
  }
  stop() {
    this.retryManager.stop();
  }
  async send(encoder2, message2, options = {}) {
    options = {
      useLegacy: false,
      ...this.config,
      ...options
    };
    const { pubsubTopic } = encoder2;
    log18.info("send: attempting to send a message to pubsubTopic:", pubsubTopic);
    const peerIds = await this.peerManager.getPeers({
      protocol: options.useLegacy ? "light-push-v2" : Protocols.LightPush,
      pubsubTopic: encoder2.pubsubTopic
    });
    const coreResults = (peerIds == null ? void 0 : peerIds.length) > 0 ? await Promise.all(peerIds.map((peerId2) => this.protocol.send(encoder2, message2, peerId2, options.useLegacy).catch((_e) => ({
      success: null,
      failure: {
        error: LightPushError.GENERIC_FAIL
      }
    })))) : [];
    const results = coreResults.length ? {
      successes: coreResults.filter((v) => v.success).map((v) => v.success),
      failures: coreResults.filter((v) => v.failure).map((v) => v.failure)
    } : {
      successes: [],
      failures: [
        {
          error: LightPushError.NO_PEER_AVAILABLE
        }
      ]
    };
    if (options.autoRetry && results.successes.length === 0) {
      const sendCallback = (peerId2) => this.protocol.send(encoder2, message2, peerId2, options.useLegacy);
      this.retryManager.push(sendCallback.bind(this), options.maxAttempts || DEFAULT_MAX_ATTEMPTS, encoder2.routingInfo);
    }
    return results;
  }
};

// node_modules/@waku/sdk/dist/store/store.js
var log19 = new Logger("store-sdk");
var Store = class {
  constructor(params) {
    __publicField(this, "options");
    __publicField(this, "libp2p");
    __publicField(this, "peerManager");
    __publicField(this, "protocol");
    this.options = params.options || {};
    this.peerManager = params.peerManager;
    this.libp2p = params.libp2p;
    this.protocol = new StoreCore(params.libp2p);
  }
  get multicodec() {
    return this.protocol.multicodec;
  }
  /**
   * Queries the Waku Store for historical messages using the provided decoders and options.
   * Returns an asynchronous generator that yields promises of decoded messages.
   *
   * @param decoders - An array of message decoders.
   * @param options - Optional query parameters.
   * @returns An asynchronous generator of promises of decoded messages.
   * @throws If no peers are available to query or if an error occurs during the query.
   */
  async *queryGenerator(decoders4, options) {
    const { decodersAsMap, queryOptions } = this.buildQueryParams(decoders4, options);
    for (const queryOption of queryOptions) {
      const peer = (options == null ? void 0 : options.peerId) ?? await this.getPeerToUse(queryOption.pubsubTopic);
      if (!peer) {
        log19.error("No peers available to query");
        throw new Error("No peers available to query");
      }
      log19.info(`Querying store with options: ${JSON.stringify(queryOption)}`);
      const responseGenerator = this.protocol.queryPerPage(queryOption, decodersAsMap, peer);
      for await (const messages2 of responseGenerator) {
        yield messages2;
      }
    }
  }
  /**
   * Queries the Waku Store for historical messages and processes them with the provided callback in order.
   *
   * @param decoders - An array of message decoders.
   * @param callback - A callback function to process each decoded message.
   * @param options - Optional query parameters.
   * @returns A promise that resolves when the query and message processing are completed.
   */
  async queryWithOrderedCallback(decoders4, callback, options) {
    log19.info("Querying store with ordered callback");
    for await (const promises of this.queryGenerator(decoders4, options)) {
      if (await this.processMessages(promises, callback))
        break;
    }
  }
  /**
   * Queries the Waku Store for historical messages and processes them with the provided callback using promises.
   *
   * @param decoders - An array of message decoders.
   * @param callback - A callback function to process each promise of a decoded message.
   * @param options - Optional query parameters.
   * @returns A promise that resolves when the query and message processing are completed.
   */
  async queryWithPromiseCallback(decoders4, callback, options) {
    log19.info("Querying store with promise callback");
    let abort = false;
    for await (const page of this.queryGenerator(decoders4, options)) {
      const _promises = page.map(async (msgPromise) => {
        if (abort)
          return;
        abort = Boolean(await callback(msgPromise));
      });
      await Promise.all(_promises);
      if (abort)
        break;
    }
  }
  /**
   * Processes messages based on the provided callback and options.
   *
   * @param messages - An array of promises of decoded messages.
   * @param callback - A callback function to process each decoded message.
   * @returns A promise that resolves to a boolean indicating whether the processing should abort.
   * @private
   */
  async processMessages(messages2, callback) {
    let abort = false;
    const messagesOrUndef = await Promise.all(messages2);
    const processedMessages = messagesOrUndef.filter(isDefined);
    await Promise.all(processedMessages.map(async (msg) => {
      if (msg && !abort) {
        abort = Boolean(await callback(msg));
      }
    }));
    return abort;
  }
  /**
   * Creates a cursor based on the provided decoded message.
   *
   * @param message - The decoded message.
   * @returns A StoreCursor representing the message.
   */
  createCursor(message2) {
    return messageHash(message2.pubsubTopic, message2);
  }
  /**
   * Validates the provided decoders and pubsub topic.
   *
   * @param decoders - An array of message decoders.
   * @returns An object containing the pubsub topic, content topics, and a map of decoders.
   * @throws If no decoders are provided, if multiple pubsub topics are provided, or if no decoders are found for the pubsub topic.
   * @private
   */
  validateDecodersAndPubsubTopic(decoders4) {
    if (decoders4.length === 0) {
      log19.error("No decoders provided");
      throw new Error("No decoders provided");
    }
    const uniquePubsubTopicsInQuery = Array.from(new Set(decoders4.map((decoder) => decoder.pubsubTopic)));
    if (uniquePubsubTopicsInQuery.length > 1) {
      log19.error("API does not support querying multiple pubsub topics at once");
      throw new Error("API does not support querying multiple pubsub topics at once");
    }
    const pubsubTopicForQuery = uniquePubsubTopicsInQuery[0];
    const decodersAsMap = /* @__PURE__ */ new Map();
    decoders4.forEach((dec) => {
      if (decodersAsMap.has(dec.contentTopic)) {
        log19.error("API does not support different decoder per content topic");
        throw new Error("API does not support different decoder per content topic");
      }
      decodersAsMap.set(dec.contentTopic, dec);
    });
    const contentTopics = decoders4.filter((decoder) => decoder.pubsubTopic === pubsubTopicForQuery).map((dec) => dec.contentTopic);
    if (contentTopics.length === 0) {
      log19.error(`No decoders found for topic ${pubsubTopicForQuery}`);
      throw new Error("No decoders found for topic " + pubsubTopicForQuery);
    }
    return {
      pubsubTopic: pubsubTopicForQuery,
      contentTopics,
      decodersAsMap
    };
  }
  async getPeerToUse(pubsubTopic) {
    const peers = await this.peerManager.getPeers({
      protocol: Protocols.Store,
      pubsubTopic
    });
    return this.options.peers ? await this.getPeerFromConfigurationOrFirst(peers, this.options.peers) : peers[0];
  }
  async getPeerFromConfigurationOrFirst(peerIds, configPeers) {
    const storeConfigPeers = configPeers.map(multiaddr);
    const missing = [];
    for (const peer of storeConfigPeers) {
      const matchedPeer = peerIds.find((id) => {
        var _a27;
        return id.toString() === ((_a27 = peer.getPeerId()) == null ? void 0 : _a27.toString());
      });
      if (matchedPeer) {
        return matchedPeer;
      }
      missing.push(peer);
    }
    while (missing.length) {
      const toDial = missing.pop();
      if (!toDial) {
        return;
      }
      try {
        const conn = await this.libp2p.dial(toDial);
        if (conn) {
          return peerIdFromString(toDial.getPeerId());
        }
      } catch (e2) {
        log19.warn(`Failed to dial peer from options.peers list for Store protocol. Peer:${toDial.getPeerId()}, error:${e2}`);
      }
    }
    log19.warn(`Passed node to use for Store not found: ${configPeers.toString()}. Attempting to use first available peers.`);
    return peerIds[0];
  }
  buildQueryParams(decoders4, options) {
    var _a27;
    const isHashQuery = (options == null ? void 0 : options.messageHashes) && options.messageHashes.length > 0;
    let pubsubTopic;
    let contentTopics;
    let decodersAsMap;
    if (isHashQuery) {
      pubsubTopic = options.pubsubTopic || ((_a27 = decoders4[0]) == null ? void 0 : _a27.pubsubTopic) || "";
      contentTopics = [];
      decodersAsMap = /* @__PURE__ */ new Map();
      decoders4.forEach((dec) => {
        decodersAsMap.set(dec.contentTopic, dec);
      });
    } else {
      const validated = this.validateDecodersAndPubsubTopic(decoders4);
      pubsubTopic = validated.pubsubTopic;
      contentTopics = validated.contentTopics;
      decodersAsMap = validated.decodersAsMap;
    }
    const subTimeRanges = [];
    if ((options == null ? void 0 : options.timeStart) && (options == null ? void 0 : options.timeEnd)) {
      let start2 = options.timeStart;
      const end = options.timeEnd;
      while (end.getTime() - start2.getTime() > this.protocol.maxTimeLimit) {
        const subEnd = new Date(start2.getTime() + this.protocol.maxTimeLimit);
        subTimeRanges.push([start2, subEnd]);
        start2 = subEnd;
      }
      if (subTimeRanges.length === 0) {
        log19.info("Using single time range");
        subTimeRanges.push([start2, end]);
      }
    }
    if (subTimeRanges.length === 0) {
      log19.info("No sub time ranges");
      return {
        decodersAsMap,
        queryOptions: [
          {
            pubsubTopic,
            contentTopics,
            includeData: true,
            paginationForward: true,
            ...options
          }
        ]
      };
    }
    log19.info(`Building ${subTimeRanges.length} sub time ranges`);
    return {
      decodersAsMap,
      queryOptions: subTimeRanges.map(([start2, end]) => ({
        pubsubTopic,
        contentTopics,
        includeData: true,
        paginationForward: true,
        ...options,
        timeStart: start2,
        timeEnd: end
      }))
    };
  }
};

// node_modules/@waku/sdk/dist/waku/wait_for_remote_peer.js
var log20 = new Logger("wait-for-remote-peer");
async function waitForRemotePeer(waku, protocols2, timeoutMs) {
  protocols2 = (protocols2 == null ? void 0 : protocols2.length) ? protocols2 : getEnabledProtocols(waku);
  const connections = waku.libp2p.getConnections();
  if (!waku.isStarted()) {
    throw Error("Waku node is not started");
  }
  for (const protocol of protocols2) {
    switch (protocol) {
      case Protocols.Relay:
        if (!waku.relay)
          throw Error("Cannot wait for Relay peer: protocol not mounted");
        break;
      case Protocols.LightPush:
        if (!waku.lightPush)
          throw Error("Cannot wait for LightPush peer: protocol not mounted");
        break;
      case Protocols.Store:
        if (!waku.store)
          throw Error("Cannot wait for Store peer: protocol not mounted");
        break;
      case Protocols.Filter:
        if (!waku.filter)
          throw Error("Cannot wait for Filter peer: protocol not mounted");
        break;
    }
  }
  const promises = [waitForProtocols(waku, protocols2)];
  if (connections.length > 0 && !protocols2.includes(Protocols.Relay)) {
    promises.push(waitForMetadata(waku, protocols2));
  }
  if (timeoutMs) {
    await rejectOnTimeout(Promise.any(promises), timeoutMs, "Timed out waiting for a remote peer.");
  } else {
    await Promise.any(promises);
  }
}
function protocolToPeerPromise(codecs2, libp2p) {
  return codecs2.map((codec) => waitForConnectedPeer(codec, libp2p));
}
async function waitForProtocols(waku, protocols2) {
  const promises = [];
  if (waku.relay && protocols2.includes(Protocols.Relay)) {
    promises.push(waku.relay.waitForPeers());
  }
  if (waku.store && protocols2.includes(Protocols.Store)) {
    promises.push(...protocolToPeerPromise([StoreCodec], waku.libp2p));
  }
  if (waku.lightPush && protocols2.includes(Protocols.LightPush)) {
    const lpPromises = protocolToPeerPromise([LightPushCodec, LightPushCodecV2], waku.libp2p);
    promises.push(Promise.any(lpPromises));
  }
  if (waku.filter && protocols2.includes(Protocols.Filter)) {
    promises.push(...protocolToPeerPromise([FilterCodecs.SUBSCRIBE], waku.libp2p));
  }
  return Promise.all(promises);
}
async function waitForConnectedPeer(codec, libp2p) {
  log20.info(`Waiting for ${codec} peer.`);
  await new Promise((resolve) => {
    const cb = async (evt) => {
      var _a27, _b14;
      if ((_b14 = (_a27 = evt.detail) == null ? void 0 : _a27.protocols) == null ? void 0 : _b14.includes(codec)) {
        const metadataService = libp2p.services.metadata;
        if (!metadataService) {
          libp2p.removeEventListener("peer:identify", cb);
          resolve();
          return;
        }
        try {
          await metadataService.confirmOrAttemptHandshake(evt.detail.peerId);
          libp2p.removeEventListener("peer:identify", cb);
          resolve();
        } catch (e2) {
          if (e2.code === "ERR_CONNECTION_BEING_CLOSED") {
            log20.error("Connection closed. Some peers can be on different shard.");
          }
          log20.error(`Error waiting for metadata: ${e2}`);
        }
      }
    };
    libp2p.addEventListener("peer:identify", cb);
  });
}
async function waitForMetadata(waku, protocols2) {
  const connectedPeers = waku.libp2p.getPeers();
  const metadataService = waku.libp2p.services.metadata;
  const enabledCodes = mapProtocolsToCodecs(protocols2);
  if (!connectedPeers.length || !metadataService) {
    log20.info(`Skipping waitForMetadata due to missing connections:${connectedPeers.length} or metadataService:${!!metadataService}`);
    return;
  }
  for (const peerId2 of connectedPeers) {
    try {
      const peer = await waku.libp2p.peerStore.get(peerId2);
      const hasSomeCodes = peer.protocols.some((c2) => enabledCodes.has(c2));
      if (hasSomeCodes) {
        const response = await metadataService.confirmOrAttemptHandshake(peerId2);
        if (!response.error) {
          peer.protocols.forEach((c2) => {
            if (enabledCodes.has(c2)) {
              enabledCodes.set(c2, true);
            }
          });
          const confirmedAllCodecs = Array.from(enabledCodes.values()).every((v) => v);
          if (confirmedAllCodecs) {
            return;
          }
        }
      }
    } catch (e2) {
      if (e2.code === "ERR_CONNECTION_BEING_CLOSED") {
        log20.error("Connection closed. Some peers can be on different shard.");
      }
      log20.error(`Error while iterating through peers: ${e2}`);
      continue;
    }
  }
}
var awaitTimeout = (ms, rejectReason) => new Promise((_resolve, reject) => setTimeout(() => reject(Error(rejectReason)), ms));
async function rejectOnTimeout(promise, timeoutMs, rejectReason) {
  await Promise.race([promise, awaitTimeout(timeoutMs, rejectReason)]);
}
function getEnabledProtocols(waku) {
  const protocols2 = [];
  if (waku.relay) {
    protocols2.push(Protocols.Relay);
  }
  if (waku.filter) {
    protocols2.push(Protocols.Filter);
  }
  if (waku.store) {
    protocols2.push(Protocols.Store);
  }
  if (waku.lightPush) {
    protocols2.push(Protocols.LightPush);
  }
  return protocols2;
}
function mapProtocolsToCodecs(protocols2) {
  const codecs2 = /* @__PURE__ */ new Map();
  const protocolToCodec = {
    [Protocols.Filter]: [FilterCodecs.SUBSCRIBE],
    [Protocols.LightPush]: [LightPushCodec, LightPushCodecV2],
    [Protocols.Store]: [StoreCodec]
  };
  for (const protocol of protocols2) {
    if (protocolToCodec[protocol]) {
      protocolToCodec[protocol].forEach((codec) => {
        codecs2.set(codec, false);
      });
    }
  }
  return codecs2;
}

// node_modules/@waku/sdk/dist/waku/waku.js
var log21 = new Logger("sdk:waku");
var WakuNode = class {
  constructor(options, libp2p, protocolsEnabled, relay) {
    __publicField(this, "libp2p");
    __publicField(this, "relay");
    __publicField(this, "store");
    __publicField(this, "filter");
    __publicField(this, "lightPush");
    __publicField(this, "events", new TypedEventEmitter());
    __publicField(this, "networkConfig");
    // needed to create a lock for async operations
    __publicField(this, "_nodeStateLock", false);
    __publicField(this, "_nodeStarted", false);
    __publicField(this, "connectionManager");
    __publicField(this, "peerManager");
    __publicField(this, "healthIndicator");
    this.relay = relay;
    this.libp2p = libp2p;
    this.networkConfig = options.networkConfig || DefaultNetworkConfig;
    protocolsEnabled = {
      filter: false,
      lightpush: false,
      store: false,
      ...protocolsEnabled
    };
    const peerId2 = this.libp2p.peerId.toString();
    this.connectionManager = new ConnectionManager({
      libp2p,
      relay: this.relay,
      events: this.events,
      networkConfig: this.networkConfig,
      config: options == null ? void 0 : options.connectionManager
    });
    this.peerManager = new PeerManager({
      libp2p,
      config: {
        numPeersToUse: options.numPeersToUse
      },
      connectionManager: this.connectionManager
    });
    this.healthIndicator = new HealthIndicator({ libp2p, events: this.events });
    if (protocolsEnabled.store) {
      this.store = new Store({
        libp2p,
        peerManager: this.peerManager,
        options: options == null ? void 0 : options.store
      });
    }
    if (protocolsEnabled.lightpush) {
      this.lightPush = new LightPush({
        libp2p,
        peerManager: this.peerManager,
        options: options == null ? void 0 : options.lightPush
      });
    }
    if (protocolsEnabled.filter) {
      this.filter = new Filter({
        libp2p,
        peerManager: this.peerManager,
        options: options.filter
      });
    }
    log21.info("Waku node created", peerId2, `relay: ${!!this.relay}, store: ${!!this.store}, light push: ${!!this.lightPush}, filter: ${!!this.filter}`);
  }
  get peerId() {
    return this.libp2p.peerId;
  }
  get protocols() {
    return this.libp2p.getProtocols();
  }
  get health() {
    return this.healthIndicator.toValue();
  }
  async dial(peer, protocols2) {
    const _protocols = protocols2 ?? [];
    if (typeof protocols2 === "undefined") {
      this.relay && _protocols.push(Protocols.Relay);
      this.store && _protocols.push(Protocols.Store);
      this.filter && _protocols.push(Protocols.Filter);
      this.lightPush && _protocols.push(Protocols.LightPush);
    }
    const codecs2 = [];
    if (_protocols.includes(Protocols.Relay)) {
      if (this.relay) {
        this.relay.gossipSub.multicodecs.forEach((codec) => codecs2.push(codec));
      } else {
        log21.error("Relay codec not included in dial codec: protocol not mounted locally");
      }
    }
    if (_protocols.includes(Protocols.Store)) {
      if (this.store) {
        codecs2.push(this.store.multicodec);
      } else {
        log21.error("Store codec not included in dial codec: protocol not mounted locally");
      }
    }
    if (_protocols.includes(Protocols.LightPush)) {
      if (this.lightPush) {
        codecs2.push(...this.lightPush.multicodec);
      } else {
        log21.error("Light Push codec not included in dial codec: protocol not mounted locally");
      }
    }
    if (_protocols.includes(Protocols.Filter)) {
      if (this.filter) {
        codecs2.push(this.filter.multicodec);
      } else {
        log21.error("Filter codec not included in dial codec: protocol not mounted locally");
      }
    }
    log21.info(`Dialing to ${peer == null ? void 0 : peer.toString()} with protocols ${_protocols}`);
    return await this.connectionManager.dial(peer, codecs2);
  }
  async hangUp(peer) {
    log21.info(`Hanging up peer:${peer == null ? void 0 : peer.toString()}.`);
    return this.connectionManager.hangUp(peer);
  }
  async start() {
    var _a27, _b14;
    if (this._nodeStateLock || this.isStarted())
      return;
    this._nodeStateLock = true;
    await this.libp2p.start();
    await ((_a27 = this.filter) == null ? void 0 : _a27.start());
    this.connectionManager.start();
    this.peerManager.start();
    this.healthIndicator.start();
    (_b14 = this.lightPush) == null ? void 0 : _b14.start();
    this._nodeStateLock = false;
    this._nodeStarted = true;
  }
  async stop() {
    var _a27, _b14;
    if (this._nodeStateLock || !this.isStarted())
      return;
    this._nodeStateLock = true;
    (_a27 = this.lightPush) == null ? void 0 : _a27.stop();
    await ((_b14 = this.filter) == null ? void 0 : _b14.stop());
    this.healthIndicator.stop();
    this.peerManager.stop();
    this.connectionManager.stop();
    await this.libp2p.stop();
    this._nodeStateLock = false;
    this._nodeStarted = false;
  }
  async getConnectedPeers() {
    return this.connectionManager.getConnectedPeers();
  }
  async waitForPeers(protocols2, timeoutMs) {
    return waitForRemotePeer(this, protocols2, timeoutMs);
  }
  isStarted() {
    return this._nodeStarted && this.libp2p.status === "started";
  }
  isConnected() {
    return this.connectionManager.isConnected();
  }
  createDecoder(params) {
    const routingInfo = this.createRoutingInfo(params.contentTopic, params.shardId);
    return createDecoder(params.contentTopic, routingInfo);
  }
  createEncoder(params) {
    const routingInfo = this.createRoutingInfo(params.contentTopic, params.shardId);
    return createEncoder({
      contentTopic: params.contentTopic,
      ephemeral: params.ephemeral,
      routingInfo
    });
  }
  createRoutingInfo(contentTopic, shardId) {
    return createRoutingInfo(this.networkConfig, { contentTopic, shardId });
  }
};

// node_modules/it-length-prefixed/dist/src/constants.js
var MAX_LENGTH_LENGTH2 = 8;
var MAX_DATA_LENGTH2 = 1024 * 1024 * 4;

// node_modules/it-length-prefixed/dist/src/errors.js
var InvalidMessageLengthError2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidMessageLengthError");
    __publicField(this, "code", "ERR_INVALID_MSG_LENGTH");
  }
};
var InvalidDataLengthError2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthError");
    __publicField(this, "code", "ERR_MSG_DATA_TOO_LONG");
  }
};
var InvalidDataLengthLengthError2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthLengthError");
    __publicField(this, "code", "ERR_MSG_LENGTH_TOO_LONG");
  }
};
var UnexpectedEOFError2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UnexpectedEOFError");
    __publicField(this, "code", "ERR_UNEXPECTED_EOF");
  }
};

// node_modules/it-length-prefixed/dist/src/utils.js
function isAsyncIterable5(thing) {
  return thing[Symbol.asyncIterator] != null;
}

// node_modules/it-length-prefixed/dist/src/encode.js
function validateMaxDataLength(chunk, maxDataLength) {
  if (chunk.byteLength > maxDataLength) {
    throw new InvalidDataLengthError2("Message length too long");
  }
}
var defaultEncoder2 = (length3) => {
  const lengthLength = encodingLength(length3);
  const lengthBuf = allocUnsafe(lengthLength);
  encode(length3, lengthBuf);
  defaultEncoder2.bytes = lengthLength;
  return lengthBuf;
};
defaultEncoder2.bytes = 0;
function encode7(source, options) {
  options = options ?? {};
  const encodeLength3 = options.lengthEncoder ?? defaultEncoder2;
  const maxDataLength = (options == null ? void 0 : options.maxDataLength) ?? MAX_DATA_LENGTH2;
  function* maybeYield(chunk) {
    validateMaxDataLength(chunk, maxDataLength);
    const length3 = encodeLength3(chunk.byteLength);
    if (length3 instanceof Uint8Array) {
      yield length3;
    } else {
      yield* length3;
    }
    if (chunk instanceof Uint8Array) {
      yield chunk;
    } else {
      yield* chunk;
    }
  }
  if (isAsyncIterable5(source)) {
    return async function* () {
      for await (const chunk of source) {
        yield* maybeYield(chunk);
      }
    }();
  }
  return function* () {
    for (const chunk of source) {
      yield* maybeYield(chunk);
    }
  }();
}
encode7.single = (chunk, options) => {
  options = options ?? {};
  const encodeLength3 = options.lengthEncoder ?? defaultEncoder2;
  const maxDataLength = (options == null ? void 0 : options.maxDataLength) ?? MAX_DATA_LENGTH2;
  validateMaxDataLength(chunk, maxDataLength);
  return new Uint8ArrayList(encodeLength3(chunk.byteLength), chunk);
};

// node_modules/it-length-prefixed/dist/src/decode.js
var ReadMode2;
(function(ReadMode3) {
  ReadMode3[ReadMode3["LENGTH"] = 0] = "LENGTH";
  ReadMode3[ReadMode3["DATA"] = 1] = "DATA";
})(ReadMode2 || (ReadMode2 = {}));
var defaultDecoder2 = (buf) => {
  const length3 = decode(buf);
  defaultDecoder2.bytes = encodingLength(length3);
  return length3;
};
defaultDecoder2.bytes = 0;
function decode8(source, options) {
  const buffer = new Uint8ArrayList();
  let mode = ReadMode2.LENGTH;
  let dataLength = -1;
  const lengthDecoder = (options == null ? void 0 : options.lengthDecoder) ?? defaultDecoder2;
  const maxLengthLength = (options == null ? void 0 : options.maxLengthLength) ?? MAX_LENGTH_LENGTH2;
  const maxDataLength = (options == null ? void 0 : options.maxDataLength) ?? MAX_DATA_LENGTH2;
  function* maybeYield() {
    while (buffer.byteLength > 0) {
      if (mode === ReadMode2.LENGTH) {
        try {
          dataLength = lengthDecoder(buffer);
          if (dataLength < 0) {
            throw new InvalidMessageLengthError2("Invalid message length");
          }
          if (dataLength > maxDataLength) {
            throw new InvalidDataLengthError2("Message length too long");
          }
          const dataLengthLength = lengthDecoder.bytes;
          buffer.consume(dataLengthLength);
          if ((options == null ? void 0 : options.onLength) != null) {
            options.onLength(dataLength);
          }
          mode = ReadMode2.DATA;
        } catch (err) {
          if (err instanceof RangeError) {
            if (buffer.byteLength > maxLengthLength) {
              throw new InvalidDataLengthLengthError2("Message length length too long");
            }
            break;
          }
          throw err;
        }
      }
      if (mode === ReadMode2.DATA) {
        if (buffer.byteLength < dataLength) {
          break;
        }
        const data = buffer.sublist(0, dataLength);
        buffer.consume(dataLength);
        if ((options == null ? void 0 : options.onData) != null) {
          options.onData(data);
        }
        yield data;
        mode = ReadMode2.LENGTH;
      }
    }
  }
  if (isAsyncIterable5(source)) {
    return async function* () {
      for await (const buf of source) {
        buffer.append(buf);
        yield* maybeYield();
      }
      if (buffer.byteLength > 0) {
        throw new UnexpectedEOFError2("Unexpected end of input");
      }
    }();
  }
  return function* () {
    for (const buf of source) {
      buffer.append(buf);
      yield* maybeYield();
    }
    if (buffer.byteLength > 0) {
      throw new UnexpectedEOFError2("Unexpected end of input");
    }
  }();
}
decode8.fromReader = (reader, options) => {
  let byteLength = 1;
  const varByteSource = async function* () {
    while (true) {
      try {
        const { done, value } = await reader.next(byteLength);
        if (done === true) {
          return;
        }
        if (value != null) {
          yield value;
        }
      } catch (err) {
        if (err.code === "ERR_UNDER_READ") {
          return { done: true, value: null };
        }
        throw err;
      } finally {
        byteLength = 1;
      }
    }
  }();
  const onLength = (l2) => {
    byteLength = l2;
  };
  return decode8(varByteSource, {
    ...options ?? {},
    onLength
  });
};

// node_modules/it-byte-stream/node_modules/race-signal/dist/src/index.js
function defaultTranslate2(signal) {
  return signal.reason;
}
async function raceSignal2(promise, signal, opts) {
  if (signal == null) {
    return promise;
  }
  const translateError = (opts == null ? void 0 : opts.translateError) ?? defaultTranslate2;
  if (signal.aborted) {
    promise.catch(() => {
    });
    return Promise.reject(translateError(signal));
  }
  let listener;
  try {
    return await Promise.race([
      promise,
      new Promise((resolve, reject) => {
        listener = () => {
          reject(translateError(signal));
        };
        signal.addEventListener("abort", listener);
      })
    ]);
  } finally {
    if (listener != null) {
      signal.removeEventListener("abort", listener);
    }
  }
}

// node_modules/it-byte-stream/dist/src/errors.js
var UnexpectedEOFError3 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UnexpectedEOFError");
    __publicField(this, "code", "ERR_UNEXPECTED_EOF");
  }
};

// node_modules/it-byte-stream/dist/src/index.js
function byteStream(duplex, opts) {
  const write3 = queuelessPushable();
  duplex.sink(write3).catch(async (err) => {
    await write3.end(err);
  });
  duplex.sink = async (source2) => {
    for await (const buf of source2) {
      await write3.push(buf);
    }
    await write3.end();
  };
  let source = duplex.source;
  if (duplex.source[Symbol.iterator] != null) {
    source = duplex.source[Symbol.iterator]();
  } else if (duplex.source[Symbol.asyncIterator] != null) {
    source = duplex.source[Symbol.asyncIterator]();
  }
  const readBuffer = new Uint8ArrayList();
  const W = {
    read: async (options) => {
      var _a27;
      (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
      if ((options == null ? void 0 : options.bytes) == null) {
        const { done, value } = await raceSignal2(source.next(), options == null ? void 0 : options.signal);
        if (done === true) {
          return null;
        }
        return value;
      }
      while (readBuffer.byteLength < options.bytes) {
        const { value, done } = await raceSignal2(source.next(), options == null ? void 0 : options.signal);
        if (done === true) {
          throw new UnexpectedEOFError3("unexpected end of input");
        }
        readBuffer.append(value);
      }
      const buf = readBuffer.sublist(0, options.bytes);
      readBuffer.consume(options.bytes);
      return buf;
    },
    write: async (data, options) => {
      var _a27;
      (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
      if (data instanceof Uint8Array) {
        await write3.push(data, options);
      } else {
        await write3.push(data.subarray(), options);
      }
    },
    unwrap: () => {
      if (readBuffer.byteLength > 0) {
        const originalStream = duplex.source;
        duplex.source = async function* () {
          if ((opts == null ? void 0 : opts.yieldBytes) === false) {
            yield readBuffer;
          } else {
            yield* readBuffer;
          }
          yield* originalStream;
        }();
      }
      return duplex;
    }
  };
  return W;
}

// node_modules/it-length-prefixed-stream/dist/src/errors.js
var InvalidMessageLengthError3 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidMessageLengthError");
    __publicField(this, "code", "ERR_INVALID_MSG_LENGTH");
  }
};
var InvalidDataLengthError3 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthError");
    __publicField(this, "code", "ERR_MSG_DATA_TOO_LONG");
  }
};
var InvalidDataLengthLengthError3 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthLengthError");
    __publicField(this, "code", "ERR_MSG_LENGTH_TOO_LONG");
  }
};

// node_modules/it-length-prefixed-stream/dist/src/index.js
function lpStream(duplex, opts = {}) {
  const bytes = byteStream(duplex, opts);
  if (opts.maxDataLength != null && opts.maxLengthLength == null) {
    opts.maxLengthLength = encodingLength(opts.maxDataLength);
  }
  const decodeLength = (opts == null ? void 0 : opts.lengthDecoder) ?? decode;
  const encodeLength3 = (opts == null ? void 0 : opts.lengthEncoder) ?? encode;
  const W = {
    read: async (options) => {
      let dataLength = -1;
      const lengthBuffer = new Uint8ArrayList();
      while (true) {
        lengthBuffer.append(await bytes.read({
          ...options,
          bytes: 1
        }));
        try {
          dataLength = decodeLength(lengthBuffer);
        } catch (err) {
          if (err instanceof RangeError) {
            continue;
          }
          throw err;
        }
        if (dataLength < 0) {
          throw new InvalidMessageLengthError3("Invalid message length");
        }
        if ((opts == null ? void 0 : opts.maxLengthLength) != null && lengthBuffer.byteLength > opts.maxLengthLength) {
          throw new InvalidDataLengthLengthError3("message length length too long");
        }
        if (dataLength > -1) {
          break;
        }
      }
      if ((opts == null ? void 0 : opts.maxDataLength) != null && dataLength > opts.maxDataLength) {
        throw new InvalidDataLengthError3("message length too long");
      }
      return bytes.read({
        ...options,
        bytes: dataLength
      });
    },
    write: async (data, options) => {
      await bytes.write(new Uint8ArrayList(encodeLength3(data.byteLength), data), options);
    },
    writeV: async (data, options) => {
      const list = new Uint8ArrayList(...data.flatMap((buf) => [encodeLength3(buf.byteLength), buf]));
      await bytes.write(list, options);
    },
    unwrap: () => {
      return bytes.unwrap();
    }
  };
  return W;
}

// node_modules/it-pair/dist/src/index.js
function pair() {
  const deferred = pDefer();
  let piped = false;
  return {
    sink: async (source) => {
      if (piped) {
        throw new Error("already piped");
      }
      piped = true;
      deferred.resolve(source);
    },
    source: async function* () {
      const source = await deferred.promise;
      yield* source;
    }()
  };
}

// node_modules/it-pair/dist/src/duplex.js
function duplexPair() {
  const a2 = pair();
  const b = pair();
  return [
    {
      source: a2.source,
      sink: b.sink
    },
    {
      source: b.source,
      sink: a2.sink
    }
  ];
}

// node_modules/@chainsafe/libp2p-noise/dist/src/constants.js
var NOISE_MSG_MAX_LENGTH_BYTES = 65535;
var NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16;
var _a6, _b2;
var DUMP_SESSION_KEYS = Boolean((_b2 = (_a6 = globalThis.process) == null ? void 0 : _a6.env) == null ? void 0 : _b2.DUMP_SESSION_KEYS);

// node_modules/@noble/ciphers/esm/utils.js
function isBytes3(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
function abool2(b) {
  if (typeof b !== "boolean")
    throw new Error(`boolean expected, not ${b}`);
}
function anumber3(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error("positive integer expected, got " + n2);
}
function abytes3(b, ...lengths) {
  if (!isBytes3(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function aexists3(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput3(out, instance) {
  abytes3(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean3(...arrays) {
  for (let i2 = 0; i2 < arrays.length; i2++) {
    arrays[i2].fill(0);
  }
}
function createView3(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
var isLE3 = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
var hasHexBuiltin3 = (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes3 = Array.from({ length: 256 }, (_2, i2) => i2.toString(16).padStart(2, "0"));
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes3(data);
  else if (isBytes3(data))
    data = copyBytes2(data);
  else
    throw new Error("Uint8Array expected, got " + typeof data);
  return data;
}
function checkOpts(defaults, opts) {
  if (opts == null || typeof opts !== "object")
    throw new Error("options must be defined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function equalBytes2(a2, b) {
  if (a2.length !== b.length)
    return false;
  let diff = 0;
  for (let i2 = 0; i2 < a2.length; i2++)
    diff |= a2[i2] ^ b[i2];
  return diff === 0;
}
var wrapCipher = (params, constructor) => {
  function wrappedCipher(key, ...args) {
    abytes3(key);
    if (!isLE3)
      throw new Error("Non little-endian hardware is not yet supported");
    if (params.nonceLength !== void 0) {
      const nonce = args[0];
      if (!nonce)
        throw new Error("nonce / iv required");
      if (params.varSizeNonce)
        abytes3(nonce);
      else
        abytes3(nonce, params.nonceLength);
    }
    const tagl = params.tagLength;
    if (tagl && args[1] !== void 0) {
      abytes3(args[1]);
    }
    const cipher = constructor(key, ...args);
    const checkOutput = (fnLength, output) => {
      if (output !== void 0) {
        if (fnLength !== 2)
          throw new Error("cipher output not supported");
        abytes3(output);
      }
    };
    let called = false;
    const wrCipher = {
      encrypt(data, output) {
        if (called)
          throw new Error("cannot encrypt() twice with same key + nonce");
        called = true;
        abytes3(data);
        checkOutput(cipher.encrypt.length, output);
        return cipher.encrypt(data, output);
      },
      decrypt(data, output) {
        abytes3(data);
        if (tagl && data.length < tagl)
          throw new Error("invalid ciphertext length: smaller than tagLength=" + tagl);
        checkOutput(cipher.decrypt.length, output);
        return cipher.decrypt(data, output);
      }
    };
    return wrCipher;
  }
  Object.assign(wrappedCipher, params);
  return wrappedCipher;
};
function getOutput(expectedLength, out, onlyAligned = true) {
  if (out === void 0)
    return new Uint8Array(expectedLength);
  if (out.length !== expectedLength)
    throw new Error("invalid output length, expected " + expectedLength + ", got: " + out.length);
  if (onlyAligned && !isAligned32(out))
    throw new Error("invalid output, must be aligned");
  return out;
}
function setBigUint642(view, byteOffset, value, isLE4) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE4);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n3 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE4 ? 4 : 0;
  const l2 = isLE4 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE4);
  view.setUint32(byteOffset + l2, wl, isLE4);
}
function u64Lengths(dataLength, aadLength, isLE4) {
  abool2(isLE4);
  const num3 = new Uint8Array(16);
  const view = createView3(num3);
  setBigUint642(view, 0, BigInt(aadLength), isLE4);
  setBigUint642(view, 8, BigInt(dataLength), isLE4);
  return num3;
}
function isAligned32(bytes) {
  return bytes.byteOffset % 4 === 0;
}
function copyBytes2(bytes) {
  return Uint8Array.from(bytes);
}

// node_modules/@noble/ciphers/esm/_arx.js
var _utf8ToBytes = (str) => Uint8Array.from(str.split("").map((c2) => c2.charCodeAt(0)));
var sigma16 = _utf8ToBytes("expand 16-byte k");
var sigma32 = _utf8ToBytes("expand 32-byte k");
var sigma16_32 = u32(sigma16);
var sigma32_32 = u32(sigma32);
function rotl2(a2, b) {
  return a2 << b | a2 >>> 32 - b;
}
function isAligned322(b) {
  return b.byteOffset % 4 === 0;
}
var BLOCK_LEN = 64;
var BLOCK_LEN32 = 16;
var MAX_COUNTER = 2 ** 32 - 1;
var U32_EMPTY = new Uint32Array();
function runCipher(core, sigma, key, nonce, data, output, counter, rounds) {
  const len = data.length;
  const block = new Uint8Array(BLOCK_LEN);
  const b32 = u32(block);
  const isAligned = isAligned322(data) && isAligned322(output);
  const d32 = isAligned ? u32(data) : U32_EMPTY;
  const o32 = isAligned ? u32(output) : U32_EMPTY;
  for (let pos = 0; pos < len; counter++) {
    core(sigma, key, nonce, b32, counter, rounds);
    if (counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    const take2 = Math.min(BLOCK_LEN, len - pos);
    if (isAligned && take2 === BLOCK_LEN) {
      const pos32 = pos / 4;
      if (pos % 4 !== 0)
        throw new Error("arx: invalid block position");
      for (let j = 0, posj; j < BLOCK_LEN32; j++) {
        posj = pos32 + j;
        o32[posj] = d32[posj] ^ b32[j];
      }
      pos += BLOCK_LEN;
      continue;
    }
    for (let j = 0, posj; j < take2; j++) {
      posj = pos + j;
      output[posj] = data[posj] ^ block[j];
    }
    pos += take2;
  }
}
function createCipher(core, opts) {
  const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
  if (typeof core !== "function")
    throw new Error("core must be a function");
  anumber3(counterLength);
  anumber3(rounds);
  abool2(counterRight);
  abool2(allowShortKeys);
  return (key, nonce, data, output, counter = 0) => {
    abytes3(key);
    abytes3(nonce);
    abytes3(data);
    const len = data.length;
    if (output === void 0)
      output = new Uint8Array(len);
    abytes3(output);
    anumber3(counter);
    if (counter < 0 || counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    if (output.length < len)
      throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);
    const toClean = [];
    let l2 = key.length;
    let k;
    let sigma;
    if (l2 === 32) {
      toClean.push(k = copyBytes2(key));
      sigma = sigma32_32;
    } else if (l2 === 16 && allowShortKeys) {
      k = new Uint8Array(32);
      k.set(key);
      k.set(key, 16);
      sigma = sigma16_32;
      toClean.push(k);
    } else {
      throw new Error(`arx: invalid 32-byte key, got length=${l2}`);
    }
    if (!isAligned322(nonce))
      toClean.push(nonce = copyBytes2(nonce));
    const k32 = u32(k);
    if (extendNonceFn) {
      if (nonce.length !== 24)
        throw new Error(`arx: extended nonce must be 24 bytes`);
      extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);
      nonce = nonce.subarray(16);
    }
    const nonceNcLen = 16 - counterLength;
    if (nonceNcLen !== nonce.length)
      throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
    if (nonceNcLen !== 12) {
      const nc = new Uint8Array(12);
      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
      nonce = nc;
      toClean.push(nonce);
    }
    const n32 = u32(nonce);
    runCipher(core, sigma, k32, n32, data, output, counter, rounds);
    clean3(...toClean);
    return output;
  };
}

// node_modules/@noble/ciphers/esm/_poly1305.js
var u8to16 = (a2, i2) => a2[i2++] & 255 | (a2[i2++] & 255) << 8;
var Poly1305 = class {
  constructor(key) {
    this.blockLen = 16;
    this.outputLen = 16;
    this.buffer = new Uint8Array(16);
    this.r = new Uint16Array(10);
    this.h = new Uint16Array(10);
    this.pad = new Uint16Array(8);
    this.pos = 0;
    this.finished = false;
    key = toBytes2(key);
    abytes3(key, 32);
    const t0 = u8to16(key, 0);
    const t1 = u8to16(key, 2);
    const t2 = u8to16(key, 4);
    const t3 = u8to16(key, 6);
    const t4 = u8to16(key, 8);
    const t5 = u8to16(key, 10);
    const t6 = u8to16(key, 12);
    const t7 = u8to16(key, 14);
    this.r[0] = t0 & 8191;
    this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
    this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
    this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
    this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
    this.r[5] = t4 >>> 1 & 8190;
    this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
    this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
    this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
    this.r[9] = t7 >>> 5 & 127;
    for (let i2 = 0; i2 < 8; i2++)
      this.pad[i2] = u8to16(key, 16 + 2 * i2);
  }
  process(data, offset, isLast = false) {
    const hibit = isLast ? 0 : 1 << 11;
    const { h, r: r2 } = this;
    const r0 = r2[0];
    const r1 = r2[1];
    const r22 = r2[2];
    const r3 = r2[3];
    const r4 = r2[4];
    const r5 = r2[5];
    const r6 = r2[6];
    const r7 = r2[7];
    const r8 = r2[8];
    const r9 = r2[9];
    const t0 = u8to16(data, offset + 0);
    const t1 = u8to16(data, offset + 2);
    const t2 = u8to16(data, offset + 4);
    const t3 = u8to16(data, offset + 6);
    const t4 = u8to16(data, offset + 8);
    const t5 = u8to16(data, offset + 10);
    const t6 = u8to16(data, offset + 12);
    const t7 = u8to16(data, offset + 14);
    let h0 = h[0] + (t0 & 8191);
    let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
    let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
    let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
    let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
    let h5 = h[5] + (t4 >>> 1 & 8191);
    let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
    let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
    let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
    let h9 = h[9] + (t7 >>> 5 | hibit);
    let c2 = 0;
    let d0 = c2 + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
    c2 = d0 >>> 13;
    d0 &= 8191;
    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r22) + h9 * (5 * r1);
    c2 += d0 >>> 13;
    d0 &= 8191;
    let d1 = c2 + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
    c2 = d1 >>> 13;
    d1 &= 8191;
    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r22);
    c2 += d1 >>> 13;
    d1 &= 8191;
    let d2 = c2 + h0 * r22 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
    c2 = d2 >>> 13;
    d2 &= 8191;
    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
    c2 += d2 >>> 13;
    d2 &= 8191;
    let d3 = c2 + h0 * r3 + h1 * r22 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
    c2 = d3 >>> 13;
    d3 &= 8191;
    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
    c2 += d3 >>> 13;
    d3 &= 8191;
    let d4 = c2 + h0 * r4 + h1 * r3 + h2 * r22 + h3 * r1 + h4 * r0;
    c2 = d4 >>> 13;
    d4 &= 8191;
    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
    c2 += d4 >>> 13;
    d4 &= 8191;
    let d5 = c2 + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r22 + h4 * r1;
    c2 = d5 >>> 13;
    d5 &= 8191;
    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
    c2 += d5 >>> 13;
    d5 &= 8191;
    let d6 = c2 + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r22;
    c2 = d6 >>> 13;
    d6 &= 8191;
    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
    c2 += d6 >>> 13;
    d6 &= 8191;
    let d7 = c2 + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
    c2 = d7 >>> 13;
    d7 &= 8191;
    d7 += h5 * r22 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
    c2 += d7 >>> 13;
    d7 &= 8191;
    let d8 = c2 + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
    c2 = d8 >>> 13;
    d8 &= 8191;
    d8 += h5 * r3 + h6 * r22 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
    c2 += d8 >>> 13;
    d8 &= 8191;
    let d9 = c2 + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
    c2 = d9 >>> 13;
    d9 &= 8191;
    d9 += h5 * r4 + h6 * r3 + h7 * r22 + h8 * r1 + h9 * r0;
    c2 += d9 >>> 13;
    d9 &= 8191;
    c2 = (c2 << 2) + c2 | 0;
    c2 = c2 + d0 | 0;
    d0 = c2 & 8191;
    c2 = c2 >>> 13;
    d1 += c2;
    h[0] = d0;
    h[1] = d1;
    h[2] = d2;
    h[3] = d3;
    h[4] = d4;
    h[5] = d5;
    h[6] = d6;
    h[7] = d7;
    h[8] = d8;
    h[9] = d9;
  }
  finalize() {
    const { h, pad } = this;
    const g = new Uint16Array(10);
    let c2 = h[1] >>> 13;
    h[1] &= 8191;
    for (let i2 = 2; i2 < 10; i2++) {
      h[i2] += c2;
      c2 = h[i2] >>> 13;
      h[i2] &= 8191;
    }
    h[0] += c2 * 5;
    c2 = h[0] >>> 13;
    h[0] &= 8191;
    h[1] += c2;
    c2 = h[1] >>> 13;
    h[1] &= 8191;
    h[2] += c2;
    g[0] = h[0] + 5;
    c2 = g[0] >>> 13;
    g[0] &= 8191;
    for (let i2 = 1; i2 < 10; i2++) {
      g[i2] = h[i2] + c2;
      c2 = g[i2] >>> 13;
      g[i2] &= 8191;
    }
    g[9] -= 1 << 13;
    let mask = (c2 ^ 1) - 1;
    for (let i2 = 0; i2 < 10; i2++)
      g[i2] &= mask;
    mask = ~mask;
    for (let i2 = 0; i2 < 10; i2++)
      h[i2] = h[i2] & mask | g[i2];
    h[0] = (h[0] | h[1] << 13) & 65535;
    h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
    h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
    h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
    h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
    h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
    h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
    h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
    let f3 = h[0] + pad[0];
    h[0] = f3 & 65535;
    for (let i2 = 1; i2 < 8; i2++) {
      f3 = (h[i2] + pad[i2] | 0) + (f3 >>> 16) | 0;
      h[i2] = f3 & 65535;
    }
    clean3(g);
  }
  update(data) {
    aexists3(this);
    data = toBytes2(data);
    abytes3(data);
    const { buffer, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take2 = Math.min(blockLen - this.pos, len - pos);
      if (take2 === blockLen) {
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(data, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take2), this.pos);
      this.pos += take2;
      pos += take2;
      if (this.pos === blockLen) {
        this.process(buffer, 0, false);
        this.pos = 0;
      }
    }
    return this;
  }
  destroy() {
    clean3(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(out) {
    aexists3(this);
    aoutput3(out, this);
    this.finished = true;
    const { buffer, h } = this;
    let { pos } = this;
    if (pos) {
      buffer[pos++] = 1;
      for (; pos < 16; pos++)
        buffer[pos] = 0;
      this.process(buffer, 0, true);
    }
    this.finalize();
    let opos = 0;
    for (let i2 = 0; i2 < 8; i2++) {
      out[opos++] = h[i2] >>> 0;
      out[opos++] = h[i2] >>> 8;
    }
    return out;
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
};
function wrapConstructorWithKey(hashCons) {
  const hashC = (msg, key) => hashCons(key).update(toBytes2(msg)).digest();
  const tmp = hashCons(new Uint8Array(32));
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key) => hashCons(key);
  return hashC;
}
var poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));

// node_modules/@noble/ciphers/esm/chacha.js
function chachaCore(s2, k, n2, out, cnt, rounds = 20) {
  let y00 = s2[0], y01 = s2[1], y02 = s2[2], y03 = s2[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n2[0], y14 = n2[1], y15 = n2[2];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let r2 = 0; r2 < rounds; r2 += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl2(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl2(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl2(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl2(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl2(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl2(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl2(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl2(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl2(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl2(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl2(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl2(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl2(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl2(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl2(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl2(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl2(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl2(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl2(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl2(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl2(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl2(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl2(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl2(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl2(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl2(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl2(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl2(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl2(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl2(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl2(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl2(x04 ^ x09, 7);
  }
  let oi = 0;
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function hchacha(s2, k, i2, o32) {
  let x00 = s2[0], x01 = s2[1], x02 = s2[2], x03 = s2[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i2[0], x13 = i2[1], x14 = i2[2], x15 = i2[3];
  for (let r2 = 0; r2 < 20; r2 += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl2(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl2(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl2(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl2(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl2(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl2(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl2(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl2(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl2(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl2(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl2(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl2(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl2(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl2(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl2(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl2(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl2(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl2(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl2(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl2(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl2(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl2(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl2(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl2(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl2(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl2(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl2(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl2(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl2(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl2(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl2(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl2(x04 ^ x09, 7);
  }
  let oi = 0;
  o32[oi++] = x00;
  o32[oi++] = x01;
  o32[oi++] = x02;
  o32[oi++] = x03;
  o32[oi++] = x12;
  o32[oi++] = x13;
  o32[oi++] = x14;
  o32[oi++] = x15;
}
var chacha20orig = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 8,
  allowShortKeys: true
});
var chacha20 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  allowShortKeys: false
});
var xchacha20 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 8,
  extendNonceFn: hchacha,
  allowShortKeys: false
});
var chacha8 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  rounds: 8
});
var chacha12 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  rounds: 12
});
var ZEROS16 = new Uint8Array(16);
var updatePadded = (h, msg) => {
  h.update(msg);
  const left = msg.length % 16;
  if (left)
    h.update(ZEROS16.subarray(left));
};
var ZEROS32 = new Uint8Array(32);
function computeTag(fn, key, nonce, data, AAD) {
  const authKey = fn(key, nonce, ZEROS32);
  const h = poly1305.create(authKey);
  if (AAD)
    updatePadded(h, AAD);
  updatePadded(h, data);
  const num3 = u64Lengths(data.length, AAD ? AAD.length : 0, true);
  h.update(num3);
  const res = h.digest();
  clean3(authKey, num3);
  return res;
}
var _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
  const tagLength = 16;
  return {
    encrypt(plaintext, output) {
      const plength = plaintext.length;
      output = getOutput(plength + tagLength, output, false);
      output.set(plaintext);
      const oPlain = output.subarray(0, -tagLength);
      xorStream(key, nonce, oPlain, oPlain, 1);
      const tag = computeTag(xorStream, key, nonce, oPlain, AAD);
      output.set(tag, plength);
      clean3(tag);
      return output;
    },
    decrypt(ciphertext, output) {
      output = getOutput(ciphertext.length - tagLength, output, false);
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag = computeTag(xorStream, key, nonce, data, AAD);
      if (!equalBytes2(passedTag, tag))
        throw new Error("invalid tag");
      output.set(ciphertext.subarray(0, -tagLength));
      xorStream(key, nonce, output, output, 1);
      clean3(tag);
      return output;
    }
  };
};
var chacha20poly1305 = wrapCipher({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));
var xchacha20poly1305 = wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));

// node_modules/@noble/curves/esm/utils.js
var _0n9 = BigInt(0);
var _1n8 = BigInt(1);
function _abool2(value, title = "") {
  if (typeof value !== "boolean") {
    const prefix = title && `"${title}"`;
    throw new Error(prefix + "expected boolean, got type=" + typeof value);
  }
  return value;
}
function _abytes2(value, length3, title = "") {
  const bytes = isBytes(value);
  const len = value == null ? void 0 : value.length;
  const needsLen = length3 !== void 0;
  if (!bytes || needsLen && len !== length3) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length3}` : "";
    const got = bytes ? `length=${len}` : `type=${typeof value}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value;
}
function numberToHexUnpadded2(num3) {
  const hex = num3.toString(16);
  return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n9 : BigInt("0x" + hex);
}
function bytesToNumberBE2(bytes) {
  return hexToNumber2(bytesToHex(bytes));
}
function bytesToNumberLE2(bytes) {
  abytes(bytes);
  return hexToNumber2(bytesToHex(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE2(n2, len) {
  return hexToBytes(n2.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE2(n2, len) {
  return numberToBytesBE2(n2, len).reverse();
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e2) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e2);
    }
  } else if (isBytes(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
function equalBytes3(a2, b) {
  if (a2.length !== b.length)
    return false;
  let diff = 0;
  for (let i2 = 0; i2 < a2.length; i2++)
    diff |= a2[i2] ^ b[i2];
  return diff === 0;
}
function copyBytes3(bytes) {
  return Uint8Array.from(bytes);
}
var isPosBig2 = (n2) => typeof n2 === "bigint" && _0n9 <= n2;
function inRange2(n2, min, max) {
  return isPosBig2(n2) && isPosBig2(min) && isPosBig2(max) && min <= n2 && n2 < max;
}
function aInRange2(title, n2, min, max) {
  if (!inRange2(n2, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n2);
}
function bitLen2(n2) {
  let len;
  for (len = 0; n2 > _0n9; n2 >>= _1n8, len += 1)
    ;
  return len;
}
var bitMask2 = (n2) => (_1n8 << BigInt(n2)) - _1n8;
function createHmacDrbg2(hashLen2, qByteLen, hmacFn) {
  if (typeof hashLen2 !== "number" || hashLen2 < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  const u8n = (len) => new Uint8Array(len);
  const u8of = (byte) => Uint8Array.of(byte);
  let v = u8n(hashLen2);
  let k = u8n(hashLen2);
  let i2 = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i2 = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n(0)) => {
    k = h(u8of(0), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8of(1), seed);
    v = h();
  };
  const gen = () => {
    if (i2++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function isHash(val) {
  return typeof val === "function" && Number.isSafeInteger(val.outputLen);
}
function _validateObject(object, fields, optFields = {}) {
  if (!object || typeof object !== "object")
    throw new Error("expected valid options object");
  function checkField(fieldName, expectedType, isOpt) {
    const val = object[fieldName];
    if (isOpt && val === void 0)
      return;
    const current = typeof val;
    if (current !== expectedType || val === null)
      throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
  }
  Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
  Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
var notImplemented2 = () => {
  throw new Error("not implemented");
};
function memoized2(fn) {
  const map2 = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map2.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn(arg, ...args);
    map2.set(arg, computed);
    return computed;
  };
}

// node_modules/@noble/curves/esm/abstract/modular.js
var _0n10 = BigInt(0);
var _1n9 = BigInt(1);
var _2n7 = BigInt(2);
var _3n4 = BigInt(3);
var _4n3 = BigInt(4);
var _5n3 = BigInt(5);
var _7n2 = BigInt(7);
var _8n4 = BigInt(8);
var _9n2 = BigInt(9);
var _16n2 = BigInt(16);
function mod2(a2, b) {
  const result = a2 % b;
  return result >= _0n10 ? result : b + result;
}
function pow22(x, power, modulo) {
  let res = x;
  while (power-- > _0n10) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert2(number2, modulo) {
  if (number2 === _0n10)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n10)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a2 = mod2(number2, modulo);
  let b = modulo;
  let x = _0n10, y = _1n9, u = _1n9, v = _0n10;
  while (a2 !== _0n10) {
    const q = b / a2;
    const r2 = b % a2;
    const m2 = x - u * q;
    const n2 = y - v * q;
    b = a2, a2 = r2, x = u, y = v, u = m2, v = n2;
  }
  const gcd = b;
  if (gcd !== _1n9)
    throw new Error("invert: does not exist");
  return mod2(x, modulo);
}
function assertIsSquare2(Fp3, root, n2) {
  if (!Fp3.eql(Fp3.sqr(root), n2))
    throw new Error("Cannot find square root");
}
function sqrt3mod42(Fp3, n2) {
  const p1div4 = (Fp3.ORDER + _1n9) / _4n3;
  const root = Fp3.pow(n2, p1div4);
  assertIsSquare2(Fp3, root, n2);
  return root;
}
function sqrt5mod82(Fp3, n2) {
  const p5div8 = (Fp3.ORDER - _5n3) / _8n4;
  const n22 = Fp3.mul(n2, _2n7);
  const v = Fp3.pow(n22, p5div8);
  const nv = Fp3.mul(n2, v);
  const i2 = Fp3.mul(Fp3.mul(nv, _2n7), v);
  const root = Fp3.mul(nv, Fp3.sub(i2, Fp3.ONE));
  assertIsSquare2(Fp3, root, n2);
  return root;
}
function sqrt9mod162(P) {
  const Fp_ = Field2(P);
  const tn = tonelliShanks2(P);
  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
  const c2 = tn(Fp_, c1);
  const c3 = tn(Fp_, Fp_.neg(c1));
  const c4 = (P + _7n2) / _16n2;
  return (Fp3, n2) => {
    let tv1 = Fp3.pow(n2, c4);
    let tv2 = Fp3.mul(tv1, c1);
    const tv3 = Fp3.mul(tv1, c2);
    const tv4 = Fp3.mul(tv1, c3);
    const e1 = Fp3.eql(Fp3.sqr(tv2), n2);
    const e2 = Fp3.eql(Fp3.sqr(tv3), n2);
    tv1 = Fp3.cmov(tv1, tv2, e1);
    tv2 = Fp3.cmov(tv4, tv3, e2);
    const e3 = Fp3.eql(Fp3.sqr(tv2), n2);
    const root = Fp3.cmov(tv1, tv2, e3);
    assertIsSquare2(Fp3, root, n2);
    return root;
  };
}
function tonelliShanks2(P) {
  if (P < _3n4)
    throw new Error("sqrt is not defined for small field");
  let Q = P - _1n9;
  let S = 0;
  while (Q % _2n7 === _0n10) {
    Q /= _2n7;
    S++;
  }
  let Z = _2n7;
  const _Fp = Field2(P);
  while (FpLegendre2(_Fp, Z) === 1) {
    if (Z++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S === 1)
    return sqrt3mod42;
  let cc = _Fp.pow(Z, Q);
  const Q1div2 = (Q + _1n9) / _2n7;
  return function tonelliSlow(Fp3, n2) {
    if (Fp3.is0(n2))
      return n2;
    if (FpLegendre2(Fp3, n2) !== 1)
      throw new Error("Cannot find square root");
    let M = S;
    let c2 = Fp3.mul(Fp3.ONE, cc);
    let t2 = Fp3.pow(n2, Q);
    let R = Fp3.pow(n2, Q1div2);
    while (!Fp3.eql(t2, Fp3.ONE)) {
      if (Fp3.is0(t2))
        return Fp3.ZERO;
      let i2 = 1;
      let t_tmp = Fp3.sqr(t2);
      while (!Fp3.eql(t_tmp, Fp3.ONE)) {
        i2++;
        t_tmp = Fp3.sqr(t_tmp);
        if (i2 === M)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n9 << BigInt(M - i2 - 1);
      const b = Fp3.pow(c2, exponent);
      M = i2;
      c2 = Fp3.sqr(b);
      t2 = Fp3.mul(t2, c2);
      R = Fp3.mul(R, b);
    }
    return R;
  };
}
function FpSqrt2(P) {
  if (P % _4n3 === _3n4)
    return sqrt3mod42;
  if (P % _8n4 === _5n3)
    return sqrt5mod82;
  if (P % _16n2 === _9n2)
    return sqrt9mod162(P);
  return tonelliShanks2(P);
}
var isNegativeLE2 = (num3, modulo) => (mod2(num3, modulo) & _1n9) === _1n9;
var FIELD_FIELDS2 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField2(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts = FIELD_FIELDS2.reduce((map2, val) => {
    map2[val] = "function";
    return map2;
  }, initial);
  _validateObject(field, opts);
  return field;
}
function FpPow2(Fp3, num3, power) {
  if (power < _0n10)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n10)
    return Fp3.ONE;
  if (power === _1n9)
    return num3;
  let p2 = Fp3.ONE;
  let d2 = num3;
  while (power > _0n10) {
    if (power & _1n9)
      p2 = Fp3.mul(p2, d2);
    d2 = Fp3.sqr(d2);
    power >>= _1n9;
  }
  return p2;
}
function FpInvertBatch2(Fp3, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp3.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num3, i2) => {
    if (Fp3.is0(num3))
      return acc;
    inverted[i2] = acc;
    return Fp3.mul(acc, num3);
  }, Fp3.ONE);
  const invertedAcc = Fp3.inv(multipliedAcc);
  nums.reduceRight((acc, num3, i2) => {
    if (Fp3.is0(num3))
      return acc;
    inverted[i2] = Fp3.mul(acc, inverted[i2]);
    return Fp3.mul(acc, num3);
  }, invertedAcc);
  return inverted;
}
function FpLegendre2(Fp3, n2) {
  const p1mod2 = (Fp3.ORDER - _1n9) / _2n7;
  const powered = Fp3.pow(n2, p1mod2);
  const yes = Fp3.eql(powered, Fp3.ONE);
  const zero2 = Fp3.eql(powered, Fp3.ZERO);
  const no = Fp3.eql(powered, Fp3.neg(Fp3.ONE));
  if (!yes && !zero2 && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero2 ? 0 : -1;
}
function nLength2(n2, nBitLength) {
  if (nBitLength !== void 0)
    anumber(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field2(ORDER, bitLenOrOpts, isLE4 = false, opts = {}) {
  if (ORDER <= _0n10)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  let _nbitLength = void 0;
  let _sqrt = void 0;
  let modFromBytes = false;
  let allowedLengths = void 0;
  if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
    if (opts.sqrt || isLE4)
      throw new Error("cannot specify opts in two arguments");
    const _opts = bitLenOrOpts;
    if (_opts.BITS)
      _nbitLength = _opts.BITS;
    if (_opts.sqrt)
      _sqrt = _opts.sqrt;
    if (typeof _opts.isLE === "boolean")
      isLE4 = _opts.isLE;
    if (typeof _opts.modFromBytes === "boolean")
      modFromBytes = _opts.modFromBytes;
    allowedLengths = _opts.allowedLengths;
  } else {
    if (typeof bitLenOrOpts === "number")
      _nbitLength = bitLenOrOpts;
    if (opts.sqrt)
      _sqrt = opts.sqrt;
  }
  const { nBitLength: BITS, nByteLength: BYTES } = nLength2(ORDER, _nbitLength);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f3 = Object.freeze({
    ORDER,
    isLE: isLE4,
    BITS,
    BYTES,
    MASK: bitMask2(BITS),
    ZERO: _0n10,
    ONE: _1n9,
    allowedLengths,
    create: (num3) => mod2(num3, ORDER),
    isValid: (num3) => {
      if (typeof num3 !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num3);
      return _0n10 <= num3 && num3 < ORDER;
    },
    is0: (num3) => num3 === _0n10,
    // is valid and invertible
    isValidNot0: (num3) => !f3.is0(num3) && f3.isValid(num3),
    isOdd: (num3) => (num3 & _1n9) === _1n9,
    neg: (num3) => mod2(-num3, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num3) => mod2(num3 * num3, ORDER),
    add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
    pow: (num3, power) => FpPow2(f3, num3, power),
    div: (lhs, rhs) => mod2(lhs * invert2(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num3) => num3 * num3,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num3) => invert2(num3, ORDER),
    sqrt: _sqrt || ((n2) => {
      if (!sqrtP)
        sqrtP = FpSqrt2(ORDER);
      return sqrtP(f3, n2);
    }),
    toBytes: (num3) => isLE4 ? numberToBytesLE2(num3, BYTES) : numberToBytesBE2(num3, BYTES),
    fromBytes: (bytes, skipValidation = true) => {
      if (allowedLengths) {
        if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
          throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
        }
        const padded = new Uint8Array(BYTES);
        padded.set(bytes, isLE4 ? 0 : padded.length - bytes.length);
        bytes = padded;
      }
      if (bytes.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
      let scalar = isLE4 ? bytesToNumberLE2(bytes) : bytesToNumberBE2(bytes);
      if (modFromBytes)
        scalar = mod2(scalar, ORDER);
      if (!skipValidation) {
        if (!f3.isValid(scalar))
          throw new Error("invalid field element: outside of range 0..ORDER");
      }
      return scalar;
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (lst) => FpInvertBatch2(f3, lst),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (a2, b, c2) => c2 ? b : a2
  });
  return Object.freeze(f3);
}
function FpSqrtEven2(Fp3, elm) {
  if (!Fp3.isOdd)
    throw new Error("Field doesn't have isOdd");
  const root = Fp3.sqrt(elm);
  return Fp3.isOdd(root) ? Fp3.neg(root) : root;
}
function getFieldBytesLength2(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength2(fieldOrder) {
  const length3 = getFieldBytesLength2(fieldOrder);
  return length3 + Math.ceil(length3 / 2);
}
function mapHashToField2(key, fieldOrder, isLE4 = false) {
  const len = key.length;
  const fieldLen2 = getFieldBytesLength2(fieldOrder);
  const minLen = getMinHashLength2(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num3 = isLE4 ? bytesToNumberLE2(key) : bytesToNumberBE2(key);
  const reduced = mod2(num3, fieldOrder - _1n9) + _1n9;
  return isLE4 ? numberToBytesLE2(reduced, fieldLen2) : numberToBytesBE2(reduced, fieldLen2);
}

// node_modules/@noble/curves/esm/abstract/curve.js
var _0n11 = BigInt(0);
var _1n10 = BigInt(1);
function negateCt2(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function normalizeZ2(c2, points) {
  const invertedZs = FpInvertBatch2(c2.Fp, points.map((p2) => p2.Z));
  return points.map((p2, i2) => c2.fromAffine(p2.toAffine(invertedZs[i2])));
}
function validateW2(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts2(W, scalarBits) {
  validateW2(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask = bitMask2(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets2(n2, window2, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n2 & mask);
  let nextN = n2 >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n10;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints2(points, c2) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p2, i2) => {
    if (!(p2 instanceof c2))
      throw new Error("invalid point at index " + i2);
  });
}
function validateMSMScalars2(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s2, i2) => {
    if (!field.isValid(s2))
      throw new Error("invalid scalar at index " + i2);
  });
}
var pointPrecomputes2 = /* @__PURE__ */ new WeakMap();
var pointWindowSizes2 = /* @__PURE__ */ new WeakMap();
function getW2(P) {
  return pointWindowSizes2.get(P) || 1;
}
function assert02(n2) {
  if (n2 !== _0n11)
    throw new Error("invalid wNAF");
}
var wNAF2 = class {
  // Parametrized with a given Point class (not individual point)
  constructor(Point2, bits) {
    this.BASE = Point2.BASE;
    this.ZERO = Point2.ZERO;
    this.Fn = Point2.Fn;
    this.bits = bits;
  }
  // non-const time multiplication ladder
  _unsafeLadder(elm, n2, p2 = this.ZERO) {
    let d2 = elm;
    while (n2 > _0n11) {
      if (n2 & _1n10)
        p2 = p2.add(d2);
      d2 = d2.double();
      n2 >>= _1n10;
    }
    return p2;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(1) * (Math.ceil( / ) + 1), where:
   * -  is the window size
   * -  is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(point, W) {
    const { windows, windowSize } = calcWOpts2(W, this.bits);
    const points = [];
    let p2 = point;
    let base4 = p2;
    for (let window2 = 0; window2 < windows; window2++) {
      base4 = p2;
      points.push(base4);
      for (let i2 = 1; i2 < windowSize; i2++) {
        base4 = base4.add(p2);
        points.push(base4);
      }
      p2 = base4.double();
    }
    return points;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(W, precomputes, n2) {
    if (!this.Fn.isValid(n2))
      throw new Error("invalid scalar");
    let p2 = this.ZERO;
    let f3 = this.BASE;
    const wo = calcWOpts2(W, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets2(n2, window2, wo);
      n2 = nextN;
      if (isZero) {
        f3 = f3.add(negateCt2(isNegF, precomputes[offsetF]));
      } else {
        p2 = p2.add(negateCt2(isNeg, precomputes[offset]));
      }
    }
    assert02(n2);
    return { p: p2, f: f3 };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(W, precomputes, n2, acc = this.ZERO) {
    const wo = calcWOpts2(W, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      if (n2 === _0n11)
        break;
      const { nextN, offset, isZero, isNeg } = calcOffsets2(n2, window2, wo);
      n2 = nextN;
      if (isZero) {
        continue;
      } else {
        const item = precomputes[offset];
        acc = acc.add(isNeg ? item.negate() : item);
      }
    }
    assert02(n2);
    return acc;
  }
  getPrecomputes(W, point, transform) {
    let comp = pointPrecomputes2.get(point);
    if (!comp) {
      comp = this.precomputeWindow(point, W);
      if (W !== 1) {
        if (typeof transform === "function")
          comp = transform(comp);
        pointPrecomputes2.set(point, comp);
      }
    }
    return comp;
  }
  cached(point, scalar, transform) {
    const W = getW2(point);
    return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
  }
  unsafe(point, scalar, transform, prev) {
    const W = getW2(point);
    if (W === 1)
      return this._unsafeLadder(point, scalar, prev);
    return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(P, W) {
    validateW2(W, this.bits);
    pointWindowSizes2.set(P, W);
    pointPrecomputes2.delete(P);
  }
  hasCache(elm) {
    return getW2(elm) !== 1;
  }
};
function mulEndoUnsafe2(Point2, point, k1, k2) {
  let acc = point;
  let p1 = Point2.ZERO;
  let p2 = Point2.ZERO;
  while (k1 > _0n11 || k2 > _0n11) {
    if (k1 & _1n10)
      p1 = p1.add(acc);
    if (k2 & _1n10)
      p2 = p2.add(acc);
    acc = acc.double();
    k1 >>= _1n10;
    k2 >>= _1n10;
  }
  return { p1, p2 };
}
function pippenger2(c2, fieldN, points, scalars) {
  validateMSMPoints2(points, c2);
  validateMSMScalars2(scalars, fieldN);
  const plength = points.length;
  const slength = scalars.length;
  if (plength !== slength)
    throw new Error("arrays of points and scalars must have equal length");
  const zero2 = c2.ZERO;
  const wbits = bitLen2(BigInt(plength));
  let windowSize = 1;
  if (wbits > 12)
    windowSize = wbits - 3;
  else if (wbits > 4)
    windowSize = wbits - 2;
  else if (wbits > 0)
    windowSize = 2;
  const MASK = bitMask2(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero2);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero2;
  for (let i2 = lastBits; i2 >= 0; i2 -= windowSize) {
    buckets.fill(zero2);
    for (let j = 0; j < slength; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i2) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero2;
    for (let j = buckets.length - 1, sumI = zero2; j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i2 !== 0)
      for (let j = 0; j < windowSize; j++)
        sum = sum.double();
  }
  return sum;
}
function createField2(order, field, isLE4) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField2(field);
    return field;
  } else {
    return Field2(order, { isLE: isLE4 });
  }
}
function _createCurveFields(type, CURVE2, curveOpts = {}, FpFnLE) {
  if (FpFnLE === void 0)
    FpFnLE = type === "edwards";
  if (!CURVE2 || typeof CURVE2 !== "object")
    throw new Error(`expected valid ${type} CURVE object`);
  for (const p2 of ["p", "n", "h"]) {
    const val = CURVE2[p2];
    if (!(typeof val === "bigint" && val > _0n11))
      throw new Error(`CURVE.${p2} must be positive bigint`);
  }
  const Fp3 = createField2(CURVE2.p, curveOpts.Fp, FpFnLE);
  const Fn3 = createField2(CURVE2.n, curveOpts.Fn, FpFnLE);
  const _b14 = type === "weierstrass" ? "b" : "d";
  const params = ["Gx", "Gy", "a", _b14];
  for (const p2 of params) {
    if (!Fp3.isValid(CURVE2[p2]))
      throw new Error(`CURVE.${p2} must be valid field element of CURVE.Fp`);
  }
  CURVE2 = Object.freeze(Object.assign({}, CURVE2));
  return { CURVE: CURVE2, Fp: Fp3, Fn: Fn3 };
}

// node_modules/@noble/curves/esm/abstract/edwards.js
var _0n12 = BigInt(0);
var _1n11 = BigInt(1);
var _2n8 = BigInt(2);
var _8n5 = BigInt(8);
function isEdValidXY2(Fp3, CURVE2, x, y) {
  const x2 = Fp3.sqr(x);
  const y2 = Fp3.sqr(y);
  const left = Fp3.add(Fp3.mul(CURVE2.a, x2), y2);
  const right = Fp3.add(Fp3.ONE, Fp3.mul(CURVE2.d, Fp3.mul(x2, y2)));
  return Fp3.eql(left, right);
}
function edwards2(params, extraOpts = {}) {
  const validated = _createCurveFields("edwards", params, extraOpts, extraOpts.FpFnLE);
  const { Fp: Fp3, Fn: Fn3 } = validated;
  let CURVE2 = validated.CURVE;
  const { h: cofactor } = CURVE2;
  _validateObject(extraOpts, {}, { uvRatio: "function" });
  const MASK = _2n8 << BigInt(Fn3.BYTES * 8) - _1n11;
  const modP = (n2) => Fp3.create(n2);
  const uvRatio3 = extraOpts.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp3.sqrt(Fp3.div(u, v)) };
    } catch (e2) {
      return { isValid: false, value: _0n12 };
    }
  });
  if (!isEdValidXY2(Fp3, CURVE2, CURVE2.Gx, CURVE2.Gy))
    throw new Error("bad curve params: generator point");
  function acoord(title, n2, banZero = false) {
    const min = banZero ? _1n11 : _0n12;
    aInRange2("coordinate " + title, n2, min, MASK);
    return n2;
  }
  function aextpoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized2((p2, iz) => {
    const { X, Y, Z } = p2;
    const is0 = p2.is0();
    if (iz == null)
      iz = is0 ? _8n5 : Fp3.inv(Z);
    const x = modP(X * iz);
    const y = modP(Y * iz);
    const zz = Fp3.mul(Z, iz);
    if (is0)
      return { x: _0n12, y: _1n11 };
    if (zz !== _1n11)
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized2((p2) => {
    const { a: a2, d: d2 } = CURVE2;
    if (p2.is0())
      throw new Error("bad point: ZERO");
    const { X, Y, Z, T } = p2;
    const X2 = modP(X * X);
    const Y2 = modP(Y * Y);
    const Z2 = modP(Z * Z);
    const Z4 = modP(Z2 * Z2);
    const aX2 = modP(X2 * a2);
    const left = modP(Z2 * modP(aX2 + Y2));
    const right = modP(Z4 + modP(d2 * modP(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT = modP(Z * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point2 {
    constructor(X, Y, Z, T) {
      this.X = acoord("x", X);
      this.Y = acoord("y", Y);
      this.Z = acoord("z", Z, true);
      this.T = acoord("t", T);
      Object.freeze(this);
    }
    static CURVE() {
      return CURVE2;
    }
    static fromAffine(p2) {
      if (p2 instanceof Point2)
        throw new Error("extended point not allowed");
      const { x, y } = p2 || {};
      acoord("x", x);
      acoord("y", y);
      return new Point2(x, y, _1n11, modP(x * y));
    }
    // Uses algo from RFC8032 5.1.3.
    static fromBytes(bytes, zip215 = false) {
      const len = Fp3.BYTES;
      const { a: a2, d: d2 } = CURVE2;
      bytes = copyBytes3(_abytes2(bytes, len, "point"));
      _abool2(zip215, "zip215");
      const normed = copyBytes3(bytes);
      const lastByte = bytes[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y = bytesToNumberLE2(normed);
      const max = zip215 ? MASK : Fp3.ORDER;
      aInRange2("point.y", y, _0n12, max);
      const y2 = modP(y * y);
      const u = modP(y2 - _1n11);
      const v = modP(d2 * y2 - a2);
      let { isValid, value: x } = uvRatio3(u, v);
      if (!isValid)
        throw new Error("bad point: invalid y coordinate");
      const isXOdd = (x & _1n11) === _1n11;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x === _0n12 && isLastByteOdd)
        throw new Error("bad point: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x = modP(-x);
      return Point2.fromAffine({ x, y });
    }
    static fromHex(bytes, zip215 = false) {
      return Point2.fromBytes(ensureBytes("point", bytes), zip215);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_2n8);
      return this;
    }
    // Useful in fromAffine() - not for fromBytes(), which always created valid points.
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      aextpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    negate() {
      return new Point2(modP(-this.X), this.Y, this.Z, modP(-this.T));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a: a2 } = CURVE2;
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const A = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C = modP(_2n8 * modP(Z1 * Z1));
      const D = modP(a2 * A);
      const x1y1 = X1 + Y1;
      const E = modP(modP(x1y1 * x1y1) - A - B);
      const G = D + B;
      const F = G - C;
      const H = D - B;
      const X3 = modP(E * F);
      const Y3 = modP(G * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G);
      return new Point2(X3, Y3, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      aextpoint(other);
      const { a: a2, d: d2 } = CURVE2;
      const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
      const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
      const A = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C = modP(T1 * d2 * T2);
      const D = modP(Z1 * Z2);
      const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D - C;
      const G = D + C;
      const H = modP(B - a2 * A);
      const X3 = modP(E * F);
      const Y3 = modP(G * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G);
      return new Point2(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    // Constant-time multiplication.
    multiply(scalar) {
      if (!Fn3.isValidNot0(scalar))
        throw new Error("invalid scalar: expected 1 <= sc < curve.n");
      const { p: p2, f: f3 } = wnaf.cached(this, scalar, (p3) => normalizeZ2(Point2, p3));
      return normalizeZ2(Point2, [p2, f3])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    // Accepts optional accumulator to merge with multiply (important for sparse scalars)
    multiplyUnsafe(scalar, acc = Point2.ZERO) {
      if (!Fn3.isValid(scalar))
        throw new Error("invalid scalar: expected 0 <= sc < curve.n");
      if (scalar === _0n12)
        return Point2.ZERO;
      if (this.is0() || scalar === _1n11)
        return this;
      return wnaf.unsafe(this, scalar, (p2) => normalizeZ2(Point2, p2), acc);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafe(this, CURVE2.n).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    clearCofactor() {
      if (cofactor === _1n11)
        return this;
      return this.multiplyUnsafe(cofactor);
    }
    toBytes() {
      const { x, y } = this.toAffine();
      const bytes = Fp3.toBytes(y);
      bytes[bytes.length - 1] |= x & _1n11 ? 128 : 0;
      return bytes;
    }
    toHex() {
      return bytesToHex(this.toBytes());
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
    // TODO: remove
    get ex() {
      return this.X;
    }
    get ey() {
      return this.Y;
    }
    get ez() {
      return this.Z;
    }
    get et() {
      return this.T;
    }
    static normalizeZ(points) {
      return normalizeZ2(Point2, points);
    }
    static msm(points, scalars) {
      return pippenger2(Point2, Fn3, points, scalars);
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    toRawBytes() {
      return this.toBytes();
    }
  }
  Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy, _1n11, modP(CURVE2.Gx * CURVE2.Gy));
  Point2.ZERO = new Point2(_0n12, _1n11, _1n11, _0n12);
  Point2.Fp = Fp3;
  Point2.Fn = Fn3;
  const wnaf = new wNAF2(Point2, Fn3.BITS);
  Point2.BASE.precompute(8);
  return Point2;
}
var PrimeEdwardsPoint2 = class {
  constructor(ep) {
    this.ep = ep;
  }
  // Static methods that must be implemented by subclasses
  static fromBytes(_bytes2) {
    notImplemented2();
  }
  static fromHex(_hex) {
    notImplemented2();
  }
  get x() {
    return this.toAffine().x;
  }
  get y() {
    return this.toAffine().y;
  }
  // Common implementations
  clearCofactor() {
    return this;
  }
  assertValidity() {
    this.ep.assertValidity();
  }
  toAffine(invertedZ) {
    return this.ep.toAffine(invertedZ);
  }
  toHex() {
    return bytesToHex(this.toBytes());
  }
  toString() {
    return this.toHex();
  }
  isTorsionFree() {
    return true;
  }
  isSmallOrder() {
    return false;
  }
  add(other) {
    this.assertSame(other);
    return this.init(this.ep.add(other.ep));
  }
  subtract(other) {
    this.assertSame(other);
    return this.init(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return this.init(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return this.init(this.ep.multiplyUnsafe(scalar));
  }
  double() {
    return this.init(this.ep.double());
  }
  negate() {
    return this.init(this.ep.negate());
  }
  precompute(windowSize, isLazy) {
    return this.init(this.ep.precompute(windowSize, isLazy));
  }
  /** @deprecated use `toBytes` */
  toRawBytes() {
    return this.toBytes();
  }
};
function eddsa2(Point2, cHash, eddsaOpts = {}) {
  if (typeof cHash !== "function")
    throw new Error('"hash" function param is required');
  _validateObject(eddsaOpts, {}, {
    adjustScalarBytes: "function",
    randomBytes: "function",
    domain: "function",
    prehash: "function",
    mapToCurve: "function"
  });
  const { prehash } = eddsaOpts;
  const { BASE, Fp: Fp3, Fn: Fn3 } = Point2;
  const randomBytes5 = eddsaOpts.randomBytes || randomBytes;
  const adjustScalarBytes3 = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
  const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
    _abool2(phflag, "phflag");
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function modN_LE(hash) {
    return Fn3.create(bytesToNumberLE2(hash));
  }
  function getPrivateScalar(key) {
    const len = lengths.secretKey;
    key = ensureBytes("private key", key, len);
    const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes3(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    return { head, prefix, scalar };
  }
  function getExtendedPublicKey(secretKey) {
    const { head, prefix, scalar } = getPrivateScalar(secretKey);
    const point = BASE.multiply(scalar);
    const pointBytes = point.toBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey(secretKey) {
    return getExtendedPublicKey(secretKey).pointBytes;
  }
  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
    const msg = concatBytes(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
  }
  function sign3(msg, secretKey, options = {}) {
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
    const r2 = hashDomainToScalar(options.context, prefix, msg);
    const R = BASE.multiply(r2).toBytes();
    const k = hashDomainToScalar(options.context, R, pointBytes, msg);
    const s2 = Fn3.create(r2 + k * scalar);
    if (!Fn3.isValid(s2))
      throw new Error("sign failed: invalid s");
    const rs = concatBytes(R, Fn3.toBytes(s2));
    return _abytes2(rs, lengths.signature, "result");
  }
  const verifyOpts = { zip215: true };
  function verify2(sig, msg, publicKey, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = lengths.signature;
    sig = ensureBytes("signature", sig, len);
    msg = ensureBytes("message", msg);
    publicKey = ensureBytes("publicKey", publicKey, lengths.publicKey);
    if (zip215 !== void 0)
      _abool2(zip215, "zip215");
    if (prehash)
      msg = prehash(msg);
    const mid = len / 2;
    const r2 = sig.subarray(0, mid);
    const s2 = bytesToNumberLE2(sig.subarray(mid, len));
    let A, R, SB;
    try {
      A = Point2.fromBytes(publicKey, zip215);
      R = Point2.fromBytes(r2, zip215);
      SB = BASE.multiplyUnsafe(s2);
    } catch (error) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
    const RkA = R.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().is0();
  }
  const _size2 = Fp3.BYTES;
  const lengths = {
    secretKey: _size2,
    publicKey: _size2,
    signature: 2 * _size2,
    seed: _size2
  };
  function randomSecretKey(seed = randomBytes5(lengths.seed)) {
    return _abytes2(seed, lengths.seed, "seed");
  }
  function keygen(seed) {
    const secretKey = utils2.randomSecretKey(seed);
    return { secretKey, publicKey: getPublicKey(secretKey) };
  }
  function isValidSecretKey(key) {
    return isBytes(key) && key.length === Fn3.BYTES;
  }
  function isValidPublicKey(key, zip215) {
    try {
      return !!Point2.fromBytes(key, zip215);
    } catch (error) {
      return false;
    }
  }
  const utils2 = {
    getExtendedPublicKey,
    randomSecretKey,
    isValidSecretKey,
    isValidPublicKey,
    /**
     * Converts ed public key to x public key. Uses formula:
     * - ed25519:
     *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
     *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
     * - ed448:
     *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
     *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
     */
    toMontgomery(publicKey) {
      const { y } = Point2.fromBytes(publicKey);
      const size = lengths.publicKey;
      const is25519 = size === 32;
      if (!is25519 && size !== 57)
        throw new Error("only defined for 25519 and 448");
      const u = is25519 ? Fp3.div(_1n11 + y, _1n11 - y) : Fp3.div(y - _1n11, y + _1n11);
      return Fp3.toBytes(u);
    },
    toMontgomerySecret(secretKey) {
      const size = lengths.secretKey;
      _abytes2(secretKey, size);
      const hashed = cHash(secretKey.subarray(0, size));
      return adjustScalarBytes3(hashed).subarray(0, size);
    },
    /** @deprecated */
    randomPrivateKey: randomSecretKey,
    /** @deprecated */
    precompute(windowSize = 8, point = Point2.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  return Object.freeze({
    keygen,
    getPublicKey,
    sign: sign3,
    verify: verify2,
    utils: utils2,
    Point: Point2,
    lengths
  });
}
function _eddsa_legacy_opts_to_new(c2) {
  const CURVE2 = {
    a: c2.a,
    d: c2.d,
    p: c2.Fp.ORDER,
    n: c2.n,
    h: c2.h,
    Gx: c2.Gx,
    Gy: c2.Gy
  };
  const Fp3 = c2.Fp;
  const Fn3 = Field2(CURVE2.n, c2.nBitLength, true);
  const curveOpts = { Fp: Fp3, Fn: Fn3, uvRatio: c2.uvRatio };
  const eddsaOpts = {
    randomBytes: c2.randomBytes,
    adjustScalarBytes: c2.adjustScalarBytes,
    domain: c2.domain,
    prehash: c2.prehash,
    mapToCurve: c2.mapToCurve
  };
  return { CURVE: CURVE2, curveOpts, hash: c2.hash, eddsaOpts };
}
function _eddsa_new_output_to_legacy(c2, eddsa3) {
  const Point2 = eddsa3.Point;
  const legacy = Object.assign({}, eddsa3, {
    ExtendedPoint: Point2,
    CURVE: c2,
    nBitLength: Point2.Fn.BITS,
    nByteLength: Point2.Fn.BYTES
  });
  return legacy;
}
function twistedEdwards(c2) {
  const { CURVE: CURVE2, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new(c2);
  const Point2 = edwards2(CURVE2, curveOpts);
  const EDDSA = eddsa2(Point2, hash, eddsaOpts);
  return _eddsa_new_output_to_legacy(c2, EDDSA);
}

// node_modules/@noble/curves/esm/abstract/hash-to-curve.js
var os2ip2 = bytesToNumberBE2;
function i2osp2(value, length3) {
  anum(value);
  anum(length3);
  if (value < 0 || value >= 1 << 8 * length3)
    throw new Error("invalid I2OSP input: " + value);
  const res = Array.from({ length: length3 }).fill(0);
  for (let i2 = length3 - 1; i2 >= 0; i2--) {
    res[i2] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor2(a2, b) {
  const arr = new Uint8Array(a2.length);
  for (let i2 = 0; i2 < a2.length; i2++) {
    arr[i2] = a2[i2] ^ b[i2];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function normDST2(DST) {
  if (!isBytes(DST) && typeof DST !== "string")
    throw new Error("DST must be Uint8Array or string");
  return typeof DST === "string" ? utf8ToBytes(DST) : DST;
}
function expand_message_xmd2(msg, DST, lenInBytes, H) {
  abytes(msg);
  anum(lenInBytes);
  DST = normDST2(DST);
  if (DST.length > 255)
    DST = H(concatBytes(utf8ToBytes("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (lenInBytes > 65535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes(DST, i2osp2(DST.length, 1));
  const Z_pad = i2osp2(0, r_in_bytes);
  const l_i_b_str = i2osp2(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp2(0, 1), DST_prime));
  b[0] = H(concatBytes(b_0, i2osp2(1, 1), DST_prime));
  for (let i2 = 1; i2 <= ell; i2++) {
    const args = [strxor2(b_0, b[i2 - 1]), i2osp2(i2 + 1, 1), DST_prime];
    b[i2] = H(concatBytes(...args));
  }
  const pseudo_random_bytes = concatBytes(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof2(msg, DST, lenInBytes, k, H) {
  abytes(msg);
  anum(lenInBytes);
  DST = normDST2(DST);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp2(lenInBytes, 2)).update(DST).update(i2osp2(DST.length, 1)).digest();
}
function hash_to_field2(msg, count, options) {
  _validateObject(options, {
    p: "bigint",
    m: "number",
    k: "number",
    hash: "function"
  });
  const { p: p2, k, m: m2, hash, expand: expand2, DST } = options;
  if (!isHash(options.hash))
    throw new Error("expected valid hash");
  abytes(msg);
  anum(count);
  const log2p = p2.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m2 * L;
  let prb;
  if (expand2 === "xmd") {
    prb = expand_message_xmd2(msg, DST, len_in_bytes, hash);
  } else if (expand2 === "xof") {
    prb = expand_message_xof2(msg, DST, len_in_bytes, k, hash);
  } else if (expand2 === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i2 = 0; i2 < count; i2++) {
    const e2 = new Array(m2);
    for (let j = 0; j < m2; j++) {
      const elm_offset = L * (j + i2 * m2);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e2[j] = mod2(os2ip2(tv), p2);
    }
    u[i2] = e2;
  }
  return u;
}
function isogenyMap2(field, map2) {
  const coeff = map2.map((i2) => Array.from(i2).reverse());
  return (x, y) => {
    const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i2) => field.add(field.mul(acc, x), i2)));
    const [xd_inv, yd_inv] = FpInvertBatch2(field, [xd, yd], true);
    x = field.mul(xn, xd_inv);
    y = field.mul(y, field.mul(yn, yd_inv));
    return { x, y };
  };
}
var _DST_scalar2 = utf8ToBytes("HashToScalar-");
function createHasher4(Point2, mapToCurve, defaults) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  function map2(num3) {
    return Point2.fromAffine(mapToCurve(num3));
  }
  function clear(initial) {
    const P = initial.clearCofactor();
    if (P.equals(Point2.ZERO))
      return Point2.ZERO;
    P.assertValidity();
    return P;
  }
  return {
    defaults,
    hashToCurve(msg, options) {
      const opts = Object.assign({}, defaults, options);
      const u = hash_to_field2(msg, 2, opts);
      const u0 = map2(u[0]);
      const u1 = map2(u[1]);
      return clear(u0.add(u1));
    },
    encodeToCurve(msg, options) {
      const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
      const opts = Object.assign({}, defaults, optsDst, options);
      const u = hash_to_field2(msg, 1, opts);
      const u0 = map2(u[0]);
      return clear(u0);
    },
    /** See {@link H2CHasher} */
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("expected array of bigints");
      for (const i2 of scalars)
        if (typeof i2 !== "bigint")
          throw new Error("expected array of bigints");
      return clear(map2(scalars));
    },
    // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
    // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
    hashToScalar(msg, options) {
      const N = Point2.Fn.ORDER;
      const opts = Object.assign({}, defaults, { p: N, m: 1, DST: _DST_scalar2 }, options);
      return hash_to_field2(msg, 1, opts)[0][0];
    }
  };
}

// node_modules/@noble/curves/esm/abstract/montgomery.js
var _0n13 = BigInt(0);
var _1n12 = BigInt(1);
var _2n9 = BigInt(2);
function validateOpts2(curve) {
  _validateObject(curve, {
    adjustScalarBytes: "function",
    powPminus2: "function"
  });
  return Object.freeze({ ...curve });
}
function montgomery2(curveDef) {
  const CURVE2 = validateOpts2(curveDef);
  const { P, type, adjustScalarBytes: adjustScalarBytes3, powPminus2, randomBytes: rand } = CURVE2;
  const is25519 = type === "x25519";
  if (!is25519 && type !== "x448")
    throw new Error("invalid type");
  const randomBytes_ = rand || randomBytes;
  const montgomeryBits = is25519 ? 255 : 448;
  const fieldLen2 = is25519 ? 32 : 56;
  const Gu = is25519 ? BigInt(9) : BigInt(5);
  const a24 = is25519 ? BigInt(121665) : BigInt(39081);
  const minScalar = is25519 ? _2n9 ** BigInt(254) : _2n9 ** BigInt(447);
  const maxAdded = is25519 ? BigInt(8) * _2n9 ** BigInt(251) - _1n12 : BigInt(4) * _2n9 ** BigInt(445) - _1n12;
  const maxScalar = minScalar + maxAdded + _1n12;
  const modP = (n2) => mod2(n2, P);
  const GuBytes = encodeU(Gu);
  function encodeU(u) {
    return numberToBytesLE2(modP(u), fieldLen2);
  }
  function decodeU(u) {
    const _u = ensureBytes("u coordinate", u, fieldLen2);
    if (is25519)
      _u[31] &= 127;
    return modP(bytesToNumberLE2(_u));
  }
  function decodeScalar(scalar) {
    return bytesToNumberLE2(adjustScalarBytes3(ensureBytes("scalar", scalar, fieldLen2)));
  }
  function scalarMult(scalar, u) {
    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
    if (pu === _0n13)
      throw new Error("invalid private or public key received");
    return encodeU(pu);
  }
  function scalarMultBase(scalar) {
    return scalarMult(scalar, GuBytes);
  }
  function cswap(swap, x_2, x_3) {
    const dummy = modP(swap * (x_2 - x_3));
    x_2 = modP(x_2 - dummy);
    x_3 = modP(x_3 + dummy);
    return { x_2, x_3 };
  }
  function montgomeryLadder(u, scalar) {
    aInRange2("u", u, _0n13, P);
    aInRange2("scalar", scalar, minScalar, maxScalar);
    const k = scalar;
    const x_1 = u;
    let x_2 = _1n12;
    let z_2 = _0n13;
    let x_3 = u;
    let z_3 = _1n12;
    let swap = _0n13;
    for (let t2 = BigInt(montgomeryBits - 1); t2 >= _0n13; t2--) {
      const k_t = k >> t2 & _1n12;
      swap ^= k_t;
      ({ x_2, x_3 } = cswap(swap, x_2, x_3));
      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
      swap = k_t;
      const A = x_2 + z_2;
      const AA = modP(A * A);
      const B = x_2 - z_2;
      const BB = modP(B * B);
      const E = AA - BB;
      const C = x_3 + z_3;
      const D = x_3 - z_3;
      const DA = modP(D * A);
      const CB = modP(C * B);
      const dacb = DA + CB;
      const da_cb = DA - CB;
      x_3 = modP(dacb * dacb);
      z_3 = modP(x_1 * modP(da_cb * da_cb));
      x_2 = modP(AA * BB);
      z_2 = modP(E * (AA + modP(a24 * E)));
    }
    ({ x_2, x_3 } = cswap(swap, x_2, x_3));
    ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
    const z2 = powPminus2(z_2);
    return modP(x_2 * z2);
  }
  const lengths = {
    secretKey: fieldLen2,
    publicKey: fieldLen2,
    seed: fieldLen2
  };
  const randomSecretKey = (seed = randomBytes_(fieldLen2)) => {
    abytes(seed, lengths.seed);
    return seed;
  };
  function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: scalarMultBase(secretKey) };
  }
  const utils2 = {
    randomSecretKey,
    randomPrivateKey: randomSecretKey
  };
  return {
    keygen,
    getSharedSecret: (secretKey, publicKey) => scalarMult(secretKey, publicKey),
    getPublicKey: (secretKey) => scalarMultBase(secretKey),
    scalarMult,
    scalarMultBase,
    utils: utils2,
    GuBytes: GuBytes.slice(),
    lengths
  };
}

// node_modules/@noble/curves/esm/ed25519.js
var _0n14 = BigInt(0);
var _1n13 = BigInt(1);
var _2n10 = BigInt(2);
var _3n5 = BigInt(3);
var _5n4 = BigInt(5);
var _8n6 = BigInt(8);
var ed25519_CURVE_p2 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
var ed25519_CURVE2 = (() => ({
  p: ed25519_CURVE_p2,
  n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
  h: _8n6,
  a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
  d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
  Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
  Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
}))();
function ed25519_pow_2_252_32(x) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P = ed25519_CURVE_p2;
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow22(b2, _2n10, P) * b2 % P;
  const b5 = pow22(b4, _1n13, P) * x % P;
  const b10 = pow22(b5, _5n4, P) * b5 % P;
  const b20 = pow22(b10, _10n, P) * b10 % P;
  const b40 = pow22(b20, _20n, P) * b20 % P;
  const b80 = pow22(b40, _40n, P) * b40 % P;
  const b160 = pow22(b80, _80n, P) * b80 % P;
  const b240 = pow22(b160, _80n, P) * b80 % P;
  const b250 = pow22(b240, _10n, P) * b10 % P;
  const pow_p_5_8 = pow22(b250, _2n10, P) * x % P;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes2(bytes) {
  bytes[0] &= 248;
  bytes[31] &= 127;
  bytes[31] |= 64;
  return bytes;
}
var ED25519_SQRT_M12 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
function uvRatio2(u, v) {
  const P = ed25519_CURVE_p2;
  const v32 = mod2(v * v * v, P);
  const v7 = mod2(v32 * v32 * v, P);
  const pow = ed25519_pow_2_252_32(u * v7).pow_p_5_8;
  let x = mod2(u * v32 * pow, P);
  const vx2 = mod2(v * x * x, P);
  const root1 = x;
  const root2 = mod2(x * ED25519_SQRT_M12, P);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod2(-u, P);
  const noRoot = vx2 === mod2(-u * ED25519_SQRT_M12, P);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (isNegativeLE2(x, P))
    x = mod2(-x, P);
  return { isValid: useRoot1 || useRoot2, value: x };
}
var Fp2 = (() => Field2(ed25519_CURVE2.p, { isLE: true }))();
var Fn2 = (() => Field2(ed25519_CURVE2.n, { isLE: true }))();
var ed25519Defaults = (() => ({
  ...ed25519_CURVE2,
  Fp: Fp2,
  hash: sha5122,
  adjustScalarBytes: adjustScalarBytes2,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/v
  uvRatio: uvRatio2
}))();
var ed255192 = (() => twistedEdwards(ed25519Defaults))();
function ed25519_domain2(data, ctx, phflag) {
  if (ctx.length > 255)
    throw new Error("Context is too big");
  return concatBytes(utf8ToBytes("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
}
var ed25519ctx2 = (() => twistedEdwards({
  ...ed25519Defaults,
  domain: ed25519_domain2
}))();
var ed25519ph2 = (() => twistedEdwards(Object.assign({}, ed25519Defaults, {
  domain: ed25519_domain2,
  prehash: sha5122
})))();
var x255192 = (() => {
  const P = Fp2.ORDER;
  return montgomery2({
    P,
    type: "x25519",
    powPminus2: (x) => {
      const { pow_p_5_8, b2 } = ed25519_pow_2_252_32(x);
      return mod2(pow22(pow_p_5_8, _3n5, P) * b2, P);
    },
    adjustScalarBytes: adjustScalarBytes2
  });
})();
var ELL2_C12 = (() => (ed25519_CURVE_p2 + _3n5) / _8n6)();
var ELL2_C22 = (() => Fp2.pow(_2n10, ELL2_C12))();
var ELL2_C32 = (() => Fp2.sqrt(Fp2.neg(Fp2.ONE)))();
function map_to_curve_elligator2_curve25519(u) {
  const ELL2_C4 = (ed25519_CURVE_p2 - _5n4) / _8n6;
  const ELL2_J = BigInt(486662);
  let tv1 = Fp2.sqr(u);
  tv1 = Fp2.mul(tv1, _2n10);
  let xd = Fp2.add(tv1, Fp2.ONE);
  let x1n = Fp2.neg(ELL2_J);
  let tv2 = Fp2.sqr(xd);
  let gxd = Fp2.mul(tv2, xd);
  let gx1 = Fp2.mul(tv1, ELL2_J);
  gx1 = Fp2.mul(gx1, x1n);
  gx1 = Fp2.add(gx1, tv2);
  gx1 = Fp2.mul(gx1, x1n);
  let tv3 = Fp2.sqr(gxd);
  tv2 = Fp2.sqr(tv3);
  tv3 = Fp2.mul(tv3, gxd);
  tv3 = Fp2.mul(tv3, gx1);
  tv2 = Fp2.mul(tv2, tv3);
  let y11 = Fp2.pow(tv2, ELL2_C4);
  y11 = Fp2.mul(y11, tv3);
  let y12 = Fp2.mul(y11, ELL2_C32);
  tv2 = Fp2.sqr(y11);
  tv2 = Fp2.mul(tv2, gxd);
  let e1 = Fp2.eql(tv2, gx1);
  let y1 = Fp2.cmov(y12, y11, e1);
  let x2n = Fp2.mul(x1n, tv1);
  let y21 = Fp2.mul(y11, u);
  y21 = Fp2.mul(y21, ELL2_C22);
  let y22 = Fp2.mul(y21, ELL2_C32);
  let gx2 = Fp2.mul(gx1, tv1);
  tv2 = Fp2.sqr(y21);
  tv2 = Fp2.mul(tv2, gxd);
  let e2 = Fp2.eql(tv2, gx2);
  let y2 = Fp2.cmov(y22, y21, e2);
  tv2 = Fp2.sqr(y1);
  tv2 = Fp2.mul(tv2, gxd);
  let e3 = Fp2.eql(tv2, gx1);
  let xn = Fp2.cmov(x2n, x1n, e3);
  let y = Fp2.cmov(y2, y1, e3);
  let e4 = Fp2.isOdd(y);
  y = Fp2.cmov(y, Fp2.neg(y), e3 !== e4);
  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n13 };
}
var ELL2_C1_EDWARDS2 = (() => FpSqrtEven2(Fp2, Fp2.neg(BigInt(486664))))();
function map_to_curve_elligator2_edwards255192(u) {
  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
  let xn = Fp2.mul(xMn, yMd);
  xn = Fp2.mul(xn, ELL2_C1_EDWARDS2);
  let xd = Fp2.mul(xMd, yMn);
  let yn = Fp2.sub(xMn, xMd);
  let yd = Fp2.add(xMn, xMd);
  let tv1 = Fp2.mul(xd, yd);
  let e2 = Fp2.eql(tv1, Fp2.ZERO);
  xn = Fp2.cmov(xn, Fp2.ZERO, e2);
  xd = Fp2.cmov(xd, Fp2.ONE, e2);
  yn = Fp2.cmov(yn, Fp2.ONE, e2);
  yd = Fp2.cmov(yd, Fp2.ONE, e2);
  const [xd_inv, yd_inv] = FpInvertBatch2(Fp2, [xd, yd], true);
  return { x: Fp2.mul(xn, xd_inv), y: Fp2.mul(yn, yd_inv) };
}
var ed25519_hasher2 = (() => createHasher4(ed255192.Point, (scalars) => map_to_curve_elligator2_edwards255192(scalars[0]), {
  DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
  encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
  p: ed25519_CURVE_p2,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha5122
}))();
var SQRT_M12 = ED25519_SQRT_M12;
var SQRT_AD_MINUS_ONE2 = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D2 = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ2 = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ2 = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var invertSqrt2 = (number2) => uvRatio2(_1n13, number2);
var MAX_255B2 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var bytes255ToNumberLE2 = (bytes) => ed255192.Point.Fp.create(bytesToNumberLE2(bytes) & MAX_255B2);
function calcElligatorRistrettoMap2(r0) {
  const { d: d2 } = ed25519_CURVE2;
  const P = ed25519_CURVE_p2;
  const mod4 = (n2) => Fp2.create(n2);
  const r2 = mod4(SQRT_M12 * r0 * r0);
  const Ns = mod4((r2 + _1n13) * ONE_MINUS_D_SQ2);
  let c2 = BigInt(-1);
  const D = mod4((c2 - d2 * r2) * mod4(r2 + d2));
  let { isValid: Ns_D_is_sq, value: s2 } = uvRatio2(Ns, D);
  let s_ = mod4(s2 * r0);
  if (!isNegativeLE2(s_, P))
    s_ = mod4(-s_);
  if (!Ns_D_is_sq)
    s2 = s_;
  if (!Ns_D_is_sq)
    c2 = r2;
  const Nt = mod4(c2 * (r2 - _1n13) * D_MINUS_ONE_SQ2 - D);
  const s22 = s2 * s2;
  const W0 = mod4((s2 + s2) * D);
  const W1 = mod4(Nt * SQRT_AD_MINUS_ONE2);
  const W2 = mod4(_1n13 - s22);
  const W3 = mod4(_1n13 + s22);
  return new ed255192.Point(mod4(W0 * W3), mod4(W2 * W1), mod4(W1 * W3), mod4(W0 * W2));
}
function ristretto255_map(bytes) {
  abytes(bytes, 64);
  const r1 = bytes255ToNumberLE2(bytes.subarray(0, 32));
  const R1 = calcElligatorRistrettoMap2(r1);
  const r2 = bytes255ToNumberLE2(bytes.subarray(32, 64));
  const R2 = calcElligatorRistrettoMap2(r2);
  return new _RistrettoPoint2(R1.add(R2));
}
var _RistrettoPoint2 = class __RistrettoPoint2 extends PrimeEdwardsPoint2 {
  constructor(ep) {
    super(ep);
  }
  static fromAffine(ap) {
    return new __RistrettoPoint2(ed255192.Point.fromAffine(ap));
  }
  assertSame(other) {
    if (!(other instanceof __RistrettoPoint2))
      throw new Error("RistrettoPoint expected");
  }
  init(ep) {
    return new __RistrettoPoint2(ep);
  }
  /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
  static hashToCurve(hex) {
    return ristretto255_map(ensureBytes("ristrettoHash", hex, 64));
  }
  static fromBytes(bytes) {
    abytes(bytes, 32);
    const { a: a2, d: d2 } = ed25519_CURVE2;
    const P = ed25519_CURVE_p2;
    const mod4 = (n2) => Fp2.create(n2);
    const s2 = bytes255ToNumberLE2(bytes);
    if (!equalBytes3(Fp2.toBytes(s2), bytes) || isNegativeLE2(s2, P))
      throw new Error("invalid ristretto255 encoding 1");
    const s22 = mod4(s2 * s2);
    const u1 = mod4(_1n13 + a2 * s22);
    const u2 = mod4(_1n13 - a2 * s22);
    const u1_2 = mod4(u1 * u1);
    const u2_2 = mod4(u2 * u2);
    const v = mod4(a2 * d2 * u1_2 - u2_2);
    const { isValid, value: I } = invertSqrt2(mod4(v * u2_2));
    const Dx = mod4(I * u2);
    const Dy = mod4(I * Dx * v);
    let x = mod4((s2 + s2) * Dx);
    if (isNegativeLE2(x, P))
      x = mod4(-x);
    const y = mod4(u1 * Dy);
    const t2 = mod4(x * y);
    if (!isValid || isNegativeLE2(t2, P) || y === _0n14)
      throw new Error("invalid ristretto255 encoding 2");
    return new __RistrettoPoint2(new ed255192.Point(x, y, _1n13, t2));
  }
  /**
   * Converts ristretto-encoded string to ristretto point.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
   */
  static fromHex(hex) {
    return __RistrettoPoint2.fromBytes(ensureBytes("ristrettoHex", hex, 32));
  }
  static msm(points, scalars) {
    return pippenger2(__RistrettoPoint2, ed255192.Point.Fn, points, scalars);
  }
  /**
   * Encodes ristretto point to Uint8Array.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
   */
  toBytes() {
    let { X, Y, Z, T } = this.ep;
    const P = ed25519_CURVE_p2;
    const mod4 = (n2) => Fp2.create(n2);
    const u1 = mod4(mod4(Z + Y) * mod4(Z - Y));
    const u2 = mod4(X * Y);
    const u2sq = mod4(u2 * u2);
    const { value: invsqrt } = invertSqrt2(mod4(u1 * u2sq));
    const D1 = mod4(invsqrt * u1);
    const D2 = mod4(invsqrt * u2);
    const zInv = mod4(D1 * D2 * T);
    let D;
    if (isNegativeLE2(T * zInv, P)) {
      let _x = mod4(Y * SQRT_M12);
      let _y = mod4(X * SQRT_M12);
      X = _x;
      Y = _y;
      D = mod4(D1 * INVSQRT_A_MINUS_D2);
    } else {
      D = D2;
    }
    if (isNegativeLE2(X * zInv, P))
      Y = mod4(-Y);
    let s2 = mod4((Z - Y) * D);
    if (isNegativeLE2(s2, P))
      s2 = mod4(-s2);
    return Fp2.toBytes(s2);
  }
  /**
   * Compares two Ristretto points.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
   */
  equals(other) {
    this.assertSame(other);
    const { X: X1, Y: Y1 } = this.ep;
    const { X: X2, Y: Y2 } = other.ep;
    const mod4 = (n2) => Fp2.create(n2);
    const one = mod4(X1 * Y2) === mod4(Y1 * X2);
    const two = mod4(Y1 * Y2) === mod4(X1 * X2);
    return one || two;
  }
  is0() {
    return this.equals(__RistrettoPoint2.ZERO);
  }
};
_RistrettoPoint2.BASE = (() => new _RistrettoPoint2(ed255192.Point.BASE))();
_RistrettoPoint2.ZERO = (() => new _RistrettoPoint2(ed255192.Point.ZERO))();
_RistrettoPoint2.Fp = /* @__PURE__ */ (() => Fp2)();
_RistrettoPoint2.Fn = /* @__PURE__ */ (() => Fn2)();
var ristretto255_hasher2 = {
  hashToCurve(msg, options) {
    const DST = (options == null ? void 0 : options.DST) || "ristretto255_XMD:SHA-512_R255MAP_RO_";
    const xmd = expand_message_xmd2(msg, DST, 64, sha5122);
    return ristretto255_map(xmd);
  },
  hashToScalar(msg, options = { DST: _DST_scalar2 }) {
    const xmd = expand_message_xmd2(msg, options.DST, 64, sha5122);
    return Fn2.create(bytesToNumberLE2(xmd));
  }
};
var hashToCurve = (() => ed25519_hasher2.hashToCurve)();
var encodeToCurve = (() => ed25519_hasher2.encodeToCurve)();
var hashToRistretto255 = (() => ristretto255_hasher2.hashToCurve)();
var hash_to_ristretto255 = (() => ristretto255_hasher2.hashToCurve)();

// node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash(hash);
    const key = toBytes(_key);
    this.iHash = hash.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
    for (let i2 = 0; i2 < pad.length; i2++)
      pad[i2] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash.create();
    for (let i2 = 0; i2 < pad.length; i2++)
      pad[i2] ^= 54 ^ 92;
    this.oHash.update(pad);
    clean(pad);
  }
  update(buf) {
    aexists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac2 = (hash, key, message2) => new HMAC(hash, key).update(message2).digest();
hmac2.create = (hash, key) => new HMAC(hash, key);

// node_modules/@noble/hashes/esm/hkdf.js
function extract(hash, ikm, salt) {
  ahash(hash);
  if (salt === void 0)
    salt = new Uint8Array(hash.outputLen);
  return hmac2(hash, toBytes(salt), toBytes(ikm));
}
var HKDF_COUNTER = Uint8Array.from([0]);
var EMPTY_BUFFER = Uint8Array.of();
function expand(hash, prk, info, length3 = 32) {
  ahash(hash);
  anumber(length3);
  const olen = hash.outputLen;
  if (length3 > 255 * olen)
    throw new Error("Length should be <= 255*HashLen");
  const blocks = Math.ceil(length3 / olen);
  if (info === void 0)
    info = EMPTY_BUFFER;
  const okm = new Uint8Array(blocks * olen);
  const HMAC2 = hmac2.create(hash, prk);
  const HMACTmp = HMAC2._cloneInto();
  const T = new Uint8Array(HMAC2.outputLen);
  for (let counter = 0; counter < blocks; counter++) {
    HKDF_COUNTER[0] = counter + 1;
    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
    okm.set(T, olen * counter);
    HMAC2._cloneInto(HMACTmp);
  }
  HMAC2.destroy();
  HMACTmp.destroy();
  clean(T, HKDF_COUNTER);
  return okm.slice(0, length3);
}

// node_modules/@chainsafe/libp2p-noise/dist/src/crypto/js.js
var pureJsCrypto = {
  hashSHA256(data) {
    return sha2563(data.subarray());
  },
  getHKDF(ck, ikm) {
    const prk = extract(sha2563, ikm, ck);
    const okmU8Array = expand(sha2563, prk, void 0, 96);
    const okm = okmU8Array;
    const k1 = okm.subarray(0, 32);
    const k2 = okm.subarray(32, 64);
    const k3 = okm.subarray(64, 96);
    return [k1, k2, k3];
  },
  generateX25519KeyPair() {
    const secretKey = x255192.utils.randomPrivateKey();
    const publicKey = x255192.getPublicKey(secretKey);
    return {
      publicKey,
      privateKey: secretKey
    };
  },
  generateX25519KeyPairFromSeed(seed) {
    const publicKey = x255192.getPublicKey(seed);
    return {
      publicKey,
      privateKey: seed
    };
  },
  generateX25519SharedKey(privateKey, publicKey) {
    return x255192.getSharedSecret(privateKey.subarray(), publicKey.subarray());
  },
  chaCha20Poly1305Encrypt(plaintext, nonce, ad, k) {
    return chacha20poly1305(k, nonce, ad).encrypt(plaintext.subarray());
  },
  chaCha20Poly1305Decrypt(ciphertext, nonce, ad, k, dst) {
    return chacha20poly1305(k, nonce, ad).decrypt(ciphertext.subarray(), dst);
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/crypto/index.browser.js
var defaultCrypto = pureJsCrypto;

// node_modules/@chainsafe/libp2p-noise/dist/src/crypto.js
function wrapCrypto(crypto4) {
  return {
    generateKeypair: crypto4.generateX25519KeyPair,
    dh: (keypair, publicKey) => crypto4.generateX25519SharedKey(keypair.privateKey, publicKey).subarray(0, 32),
    encrypt: crypto4.chaCha20Poly1305Encrypt,
    decrypt: crypto4.chaCha20Poly1305Decrypt,
    hash: crypto4.hashSHA256,
    hkdf: crypto4.getHKDF
  };
}

// node_modules/@chainsafe/libp2p-noise/dist/src/encoder.js
var uint16BEEncode = (value) => {
  const target = allocUnsafe(2);
  target[0] = value >> 8;
  target[1] = value;
  return target;
};
uint16BEEncode.bytes = 2;
var uint16BEDecode = (data) => {
  if (data.length < 2)
    throw RangeError("Could not decode int16BE");
  if (data instanceof Uint8Array) {
    let value = 0;
    value += data[0] << 8;
    value += data[1];
    return value;
  }
  return data.getUint16(0);
};
uint16BEDecode.bytes = 2;

// node_modules/@chainsafe/libp2p-noise/dist/src/metrics.js
function registerMetrics(metrics) {
  return {
    xxHandshakeSuccesses: metrics.registerCounter("libp2p_noise_xxhandshake_successes_total", {
      help: "Total count of noise xxHandshakes successes_"
    }),
    xxHandshakeErrors: metrics.registerCounter("libp2p_noise_xxhandshake_error_total", {
      help: "Total count of noise xxHandshakes errors"
    }),
    encryptedPackets: metrics.registerCounter("libp2p_noise_encrypted_packets_total", {
      help: "Total count of noise encrypted packets successfully"
    }),
    decryptedPackets: metrics.registerCounter("libp2p_noise_decrypted_packets_total", {
      help: "Total count of noise decrypted packets"
    }),
    decryptErrors: metrics.registerCounter("libp2p_noise_decrypt_errors_total", {
      help: "Total count of noise decrypt errors"
    })
  };
}

// node_modules/@chainsafe/libp2p-noise/dist/src/logger.js
function logLocalStaticKeys(s2, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  if (s2) {
    keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${toString2(s2.publicKey, "hex")}`);
    keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${toString2(s2.privateKey, "hex")}`);
  } else {
    keyLogger("Missing local static keys.");
  }
}
function logLocalEphemeralKeys(e2, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  if (e2) {
    keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${toString2(e2.publicKey, "hex")}`);
    keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${toString2(e2.privateKey, "hex")}`);
  } else {
    keyLogger("Missing local ephemeral keys.");
  }
}
function logRemoteStaticKey(rs, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  if (rs) {
    keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${toString2(rs.subarray(), "hex")}`);
  } else {
    keyLogger("Missing remote static public key.");
  }
}
function logRemoteEphemeralKey(re, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  if (re) {
    keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${toString2(re.subarray(), "hex")}`);
  } else {
    keyLogger("Missing remote ephemeral keys.");
  }
}
function logCipherState(cs1, cs2, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  keyLogger(`CIPHER_STATE_1 ${cs1.n.getUint64()} ${cs1.k && toString2(cs1.k, "hex")}`);
  keyLogger(`CIPHER_STATE_2 ${cs2.n.getUint64()} ${cs2.k && toString2(cs2.k, "hex")}`);
}

// node_modules/@chainsafe/libp2p-noise/dist/src/errors.js
var _InvalidCryptoExchangeError = class _InvalidCryptoExchangeError extends Error {
  constructor(message2 = "Invalid crypto exchange") {
    super(message2);
    __publicField(this, "code");
    this.code = _InvalidCryptoExchangeError.code;
  }
};
__publicField(_InvalidCryptoExchangeError, "code", "ERR_INVALID_CRYPTO_EXCHANGE");
var InvalidCryptoExchangeError2 = _InvalidCryptoExchangeError;

// node_modules/@chainsafe/libp2p-noise/dist/src/nonce.js
var MIN_NONCE = 0;
var MAX_NONCE = 4294967295;
var ERR_MAX_NONCE = "Cipherstate has reached maximum n, a new handshake must be performed";
var Nonce = class {
  constructor(n2 = MIN_NONCE) {
    __publicField(this, "n");
    __publicField(this, "bytes");
    __publicField(this, "view");
    this.n = n2;
    this.bytes = alloc(12);
    this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength);
    this.view.setUint32(4, n2, true);
  }
  increment() {
    this.n++;
    this.view.setUint32(4, this.n, true);
  }
  getBytes() {
    return this.bytes;
  }
  getUint64() {
    return this.n;
  }
  assertValue() {
    if (this.n > MAX_NONCE) {
      throw new Error(ERR_MAX_NONCE);
    }
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/protocol.js
var ZEROLEN = alloc(0);
var CipherState = class {
  constructor(crypto4, k = void 0, n2 = 0) {
    __publicField(this, "k");
    __publicField(this, "n");
    __publicField(this, "crypto");
    this.crypto = crypto4;
    this.k = k;
    this.n = new Nonce(n2);
  }
  hasKey() {
    return Boolean(this.k);
  }
  encryptWithAd(ad, plaintext) {
    if (!this.hasKey()) {
      return plaintext;
    }
    this.n.assertValue();
    const e2 = this.crypto.encrypt(plaintext, this.n.getBytes(), ad, this.k);
    this.n.increment();
    return e2;
  }
  decryptWithAd(ad, ciphertext, dst) {
    if (!this.hasKey()) {
      return ciphertext;
    }
    this.n.assertValue();
    const plaintext = this.crypto.decrypt(ciphertext, this.n.getBytes(), ad, this.k, dst);
    this.n.increment();
    return plaintext;
  }
};
var SymmetricState = class {
  constructor(crypto4, protocolName) {
    __publicField(this, "cs");
    __publicField(this, "ck");
    __publicField(this, "h");
    __publicField(this, "crypto");
    this.crypto = crypto4;
    const protocolNameBytes = fromString2(protocolName, "utf-8");
    this.h = hashProtocolName(crypto4, protocolNameBytes);
    this.ck = this.h;
    this.cs = new CipherState(crypto4);
  }
  mixKey(ikm) {
    const [ck, tempK] = this.crypto.hkdf(this.ck, ikm);
    this.ck = ck;
    this.cs = new CipherState(this.crypto, tempK);
  }
  mixHash(data) {
    this.h = this.crypto.hash(new Uint8ArrayList(this.h, data));
  }
  encryptAndHash(plaintext) {
    const ciphertext = this.cs.encryptWithAd(this.h, plaintext);
    this.mixHash(ciphertext);
    return ciphertext;
  }
  decryptAndHash(ciphertext) {
    const plaintext = this.cs.decryptWithAd(this.h, ciphertext);
    this.mixHash(ciphertext);
    return plaintext;
  }
  split() {
    const [tempK1, tempK2] = this.crypto.hkdf(this.ck, ZEROLEN);
    return [new CipherState(this.crypto, tempK1), new CipherState(this.crypto, tempK2)];
  }
};
var AbstractHandshakeState = class {
  constructor(init) {
    __publicField(this, "ss");
    __publicField(this, "s");
    __publicField(this, "e");
    __publicField(this, "rs");
    __publicField(this, "re");
    __publicField(this, "initiator");
    __publicField(this, "crypto");
    const { crypto: crypto4, protocolName, prologue, initiator, s: s2, e: e2, rs, re } = init;
    this.crypto = crypto4;
    this.ss = new SymmetricState(crypto4, protocolName);
    this.ss.mixHash(prologue);
    this.initiator = initiator;
    this.s = s2;
    this.e = e2;
    this.rs = rs;
    this.re = re;
  }
  writeE() {
    if (this.e) {
      throw new Error("ephemeral keypair is already set");
    }
    const e2 = this.crypto.generateKeypair();
    this.ss.mixHash(e2.publicKey);
    this.e = e2;
    return e2.publicKey;
  }
  writeS() {
    if (!this.s) {
      throw new Error("static keypair is not set");
    }
    return this.ss.encryptAndHash(this.s.publicKey);
  }
  writeEE() {
    if (!this.e) {
      throw new Error("ephemeral keypair is not set");
    }
    if (!this.re) {
      throw new Error("remote ephemeral public key is not set");
    }
    this.ss.mixKey(this.crypto.dh(this.e, this.re));
  }
  writeES() {
    if (this.initiator) {
      if (!this.e) {
        throw new Error("ephemeral keypair is not set");
      }
      if (!this.rs) {
        throw new Error("remote static public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.e, this.rs));
    } else {
      if (!this.s) {
        throw new Error("static keypair is not set");
      }
      if (!this.re) {
        throw new Error("remote ephemeral public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.s, this.re));
    }
  }
  writeSE() {
    if (this.initiator) {
      if (!this.s) {
        throw new Error("static keypair is not set");
      }
      if (!this.re) {
        throw new Error("remote ephemeral public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.s, this.re));
    } else {
      if (!this.e) {
        throw new Error("ephemeral keypair is not set");
      }
      if (!this.rs) {
        throw new Error("remote static public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.e, this.rs));
    }
  }
  readE(message2, offset = 0) {
    if (this.re) {
      throw new Error("remote ephemeral public key is already set");
    }
    if (message2.byteLength < offset + 32) {
      throw new Error("message is not long enough");
    }
    this.re = message2.sublist(offset, offset + 32);
    this.ss.mixHash(this.re);
  }
  readS(message2, offset = 0) {
    if (this.rs) {
      throw new Error("remote static public key is already set");
    }
    const cipherLength = 32 + (this.ss.cs.hasKey() ? 16 : 0);
    if (message2.byteLength < offset + cipherLength) {
      throw new Error("message is not long enough");
    }
    const temp = message2.sublist(offset, offset + cipherLength);
    this.rs = this.ss.decryptAndHash(temp);
    return cipherLength;
  }
  readEE() {
    this.writeEE();
  }
  readES() {
    this.writeES();
  }
  readSE() {
    this.writeSE();
  }
};
var XXHandshakeState = class extends AbstractHandshakeState {
  // e
  writeMessageA(payload) {
    return new Uint8ArrayList(this.writeE(), this.ss.encryptAndHash(payload));
  }
  // e, ee, s, es
  writeMessageB(payload) {
    const e2 = this.writeE();
    this.writeEE();
    const encS = this.writeS();
    this.writeES();
    return new Uint8ArrayList(e2, encS, this.ss.encryptAndHash(payload));
  }
  // s, se
  writeMessageC(payload) {
    const encS = this.writeS();
    this.writeSE();
    return new Uint8ArrayList(encS, this.ss.encryptAndHash(payload));
  }
  // e
  readMessageA(message2) {
    try {
      this.readE(message2);
      return this.ss.decryptAndHash(message2.sublist(32));
    } catch (e2) {
      throw new InvalidCryptoExchangeError2(`handshake stage 0 validation fail: ${e2.message}`);
    }
  }
  // e, ee, s, es
  readMessageB(message2) {
    try {
      this.readE(message2);
      this.readEE();
      const consumed = this.readS(message2, 32);
      this.readES();
      return this.ss.decryptAndHash(message2.sublist(32 + consumed));
    } catch (e2) {
      throw new InvalidCryptoExchangeError2(`handshake stage 1 validation fail: ${e2.message}`);
    }
  }
  // s, se
  readMessageC(message2) {
    try {
      const consumed = this.readS(message2);
      this.readSE();
      return this.ss.decryptAndHash(message2.sublist(consumed));
    } catch (e2) {
      throw new InvalidCryptoExchangeError2(`handshake stage 2 validation fail: ${e2.message}`);
    }
  }
};
function hashProtocolName(crypto4, protocolName) {
  if (protocolName.length <= 32) {
    const h = alloc(32);
    h.set(protocolName);
    return h;
  } else {
    return crypto4.hash(protocolName);
  }
}

// node_modules/@chainsafe/libp2p-noise/dist/src/proto/payload.js
var NoiseExtensions;
(function(NoiseExtensions2) {
  let _codec;
  NoiseExtensions2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.webtransportCerthashes != null) {
          for (const value of obj.webtransportCerthashes) {
            w.uint32(10);
            w.bytes(value);
          }
        }
        if (obj.streamMuxers != null) {
          for (const value of obj.streamMuxers) {
            w.uint32(18);
            w.string(value);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27, _b14;
        const obj = {
          webtransportCerthashes: [],
          streamMuxers: []
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (((_a27 = opts.limits) == null ? void 0 : _a27.webtransportCerthashes) != null && obj.webtransportCerthashes.length === opts.limits.webtransportCerthashes) {
                throw new MaxLengthError('Decode error - map field "webtransportCerthashes" had too many elements');
              }
              obj.webtransportCerthashes.push(reader.bytes());
              break;
            }
            case 2: {
              if (((_b14 = opts.limits) == null ? void 0 : _b14.streamMuxers) != null && obj.streamMuxers.length === opts.limits.streamMuxers) {
                throw new MaxLengthError('Decode error - map field "streamMuxers" had too many elements');
              }
              obj.streamMuxers.push(reader.string());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  NoiseExtensions2.encode = (obj) => {
    return encodeMessage(obj, NoiseExtensions2.codec());
  };
  NoiseExtensions2.decode = (buf, opts) => {
    return decodeMessage(buf, NoiseExtensions2.codec(), opts);
  };
})(NoiseExtensions || (NoiseExtensions = {}));
var NoiseHandshakePayload;
(function(NoiseHandshakePayload2) {
  let _codec;
  NoiseHandshakePayload2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.identityKey != null && obj.identityKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.identityKey);
        }
        if (obj.identitySig != null && obj.identitySig.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.identitySig);
        }
        if (obj.extensions != null) {
          w.uint32(34);
          NoiseExtensions.codec().encode(obj.extensions, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27;
        const obj = {
          identityKey: alloc(0),
          identitySig: alloc(0)
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.identityKey = reader.bytes();
              break;
            }
            case 2: {
              obj.identitySig = reader.bytes();
              break;
            }
            case 4: {
              obj.extensions = NoiseExtensions.codec().decode(reader, reader.uint32(), {
                limits: (_a27 = opts.limits) == null ? void 0 : _a27.extensions
              });
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  NoiseHandshakePayload2.encode = (obj) => {
    return encodeMessage(obj, NoiseHandshakePayload2.codec());
  };
  NoiseHandshakePayload2.decode = (buf, opts) => {
    return decodeMessage(buf, NoiseHandshakePayload2.codec(), opts);
  };
})(NoiseHandshakePayload || (NoiseHandshakePayload = {}));

// node_modules/@chainsafe/libp2p-noise/dist/src/utils.js
async function createHandshakePayload(privateKey, staticPublicKey, extensions) {
  const identitySig = await privateKey.sign(getSignaturePayload(staticPublicKey));
  return NoiseHandshakePayload.encode({
    identityKey: publicKeyToProtobuf(privateKey.publicKey),
    identitySig,
    extensions
  });
}
async function decodeHandshakePayload(payloadBytes, remoteStaticKey, remoteIdentityKey) {
  try {
    const payload = NoiseHandshakePayload.decode(payloadBytes);
    const publicKey = publicKeyFromProtobuf(payload.identityKey);
    if ((remoteIdentityKey == null ? void 0 : remoteIdentityKey.equals(publicKey)) === false) {
      throw new Error(`Payload identity key ${publicKey} does not match expected remote identity key ${remoteIdentityKey}`);
    }
    if (!remoteStaticKey) {
      throw new Error("Remote static does not exist");
    }
    const signaturePayload = getSignaturePayload(remoteStaticKey);
    if (!await publicKey.verify(signaturePayload, payload.identitySig)) {
      throw new Error("Invalid payload signature");
    }
    return payload;
  } catch (e2) {
    throw new UnexpectedPeerError(e2.message);
  }
}
function getSignaturePayload(publicKey) {
  const prefix = fromString2("noise-libp2p-static-key:");
  if (publicKey instanceof Uint8Array) {
    return concat2([prefix, publicKey], prefix.length + publicKey.length);
  }
  publicKey.prepend(prefix);
  return publicKey;
}

// node_modules/@chainsafe/libp2p-noise/dist/src/performHandshake.js
async function performHandshakeInitiator(init, options) {
  const { log: log41, connection, crypto: crypto4, privateKey, prologue, s: s2, remoteIdentityKey, extensions } = init;
  const payload = await createHandshakePayload(privateKey, s2.publicKey, extensions);
  const xx = new XXHandshakeState({
    crypto: crypto4,
    protocolName: "Noise_XX_25519_ChaChaPoly_SHA256",
    initiator: true,
    prologue,
    s: s2
  });
  logLocalStaticKeys(xx.s, log41);
  log41.trace("Stage 0 - Initiator starting to send first message.");
  await connection.write(xx.writeMessageA(ZEROLEN), options);
  log41.trace("Stage 0 - Initiator finished sending first message.");
  logLocalEphemeralKeys(xx.e, log41);
  log41.trace("Stage 1 - Initiator waiting to receive first message from responder...");
  const plaintext = xx.readMessageB(await connection.read(options));
  log41.trace("Stage 1 - Initiator received the message.");
  logRemoteEphemeralKey(xx.re, log41);
  logRemoteStaticKey(xx.rs, log41);
  log41.trace("Initiator going to check remote's signature...");
  const receivedPayload = await decodeHandshakePayload(plaintext, xx.rs, remoteIdentityKey);
  log41.trace("All good with the signature!");
  log41.trace("Stage 2 - Initiator sending third handshake message.");
  await connection.write(xx.writeMessageC(payload), options);
  log41.trace("Stage 2 - Initiator sent message with signed payload.");
  const [cs1, cs2] = xx.ss.split();
  logCipherState(cs1, cs2, log41);
  return {
    payload: receivedPayload,
    encrypt: (plaintext2) => cs1.encryptWithAd(ZEROLEN, plaintext2),
    decrypt: (ciphertext, dst) => cs2.decryptWithAd(ZEROLEN, ciphertext, dst)
  };
}
async function performHandshakeResponder(init, options) {
  const { log: log41, connection, crypto: crypto4, privateKey, prologue, s: s2, remoteIdentityKey, extensions } = init;
  const payload = await createHandshakePayload(privateKey, s2.publicKey, extensions);
  const xx = new XXHandshakeState({
    crypto: crypto4,
    protocolName: "Noise_XX_25519_ChaChaPoly_SHA256",
    initiator: false,
    prologue,
    s: s2
  });
  logLocalStaticKeys(xx.s, log41);
  log41.trace("Stage 0 - Responder waiting to receive first message.");
  xx.readMessageA(await connection.read(options));
  log41.trace("Stage 0 - Responder received first message.");
  logRemoteEphemeralKey(xx.re, log41);
  log41.trace("Stage 1 - Responder sending out first message with signed payload and static key.");
  await connection.write(xx.writeMessageB(payload), options);
  log41.trace("Stage 1 - Responder sent the second handshake message with signed payload.");
  logLocalEphemeralKeys(xx.e, log41);
  log41.trace("Stage 2 - Responder waiting for third handshake message...");
  const plaintext = xx.readMessageC(await connection.read(options));
  log41.trace("Stage 2 - Responder received the message, finished handshake.");
  const receivedPayload = await decodeHandshakePayload(plaintext, xx.rs, remoteIdentityKey);
  const [cs1, cs2] = xx.ss.split();
  logCipherState(cs1, cs2, log41);
  return {
    payload: receivedPayload,
    encrypt: (plaintext2) => cs2.encryptWithAd(ZEROLEN, plaintext2),
    decrypt: (ciphertext, dst) => cs1.decryptWithAd(ZEROLEN, ciphertext, dst)
  };
}

// node_modules/@chainsafe/libp2p-noise/dist/src/streaming.js
var CHACHA_TAG_LENGTH = 16;
function encryptStream(handshake, metrics) {
  return async function* (source) {
    for await (const chunk of source) {
      for (let i2 = 0; i2 < chunk.length; i2 += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
        let end = i2 + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
        if (end > chunk.length) {
          end = chunk.length;
        }
        let data;
        if (chunk instanceof Uint8Array) {
          data = handshake.encrypt(chunk.subarray(i2, end));
        } else {
          data = handshake.encrypt(chunk.sublist(i2, end));
        }
        metrics == null ? void 0 : metrics.encryptedPackets.increment();
        yield new Uint8ArrayList(uint16BEEncode(data.byteLength), data);
      }
    }
  };
}
function decryptStream(handshake, metrics) {
  return async function* (source) {
    for await (const chunk of source) {
      for (let i2 = 0; i2 < chunk.length; i2 += NOISE_MSG_MAX_LENGTH_BYTES) {
        let end = i2 + NOISE_MSG_MAX_LENGTH_BYTES;
        if (end > chunk.length) {
          end = chunk.length;
        }
        if (end - CHACHA_TAG_LENGTH < i2) {
          throw new Error("Invalid chunk");
        }
        const encrypted = chunk.sublist(i2, end);
        const dst = chunk.subarray(i2, end - CHACHA_TAG_LENGTH);
        try {
          const plaintext = handshake.decrypt(encrypted, dst);
          metrics == null ? void 0 : metrics.decryptedPackets.increment();
          yield plaintext;
        } catch (e2) {
          metrics == null ? void 0 : metrics.decryptErrors.increment();
          throw e2;
        }
      }
    }
  };
}

// node_modules/@chainsafe/libp2p-noise/dist/src/noise.js
var _a7, _b3;
_b3 = Symbol.toStringTag, _a7 = serviceCapabilities;
var Noise = class {
  constructor(components, init = {}) {
    __publicField(this, "protocol", "/noise");
    __publicField(this, "crypto");
    __publicField(this, "prologue");
    __publicField(this, "staticKey");
    __publicField(this, "extensions");
    __publicField(this, "metrics");
    __publicField(this, "components");
    __publicField(this, _b3, "@chainsafe/libp2p-noise");
    __publicField(this, _a7, [
      "@libp2p/connection-encryption",
      "@chainsafe/libp2p-noise"
    ]);
    const { staticNoiseKey, extensions, crypto: crypto4, prologueBytes } = init;
    const { metrics } = components;
    this.components = components;
    const _crypto = crypto4 ?? defaultCrypto;
    this.crypto = wrapCrypto(_crypto);
    this.extensions = {
      webtransportCerthashes: [],
      ...extensions
    };
    this.metrics = metrics ? registerMetrics(metrics) : void 0;
    if (staticNoiseKey) {
      this.staticKey = _crypto.generateX25519KeyPairFromSeed(staticNoiseKey);
    } else {
      this.staticKey = _crypto.generateX25519KeyPair();
    }
    this.prologue = prologueBytes ?? alloc(0);
  }
  /**
   * Encrypt outgoing data to the remote party (handshake as initiator)
   *
   * @param connection - streaming iterable duplex that will be encrypted
   * @param options
   * @param options.remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer
   * @param options.signal - Used to abort the operation
   */
  async secureOutbound(connection, options) {
    var _a27, _b14;
    const wrappedConnection = lpStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake = await this.performHandshakeInitiator(wrappedConnection, this.components.privateKey, (_a27 = options == null ? void 0 : options.remotePeer) == null ? void 0 : _a27.publicKey, options);
    const conn = await this.createSecureConnection(wrappedConnection, handshake);
    connection.source = conn.source;
    connection.sink = conn.sink;
    const publicKey = publicKeyFromProtobuf(handshake.payload.identityKey);
    return {
      conn: connection,
      remoteExtensions: handshake.payload.extensions,
      remotePeer: peerIdFromPublicKey(publicKey),
      streamMuxer: (options == null ? void 0 : options.skipStreamMuxerNegotiation) === true ? void 0 : this.getStreamMuxer((_b14 = handshake.payload.extensions) == null ? void 0 : _b14.streamMuxers)
    };
  }
  getStreamMuxer(protocols2) {
    if (protocols2 == null || protocols2.length === 0) {
      return;
    }
    const streamMuxers = this.components.upgrader.getStreamMuxers();
    if (streamMuxers != null) {
      for (const protocol of protocols2) {
        const streamMuxer = streamMuxers.get(protocol);
        if (streamMuxer != null) {
          return streamMuxer;
        }
      }
    }
    if (protocols2.length) {
      throw new InvalidCryptoExchangeError("Early muxer negotiation was requested but the initiator and responder had no common muxers");
    }
  }
  /**
   * Decrypt incoming data (handshake as responder).
   *
   * @param connection - streaming iterable duplex that will be encrypted
   * @param options
   * @param options.remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer
   * @param options.signal - Used to abort the operation
   */
  async secureInbound(connection, options) {
    var _a27, _b14;
    const wrappedConnection = lpStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake = await this.performHandshakeResponder(wrappedConnection, this.components.privateKey, (_a27 = options == null ? void 0 : options.remotePeer) == null ? void 0 : _a27.publicKey, options);
    const conn = await this.createSecureConnection(wrappedConnection, handshake);
    connection.source = conn.source;
    connection.sink = conn.sink;
    const publicKey = publicKeyFromProtobuf(handshake.payload.identityKey);
    return {
      conn: connection,
      remoteExtensions: handshake.payload.extensions,
      remotePeer: peerIdFromPublicKey(publicKey),
      streamMuxer: (options == null ? void 0 : options.skipStreamMuxerNegotiation) === true ? void 0 : this.getStreamMuxer((_b14 = handshake.payload.extensions) == null ? void 0 : _b14.streamMuxers)
    };
  }
  /**
   * Perform XX handshake as initiator.
   */
  async performHandshakeInitiator(connection, privateKey, remoteIdentityKey, options) {
    var _a27, _b14;
    let result;
    const streamMuxers = (options == null ? void 0 : options.skipStreamMuxerNegotiation) === true ? [] : [...this.components.upgrader.getStreamMuxers().keys()];
    try {
      result = await performHandshakeInitiator({
        connection,
        privateKey,
        remoteIdentityKey,
        log: this.components.logger.forComponent("libp2p:noise:xxhandshake"),
        crypto: this.crypto,
        prologue: this.prologue,
        s: this.staticKey,
        extensions: {
          streamMuxers,
          webtransportCerthashes: [],
          ...this.extensions
        }
      }, options);
      (_a27 = this.metrics) == null ? void 0 : _a27.xxHandshakeSuccesses.increment();
    } catch (e2) {
      (_b14 = this.metrics) == null ? void 0 : _b14.xxHandshakeErrors.increment();
      throw e2;
    }
    return result;
  }
  /**
   * Perform XX handshake as responder.
   */
  async performHandshakeResponder(connection, privateKey, remoteIdentityKey, options) {
    var _a27, _b14;
    let result;
    const streamMuxers = (options == null ? void 0 : options.skipStreamMuxerNegotiation) === true ? [] : [...this.components.upgrader.getStreamMuxers().keys()];
    try {
      result = await performHandshakeResponder({
        connection,
        privateKey,
        remoteIdentityKey,
        log: this.components.logger.forComponent("libp2p:noise:xxhandshake"),
        crypto: this.crypto,
        prologue: this.prologue,
        s: this.staticKey,
        extensions: {
          streamMuxers,
          webtransportCerthashes: [],
          ...this.extensions
        }
      }, options);
      (_a27 = this.metrics) == null ? void 0 : _a27.xxHandshakeSuccesses.increment();
    } catch (e2) {
      (_b14 = this.metrics) == null ? void 0 : _b14.xxHandshakeErrors.increment();
      throw e2;
    }
    return result;
  }
  async createSecureConnection(connection, handshake) {
    const [secure, user] = duplexPair();
    const network = connection.unwrap();
    await pipe(
      secure,
      // write to wrapper
      encryptStream(handshake, this.metrics),
      // encrypt data + prefix with message length
      network,
      // send to the remote peer
      (source) => decode8(source, { lengthDecoder: uint16BEDecode }),
      // read message length prefix
      decryptStream(handshake, this.metrics),
      // decrypt the incoming data
      secure
      // pipe to the wrapper
    );
    return user;
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/index.js
function noise(init = {}) {
  return (components) => new Noise(components, init);
}

// node_modules/@multiformats/mafmt/dist/src/index.js
var DNS4 = base3("dns4");
var DNS6 = base3("dns6");
var DNSADDR = base3("dnsaddr");
var DNS2 = or2(base3("dns"), DNSADDR, DNS4, DNS6);
var IP = or2(base3("ip4"), base3("ip6"));
var TCP = or2(and(IP, base3("tcp")), and(DNS2, base3("tcp")));
var UDP = and(IP, base3("udp"));
var UTP = and(UDP, base3("utp"));
var QUIC = and(UDP, base3("quic"));
var QUICV1 = and(UDP, base3("quic-v1"));
var _WebSockets = or2(and(TCP, base3("ws")), and(DNS2, base3("ws")));
var WebSockets = or2(and(_WebSockets, base3("p2p")), _WebSockets);
var _WebSocketsSecure = or2(and(TCP, base3("wss")), and(DNS2, base3("wss")), and(TCP, base3("tls"), base3("ws")), and(DNS2, base3("tls"), base3("ws")));
var WebSocketsSecure = or2(and(_WebSocketsSecure, base3("p2p")), _WebSocketsSecure);
var HTTP = or2(and(TCP, base3("http")), and(IP, base3("http")), and(DNS2, base3("http")));
var HTTPS = or2(and(TCP, base3("https")), and(IP, base3("https")), and(DNS2, base3("https")));
var _WebRTCDirect = and(UDP, base3("webrtc-direct"), base3("certhash"));
var WebRTCDirect = or2(and(_WebRTCDirect, base3("p2p")), _WebRTCDirect);
var _WebTransport = and(QUICV1, base3("webtransport"), base3("certhash"), base3("certhash"));
var WebTransport = or2(and(_WebTransport, base3("p2p")), _WebTransport);
var P2PWebRTCStar = or2(and(WebSockets, base3("p2p-webrtc-star"), base3("p2p")), and(WebSocketsSecure, base3("p2p-webrtc-star"), base3("p2p")), and(WebSockets, base3("p2p-webrtc-star")), and(WebSocketsSecure, base3("p2p-webrtc-star")));
var WebSocketStar = or2(and(WebSockets, base3("p2p-websocket-star"), base3("p2p")), and(WebSocketsSecure, base3("p2p-websocket-star"), base3("p2p")), and(WebSockets, base3("p2p-websocket-star")), and(WebSocketsSecure, base3("p2p-websocket-star")));
var P2PWebRTCDirect = or2(and(HTTP, base3("p2p-webrtc-direct"), base3("p2p")), and(HTTPS, base3("p2p-webrtc-direct"), base3("p2p")), and(HTTP, base3("p2p-webrtc-direct")), and(HTTPS, base3("p2p-webrtc-direct")));
var Reliable = or2(_WebSockets, _WebSocketsSecure, HTTP, HTTPS, P2PWebRTCStar, P2PWebRTCDirect, TCP, UTP, QUIC, DNS2, WebRTCDirect, WebTransport);
var Stardust = or2(and(Reliable, base3("p2p-stardust"), base3("p2p")), and(Reliable, base3("p2p-stardust")));
var _P2P = or2(and(Reliable, base3("p2p")), P2PWebRTCStar, P2PWebRTCDirect, WebRTCDirect, WebTransport, base3("p2p"));
var _Circuit = or2(and(_P2P, base3("p2p-circuit"), _P2P), and(_P2P, base3("p2p-circuit")), and(base3("p2p-circuit"), _P2P), and(Reliable, base3("p2p-circuit")), and(base3("p2p-circuit"), Reliable), base3("p2p-circuit"));
var CircuitRecursive = () => or2(and(_Circuit, CircuitRecursive), _Circuit);
var Circuit = CircuitRecursive();
var P2P = or2(and(Circuit, _P2P, Circuit), and(_P2P, Circuit), and(Circuit, _P2P), Circuit, _P2P);
var WebRTC = or2(and(Circuit, base3("webrtc"), base3("p2p")), and(Circuit, base3("webrtc")), and(Reliable, base3("webrtc"), base3("p2p")), and(Reliable, base3("webrtc")), base3("webrtc"));
function makeMatchesFunction(partialMatch) {
  function matches(a2) {
    let ma;
    try {
      ma = multiaddr(a2);
    } catch (err) {
      return false;
    }
    const out = partialMatch(ma.protoNames());
    if (out === null) {
      return false;
    }
    if (out === true || out === false) {
      return out;
    }
    return out.length === 0;
  }
  return matches;
}
function and(...args) {
  function partialMatch(a2) {
    if (a2.length < args.length) {
      return null;
    }
    let out = a2;
    args.some((arg) => {
      out = typeof arg === "function" ? arg().partialMatch(a2) : arg.partialMatch(a2);
      if (Array.isArray(out)) {
        a2 = out;
      }
      if (out === null) {
        return true;
      }
      return false;
    });
    return out;
  }
  return {
    toString: function() {
      return "{ " + args.join(" ") + " }";
    },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch
  };
}
function or2(...args) {
  function partialMatch(a2) {
    let out = null;
    args.some((arg) => {
      const res = typeof arg === "function" ? arg().partialMatch(a2) : arg.partialMatch(a2);
      if (res != null) {
        out = res;
        return true;
      }
      return false;
    });
    return out;
  }
  const result = {
    toString: function() {
      return "{ " + args.join(" ") + " }";
    },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch
  };
  return result;
}
function base3(n2) {
  const name3 = n2;
  function matches(a2) {
    let ma;
    try {
      ma = multiaddr(a2);
    } catch (err) {
      return false;
    }
    const pnames = ma.protoNames();
    if (pnames.length === 1 && pnames[0] === name3) {
      return true;
    }
    return false;
  }
  function partialMatch(protos) {
    if (protos.length === 0) {
      return null;
    }
    if (protos[0] === name3) {
      return protos.slice(1);
    }
    return null;
  }
  return {
    toString: function() {
      return name3;
    },
    matches,
    partialMatch
  };
}

// node_modules/@libp2p/bootstrap/dist/src/index.js
var DEFAULT_BOOTSTRAP_TAG_NAME = "bootstrap";
var DEFAULT_BOOTSTRAP_TAG_VALUE = 50;
var DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT = 1e3;
var _a8, _b4, _c, _d;
var Bootstrap = class extends (_d = TypedEventEmitter, _c = peerDiscoverySymbol, _b4 = Symbol.toStringTag, _a8 = serviceCapabilities, _d) {
  constructor(components, options = { list: [] }) {
    if (options.list == null || options.list.length === 0) {
      throw new Error("Bootstrap requires a list of peer addresses");
    }
    super();
    __publicField(this, "log");
    __publicField(this, "timer");
    __publicField(this, "list");
    __publicField(this, "timeout");
    __publicField(this, "components");
    __publicField(this, "_init");
    __publicField(this, _c, this);
    __publicField(this, _b4, "@libp2p/bootstrap");
    __publicField(this, _a8, [
      "@libp2p/peer-discovery"
    ]);
    this.components = components;
    this.log = components.logger.forComponent("libp2p:bootstrap");
    this.timeout = options.timeout ?? DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT;
    this.list = [];
    for (const candidate of options.list) {
      if (!P2P.matches(candidate)) {
        this.log.error("Invalid multiaddr");
        continue;
      }
      const ma = multiaddr(candidate);
      const peerIdStr = ma.getPeerId();
      if (peerIdStr == null) {
        this.log.error("Invalid bootstrap multiaddr without peer id");
        continue;
      }
      const peerData = {
        id: peerIdFromString(peerIdStr),
        multiaddrs: [ma]
      };
      this.list.push(peerData);
    }
    this._init = options;
  }
  isStarted() {
    return Boolean(this.timer);
  }
  /**
   * Start emitting events
   */
  start() {
    if (this.isStarted()) {
      return;
    }
    this.log("Starting bootstrap node discovery, discovering peers after %s ms", this.timeout);
    this.timer = setTimeout(() => {
      void this._discoverBootstrapPeers().catch((err) => {
        this.log.error(err);
      });
    }, this.timeout);
  }
  /**
   * Emit each address in the list as a PeerInfo
   */
  async _discoverBootstrapPeers() {
    if (this.timer == null) {
      return;
    }
    for (const peerData of this.list) {
      await this.components.peerStore.merge(peerData.id, {
        tags: {
          [this._init.tagName ?? DEFAULT_BOOTSTRAP_TAG_NAME]: {
            value: this._init.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE,
            ttl: this._init.tagTTL
          }
        },
        multiaddrs: peerData.multiaddrs
      });
      if (this.timer == null) {
        return;
      }
      this.safeDispatchEvent("peer", { detail: peerData });
      this.components.connectionManager.openConnection(peerData.id).catch((err) => {
        this.log.error("could not dial bootstrap peer %p", peerData.id, err);
      });
    }
  }
  /**
   * Stop emitting events
   */
  stop() {
    if (this.timer != null) {
      clearTimeout(this.timer);
    }
    this.timer = void 0;
  }
};
__publicField(Bootstrap, "tag", "bootstrap");
function bootstrap(init) {
  return (components) => new Bootstrap(components, init);
}

// node_modules/@libp2p/peer-record/dist/src/envelope/envelope.js
var Envelope;
(function(Envelope2) {
  let _codec;
  Envelope2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.payloadType != null && obj.payloadType.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.payloadType);
        }
        if (obj.payload != null && obj.payload.byteLength > 0) {
          w.uint32(26);
          w.bytes(obj.payload);
        }
        if (obj.signature != null && obj.signature.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.signature);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          publicKey: alloc(0),
          payloadType: alloc(0),
          payload: alloc(0),
          signature: alloc(0)
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 2: {
              obj.payloadType = reader.bytes();
              break;
            }
            case 3: {
              obj.payload = reader.bytes();
              break;
            }
            case 5: {
              obj.signature = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Envelope2.encode = (obj) => {
    return encodeMessage(obj, Envelope2.codec());
  };
  Envelope2.decode = (buf, opts) => {
    return decodeMessage(buf, Envelope2.codec(), opts);
  };
})(Envelope || (Envelope = {}));

// node_modules/@libp2p/peer-record/dist/src/envelope/errors.js
var InvalidSignatureError = class extends Error {
  constructor(message2 = "Invalid signature") {
    super(message2);
    this.name = "InvalidSignatureError";
  }
};

// node_modules/@libp2p/peer-record/dist/src/envelope/index.js
var _RecordEnvelope = class _RecordEnvelope {
  /**
   * The Envelope is responsible for keeping an arbitrary signed record
   * by a libp2p peer.
   */
  constructor(init) {
    __publicField(this, "publicKey");
    __publicField(this, "payloadType");
    __publicField(this, "payload");
    __publicField(this, "signature");
    __publicField(this, "marshaled");
    const { publicKey, payloadType, payload, signature } = init;
    this.publicKey = publicKey;
    this.payloadType = payloadType;
    this.payload = payload;
    this.signature = signature;
  }
  /**
   * Marshal the envelope content
   */
  marshal() {
    if (this.marshaled == null) {
      this.marshaled = Envelope.encode({
        publicKey: publicKeyToProtobuf(this.publicKey),
        payloadType: this.payloadType,
        payload: this.payload.subarray(),
        signature: this.signature
      });
    }
    return this.marshaled;
  }
  /**
   * Verifies if the other Envelope is identical to this one
   */
  equals(other) {
    if (other == null) {
      return false;
    }
    return equals3(this.marshal(), other.marshal());
  }
  /**
   * Validate envelope data signature for the given domain
   */
  async validate(domain, options) {
    const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
    return this.publicKey.verify(signData.subarray(), this.signature, options);
  }
};
/**
 * Unmarshal a serialized Envelope protobuf message
 */
__publicField(_RecordEnvelope, "createFromProtobuf", (data) => {
  const envelopeData = Envelope.decode(data);
  const publicKey = publicKeyFromProtobuf(envelopeData.publicKey);
  return new _RecordEnvelope({
    publicKey,
    payloadType: envelopeData.payloadType,
    payload: envelopeData.payload,
    signature: envelopeData.signature
  });
});
/**
 * Seal marshals the given Record, places the marshaled bytes inside an Envelope
 * and signs it with the given peerId's private key
 */
__publicField(_RecordEnvelope, "seal", async (record, privateKey, options) => {
  if (privateKey == null) {
    throw new Error("Missing private key");
  }
  const domain = record.domain;
  const payloadType = record.codec;
  const payload = record.marshal();
  const signData = formatSignaturePayload(domain, payloadType, payload);
  const signature = await privateKey.sign(signData.subarray(), options);
  return new _RecordEnvelope({
    publicKey: privateKey.publicKey,
    payloadType,
    payload,
    signature
  });
});
/**
 * Open and certify a given marshaled envelope.
 * Data is unmarshaled and the signature validated for the given domain.
 */
__publicField(_RecordEnvelope, "openAndCertify", async (data, domain, options) => {
  const envelope = _RecordEnvelope.createFromProtobuf(data);
  const valid = await envelope.validate(domain, options);
  if (!valid) {
    throw new InvalidSignatureError("Envelope signature is not valid for the given domain");
  }
  return envelope;
});
var RecordEnvelope = _RecordEnvelope;
var formatSignaturePayload = (domain, payloadType, payload) => {
  const domainUint8Array = fromString2(domain);
  const domainLength = encode(domainUint8Array.byteLength);
  const payloadTypeLength = encode(payloadType.length);
  const payloadLength = encode(payload.length);
  return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);
};

// node_modules/@libp2p/utils/dist/src/array-equals.js
function arrayEquals(a2, b) {
  const sort2 = (a3, b2) => a3.toString().localeCompare(b2.toString());
  if (a2.length !== b.length) {
    return false;
  }
  b.sort(sort2);
  return a2.sort(sort2).every((item, index) => b[index].equals(item));
}

// node_modules/@libp2p/peer-record/dist/src/peer-record/consts.js
var ENVELOPE_DOMAIN_PEER_RECORD = "libp2p-peer-record";
var ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);

// node_modules/@libp2p/peer-record/dist/src/peer-record/peer-record.js
var PeerRecord;
(function(PeerRecord3) {
  let AddressInfo;
  (function(AddressInfo2) {
    let _codec2;
    AddressInfo2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.multiaddr);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length3, opts = {}) => {
          const obj = {
            multiaddr: alloc(0)
          };
          const end = length3 == null ? reader.len : reader.pos + length3;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.multiaddr = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    AddressInfo2.encode = (obj) => {
      return encodeMessage(obj, AddressInfo2.codec());
    };
    AddressInfo2.decode = (buf, opts) => {
      return decodeMessage(buf, AddressInfo2.codec(), opts);
    };
  })(AddressInfo = PeerRecord3.AddressInfo || (PeerRecord3.AddressInfo = {}));
  let _codec;
  PeerRecord3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.peerId != null && obj.peerId.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.peerId);
        }
        if (obj.seq != null && obj.seq !== 0n) {
          w.uint32(16);
          w.uint64(obj.seq);
        }
        if (obj.addresses != null) {
          for (const value of obj.addresses) {
            w.uint32(26);
            PeerRecord3.AddressInfo.codec().encode(value, w);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27, _b14;
        const obj = {
          peerId: alloc(0),
          seq: 0n,
          addresses: []
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.peerId = reader.bytes();
              break;
            }
            case 2: {
              obj.seq = reader.uint64();
              break;
            }
            case 3: {
              if (((_a27 = opts.limits) == null ? void 0 : _a27.addresses) != null && obj.addresses.length === opts.limits.addresses) {
                throw new MaxLengthError('Decode error - map field "addresses" had too many elements');
              }
              obj.addresses.push(PeerRecord3.AddressInfo.codec().decode(reader, reader.uint32(), {
                limits: (_b14 = opts.limits) == null ? void 0 : _b14.addresses$
              }));
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerRecord3.encode = (obj) => {
    return encodeMessage(obj, PeerRecord3.codec());
  };
  PeerRecord3.decode = (buf, opts) => {
    return decodeMessage(buf, PeerRecord3.codec(), opts);
  };
})(PeerRecord || (PeerRecord = {}));

// node_modules/@libp2p/peer-record/dist/src/peer-record/index.js
var _PeerRecord = class _PeerRecord {
  constructor(init) {
    __publicField(this, "peerId");
    __publicField(this, "multiaddrs");
    __publicField(this, "seqNumber");
    __publicField(this, "domain", _PeerRecord.DOMAIN);
    __publicField(this, "codec", _PeerRecord.CODEC);
    __publicField(this, "marshaled");
    const { peerId: peerId2, multiaddrs, seqNumber } = init;
    this.peerId = peerId2;
    this.multiaddrs = multiaddrs ?? [];
    this.seqNumber = seqNumber ?? BigInt(Date.now());
  }
  /**
   * Marshal a record to be used in an envelope
   */
  marshal() {
    if (this.marshaled == null) {
      this.marshaled = PeerRecord.encode({
        peerId: this.peerId.toMultihash().bytes,
        seq: BigInt(this.seqNumber),
        addresses: this.multiaddrs.map((m2) => ({
          multiaddr: m2.bytes
        }))
      });
    }
    return this.marshaled;
  }
  /**
   * Returns true if `this` record equals the `other`
   */
  equals(other) {
    if (!(other instanceof _PeerRecord)) {
      return false;
    }
    if (!this.peerId.equals(other.peerId)) {
      return false;
    }
    if (this.seqNumber !== other.seqNumber) {
      return false;
    }
    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
      return false;
    }
    return true;
  }
};
/**
 * Unmarshal Peer Record Protobuf
 */
__publicField(_PeerRecord, "createFromProtobuf", (buf) => {
  const peerRecord = PeerRecord.decode(buf);
  const peerId2 = peerIdFromMultihash(decode6(peerRecord.peerId));
  const multiaddrs = (peerRecord.addresses ?? []).map((a2) => multiaddr(a2.multiaddr));
  const seqNumber = peerRecord.seq;
  return new _PeerRecord({ peerId: peerId2, multiaddrs, seqNumber });
});
__publicField(_PeerRecord, "DOMAIN", ENVELOPE_DOMAIN_PEER_RECORD);
__publicField(_PeerRecord, "CODEC", ENVELOPE_PAYLOAD_TYPE_PEER_RECORD);
var PeerRecord2 = _PeerRecord;

// node_modules/@libp2p/utils/dist/src/debounce.js
function debounce2(func2, wait2) {
  let timeout2;
  const output = function() {
    const later = function() {
      timeout2 = void 0;
      void func2();
    };
    clearTimeout(timeout2);
    timeout2 = setTimeout(later, wait2);
  };
  output.start = () => {
  };
  output.stop = () => {
    clearTimeout(timeout2);
  };
  return output;
}

// node_modules/it-drain/dist/src/index.js
function isAsyncIterable6(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function drain(source) {
  if (isAsyncIterable6(source)) {
    return (async () => {
      for await (const _2 of source) {
      }
    })();
  } else {
    for (const _2 of source) {
    }
  }
}
var src_default3 = drain;

// node_modules/it-parallel/dist/src/index.js
var CustomEvent2 = globalThis.CustomEvent ?? Event;
async function* parallel(source, options = {}) {
  let concurrency = options.concurrency ?? Infinity;
  if (concurrency < 1) {
    concurrency = Infinity;
  }
  const ordered = options.ordered ?? false;
  const emitter = new EventTarget();
  const ops = [];
  let slotAvailable = pDefer();
  let resultAvailable = pDefer();
  let sourceFinished = false;
  let sourceErr;
  let opErred = false;
  emitter.addEventListener("task-complete", () => {
    resultAvailable.resolve();
  });
  void Promise.resolve().then(async () => {
    try {
      for await (const task of source) {
        if (ops.length === concurrency) {
          slotAvailable = pDefer();
          await slotAvailable.promise;
        }
        if (opErred) {
          break;
        }
        const op = {
          done: false
        };
        ops.push(op);
        task().then((result) => {
          op.done = true;
          op.ok = true;
          op.value = result;
          emitter.dispatchEvent(new CustomEvent2("task-complete"));
        }, (err) => {
          op.done = true;
          op.err = err;
          emitter.dispatchEvent(new CustomEvent2("task-complete"));
        });
      }
      sourceFinished = true;
      emitter.dispatchEvent(new CustomEvent2("task-complete"));
    } catch (err) {
      sourceErr = err;
      emitter.dispatchEvent(new CustomEvent2("task-complete"));
    }
  });
  function valuesAvailable() {
    var _a27;
    if (ordered) {
      return (_a27 = ops[0]) == null ? void 0 : _a27.done;
    }
    return Boolean(ops.find((op) => op.done));
  }
  function* yieldOrderedValues() {
    while (ops.length > 0 && ops[0].done) {
      const op = ops[0];
      ops.shift();
      if (op.ok) {
        yield op.value;
      } else {
        opErred = true;
        slotAvailable.resolve();
        throw op.err;
      }
      slotAvailable.resolve();
    }
  }
  function* yieldUnOrderedValues() {
    while (valuesAvailable()) {
      for (let i2 = 0; i2 < ops.length; i2++) {
        if (ops[i2].done) {
          const op = ops[i2];
          ops.splice(i2, 1);
          i2--;
          if (op.ok) {
            yield op.value;
          } else {
            opErred = true;
            slotAvailable.resolve();
            throw op.err;
          }
          slotAvailable.resolve();
        }
      }
    }
  }
  while (true) {
    if (!valuesAvailable()) {
      resultAvailable = pDefer();
      await resultAvailable.promise;
    }
    if (sourceErr != null) {
      throw sourceErr;
    }
    if (ordered) {
      yield* yieldOrderedValues();
    } else {
      yield* yieldUnOrderedValues();
    }
    if (sourceErr != null) {
      throw sourceErr;
    }
    if (sourceFinished && ops.length === 0) {
      break;
    }
  }
}

// node_modules/it-protobuf-stream/dist/src/index.js
function pbStream(duplex, opts) {
  const lp = lpStream(duplex, opts);
  const W = {
    read: async (proto, options) => {
      const value = await lp.read(options);
      return proto.decode(value);
    },
    write: async (message2, proto, options) => {
      await lp.write(proto.encode(message2), options);
    },
    writeV: async (messages2, proto, options) => {
      await lp.writeV(messages2.map((message2) => proto.encode(message2)), options);
    },
    pb: (proto) => {
      return {
        read: async (options) => W.read(proto, options),
        write: async (d2, options) => W.write(d2, proto, options),
        writeV: async (d2, options) => W.writeV(d2, proto, options),
        unwrap: () => W
      };
    },
    unwrap: () => {
      return lp.unwrap();
    }
  };
  return W;
}

// node_modules/@libp2p/identify/dist/src/consts.js
var IDENTIFY_PROTOCOL_VERSION = "0.1.0";
var MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push";
var MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";
var MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;
var MAX_PUSH_CONCURRENCY = 32;
var PUSH_DEBOUNCE_MS = 1e3;

// node_modules/@libp2p/identify/dist/src/pb/message.js
var Identify;
(function(Identify3) {
  let _codec;
  Identify3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.protocolVersion != null) {
          w.uint32(42);
          w.string(obj.protocolVersion);
        }
        if (obj.agentVersion != null) {
          w.uint32(50);
          w.string(obj.agentVersion);
        }
        if (obj.publicKey != null) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.listenAddrs != null) {
          for (const value of obj.listenAddrs) {
            w.uint32(18);
            w.bytes(value);
          }
        }
        if (obj.observedAddr != null) {
          w.uint32(34);
          w.bytes(obj.observedAddr);
        }
        if (obj.protocols != null) {
          for (const value of obj.protocols) {
            w.uint32(26);
            w.string(value);
          }
        }
        if (obj.signedPeerRecord != null) {
          w.uint32(66);
          w.bytes(obj.signedPeerRecord);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27, _b14;
        const obj = {
          listenAddrs: [],
          protocols: []
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 5: {
              obj.protocolVersion = reader.string();
              break;
            }
            case 6: {
              obj.agentVersion = reader.string();
              break;
            }
            case 1: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 2: {
              if (((_a27 = opts.limits) == null ? void 0 : _a27.listenAddrs) != null && obj.listenAddrs.length === opts.limits.listenAddrs) {
                throw new MaxLengthError('Decode error - map field "listenAddrs" had too many elements');
              }
              obj.listenAddrs.push(reader.bytes());
              break;
            }
            case 4: {
              obj.observedAddr = reader.bytes();
              break;
            }
            case 3: {
              if (((_b14 = opts.limits) == null ? void 0 : _b14.protocols) != null && obj.protocols.length === opts.limits.protocols) {
                throw new MaxLengthError('Decode error - map field "protocols" had too many elements');
              }
              obj.protocols.push(reader.string());
              break;
            }
            case 8: {
              obj.signedPeerRecord = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Identify3.encode = (obj) => {
    return encodeMessage(obj, Identify3.codec());
  };
  Identify3.decode = (buf, opts) => {
    return decodeMessage(buf, Identify3.codec(), opts);
  };
})(Identify || (Identify = {}));

// node_modules/@libp2p/identify/dist/src/utils.js
var defaultValues = {
  protocolPrefix: "ipfs",
  timeout: 5e3,
  maxInboundStreams: 1,
  maxOutboundStreams: 1,
  maxObservedAddresses: 10,
  maxMessageSize: MAX_IDENTIFY_MESSAGE_SIZE,
  runOnConnectionOpen: true,
  runOnSelfUpdate: true,
  runOnLimitedConnection: true,
  concurrency: MAX_PUSH_CONCURRENCY
};
function getCleanMultiaddr(addr) {
  if (addr != null && addr.length > 0) {
    try {
      return multiaddr(addr);
    } catch {
    }
  }
}
function getAgentVersion(nodeInfo, agentVersion) {
  if (agentVersion != null) {
    return agentVersion;
  }
  return nodeInfo.userAgent;
}
async function consumeIdentifyMessage(peerStore, events, log41, connection, message2) {
  log41("received identify from %p", connection.remotePeer);
  if (message2 == null) {
    throw new InvalidMessageError("message was null or undefined");
  }
  const peer = {};
  if (message2.listenAddrs.length > 0) {
    peer.addresses = message2.listenAddrs.map((buf) => ({
      isCertified: false,
      multiaddr: multiaddr(buf)
    }));
  }
  if (message2.protocols.length > 0) {
    peer.protocols = message2.protocols;
  }
  if (message2.publicKey != null) {
    const publicKey = publicKeyFromProtobuf(message2.publicKey);
    const peerId2 = peerIdFromPublicKey(publicKey);
    if (!peerId2.equals(connection.remotePeer)) {
      throw new InvalidMessageError("public key did not match remote PeerId");
    }
    peer.publicKey = publicKey;
  }
  let output;
  if (message2.signedPeerRecord != null) {
    log41.trace("received signedPeerRecord from %p", connection.remotePeer);
    let peerRecordEnvelope2 = message2.signedPeerRecord;
    const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope2, PeerRecord2.DOMAIN);
    let peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
    const envelopePeer = peerIdFromCID(envelope.publicKey.toCID());
    if (!peerRecord.peerId.equals(envelopePeer)) {
      throw new InvalidMessageError("signing key does not match PeerId in the PeerRecord");
    }
    if (!connection.remotePeer.equals(peerRecord.peerId)) {
      throw new InvalidMessageError("signing key does not match remote PeerId");
    }
    let existingPeer;
    try {
      existingPeer = await peerStore.get(peerRecord.peerId);
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    if (existingPeer != null) {
      peer.metadata = existingPeer.metadata;
      if (existingPeer.peerRecordEnvelope != null) {
        const storedEnvelope = RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope);
        const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
        if (storedRecord.seqNumber >= peerRecord.seqNumber) {
          log41("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
          peerRecord = storedRecord;
          peerRecordEnvelope2 = existingPeer.peerRecordEnvelope;
        }
      }
    }
    peer.peerRecordEnvelope = peerRecordEnvelope2;
    peer.addresses = peerRecord.multiaddrs.map((multiaddr2) => ({
      isCertified: true,
      multiaddr: multiaddr2
    }));
    output = {
      seq: peerRecord.seqNumber,
      addresses: peerRecord.multiaddrs
    };
  } else {
    log41("%p did not send a signed peer record", connection.remotePeer);
  }
  log41.trace("patching %p with", connection.remotePeer, peer);
  await peerStore.patch(connection.remotePeer, peer);
  if (message2.agentVersion != null || message2.protocolVersion != null) {
    const metadata = {};
    if (message2.agentVersion != null) {
      metadata.AgentVersion = fromString2(message2.agentVersion);
    }
    if (message2.protocolVersion != null) {
      metadata.ProtocolVersion = fromString2(message2.protocolVersion);
    }
    log41.trace("merging %p metadata", connection.remotePeer, metadata);
    await peerStore.merge(connection.remotePeer, {
      metadata
    });
  }
  const result = {
    peerId: connection.remotePeer,
    protocolVersion: message2.protocolVersion,
    agentVersion: message2.agentVersion,
    publicKey: message2.publicKey,
    listenAddrs: message2.listenAddrs.map((buf) => multiaddr(buf)),
    observedAddr: message2.observedAddr == null ? void 0 : multiaddr(message2.observedAddr),
    protocols: message2.protocols,
    signedPeerRecord: output,
    connection
  };
  events.safeDispatchEvent("peer:identify", { detail: result });
  return result;
}
var AbstractIdentify = class {
  constructor(components, init) {
    __publicField(this, "host");
    __publicField(this, "protocol");
    __publicField(this, "started");
    __publicField(this, "timeout");
    __publicField(this, "peerId");
    __publicField(this, "privateKey");
    __publicField(this, "peerStore");
    __publicField(this, "registrar");
    __publicField(this, "addressManager");
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    __publicField(this, "maxMessageSize");
    __publicField(this, "maxObservedAddresses");
    __publicField(this, "events");
    __publicField(this, "runOnLimitedConnection");
    __publicField(this, "log");
    this.protocol = init.protocol;
    this.started = false;
    this.peerId = components.peerId;
    this.privateKey = components.privateKey;
    this.peerStore = components.peerStore;
    this.registrar = components.registrar;
    this.addressManager = components.addressManager;
    this.events = components.events;
    this.log = init.log;
    this.timeout = init.timeout ?? defaultValues.timeout;
    this.maxInboundStreams = init.maxInboundStreams ?? defaultValues.maxInboundStreams;
    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues.maxOutboundStreams;
    this.maxMessageSize = init.maxMessageSize ?? defaultValues.maxMessageSize;
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses;
    this.runOnLimitedConnection = init.runOnLimitedConnection ?? defaultValues.runOnLimitedConnection;
    this.host = {
      protocolVersion: `${init.protocolPrefix ?? defaultValues.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
      agentVersion: getAgentVersion(components.nodeInfo, init.agentVersion)
    };
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    await this.peerStore.merge(this.peerId, {
      metadata: {
        AgentVersion: fromString2(this.host.agentVersion),
        ProtocolVersion: fromString2(this.host.protocolVersion)
      }
    });
    await this.registrar.handle(this.protocol, (data) => {
      void this.handleProtocol(data).catch((err) => {
        this.log.error(err);
      });
    }, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnLimitedConnection: this.runOnLimitedConnection
    });
    this.started = true;
  }
  async stop() {
    await this.registrar.unhandle(this.protocol);
    this.started = false;
  }
};

// node_modules/@libp2p/identify/dist/src/identify-push.js
var _a9, _b5;
var IdentifyPush = class extends (_b5 = AbstractIdentify, _a9 = serviceCapabilities, _b5) {
  constructor(components, init = {}) {
    super(components, {
      ...init,
      protocol: `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`,
      log: components.logger.forComponent("libp2p:identify-push")
    });
    __publicField(this, "connectionManager");
    __publicField(this, "concurrency");
    __publicField(this, "_push");
    __publicField(this, _a9, [
      "@libp2p/identify-push"
    ]);
    this.connectionManager = components.connectionManager;
    this.concurrency = init.concurrency ?? defaultValues.concurrency;
    this._push = debounce2(this.sendPushMessage.bind(this), init.debounce ?? PUSH_DEBOUNCE_MS);
    if (init.runOnSelfUpdate ?? defaultValues.runOnSelfUpdate) {
      components.events.addEventListener("self:peer:update", (evt) => {
        this.push().catch((err) => {
          this.log.error("error pushing updates to peers - %e", err);
        });
      });
    }
  }
  /**
   * Calls `push` on all peer connections
   */
  async push() {
    this._push();
  }
  async sendPushMessage() {
    if (!this.isStarted()) {
      return;
    }
    try {
      const listenAddresses = this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(protocols("p2p").code));
      const peerRecord = new PeerRecord2({
        peerId: this.peerId,
        multiaddrs: listenAddresses
      });
      const signedPeerRecord = await RecordEnvelope.seal(peerRecord, this.privateKey);
      const supportedProtocols = this.registrar.getProtocols();
      const peer = await this.peerStore.get(this.peerId);
      const agentVersion = toString2(peer.metadata.get("AgentVersion") ?? fromString2(this.host.agentVersion));
      const protocolVersion = toString2(peer.metadata.get("ProtocolVersion") ?? fromString2(this.host.protocolVersion));
      const self2 = this;
      async function* pushToConnections() {
        for (const connection of self2.connectionManager.getConnections()) {
          const peer2 = await self2.peerStore.get(connection.remotePeer);
          if (!peer2.protocols.includes(self2.protocol)) {
            continue;
          }
          yield async () => {
            let stream;
            const signal = AbortSignal.timeout(self2.timeout);
            setMaxListeners(Infinity, signal);
            try {
              stream = await connection.newStream(self2.protocol, {
                signal,
                runOnLimitedConnection: self2.runOnLimitedConnection
              });
              const pb = pbStream(stream, {
                maxDataLength: self2.maxMessageSize
              }).pb(Identify);
              await pb.write({
                listenAddrs: listenAddresses.map((ma) => ma.bytes),
                signedPeerRecord: signedPeerRecord.marshal(),
                protocols: supportedProtocols,
                agentVersion,
                protocolVersion
              }, {
                signal
              });
              await stream.close({
                signal
              });
            } catch (err) {
              self2.log.error("could not push identify update to peer", err);
              stream == null ? void 0 : stream.abort(err);
            }
          };
        }
      }
      await src_default3(parallel(pushToConnections(), {
        concurrency: this.concurrency
      }));
    } catch (err) {
      this.log.error("error pushing updates to peers - %e", err);
    }
  }
  /**
   * Reads the Identify Push message from the given `connection`
   */
  async handleProtocol(data) {
    const { connection, stream } = data;
    try {
      if (this.peerId.equals(connection.remotePeer)) {
        throw new Error("received push from ourselves?");
      }
      const options = {
        signal: AbortSignal.timeout(this.timeout)
      };
      const pb = pbStream(stream, {
        maxDataLength: this.maxMessageSize
      }).pb(Identify);
      const message2 = await pb.read(options);
      await stream.close(options);
      await consumeIdentifyMessage(this.peerStore, this.events, this.log, connection, message2);
    } catch (err) {
      this.log.error("received invalid message", err);
      stream.abort(err);
      return;
    }
    this.log.trace("handled push from %p", connection.remotePeer);
  }
};

// node_modules/@libp2p/utils/dist/src/multiaddr/is-global-unicast.js
function isGlobalUnicast(ma) {
  try {
    for (const { code: code2, value } of ma.getComponents()) {
      if (value == null) {
        continue;
      }
      if (code2 === CODE_IP6) {
        return cidrContains("2000::/3", value);
      }
    }
  } catch {
  }
  return false;
}

// node_modules/@libp2p/utils/dist/src/private-ip.js
var import_netmask3 = __toESM(require_netmask(), 1);
var PRIVATE_IP_RANGES = [
  "0.0.0.0/8",
  "10.0.0.0/8",
  "100.64.0.0/10",
  "127.0.0.0/8",
  "169.254.0.0/16",
  "172.16.0.0/12",
  "192.0.0.0/24",
  "192.0.0.0/29",
  "192.0.0.8/32",
  "192.0.0.9/32",
  "192.0.0.10/32",
  "192.0.0.170/32",
  "192.0.0.171/32",
  "192.0.2.0/24",
  "192.31.196.0/24",
  "192.52.193.0/24",
  "192.88.99.0/24",
  "192.168.0.0/16",
  "192.175.48.0/24",
  "198.18.0.0/15",
  "198.51.100.0/24",
  "203.0.113.0/24",
  "240.0.0.0/4",
  "255.255.255.255/32"
];
var NETMASK_RANGES = PRIVATE_IP_RANGES.map((ipRange) => new import_netmask3.Netmask(ipRange));
function ipv4Check(ipAddr) {
  for (const r2 of NETMASK_RANGES) {
    if (r2.contains(ipAddr)) {
      return true;
    }
  }
  return false;
}
function isIpv4MappedIpv6(ipAddr) {
  return /^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(ipAddr);
}
function ipv4MappedIpv6Check(ipAddr) {
  const parts = ipAddr.split(":");
  if (parts.length < 2) {
    return false;
  }
  const octet34 = parts[parts.length - 1].padStart(4, "0");
  const octet12 = parts[parts.length - 2].padStart(4, "0");
  const ip4 = `${parseInt(octet12.substring(0, 2), 16)}.${parseInt(octet12.substring(2), 16)}.${parseInt(octet34.substring(0, 2), 16)}.${parseInt(octet34.substring(2), 16)}`;
  return ipv4Check(ip4);
}
function isIpv4EmbeddedIpv6(ipAddr) {
  return /^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr);
}
function ipv4EmbeddedIpv6Check(ipAddr) {
  const parts = ipAddr.split(":");
  const ip4 = parts[parts.length - 1];
  return ipv4Check(ip4);
}
function ipv6Check(ipAddr) {
  return /^::$/.test(ipAddr) || /^::1$/.test(ipAddr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ipAddr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ipAddr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ipAddr);
}
function isPrivateIp(ip) {
  if (isIPv4(ip)) {
    return ipv4Check(ip);
  }
  if (isIpv4MappedIpv6(ip)) {
    return ipv4MappedIpv6Check(ip);
  }
  if (isIpv4EmbeddedIpv6(ip)) {
    return ipv4EmbeddedIpv6Check(ip);
  }
  if (isIPv6(ip)) {
    return ipv6Check(ip);
  }
}

// node_modules/@libp2p/utils/dist/src/multiaddr/is-ip-based.js
function isIpBased(ma) {
  try {
    for (const { code: code2 } of ma.getComponents()) {
      if (code2 === CODE_IP6ZONE) {
        continue;
      }
      return code2 === CODE_IP4 || code2 === CODE_IP6;
    }
  } catch {
  }
  return false;
}

// node_modules/@libp2p/utils/dist/src/multiaddr/is-private.js
function isPrivate(ma) {
  try {
    if (!isIpBased(ma)) {
      return false;
    }
    const [[, value]] = ma.stringTuples();
    if (value == null) {
      return false;
    }
    return isPrivateIp(value) ?? false;
  } catch {
  }
  return true;
}

// node_modules/@multiformats/multiaddr-matcher/dist/src/utils.js
var toParts = (ma) => {
  return ma.toString().split("/").slice(1);
};
var func = (fn) => {
  return {
    match: (vals) => {
      if (vals.length < 1) {
        return false;
      }
      if (fn(vals[0])) {
        return vals.slice(1);
      }
      return false;
    },
    pattern: "fn"
  };
};
var literal = (str) => {
  return {
    match: (vals) => func((val) => val === str).match(vals),
    pattern: str
  };
};
var string2 = () => {
  return {
    match: (vals) => func((val) => typeof val === "string").match(vals),
    pattern: "{string}"
  };
};
var number = () => {
  return {
    match: (vals) => func((val) => !isNaN(parseInt(val))).match(vals),
    pattern: "{number}"
  };
};
var peerId = () => {
  return {
    match: (vals) => {
      if (vals.length < 2) {
        return false;
      }
      if (vals[0] !== "p2p" && vals[0] !== "ipfs") {
        return false;
      }
      if (vals[1].startsWith("Q") || vals[1].startsWith("1")) {
        try {
          base58btc.decode(`z${vals[1]}`);
        } catch (err) {
          return false;
        }
      } else {
        return false;
      }
      return vals.slice(2);
    },
    pattern: "/p2p/{peerid}"
  };
};
var certhash = () => {
  return {
    match: (vals) => {
      if (vals.length < 2) {
        return false;
      }
      if (vals[0] !== "certhash") {
        return false;
      }
      try {
        base64url.decode(vals[1]);
      } catch {
        return false;
      }
      return vals.slice(2);
    },
    pattern: "/certhash/{certhash}"
  };
};
var optional = (matcher) => {
  return {
    match: (vals) => {
      const result = matcher.match(vals);
      if (result === false) {
        return vals;
      }
      return result;
    },
    pattern: `optional(${matcher.pattern})`
  };
};
var or3 = (...matchers) => {
  return {
    match: (vals) => {
      let matches;
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          continue;
        }
        if (matches == null || result.length < matches.length) {
          matches = result;
        }
      }
      if (matches == null) {
        return false;
      }
      return matches;
    },
    pattern: `or(${matchers.map((m2) => m2.pattern).join(", ")})`
  };
};
var and2 = (...matchers) => {
  return {
    match: (vals) => {
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          return false;
        }
        vals = result;
      }
      return vals;
    },
    pattern: `and(${matchers.map((m2) => m2.pattern).join(", ")})`
  };
};
function fmt(...matchers) {
  function match(ma) {
    let parts = toParts(ma);
    for (const matcher of matchers) {
      const result = matcher.match(parts);
      if (result === false) {
        return false;
      }
      parts = result;
    }
    return parts;
  }
  function matches(ma) {
    const result = match(ma);
    return result !== false;
  }
  function exactMatch(ma) {
    const result = match(ma);
    if (result === false) {
      return false;
    }
    return result.length === 0;
  }
  return {
    matchers,
    matches,
    exactMatch
  };
}

// node_modules/@multiformats/multiaddr-matcher/dist/src/index.js
var _PEER_ID = peerId();
var PEER_ID = fmt(_PEER_ID);
var _DNS4 = and2(literal("dns4"), string2());
var _DNS6 = and2(literal("dns6"), string2());
var _DNSADDR = and2(literal("dnsaddr"), string2());
var _DNS = and2(literal("dns"), string2());
var DNS42 = fmt(_DNS4, optional(peerId()));
var DNS62 = fmt(_DNS6, optional(peerId()));
var DNSADDR2 = fmt(_DNSADDR, optional(peerId()));
var DNS3 = fmt(or3(_DNS, _DNSADDR, _DNS4, _DNS6), optional(peerId()));
var _IP4 = and2(literal("ip4"), func(isIPv4));
var _IP6 = and2(literal("ip6"), func(isIPv6));
var _IP = or3(_IP4, _IP6);
var _IP_OR_DOMAIN = or3(_IP, _DNS, _DNS4, _DNS6, _DNSADDR);
var IP_OR_DOMAIN = fmt(or3(_IP, and2(or3(_DNS, _DNSADDR, _DNS4, _DNS6), optional(peerId()))));
var IP4 = fmt(_IP4);
var IP6 = fmt(_IP6);
var IP2 = fmt(_IP);
var _TCP = and2(_IP_OR_DOMAIN, literal("tcp"), number());
var _UDP = and2(_IP_OR_DOMAIN, literal("udp"), number());
var TCP2 = fmt(and2(_TCP, optional(peerId())));
var UDP2 = fmt(_UDP);
var _QUIC = and2(_UDP, literal("quic"), optional(peerId()));
var _QUICV1 = and2(_UDP, literal("quic-v1"), optional(peerId()));
var QUIC_V0_OR_V1 = or3(_QUIC, _QUICV1);
var QUIC2 = fmt(_QUIC);
var QUICV12 = fmt(_QUICV1);
var _WEB = or3(_IP_OR_DOMAIN, _TCP, _UDP, _QUIC, _QUICV1);
var _WebSockets2 = or3(and2(_WEB, literal("ws"), optional(peerId())));
var WebSockets2 = fmt(_WebSockets2);
var _WebSocketsSecure2 = or3(and2(_WEB, literal("wss"), optional(peerId())), and2(_WEB, literal("tls"), optional(and2(literal("sni"), string2())), literal("ws"), optional(peerId())));
var WebSocketsSecure2 = fmt(_WebSocketsSecure2);
var _WebRTCDirect2 = and2(_UDP, literal("webrtc-direct"), optional(certhash()), optional(certhash()), optional(peerId()));
var WebRTCDirect2 = fmt(_WebRTCDirect2);
var _WebTransport2 = and2(_QUICV1, literal("webtransport"), optional(certhash()), optional(certhash()), optional(peerId()));
var WebTransport2 = fmt(_WebTransport2);
var _P2P2 = or3(_WebSockets2, _WebSocketsSecure2, and2(_TCP, optional(peerId())), and2(QUIC_V0_OR_V1, optional(peerId())), and2(_IP_OR_DOMAIN, optional(peerId())), _WebRTCDirect2, _WebTransport2, peerId());
var P2P2 = fmt(_P2P2);
var _Circuit2 = and2(_P2P2, literal("p2p-circuit"), peerId());
var Circuit2 = fmt(_Circuit2);
var _WebRTC = or3(and2(_P2P2, literal("p2p-circuit"), literal("webrtc"), optional(peerId())), and2(_P2P2, literal("webrtc"), optional(peerId())), and2(literal("webrtc"), optional(peerId())));
var WebRTC2 = fmt(_WebRTC);
var _HTTP = or3(and2(_IP_OR_DOMAIN, literal("tcp"), number(), literal("http"), optional(peerId())), and2(_IP_OR_DOMAIN, literal("http"), optional(peerId())));
var HTTP2 = fmt(_HTTP);
var _HTTPS = or3(and2(_IP_OR_DOMAIN, literal("tcp"), or3(and2(literal("443"), literal("http")), and2(number(), literal("https")), and2(number(), literal("tls"), literal("http"))), optional(peerId())), and2(_IP_OR_DOMAIN, literal("tls"), literal("http"), optional(peerId())), and2(_IP_OR_DOMAIN, literal("https"), optional(peerId())));
var HTTPS2 = fmt(_HTTPS);
var _Memory = or3(and2(literal("memory"), string2(), optional(peerId())));
var Memory = fmt(_Memory);
var _Unix = or3(and2(literal("unix"), string2(), optional(peerId())));
var Unix = fmt(_Unix);

// node_modules/@libp2p/identify/dist/src/identify.js
var _a10, _b6;
var Identify2 = class extends (_b6 = AbstractIdentify, _a10 = serviceCapabilities, _b6) {
  constructor(components, init = {}) {
    super(components, {
      ...init,
      protocol: `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,
      log: components.logger.forComponent("libp2p:identify")
    });
    __publicField(this, _a10, [
      "@libp2p/identify"
    ]);
    if (init.runOnConnectionOpen ?? defaultValues.runOnConnectionOpen) {
      components.events.addEventListener("connection:open", (evt) => {
        const connection = evt.detail;
        this.identify(connection).catch((err) => {
          if (err.name === UnsupportedProtocolError.name) {
            return;
          }
          this.log.error("error during identify trigged by connection:open", err);
        });
      });
    }
  }
  async _identify(connection, options = {}) {
    let stream;
    if (options.signal == null) {
      const signal = AbortSignal.timeout(this.timeout);
      setMaxListeners(Infinity, signal);
      options = {
        ...options,
        signal
      };
    }
    try {
      stream = await connection.newStream(this.protocol, {
        ...options,
        runOnLimitedConnection: this.runOnLimitedConnection
      });
      const pb = pbStream(stream, {
        maxDataLength: this.maxMessageSize
      }).pb(Identify);
      const message2 = await pb.read(options);
      await stream.close(options);
      return message2;
    } catch (err) {
      stream == null ? void 0 : stream.abort(err);
      throw err;
    }
  }
  async identify(connection, options = {}) {
    const message2 = await this._identify(connection, options);
    const { publicKey, protocols: protocols2, observedAddr } = message2;
    if (publicKey == null) {
      throw new InvalidMessageError("public key was missing from identify message");
    }
    const key = publicKeyFromProtobuf(publicKey);
    const id = peerIdFromCID(key.toCID());
    if (!connection.remotePeer.equals(id)) {
      throw new InvalidMessageError("identified peer does not match the expected peer");
    }
    if (this.peerId.equals(id)) {
      throw new InvalidMessageError("identified peer is our own peer id?");
    }
    this.maybeAddObservedAddress(observedAddr);
    this.log("identify completed for peer %p and protocols %o", id, protocols2);
    return consumeIdentifyMessage(this.peerStore, this.events, this.log, connection, message2);
  }
  maybeAddObservedAddress(observedAddr) {
    const cleanObservedAddr = getCleanMultiaddr(observedAddr);
    if (cleanObservedAddr == null) {
      return;
    }
    this.log.trace("our observed address was %a", cleanObservedAddr);
    if (isPrivate(cleanObservedAddr)) {
      this.log.trace("our observed address was private");
      return;
    }
    const tuples = cleanObservedAddr.getComponents();
    if ((tuples[0].code === CODE_IP6 || tuples[0].code === CODE_IP6ZONE && tuples[1].code === CODE_IP6) && !isGlobalUnicast(cleanObservedAddr)) {
      this.log.trace("our observed address was IPv6 but not a global unicast address");
      return;
    }
    if (TCP2.exactMatch(cleanObservedAddr)) {
      return;
    }
    this.log.trace("storing the observed address");
    this.addressManager.addObservedAddr(cleanObservedAddr);
  }
  /**
   * Sends the `Identify` response with the Signed Peer Record
   * to the requesting peer over the given `connection`
   */
  async handleProtocol(data) {
    const { connection, stream } = data;
    const signal = AbortSignal.timeout(this.timeout);
    setMaxListeners(Infinity, signal);
    try {
      const peerData = await this.peerStore.get(this.peerId);
      const multiaddrs = this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(protocols("p2p").code));
      let signedPeerRecord = peerData.peerRecordEnvelope;
      if (multiaddrs.length > 0 && signedPeerRecord == null) {
        const peerRecord = new PeerRecord2({
          peerId: this.peerId,
          multiaddrs
        });
        const envelope = await RecordEnvelope.seal(peerRecord, this.privateKey);
        signedPeerRecord = envelope.marshal().subarray();
      }
      let observedAddr = connection.remoteAddr.bytes;
      if (!IP_OR_DOMAIN.matches(connection.remoteAddr)) {
        observedAddr = void 0;
      }
      const pb = pbStream(stream).pb(Identify);
      await pb.write({
        protocolVersion: this.host.protocolVersion,
        agentVersion: this.host.agentVersion,
        publicKey: publicKeyToProtobuf(this.privateKey.publicKey),
        listenAddrs: multiaddrs.map((addr) => addr.bytes),
        signedPeerRecord,
        observedAddr,
        protocols: peerData.protocols
      }, {
        signal
      });
      await stream.close({
        signal
      });
    } catch (err) {
      this.log.error("could not respond to identify request", err);
      stream.abort(err);
    }
  }
};

// node_modules/@libp2p/identify/dist/src/index.js
function identify(init = {}) {
  return (components) => new Identify2(components, init);
}

// node_modules/get-iterator/dist/src/index.js
function getIterator(obj) {
  if (obj != null) {
    if (typeof obj[Symbol.iterator] === "function") {
      return obj[Symbol.iterator]();
    }
    if (typeof obj[Symbol.asyncIterator] === "function") {
      return obj[Symbol.asyncIterator]();
    }
    if (typeof obj.next === "function") {
      return obj;
    }
  }
  throw new Error("argument is not an iterator or iterable");
}

// node_modules/@libp2p/utils/dist/src/is-promise.js
function isPromise2(thing) {
  if (thing == null) {
    return false;
  }
  return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}

// node_modules/@libp2p/utils/dist/src/close-source.js
function closeSource(source, log41) {
  var _a27, _b14;
  const res = (_b14 = (_a27 = getIterator(source)).return) == null ? void 0 : _b14.call(_a27);
  if (isPromise2(res)) {
    res.catch((err) => {
      log41.error("could not cause iterator to return", err);
    });
  }
}

// node_modules/delay/index.js
var createAbortError = () => {
  const error = new Error("Delay aborted");
  error.name = "AbortError";
  return error;
};
var clearMethods = /* @__PURE__ */ new WeakMap();
function createDelay({ clearTimeout: defaultClear, setTimeout: defaultSet } = {}) {
  return (milliseconds, { value, signal } = {}) => {
    if (signal == null ? void 0 : signal.aborted) {
      return Promise.reject(createAbortError());
    }
    let timeoutId;
    let settle;
    let rejectFunction;
    const clear = defaultClear ?? clearTimeout;
    const signalListener = () => {
      clear(timeoutId);
      rejectFunction(createAbortError());
    };
    const cleanup = () => {
      if (signal) {
        signal.removeEventListener("abort", signalListener);
      }
    };
    const delayPromise = new Promise((resolve, reject) => {
      settle = () => {
        cleanup();
        resolve(value);
      };
      rejectFunction = reject;
      timeoutId = (defaultSet ?? setTimeout)(settle, milliseconds);
    });
    if (signal) {
      signal.addEventListener("abort", signalListener, { once: true });
    }
    clearMethods.set(delayPromise, () => {
      clear(timeoutId);
      timeoutId = null;
      settle();
    });
    return delayPromise;
  };
}
var delay2 = createDelay();
var delay_default = delay2;

// node_modules/@libp2p/utils/dist/src/errors.js
var RateLimitError = class extends Error {
  constructor(message2 = "Rate limit exceeded", props) {
    super(message2);
    __publicField(this, "remainingPoints");
    __publicField(this, "msBeforeNext");
    __publicField(this, "consumedPoints");
    __publicField(this, "isFirstInDuration");
    this.name = "RateLimitError";
    this.remainingPoints = props.remainingPoints;
    this.msBeforeNext = props.msBeforeNext;
    this.consumedPoints = props.consumedPoints;
    this.isFirstInDuration = props.isFirstInDuration;
  }
};
var QueueFullError = class extends Error {
  constructor(message2 = "The queue was full") {
    super(message2);
    this.name = "QueueFullError";
  }
};
__publicField(QueueFullError, "name", "QueueFullError");

// node_modules/@libp2p/utils/dist/src/rate-limiter.js
var RateLimiter = class {
  constructor(opts = {}) {
    __publicField(this, "memoryStorage");
    __publicField(this, "points");
    __publicField(this, "duration");
    __publicField(this, "blockDuration");
    __publicField(this, "execEvenly");
    __publicField(this, "execEvenlyMinDelayMs");
    __publicField(this, "keyPrefix");
    this.points = opts.points ?? 4;
    this.duration = opts.duration ?? 1;
    this.blockDuration = opts.blockDuration ?? 0;
    this.execEvenly = opts.execEvenly ?? false;
    this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs ?? this.duration * 1e3 / this.points;
    this.keyPrefix = opts.keyPrefix ?? "rlflx";
    this.memoryStorage = new MemoryStorage();
  }
  async consume(key, pointsToConsume = 1, options = {}) {
    const rlKey = this.getKey(key);
    const secDuration = this._getKeySecDuration(options);
    let res = this.memoryStorage.incrby(rlKey, pointsToConsume, secDuration);
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    if (res.consumedPoints > this.points) {
      if (this.blockDuration > 0 && res.consumedPoints <= this.points + pointsToConsume) {
        res = this.memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);
      }
      throw new RateLimitError("Rate limit exceeded", res);
    } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
      let delayMs = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
      if (delayMs < this.execEvenlyMinDelayMs) {
        delayMs = res.consumedPoints * this.execEvenlyMinDelayMs;
      }
      await delay_default(delayMs);
    }
    return res;
  }
  penalty(key, points = 1, options = {}) {
    const rlKey = this.getKey(key);
    const secDuration = this._getKeySecDuration(options);
    const res = this.memoryStorage.incrby(rlKey, points, secDuration);
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    return res;
  }
  reward(key, points = 1, options = {}) {
    const rlKey = this.getKey(key);
    const secDuration = this._getKeySecDuration(options);
    const res = this.memoryStorage.incrby(rlKey, -points, secDuration);
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    return res;
  }
  /**
   * Block any key for secDuration seconds
   *
   * @param key
   * @param secDuration
   */
  block(key, secDuration) {
    const msDuration = secDuration * 1e3;
    const initPoints = this.points + 1;
    this.memoryStorage.set(this.getKey(key), initPoints, secDuration);
    return {
      remainingPoints: 0,
      msBeforeNext: msDuration === 0 ? -1 : msDuration,
      consumedPoints: initPoints,
      isFirstInDuration: false
    };
  }
  set(key, points, secDuration = 0) {
    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
    this.memoryStorage.set(this.getKey(key), points, secDuration);
    return {
      remainingPoints: 0,
      msBeforeNext: msDuration === 0 ? -1 : msDuration,
      consumedPoints: points,
      isFirstInDuration: false
    };
  }
  get(key) {
    const res = this.memoryStorage.get(this.getKey(key));
    if (res != null) {
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    }
    return res;
  }
  delete(key) {
    this.memoryStorage.delete(this.getKey(key));
  }
  _getKeySecDuration(options) {
    if ((options == null ? void 0 : options.customDuration) != null && options.customDuration >= 0) {
      return options.customDuration;
    }
    return this.duration;
  }
  getKey(key) {
    return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key;
  }
  parseKey(rlKey) {
    return rlKey.substring(this.keyPrefix.length);
  }
};
var MemoryStorage = class {
  constructor() {
    __publicField(this, "storage");
    this.storage = /* @__PURE__ */ new Map();
  }
  incrby(key, value, durationSec) {
    const existing = this.storage.get(key);
    if (existing != null) {
      const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
      if (existing.expiresAt == null || msBeforeExpires > 0) {
        existing.value += value;
        return {
          remainingPoints: 0,
          msBeforeNext: msBeforeExpires,
          consumedPoints: existing.value,
          isFirstInDuration: false
        };
      }
      return this.set(key, value, durationSec);
    }
    return this.set(key, value, durationSec);
  }
  set(key, value, durationSec) {
    const durationMs = durationSec * 1e3;
    const existing = this.storage.get(key);
    if (existing != null) {
      clearTimeout(existing.timeoutId);
    }
    const record = {
      value,
      expiresAt: durationMs > 0 ? new Date(Date.now() + durationMs) : void 0
    };
    this.storage.set(key, record);
    if (durationMs > 0) {
      record.timeoutId = setTimeout(() => {
        this.storage.delete(key);
      }, durationMs);
      if (record.timeoutId.unref != null) {
        record.timeoutId.unref();
      }
    }
    return {
      remainingPoints: 0,
      msBeforeNext: durationMs === 0 ? -1 : durationMs,
      consumedPoints: record.value,
      isFirstInDuration: true
    };
  }
  get(key) {
    const existing = this.storage.get(key);
    if (existing != null) {
      const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
      return {
        remainingPoints: 0,
        msBeforeNext: msBeforeExpires,
        consumedPoints: existing.value,
        isFirstInDuration: false
      };
    }
  }
  delete(key) {
    const record = this.storage.get(key);
    if (record != null) {
      if (record.timeoutId != null) {
        clearTimeout(record.timeoutId);
      }
      this.storage.delete(key);
      return true;
    }
    return false;
  }
};

// node_modules/@libp2p/mplex/dist/src/message-types.js
var MessageTypes;
(function(MessageTypes2) {
  MessageTypes2[MessageTypes2["NEW_STREAM"] = 0] = "NEW_STREAM";
  MessageTypes2[MessageTypes2["MESSAGE_RECEIVER"] = 1] = "MESSAGE_RECEIVER";
  MessageTypes2[MessageTypes2["MESSAGE_INITIATOR"] = 2] = "MESSAGE_INITIATOR";
  MessageTypes2[MessageTypes2["CLOSE_RECEIVER"] = 3] = "CLOSE_RECEIVER";
  MessageTypes2[MessageTypes2["CLOSE_INITIATOR"] = 4] = "CLOSE_INITIATOR";
  MessageTypes2[MessageTypes2["RESET_RECEIVER"] = 5] = "RESET_RECEIVER";
  MessageTypes2[MessageTypes2["RESET_INITIATOR"] = 6] = "RESET_INITIATOR";
})(MessageTypes || (MessageTypes = {}));
var MessageTypeNames = Object.freeze({
  0: "NEW_STREAM",
  1: "MESSAGE_RECEIVER",
  2: "MESSAGE_INITIATOR",
  3: "CLOSE_RECEIVER",
  4: "CLOSE_INITIATOR",
  5: "RESET_RECEIVER",
  6: "RESET_INITIATOR"
});
var InitiatorMessageTypes = Object.freeze({
  NEW_STREAM: MessageTypes.NEW_STREAM,
  MESSAGE: MessageTypes.MESSAGE_INITIATOR,
  CLOSE: MessageTypes.CLOSE_INITIATOR,
  RESET: MessageTypes.RESET_INITIATOR
});
var ReceiverMessageTypes = Object.freeze({
  MESSAGE: MessageTypes.MESSAGE_RECEIVER,
  CLOSE: MessageTypes.CLOSE_RECEIVER,
  RESET: MessageTypes.RESET_RECEIVER
});

// node_modules/@libp2p/mplex/dist/src/decode.js
var MAX_MSG_SIZE = 1 << 20;
var MAX_MSG_QUEUE_SIZE = 4 << 20;
var Decoder3 = class {
  constructor(maxMessageSize = MAX_MSG_SIZE, maxUnprocessedMessageQueueSize = MAX_MSG_QUEUE_SIZE) {
    __publicField(this, "_buffer");
    __publicField(this, "_headerInfo");
    __publicField(this, "_maxMessageSize");
    __publicField(this, "_maxUnprocessedMessageQueueSize");
    this._buffer = new Uint8ArrayList();
    this._headerInfo = null;
    this._maxMessageSize = maxMessageSize;
    this._maxUnprocessedMessageQueueSize = maxUnprocessedMessageQueueSize;
  }
  write(chunk) {
    if (chunk == null || chunk.length === 0) {
      return [];
    }
    this._buffer.append(chunk);
    if (this._buffer.byteLength > this._maxUnprocessedMessageQueueSize) {
      throw new InvalidMessageError("Unprocessed message queue size too large!");
    }
    const msgs = [];
    while (this._buffer.length !== 0) {
      if (this._headerInfo == null) {
        try {
          this._headerInfo = this._decodeHeader(this._buffer);
        } catch (err) {
          if (err.name === "InvalidMessageError") {
            throw err;
          }
          break;
        }
      }
      const { id, type, length: length3, offset } = this._headerInfo;
      const bufferedDataLength = this._buffer.length - offset;
      if (bufferedDataLength < length3) {
        break;
      }
      const msg = {
        id,
        type
      };
      if (type === MessageTypes.NEW_STREAM || type === MessageTypes.MESSAGE_INITIATOR || type === MessageTypes.MESSAGE_RECEIVER) {
        msg.data = this._buffer.sublist(offset, offset + length3);
      }
      msgs.push(msg);
      this._buffer.consume(offset + length3);
      this._headerInfo = null;
    }
    return msgs;
  }
  /**
   * Attempts to decode the message header from the buffer
   */
  _decodeHeader(data) {
    const { value: h, offset } = readVarInt(data);
    const { value: length3, offset: end } = readVarInt(data, offset);
    const type = h & 7;
    if (MessageTypeNames[type] == null) {
      throw new Error(`Invalid type received: ${type}`);
    }
    if (length3 > this._maxMessageSize) {
      throw new InvalidMessageError("Message size too large");
    }
    return { id: h >> 3, type, offset: offset + end, length: length3 };
  }
};
var MSB3 = 128;
var REST3 = 127;
function readVarInt(buf, offset = 0) {
  let res = 0;
  let shift = 0;
  let counter = offset;
  let b;
  const l2 = buf.length;
  do {
    if (counter >= l2 || shift > 49) {
      offset = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf.get(counter++);
    res += shift < 28 ? (b & REST3) << shift : (b & REST3) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB3);
  offset = counter - offset;
  return {
    value: res,
    offset
  };
}

// node_modules/@libp2p/mplex/dist/src/encode.js
var POOL_SIZE = 10 * 1024;
var Encoder3 = class {
  constructor() {
    __publicField(this, "_pool");
    __publicField(this, "_poolOffset");
    this._pool = allocUnsafe(POOL_SIZE);
    this._poolOffset = 0;
  }
  /**
   * Encodes the given message and adds it to the passed list
   */
  write(msg, list) {
    const pool2 = this._pool;
    let offset = this._poolOffset;
    encode(msg.id << 3 | msg.type, pool2, offset);
    offset += encodingLength(msg.id << 3 | msg.type);
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      encode(msg.data.length, pool2, offset);
      offset += encodingLength(msg.data.length);
    } else {
      encode(0, pool2, offset);
      offset += encodingLength(0);
    }
    const header = pool2.subarray(this._poolOffset, offset);
    if (POOL_SIZE - offset < 100) {
      this._pool = allocUnsafe(POOL_SIZE);
      this._poolOffset = 0;
    } else {
      this._poolOffset = offset;
    }
    list.append(header);
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      list.append(msg.data);
    }
  }
};
var encoder = new Encoder3();
async function* encode8(source) {
  for await (const message2 of source) {
    const list = new Uint8ArrayList();
    encoder.write(message2, list);
    yield list;
  }
}

// node_modules/@libp2p/mplex/dist/src/errors.js
var StreamInputBufferError = class extends Error {
  constructor(message2 = "Stream input buffer error") {
    super(message2);
    this.name = "StreamInputBufferError";
  }
};

// node_modules/race-signal/dist/src/index.js
var AbortError3 = class extends Error {
  constructor(message2, code2, name3) {
    super(message2 ?? "The operation was aborted");
    __publicField(this, "type");
    __publicField(this, "code");
    this.type = "aborted";
    this.name = name3 ?? "AbortError";
    this.code = code2 ?? "ABORT_ERR";
  }
};
async function raceSignal3(promise, signal, opts) {
  if (signal == null) {
    return promise;
  }
  if (signal.aborted) {
    promise.catch(() => {
    });
    return Promise.reject(new AbortError3(opts == null ? void 0 : opts.errorMessage, opts == null ? void 0 : opts.errorCode, opts == null ? void 0 : opts.errorName));
  }
  let listener;
  const error = new AbortError3(opts == null ? void 0 : opts.errorMessage, opts == null ? void 0 : opts.errorCode, opts == null ? void 0 : opts.errorName);
  try {
    return await Promise.race([
      promise,
      new Promise((resolve, reject) => {
        listener = () => {
          reject(error);
        };
        signal.addEventListener("abort", listener);
      })
    ]);
  } finally {
    if (listener != null) {
      signal.removeEventListener("abort", listener);
    }
  }
}

// node_modules/@libp2p/utils/dist/src/abstract-stream.js
var DEFAULT_SEND_CLOSE_WRITE_TIMEOUT = 5e3;
function isPromise3(thing) {
  if (thing == null) {
    return false;
  }
  return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}
var AbstractStream = class {
  constructor(init) {
    __publicField(this, "id");
    __publicField(this, "direction");
    __publicField(this, "timeline");
    __publicField(this, "protocol");
    __publicField(this, "metadata");
    __publicField(this, "source");
    __publicField(this, "status");
    __publicField(this, "readStatus");
    __publicField(this, "writeStatus");
    __publicField(this, "log");
    __publicField(this, "sinkController");
    __publicField(this, "sinkEnd");
    __publicField(this, "closed");
    __publicField(this, "endErr");
    __publicField(this, "streamSource");
    __publicField(this, "onEnd");
    __publicField(this, "onCloseRead");
    __publicField(this, "onCloseWrite");
    __publicField(this, "onReset");
    __publicField(this, "onAbort");
    __publicField(this, "sendCloseWriteTimeout");
    __publicField(this, "sendingData");
    this.sinkController = new AbortController();
    this.sinkEnd = pDefer();
    this.closed = pDefer();
    this.log = init.log;
    this.status = "open";
    this.readStatus = "ready";
    this.writeStatus = "ready";
    this.id = init.id;
    this.metadata = init.metadata ?? {};
    this.direction = init.direction;
    this.timeline = {
      open: Date.now()
    };
    this.sendCloseWriteTimeout = init.sendCloseWriteTimeout ?? DEFAULT_SEND_CLOSE_WRITE_TIMEOUT;
    this.onEnd = init.onEnd;
    this.onCloseRead = init.onCloseRead;
    this.onCloseWrite = init.onCloseWrite;
    this.onReset = init.onReset;
    this.onAbort = init.onAbort;
    this.source = this.streamSource = pushable({
      onEnd: (err) => {
        if (err != null) {
          this.log.trace("source ended with error", err);
        } else {
          this.log.trace("source ended");
        }
        this.onSourceEnd(err);
      }
    });
    this.sink = this.sink.bind(this);
  }
  async sink(source) {
    if (this.writeStatus !== "ready") {
      throw new StreamStateError(`writable end state is "${this.writeStatus}" not "ready"`);
    }
    try {
      this.writeStatus = "writing";
      const options = {
        signal: this.sinkController.signal
      };
      if (this.direction === "outbound") {
        const res = this.sendNewStream(options);
        if (isPromise3(res)) {
          await res;
        }
      }
      const abortListener = () => {
        closeSource(source, this.log);
      };
      try {
        this.sinkController.signal.addEventListener("abort", abortListener);
        this.log.trace("sink reading from source");
        for await (let data of source) {
          data = data instanceof Uint8Array ? new Uint8ArrayList(data) : data;
          const res = this.sendData(data, options);
          if (isPromise3(res)) {
            this.sendingData = pDefer();
            await res;
            this.sendingData.resolve();
            this.sendingData = void 0;
          }
        }
      } finally {
        this.sinkController.signal.removeEventListener("abort", abortListener);
      }
      this.log.trace('sink finished reading from source, write status is "%s"', this.writeStatus);
      if (this.writeStatus === "writing") {
        this.writeStatus = "closing";
        this.log.trace("send close write to remote");
        await this.sendCloseWrite({
          signal: AbortSignal.timeout(this.sendCloseWriteTimeout)
        });
        this.writeStatus = "closed";
      }
      this.onSinkEnd();
    } catch (err) {
      this.log.trace("sink ended with error, calling abort with error", err);
      this.abort(err);
      throw err;
    } finally {
      this.log.trace("resolve sink end");
      this.sinkEnd.resolve();
    }
  }
  onSourceEnd(err) {
    var _a27;
    if (this.timeline.closeRead != null) {
      return;
    }
    this.timeline.closeRead = Date.now();
    this.readStatus = "closed";
    if (err != null && this.endErr == null) {
      this.endErr = err;
    }
    (_a27 = this.onCloseRead) == null ? void 0 : _a27.call(this);
    if (this.timeline.closeWrite != null) {
      this.log.trace("source and sink ended");
      this.timeline.close = Date.now();
      if (this.status !== "aborted" && this.status !== "reset") {
        this.status = "closed";
      }
      if (this.onEnd != null) {
        this.onEnd(this.endErr);
      }
      this.closed.resolve();
    } else {
      this.log.trace("source ended, waiting for sink to end");
    }
  }
  onSinkEnd(err) {
    var _a27;
    if (this.timeline.closeWrite != null) {
      return;
    }
    this.timeline.closeWrite = Date.now();
    this.writeStatus = "closed";
    if (err != null && this.endErr == null) {
      this.endErr = err;
    }
    (_a27 = this.onCloseWrite) == null ? void 0 : _a27.call(this);
    if (this.timeline.closeRead != null) {
      this.log.trace("sink and source ended");
      this.timeline.close = Date.now();
      if (this.status !== "aborted" && this.status !== "reset") {
        this.status = "closed";
      }
      if (this.onEnd != null) {
        this.onEnd(this.endErr);
      }
      this.closed.resolve();
    } else {
      this.log.trace("sink ended, waiting for source to end");
    }
  }
  // Close for both Reading and Writing
  async close(options) {
    if (this.status !== "open") {
      return;
    }
    this.log.trace("closing gracefully");
    this.status = "closing";
    await raceSignal3(Promise.all([
      this.closeWrite(options),
      this.closeRead(options),
      this.closed.promise
    ]), options == null ? void 0 : options.signal);
    this.status = "closed";
    this.log.trace("closed gracefully");
  }
  async closeRead(options = {}) {
    if (this.readStatus === "closing" || this.readStatus === "closed") {
      return;
    }
    this.log.trace('closing readable end of stream with starting read status "%s"', this.readStatus);
    const readStatus = this.readStatus;
    this.readStatus = "closing";
    if (this.status !== "reset" && this.status !== "aborted" && this.timeline.closeRead == null) {
      this.log.trace("send close read to remote");
      await this.sendCloseRead(options);
    }
    if (readStatus === "ready") {
      this.log.trace("ending internal source queue with %d queued bytes", this.streamSource.readableLength);
      this.streamSource.end();
    }
    this.log.trace("closed readable end of stream");
  }
  async closeWrite(options = {}) {
    if (this.writeStatus === "closing" || this.writeStatus === "closed") {
      return;
    }
    this.log.trace('closing writable end of stream with starting write status "%s"', this.writeStatus);
    if (this.writeStatus === "ready") {
      this.log.trace("sink was never sunk, sink an empty array");
      await raceSignal3(this.sink([]), options.signal);
    }
    if (this.writeStatus === "writing") {
      if (this.sendingData != null) {
        await raceSignal3(this.sendingData.promise, options.signal);
      }
      this.log.trace("aborting source passed to .sink");
      this.sinkController.abort();
      await raceSignal3(this.sinkEnd.promise, options.signal);
    }
    this.writeStatus = "closed";
    this.log.trace("closed writable end of stream");
  }
  /**
   * Close immediately for reading and writing and send a reset message (local
   * error)
   */
  abort(err) {
    var _a27;
    if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
      return;
    }
    this.log("abort with error", err);
    this.log("try to send reset to remote");
    const res = this.sendReset();
    if (isPromise3(res)) {
      res.catch((err2) => {
        this.log.error("error sending reset message", err2);
      });
    }
    this.status = "aborted";
    this.timeline.abort = Date.now();
    this._closeSinkAndSource(err);
    (_a27 = this.onAbort) == null ? void 0 : _a27.call(this, err);
  }
  /**
   * Receive a reset message - close immediately for reading and writing (remote
   * error)
   */
  reset() {
    var _a27;
    if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
      return;
    }
    const err = new StreamResetError("stream reset");
    this.status = "reset";
    this.timeline.reset = Date.now();
    this._closeSinkAndSource(err);
    (_a27 = this.onReset) == null ? void 0 : _a27.call(this);
  }
  _closeSinkAndSource(err) {
    this._closeSink(err);
    this._closeSource(err);
  }
  _closeSink(err) {
    if (this.writeStatus === "writing") {
      this.log.trace("end sink source");
      this.sinkController.abort();
    }
    this.onSinkEnd(err);
  }
  _closeSource(err) {
    if (this.readStatus !== "closing" && this.readStatus !== "closed") {
      this.log.trace("ending source with %d bytes to be read by consumer", this.streamSource.readableLength);
      this.readStatus = "closing";
      this.streamSource.end(err);
    }
  }
  /**
   * The remote closed for writing so we should expect to receive no more
   * messages
   */
  remoteCloseWrite() {
    if (this.readStatus === "closing" || this.readStatus === "closed") {
      this.log("received remote close write but local source is already closed");
      return;
    }
    this.log.trace("remote close write");
    this._closeSource();
  }
  /**
   * The remote closed for reading so we should not send any more
   * messages
   */
  remoteCloseRead() {
    if (this.writeStatus === "closing" || this.writeStatus === "closed") {
      this.log("received remote close read but local sink is already closed");
      return;
    }
    this.log.trace("remote close read");
    this._closeSink();
  }
  /**
   * The underlying muxer has closed, no more messages can be sent or will
   * be received, close immediately to free up resources
   */
  destroy() {
    if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
      this.log("received destroy but we are already closed");
      return;
    }
    this.log.trace("stream destroyed");
    this._closeSinkAndSource();
  }
  /**
   * When an extending class reads data from it's implementation-specific source,
   * call this method to allow the stream consumer to read the data.
   */
  sourcePush(data) {
    this.streamSource.push(data);
  }
  /**
   * Returns the amount of unread data - can be used to prevent large amounts of
   * data building up when the stream consumer is too slow.
   */
  sourceReadableLength() {
    return this.streamSource.readableLength;
  }
};

// node_modules/@libp2p/mplex/dist/src/stream.js
var MplexStream = class extends AbstractStream {
  constructor(init) {
    super(init);
    __publicField(this, "name");
    __publicField(this, "streamId");
    __publicField(this, "send");
    __publicField(this, "types");
    __publicField(this, "maxDataSize");
    this.types = init.direction === "outbound" ? InitiatorMessageTypes : ReceiverMessageTypes;
    this.send = init.send;
    this.name = init.name;
    this.streamId = init.streamId;
    this.maxDataSize = init.maxDataSize;
  }
  async sendNewStream() {
    await this.send({ id: this.streamId, type: InitiatorMessageTypes.NEW_STREAM, data: new Uint8ArrayList(fromString2(this.name)) });
  }
  async sendData(data) {
    data = data.sublist();
    while (data.byteLength > 0) {
      const toSend = Math.min(data.byteLength, this.maxDataSize);
      await this.send({
        id: this.streamId,
        type: this.types.MESSAGE,
        data: data.sublist(0, toSend)
      });
      data.consume(toSend);
    }
  }
  async sendReset() {
    await this.send({ id: this.streamId, type: this.types.RESET });
  }
  async sendCloseWrite() {
    await this.send({ id: this.streamId, type: this.types.CLOSE });
  }
  async sendCloseRead() {
  }
};
function createStream(options) {
  const { id, name: name3, send, onEnd, type = "initiator", maxMsgSize = MAX_MSG_SIZE } = options;
  return new MplexStream({
    id: type === "initiator" ? `i${id}` : `r${id}`,
    streamId: id,
    name: `${name3 ?? id}`,
    direction: type === "initiator" ? "outbound" : "inbound",
    maxDataSize: maxMsgSize,
    onEnd,
    send,
    log: options.logger.forComponent(`libp2p:mplex:stream:${type}:${id}`)
  });
}

// node_modules/@libp2p/mplex/dist/src/mplex.js
var MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION = 1024;
var MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION = 1024;
var MAX_STREAM_BUFFER_SIZE = 1024 * 1024 * 4;
var DISCONNECT_THRESHOLD = 5;
var CLOSE_TIMEOUT = 500;
function printMessage(msg) {
  const output = {
    ...msg,
    type: `${MessageTypeNames[msg.type]} (${msg.type})`
  };
  if (msg.type === MessageTypes.NEW_STREAM) {
    output.data = toString2(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray());
  }
  if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {
    output.data = toString2(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray(), "base16");
  }
  return output;
}
var MplexStreamMuxer = class {
  constructor(components, init) {
    __publicField(this, "protocol", "/mplex/6.7.0");
    __publicField(this, "sink");
    __publicField(this, "source");
    __publicField(this, "log");
    __publicField(this, "_streamId");
    __publicField(this, "_streams");
    __publicField(this, "_init");
    __publicField(this, "_source");
    __publicField(this, "closeController");
    __publicField(this, "rateLimiter");
    __publicField(this, "closeTimeout");
    __publicField(this, "logger");
    init = init ?? {};
    this.log = components.logger.forComponent("libp2p:mplex");
    this.logger = components.logger;
    this._streamId = 0;
    this._streams = {
      /**
       * Stream to ids map
       */
      initiators: /* @__PURE__ */ new Map(),
      /**
       * Stream to ids map
       */
      receivers: /* @__PURE__ */ new Map()
    };
    this._init = init;
    this.closeTimeout = init.closeTimeout ?? CLOSE_TIMEOUT;
    this.sink = this._createSink();
    this._source = pushable({
      objectMode: true,
      onEnd: () => {
        for (const stream of this._streams.initiators.values()) {
          stream.destroy();
        }
        for (const stream of this._streams.receivers.values()) {
          stream.destroy();
        }
      }
    });
    this.source = pipe(this._source, (source) => encode8(source));
    this.closeController = new AbortController();
    this.rateLimiter = new RateLimiter({
      points: init.disconnectThreshold ?? DISCONNECT_THRESHOLD,
      duration: 1
    });
  }
  /**
   * Returns a Map of streams and their ids
   */
  get streams() {
    const streams = [];
    for (const stream of this._streams.initiators.values()) {
      streams.push(stream);
    }
    for (const stream of this._streams.receivers.values()) {
      streams.push(stream);
    }
    return streams;
  }
  /**
   * Initiate a new stream with the given name. If no name is
   * provided, the id of the stream will be used.
   */
  newStream(name3) {
    if (this.closeController.signal.aborted) {
      throw new MuxerClosedError("Muxer already closed");
    }
    const id = this._streamId++;
    name3 = name3 == null ? id.toString() : name3.toString();
    const registry2 = this._streams.initiators;
    return this._newStream({ id, name: name3, type: "initiator", registry: registry2 });
  }
  /**
   * Close or abort all tracked streams and stop the muxer
   */
  async close(options) {
    if (this.closeController.signal.aborted) {
      return;
    }
    const signal = (options == null ? void 0 : options.signal) ?? AbortSignal.timeout(this.closeTimeout);
    try {
      await Promise.all(this.streams.map(async (s2) => s2.close({
        signal
      })));
      this._source.end();
      await this._source.onEmpty({
        signal
      });
      this.closeController.abort();
    } catch (err) {
      this.abort(err);
    }
  }
  abort(err) {
    if (this.closeController.signal.aborted) {
      return;
    }
    this.streams.forEach((s2) => {
      s2.abort(err);
    });
    this.closeController.abort(err);
  }
  /**
   * Called whenever an inbound stream is created
   */
  _newReceiverStream(options) {
    const { id, name: name3 } = options;
    const registry2 = this._streams.receivers;
    return this._newStream({ id, name: name3, type: "receiver", registry: registry2 });
  }
  _newStream(options) {
    const { id, name: name3, type, registry: registry2 } = options;
    this.log("new %s stream %s", type, id);
    if (type === "initiator" && this._streams.initiators.size === (this._init.maxOutboundStreams ?? MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION)) {
      throw new TooManyOutboundProtocolStreamsError("Too many outbound streams open");
    }
    if (registry2.has(id)) {
      throw new Error(`${type} stream ${id} already exists!`);
    }
    const send = async (msg) => {
      if (this.log.enabled) {
        this.log.trace("%s stream %s send", type, id, printMessage(msg));
      }
      this._source.push(msg);
    };
    const onEnd = () => {
      this.log("%s stream with id %s and protocol %s ended", type, id, stream.protocol);
      registry2.delete(id);
      if (this._init.onStreamEnd != null) {
        this._init.onStreamEnd(stream);
      }
    };
    const stream = createStream({ id, name: name3, send, type, onEnd, maxMsgSize: this._init.maxMsgSize, logger: this.logger });
    registry2.set(id, stream);
    return stream;
  }
  /**
   * Creates a sink with an abortable source. Incoming messages will
   * also have their size restricted. All messages will be varint decoded.
   */
  _createSink() {
    const sink = async (source) => {
      const abortListener = () => {
        closeSource(source, this.log);
      };
      this.closeController.signal.addEventListener("abort", abortListener);
      try {
        const decoder = new Decoder3(this._init.maxMsgSize, this._init.maxUnprocessedMessageQueueSize);
        for await (const chunk of source) {
          for (const msg of decoder.write(chunk)) {
            await this._handleIncoming(msg);
          }
        }
        this._source.end();
      } catch (err) {
        this.log("error in sink", err);
        this._source.end(err);
      } finally {
        this.closeController.signal.removeEventListener("abort", abortListener);
      }
    };
    return sink;
  }
  async _handleIncoming(message2) {
    const { id, type } = message2;
    if (this.log.enabled) {
      this.log.trace("incoming message", printMessage(message2));
    }
    if (message2.type === MessageTypes.NEW_STREAM) {
      if (this._streams.receivers.size === (this._init.maxInboundStreams ?? MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)) {
        this.log("too many inbound streams open");
        this._source.push({
          id,
          type: MessageTypes.RESET_RECEIVER
        });
        try {
          await this.rateLimiter.consume("new-stream", 1);
        } catch {
          this.log("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection");
          this.abort(new Error("Too many open streams"));
          return;
        }
        return;
      }
      const stream2 = this._newReceiverStream({ id, name: toString2(message2.data instanceof Uint8Array ? message2.data : message2.data.subarray()) });
      if (this._init.onIncomingStream != null) {
        this._init.onIncomingStream(stream2);
      }
      return;
    }
    const list = (type & 1) === 1 ? this._streams.initiators : this._streams.receivers;
    const stream = list.get(id);
    if (stream == null) {
      this.log("missing stream %s for message type %s", id, MessageTypeNames[type]);
      try {
        await this.rateLimiter.consume("missing-stream", 1);
      } catch {
        this.log("rate limit hit when receiving messages for streams that do not exist - closing remote connection");
        this.abort(new Error("Too many messages for missing streams"));
        return;
      }
      return;
    }
    const maxBufferSize = this._init.maxStreamBufferSize ?? MAX_STREAM_BUFFER_SIZE;
    try {
      switch (type) {
        case MessageTypes.MESSAGE_INITIATOR:
        case MessageTypes.MESSAGE_RECEIVER:
          if (stream.sourceReadableLength() > maxBufferSize) {
            this._source.push({
              id: message2.id,
              type: type === MessageTypes.MESSAGE_INITIATOR ? MessageTypes.RESET_RECEIVER : MessageTypes.RESET_INITIATOR
            });
            throw new StreamInputBufferError("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers");
          }
          stream.sourcePush(message2.data);
          break;
        case MessageTypes.CLOSE_INITIATOR:
        case MessageTypes.CLOSE_RECEIVER:
          stream.remoteCloseWrite();
          break;
        case MessageTypes.RESET_INITIATOR:
        case MessageTypes.RESET_RECEIVER:
          stream.reset();
          break;
        default:
          this.log("unknown message type %s", type);
      }
    } catch (err) {
      this.log.error("error while processing message", err);
      stream.abort(err);
    }
  }
};

// node_modules/@libp2p/mplex/dist/src/index.js
var _a11, _b7;
_b7 = Symbol.toStringTag, _a11 = serviceCapabilities;
var Mplex = class {
  constructor(components, init = {}) {
    __publicField(this, "protocol", "/mplex/6.7.0");
    __publicField(this, "_init");
    __publicField(this, "components");
    __publicField(this, _b7, "@libp2p/mplex");
    __publicField(this, _a11, [
      "@libp2p/stream-multiplexing"
    ]);
    this.components = components;
    this._init = init;
  }
  createStreamMuxer(init = {}) {
    return new MplexStreamMuxer(this.components, {
      ...init,
      ...this._init
    });
  }
};
function mplex(init = {}) {
  return (components) => new Mplex(components, init);
}

// node_modules/@libp2p/crypto/node_modules/@noble/hashes/legacy.js
var SHA1_IV = Uint32Array.from([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]);
var SHA1_W = new Uint32Array(80);
var _SHA1 = class extends HashMD2 {
  constructor() {
    super(64, 20, 8, false);
    __publicField(this, "A", SHA1_IV[0] | 0);
    __publicField(this, "B", SHA1_IV[1] | 0);
    __publicField(this, "C", SHA1_IV[2] | 0);
    __publicField(this, "D", SHA1_IV[3] | 0);
    __publicField(this, "E", SHA1_IV[4] | 0);
  }
  get() {
    const { A, B, C, D, E } = this;
    return [A, B, C, D, E];
  }
  set(A, B, C, D, E) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA1_W[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 80; i2++)
      SHA1_W[i2] = rotl(SHA1_W[i2 - 3] ^ SHA1_W[i2 - 8] ^ SHA1_W[i2 - 14] ^ SHA1_W[i2 - 16], 1);
    let { A, B, C, D, E } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      let F, K2;
      if (i2 < 20) {
        F = Chi2(B, C, D);
        K2 = 1518500249;
      } else if (i2 < 40) {
        F = B ^ C ^ D;
        K2 = 1859775393;
      } else if (i2 < 60) {
        F = Maj2(B, C, D);
        K2 = 2400959708;
      } else {
        F = B ^ C ^ D;
        K2 = 3395469782;
      }
      const T = rotl(A, 5) + F + E + K2 + SHA1_W[i2] | 0;
      E = D;
      D = C;
      C = rotl(B, 30);
      B = A;
      A = T;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    this.set(A, B, C, D, E);
  }
  roundClean() {
    clean2(SHA1_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0);
    clean2(this.buffer);
  }
};
var sha12 = createHasher2(() => new _SHA1());
var p32 = Math.pow(2, 32);
var K = Array.from({ length: 64 }, (_2, i2) => Math.floor(p32 * Math.abs(Math.sin(i2 + 1))));
var MD5_IV = SHA1_IV.slice(0, 4);
var MD5_W = new Uint32Array(16);
var _MD5 = class extends HashMD2 {
  constructor() {
    super(64, 16, 8, true);
    __publicField(this, "A", MD5_IV[0] | 0);
    __publicField(this, "B", MD5_IV[1] | 0);
    __publicField(this, "C", MD5_IV[2] | 0);
    __publicField(this, "D", MD5_IV[3] | 0);
  }
  get() {
    const { A, B, C, D } = this;
    return [A, B, C, D];
  }
  set(A, B, C, D) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      MD5_W[i2] = view.getUint32(offset, true);
    let { A, B, C, D } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      let F, g, s2;
      if (i2 < 16) {
        F = Chi2(B, C, D);
        g = i2;
        s2 = [7, 12, 17, 22];
      } else if (i2 < 32) {
        F = Chi2(D, B, C);
        g = (5 * i2 + 1) % 16;
        s2 = [5, 9, 14, 20];
      } else if (i2 < 48) {
        F = B ^ C ^ D;
        g = (3 * i2 + 5) % 16;
        s2 = [4, 11, 16, 23];
      } else {
        F = C ^ (B | ~D);
        g = 7 * i2 % 16;
        s2 = [6, 10, 15, 21];
      }
      F = F + A + K[i2] + MD5_W[g];
      A = D;
      D = C;
      C = B;
      B = B + rotl(F, s2[i2 % 4]);
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    this.set(A, B, C, D);
  }
  roundClean() {
    clean2(MD5_W);
  }
  destroy() {
    this.set(0, 0, 0, 0);
    clean2(this.buffer);
  }
};
var md52 = createHasher2(() => new _MD5());
var Rho160 = Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]);
var Id160 = (() => Uint8Array.from(new Array(16).fill(0).map((_2, i2) => i2)))();
var Pi160 = (() => Id160.map((i2) => (9 * i2 + 5) % 16))();
var idxLR = (() => {
  const L = [Id160];
  const R = [Pi160];
  const res = [L, R];
  for (let i2 = 0; i2 < 4; i2++)
    for (let j of res)
      j.push(j[i2].map((k) => Rho160[k]));
  return res;
})();
var idxL = (() => idxLR[0])();
var idxR = (() => idxLR[1])();
var shifts160 = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i2) => Uint8Array.from(i2));
var shiftsL160 = idxL.map((idx, i2) => idx.map((j) => shifts160[i2][j]));
var shiftsR160 = idxR.map((idx, i2) => idx.map((j) => shifts160[i2][j]));
var Kl160 = Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr160 = Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function ripemd_f(group, x, y, z) {
  if (group === 0)
    return x ^ y ^ z;
  if (group === 1)
    return x & y | ~x & z;
  if (group === 2)
    return (x | ~y) ^ z;
  if (group === 3)
    return x & z | y & ~z;
  return x ^ (y | ~z);
}
var BUF_160 = new Uint32Array(16);
var _RIPEMD160 = class extends HashMD2 {
  constructor() {
    super(64, 20, 8, true);
    __publicField(this, "h0", 1732584193 | 0);
    __publicField(this, "h1", 4023233417 | 0);
    __publicField(this, "h2", 2562383102 | 0);
    __publicField(this, "h3", 271733878 | 0);
    __publicField(this, "h4", 3285377520 | 0);
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      BUF_160[i2] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl160[group], hbr = Kr160[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL160[group], sr = shiftsR160[group];
      for (let i2 = 0; i2 < 16; i2++) {
        const tl = rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i2]] + hbl, sl[i2]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i2 = 0; i2 < 16; i2++) {
        const tr = rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i2]] + hbr, sr[i2]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    clean2(BUF_160);
  }
  destroy() {
    this.destroyed = true;
    clean2(this.buffer);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = createHasher2(() => new _RIPEMD160());

// node_modules/@libp2p/ping/dist/src/constants.js
var PING_LENGTH = 32;
var PROTOCOL_VERSION = "1.0.0";
var PROTOCOL_NAME = "ping";
var PROTOCOL_PREFIX = "ipfs";
var TIMEOUT = 1e4;
var MAX_INBOUND_STREAMS = 2;
var MAX_OUTBOUND_STREAMS = 1;

// node_modules/@libp2p/ping/dist/src/ping.js
var _a12, _b8;
_b8 = Symbol.toStringTag, _a12 = serviceCapabilities;
var Ping = class {
  constructor(components, init = {}) {
    __publicField(this, "protocol");
    __publicField(this, "components");
    __publicField(this, "started");
    __publicField(this, "timeout");
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    __publicField(this, "runOnLimitedConnection");
    __publicField(this, "log");
    __publicField(this, _b8, "@libp2p/ping");
    __publicField(this, _a12, [
      "@libp2p/ping"
    ]);
    this.components = components;
    this.log = components.logger.forComponent("libp2p:ping");
    this.started = false;
    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
    this.timeout = init.timeout ?? TIMEOUT;
    this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS;
    this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS;
    this.runOnLimitedConnection = init.runOnLimitedConnection ?? true;
    this.handleMessage = this.handleMessage.bind(this);
  }
  async start() {
    await this.components.registrar.handle(this.protocol, this.handleMessage, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnLimitedConnection: this.runOnLimitedConnection
    });
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  /**
   * A handler to register with Libp2p to process ping messages
   */
  handleMessage(data) {
    this.log("incoming ping from %p", data.connection.remotePeer);
    const { stream } = data;
    const start2 = Date.now();
    const bytes = byteStream(stream);
    let pinged = false;
    Promise.resolve().then(async () => {
      while (true) {
        const signal = AbortSignal.timeout(this.timeout);
        setMaxListeners(Infinity, signal);
        signal.addEventListener("abort", () => {
          stream == null ? void 0 : stream.abort(new TimeoutError("ping timeout"));
        });
        const buf = await bytes.read({
          bytes: PING_LENGTH,
          signal
        });
        await bytes.write(buf, {
          signal
        });
        pinged = true;
      }
    }).catch((err) => {
      if (pinged && err.name === "UnexpectedEOFError" && stream.readStatus !== "ready") {
        return;
      }
      this.log.error("incoming ping from %p failed with error - %e", data.connection.remotePeer, err);
      stream == null ? void 0 : stream.abort(err);
    }).finally(() => {
      const ms = Date.now() - start2;
      this.log("incoming ping from %p complete in %dms", data.connection.remotePeer, ms);
      const signal = AbortSignal.timeout(this.timeout);
      setMaxListeners(Infinity, signal);
      stream.close({
        signal
      }).catch((err) => {
        this.log.error("error closing ping stream from %p - %e", data.connection.remotePeer, err);
        stream == null ? void 0 : stream.abort(err);
      });
    });
  }
  /**
   * Ping a given peer and wait for its response, getting the operation latency.
   */
  async ping(peer, options = {}) {
    this.log("pinging %p", peer);
    const start2 = Date.now();
    const data = randomBytes3(PING_LENGTH);
    const connection = await this.components.connectionManager.openConnection(peer, options);
    let stream;
    if (options.signal == null) {
      const signal = AbortSignal.timeout(this.timeout);
      options = {
        ...options,
        signal
      };
    }
    try {
      stream = await connection.newStream(this.protocol, {
        ...options,
        runOnLimitedConnection: this.runOnLimitedConnection
      });
      const bytes = byteStream(stream);
      const [, result] = await Promise.all([
        bytes.write(data, options),
        bytes.read({
          ...options,
          bytes: PING_LENGTH
        })
      ]);
      const ms = Date.now() - start2;
      if (!equals3(data, result.subarray())) {
        throw new ProtocolError(`Received wrong ping ack after ${ms}ms`);
      }
      this.log("ping %p complete in %dms", connection.remotePeer, ms);
      return ms;
    } catch (err) {
      this.log.error("error while pinging %p", connection.remotePeer, err);
      stream == null ? void 0 : stream.abort(err);
      throw err;
    } finally {
      if (stream != null) {
        await stream.close(options);
      }
    }
  }
};

// node_modules/@libp2p/ping/dist/src/index.js
function ping(init = {}) {
  return (components) => new Ping(components, init);
}

// node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js
var ASSUME_HTTP_CODES = [
  CODE_TCP,
  CODE_DNS,
  CODE_DNSADDR,
  CODE_DNS4,
  CODE_DNS6
];
function extractSNI(ma) {
  var _a27;
  return (_a27 = extractTuple("sni", ma)) == null ? void 0 : _a27.value;
}
function extractPort(ma) {
  var _a27;
  const port = (_a27 = extractTuple("tcp", ma)) == null ? void 0 : _a27.value;
  if (port == null) {
    return "";
  }
  return `:${port}`;
}
function extractTuple(name3, ma) {
  return ma.find((component) => component.name === name3);
}
function hasTLS(ma) {
  return ma.some(({ code: code2 }) => code2 === CODE_TLS);
}
function interpretNext(head, rest) {
  const interpreter = interpreters[head.name];
  if (interpreter == null) {
    throw new Error(`Can't interpret protocol ${head.name}`);
  }
  const restVal = interpreter(head, rest);
  if (head.code === CODE_IP6) {
    return `[${restVal}]`;
  }
  return restVal;
}
var interpreters = {
  ip4: (head, rest) => head.value,
  ip6: (head, rest) => {
    if (rest.length === 0) {
      return head.value;
    }
    return `[${head.value}]`;
  },
  tcp: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `tcp://${interpretNext(tail, rest)}:${head.value}`;
  },
  udp: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `udp://${interpretNext(tail, rest)}:${head.value}`;
  },
  dnsaddr: (head, rest) => head.value,
  dns4: (head, rest) => head.value,
  dns6: (head, rest) => head.value,
  dns: (head, rest) => head.value,
  ipfs: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tail, rest)}`;
  },
  p2p: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tail, rest)}`;
  },
  http: (head, rest) => {
    const maHasTLS = hasTLS(rest);
    const sni = extractSNI(rest);
    const port = extractPort(rest);
    if (maHasTLS && sni != null) {
      return `https://${sni}${port}`;
    }
    const protocol = maHasTLS ? "https://" : "http://";
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tail, rest);
    baseVal = baseVal == null ? void 0 : baseVal.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  "http-path": (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    const baseVal = interpretNext(tail, rest);
    const decodedValue = decodeURIComponent(head.value ?? "");
    return `${baseVal}${decodedValue}`;
  },
  tls: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tail, rest);
  },
  sni: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tail, rest);
  },
  https: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tail, rest);
    baseVal = baseVal == null ? void 0 : baseVal.replace("tcp://", "");
    return `https://${baseVal}`;
  },
  ws: (head, rest) => {
    const maHasTLS = hasTLS(rest);
    const sni = extractSNI(rest);
    const port = extractPort(rest);
    if (maHasTLS && sni != null) {
      return `wss://${sni}${port}`;
    }
    const protocol = maHasTLS ? "wss://" : "ws://";
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tail, rest);
    baseVal = baseVal == null ? void 0 : baseVal.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  wss: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tail, rest);
    baseVal = baseVal == null ? void 0 : baseVal.replace("tcp://", "");
    return `wss://${baseVal}`;
  }
};
function multiaddrToUri(input, opts) {
  const ma = multiaddr(input);
  const components = ma.getComponents();
  const head = components.pop();
  if (head == null) {
    throw new Error("Unexpected end of multiaddr");
  }
  const interpreter = interpreters[head.name];
  if (interpreter == null) {
    throw new Error(`No interpreter found for ${head.name}`);
  }
  let uri = interpreter(head, components) ?? "";
  if ((opts == null ? void 0 : opts.assumeHttp) !== false && ASSUME_HTTP_CODES.includes(head.code)) {
    uri = uri.replace(/^.*:\/\//, "");
    if (head.value === "443") {
      uri = `https://${uri}`;
    } else {
      uri = `http://${uri}`;
    }
  }
  if (uri.startsWith("http://") || uri.startsWith("https://") || uri.startsWith("ws://") || uri.startsWith("wss://")) {
    uri = new URL(uri).toString();
    if (uri.endsWith("/")) {
      uri = uri.substring(0, uri.length - 1);
    }
  }
  return uri;
}

// node_modules/it-ws/dist/src/ready.js
var ready_default = async (socket) => {
  if (socket.readyState >= 2) {
    throw new Error("socket closed");
  }
  if (socket.readyState === 1) {
    return;
  }
  await new Promise((resolve, reject) => {
    function cleanup() {
      socket.removeEventListener("open", handleOpen);
      socket.removeEventListener("error", handleErr);
    }
    function handleOpen() {
      cleanup();
      resolve();
    }
    function handleErr(event) {
      cleanup();
      reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
    }
    socket.addEventListener("open", handleOpen);
    socket.addEventListener("error", handleErr);
  });
};

// node_modules/it-ws/dist/src/sink.js
var sink_default = (socket, options) => {
  options = options ?? {};
  options.closeOnEnd = options.closeOnEnd !== false;
  const sink = async (source) => {
    for await (const data of source) {
      try {
        await ready_default(socket);
      } catch (err) {
        if (err.message === "socket closed")
          break;
        throw err;
      }
      if (socket.readyState === socket.CLOSING || socket.readyState === socket.CLOSED) {
        break;
      }
      socket.send(data);
    }
    if (options.closeOnEnd != null && socket.readyState <= 1) {
      await new Promise((resolve, reject) => {
        socket.addEventListener("close", (event) => {
          if (event.wasClean || event.code === 1006) {
            resolve();
          } else {
            const err = Object.assign(new Error("ws error"), { event });
            reject(err);
          }
        });
        setTimeout(() => {
          socket.close();
        });
      });
    }
  };
  return sink;
};

// node_modules/it-ws/dist/src/source.js
var import_event_iterator = __toESM(require_dom(), 1);
function isArrayBuffer(obj) {
  var _a27;
  return obj instanceof ArrayBuffer || ((_a27 = obj == null ? void 0 : obj.constructor) == null ? void 0 : _a27.name) === "ArrayBuffer" && typeof (obj == null ? void 0 : obj.byteLength) === "number";
}
var source_default = (socket) => {
  socket.binaryType = "arraybuffer";
  const connected = async () => {
    await new Promise((resolve, reject) => {
      if (isConnected) {
        resolve();
        return;
      }
      if (connError != null) {
        reject(connError);
        return;
      }
      const cleanUp = (cont) => {
        socket.removeEventListener("open", onOpen);
        socket.removeEventListener("error", onError);
        cont();
      };
      const onOpen = () => {
        cleanUp(resolve);
      };
      const onError = (event) => {
        cleanUp(() => {
          reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
        });
      };
      socket.addEventListener("open", onOpen);
      socket.addEventListener("error", onError);
    });
  };
  const source = async function* () {
    const messages2 = new import_event_iterator.EventIterator(({ push, stop: stop2, fail }) => {
      const onMessage = (event) => {
        let data = null;
        if (typeof event.data === "string") {
          data = fromString2(event.data);
        }
        if (isArrayBuffer(event.data)) {
          data = new Uint8Array(event.data);
        }
        if (event.data instanceof Uint8Array) {
          data = event.data;
        }
        if (data == null) {
          return;
        }
        push(data);
      };
      const onError = (event) => {
        fail(event.error ?? new Error("Socket error"));
      };
      socket.addEventListener("message", onMessage);
      socket.addEventListener("error", onError);
      socket.addEventListener("close", stop2);
      return () => {
        socket.removeEventListener("message", onMessage);
        socket.removeEventListener("error", onError);
        socket.removeEventListener("close", stop2);
      };
    }, { highWaterMark: Infinity });
    await connected();
    for await (const chunk of messages2) {
      yield isArrayBuffer(chunk) ? new Uint8Array(chunk) : chunk;
    }
  }();
  let isConnected = socket.readyState === 1;
  let connError;
  socket.addEventListener("open", () => {
    isConnected = true;
    connError = null;
  });
  socket.addEventListener("close", () => {
    isConnected = false;
    connError = null;
  });
  socket.addEventListener("error", (event) => {
    if (!isConnected) {
      connError = event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`);
    }
  });
  return Object.assign(source, {
    connected
  });
};

// node_modules/it-ws/dist/src/duplex.js
var duplex_default = (socket, options) => {
  options = options ?? {};
  const connectedSource = source_default(socket);
  let remoteAddress = options.remoteAddress;
  let remotePort = options.remotePort;
  if (socket.url != null) {
    try {
      const url = new URL(socket.url);
      remoteAddress = url.hostname;
      remotePort = parseInt(url.port, 10);
    } catch {
    }
  }
  if (remoteAddress == null || remotePort == null) {
    throw new Error("Remote connection did not have address and/or port");
  }
  const duplex = {
    sink: sink_default(socket, options),
    source: connectedSource,
    connected: async () => {
      await connectedSource.connected();
    },
    close: async () => {
      if (socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN) {
        await new Promise((resolve) => {
          socket.addEventListener("close", () => {
            resolve();
          });
          socket.close();
        });
      }
    },
    destroy: () => {
      if (socket.terminate != null) {
        socket.terminate();
      } else {
        socket.close();
      }
    },
    remoteAddress,
    remotePort,
    socket
  };
  return duplex;
};

// node_modules/it-ws/dist/src/web-socket.browser.js
var web_socket_browser_default = WebSocket;

// node_modules/it-ws/dist/src/ws-url.js
var map = { "http:": "ws:", "https:": "wss:" };
var defaultProtocol = "ws:";
var ws_url_default = (url, location) => {
  if (url.startsWith("//")) {
    url = `${(location == null ? void 0 : location.protocol) ?? defaultProtocol}${url}`;
  }
  if (url.startsWith("/") && location != null) {
    const proto = location.protocol ?? defaultProtocol;
    const host = location.host;
    const port = location.port != null && (host == null ? void 0 : host.endsWith(`:${location.port}`)) !== true ? `:${location.port}` : "";
    url = `${proto}//${host}${port}${url}`;
  }
  const wsUrl = new URL(url);
  for (const [httpProto, wsProto] of Object.entries(map)) {
    if (wsUrl.protocol === httpProto) {
      wsUrl.protocol = wsProto;
    }
  }
  return wsUrl;
};

// node_modules/it-ws/dist/src/client.js
function connect(addr, opts) {
  const location = typeof window === "undefined" ? void 0 : window.location;
  opts = opts ?? {};
  const url = ws_url_default(addr, location);
  const socket = new web_socket_browser_default(url.toString(), opts.websocket);
  return duplex_default(socket, opts);
}

// node_modules/progress-events/dist/src/index.js
var CustomProgressEvent = class extends Event {
  constructor(type, detail) {
    super(type);
    __publicField(this, "type");
    __publicField(this, "detail");
    this.type = type;
    this.detail = detail;
  }
};

// node_modules/@libp2p/websockets/dist/src/filters.js
function all2(multiaddrs) {
  return multiaddrs.filter((ma) => {
    return WebSocketsSecure2.exactMatch(ma) || WebSockets2.exactMatch(ma);
  });
}
function wss(multiaddrs) {
  return multiaddrs.filter((ma) => {
    return WebSocketsSecure2.exactMatch(ma);
  });
}

// node_modules/@libp2p/websockets/dist/src/listener.browser.js
function createListener() {
  throw new Error("WebSocket Servers can not be created in the browser!");
}

// node_modules/@libp2p/websockets/dist/src/constants.js
var CLOSE_TIMEOUT2 = 500;

// node_modules/@libp2p/websockets/dist/src/socket-to-conn.js
function socketToMaConn(stream, remoteAddr, options) {
  const log41 = options.logger.forComponent("libp2p:websockets:maconn");
  const metrics = options.metrics;
  const metricPrefix = options.metricPrefix ?? "";
  const maConn = {
    log: log41,
    async sink(source) {
      try {
        await stream.sink(async function* () {
          for await (const buf of source) {
            if (buf instanceof Uint8Array) {
              yield buf;
            } else {
              yield buf.subarray();
            }
          }
        }());
      } catch (err) {
        if (err.type !== "aborted") {
          log41.error(err);
        }
      }
    },
    source: stream.source,
    remoteAddr,
    timeline: { open: Date.now() },
    async close(options2 = {}) {
      var _a27, _b14;
      const start2 = Date.now();
      if (options2.signal == null) {
        const signal = AbortSignal.timeout(CLOSE_TIMEOUT2);
        options2 = {
          ...options2,
          signal
        };
      }
      const listener = () => {
        const { host, port } = maConn.remoteAddr.toOptions();
        log41("timeout closing stream to %s:%s after %dms, destroying it manually", host, port, Date.now() - start2);
        this.abort(new AbortError("Socket close timeout"));
      };
      (_a27 = options2.signal) == null ? void 0 : _a27.addEventListener("abort", listener);
      try {
        await stream.close();
      } catch (err) {
        log41.error("error closing WebSocket gracefully", err);
        this.abort(err);
      } finally {
        (_b14 = options2.signal) == null ? void 0 : _b14.removeEventListener("abort", listener);
        maConn.timeline.close = Date.now();
      }
    },
    abort(err) {
      const { host, port } = maConn.remoteAddr.toOptions();
      log41("timeout closing stream to %s:%s due to error", host, port, err);
      stream.destroy();
      maConn.timeline.close = Date.now();
      metrics == null ? void 0 : metrics.increment({ [`${metricPrefix}error`]: true });
    }
  };
  stream.socket.addEventListener("close", () => {
    metrics == null ? void 0 : metrics.increment({ [`${metricPrefix}close`]: true });
    if (maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
  }, { once: true });
  return maConn;
}

// node_modules/@libp2p/websockets/dist/src/index.js
var _a13, _b9, _c2;
_c2 = transportSymbol, _b9 = Symbol.toStringTag, _a13 = serviceCapabilities;
var WebSockets3 = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "init");
    __publicField(this, "logger");
    __publicField(this, "metrics");
    __publicField(this, "components");
    __publicField(this, _c2, true);
    __publicField(this, _b9, "@libp2p/websockets");
    __publicField(this, _a13, [
      "@libp2p/transport"
    ]);
    this.log = components.logger.forComponent("libp2p:websockets");
    this.logger = components.logger;
    this.components = components;
    this.init = init;
    if (components.metrics != null) {
      this.metrics = {
        dialerEvents: components.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total", {
          label: "event",
          help: "Total count of WebSockets dialer events by type"
        })
      };
    }
  }
  async dial(ma, options) {
    var _a27;
    this.log("dialing %s", ma);
    options = options ?? {};
    const socket = await this._connect(ma, options);
    const maConn = socketToMaConn(socket, ma, {
      logger: this.logger,
      metrics: (_a27 = this.metrics) == null ? void 0 : _a27.dialerEvents
    });
    this.log("new outbound connection %s", maConn.remoteAddr);
    const conn = await options.upgrader.upgradeOutbound(maConn, options);
    this.log("outbound connection %s upgraded", maConn.remoteAddr);
    return conn;
  }
  async _connect(ma, options) {
    var _a27, _b14, _c3, _d2, _e;
    (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
    const cOpts = ma.toOptions();
    this.log("dialing %s:%s", cOpts.host, cOpts.port);
    const errorPromise = pDefer();
    const rawSocket = connect(multiaddrToUri(ma), this.init);
    rawSocket.socket.addEventListener("error", () => {
      var _a28;
      const err = new ConnectionFailedError(`Could not connect to ${ma.toString()}`);
      this.log.error("connection error:", err);
      (_a28 = this.metrics) == null ? void 0 : _a28.dialerEvents.increment({ error: true });
      errorPromise.reject(err);
    });
    try {
      (_b14 = options.onProgress) == null ? void 0 : _b14.call(options, new CustomProgressEvent("websockets:open-connection"));
      await raceSignal3(Promise.race([rawSocket.connected(), errorPromise.promise]), options.signal);
    } catch (err) {
      if ((_c3 = options.signal) == null ? void 0 : _c3.aborted) {
        (_d2 = this.metrics) == null ? void 0 : _d2.dialerEvents.increment({ abort: true });
      }
      rawSocket.close().catch((err2) => {
        this.log.error("error closing raw socket", err2);
      });
      throw err;
    }
    this.log("connected %s", ma);
    (_e = this.metrics) == null ? void 0 : _e.dialerEvents.increment({ connect: true });
    return rawSocket;
  }
  /**
   * Creates a WebSockets listener. The provided `handler` function will be called
   * anytime a new incoming Connection has been successfully upgraded via
   * `upgrader.upgradeInbound`
   */
  createListener(options) {
    return createListener({
      logger: this.logger,
      events: this.components.events,
      metrics: this.components.metrics
    }, {
      ...this.init,
      ...options
    });
  }
  /**
   * Takes a list of `Multiaddr`s and returns only valid WebSockets addresses.
   * By default, in a browser environment only DNS+WSS multiaddr is accepted,
   * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.
   */
  listenFilter(multiaddrs) {
    var _a27, _b14;
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    if (((_a27 = this.init) == null ? void 0 : _a27.filter) != null) {
      return (_b14 = this.init) == null ? void 0 : _b14.filter(multiaddrs);
    }
    return all2(multiaddrs);
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    return this.listenFilter(multiaddrs);
  }
};
function webSockets(init = {}) {
  return (components) => {
    return new WebSockets3(components, init);
  };
}

// node_modules/is-plain-obj/index.js
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// node_modules/@libp2p/utils/dist/src/merge-options.js
var { hasOwnProperty } = Object.prototype;
var { propertyIsEnumerable } = Object;
var defineProperty = (object, name3, value) => {
  Object.defineProperty(object, name3, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
};
var globalThis2 = void 0;
var defaultMergeOptions = {
  concatArrays: false,
  ignoreUndefined: false
};
var getEnumerableOwnPropertyKeys = (value) => {
  const keys = [];
  for (const key in value) {
    if (hasOwnProperty.call(value, key)) {
      keys.push(key);
    }
  }
  if (Object.getOwnPropertySymbols) {
    const symbols = Object.getOwnPropertySymbols(value);
    for (const symbol3 of symbols) {
      if (propertyIsEnumerable.call(value, symbol3)) {
        keys.push(symbol3);
      }
    }
  }
  return keys;
};
function clone(value) {
  if (Array.isArray(value)) {
    return cloneArray(value);
  }
  if (isPlainObject(value)) {
    return cloneOptionObject(value);
  }
  return value;
}
function cloneArray(array) {
  const result = array.slice(0, 0);
  getEnumerableOwnPropertyKeys(array).forEach((key) => {
    defineProperty(result, key, clone(array[key]));
  });
  return result;
}
function cloneOptionObject(object) {
  const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
  getEnumerableOwnPropertyKeys(object).forEach((key) => {
    defineProperty(result, key, clone(object[key]));
  });
  return result;
}
var mergeKeys = (merged, source, keys, config) => {
  keys.forEach((key) => {
    if (typeof source[key] === "undefined" && config.ignoreUndefined) {
      return;
    }
    if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
      defineProperty(merged, key, merge2(merged[key], source[key], config));
    } else {
      defineProperty(merged, key, clone(source[key]));
    }
  });
  return merged;
};
var concatArrays = (merged, source, config) => {
  let result = merged.slice(0, 0);
  let resultIndex = 0;
  [merged, source].forEach((array) => {
    const indices = [];
    for (let k = 0; k < array.length; k++) {
      if (!hasOwnProperty.call(array, k)) {
        continue;
      }
      indices.push(String(k));
      if (array === merged) {
        defineProperty(result, resultIndex++, array[k]);
      } else {
        defineProperty(result, resultIndex++, clone(array[k]));
      }
    }
    result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config);
  });
  return result;
};
function merge2(merged, source, config) {
  if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
    return concatArrays(merged, source, config);
  }
  if (!isPlainObject(source) || !isPlainObject(merged)) {
    return clone(source);
  }
  return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
}
function mergeOptions(...options) {
  const config = merge2(clone(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
  let merged = { _: {} };
  for (const option of options) {
    if (option === void 0) {
      continue;
    }
    if (!isPlainObject(option)) {
      throw new TypeError("`" + option + "` is not an Option Object");
    }
    merged = merge2(merged, { _: option }, config);
  }
  return merged._;
}

// node_modules/@multiformats/dns/dist/src/errors.js
var DNSQueryFailedError = class extends AggregateError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "DNSQueryFailedError");
  }
};
__publicField(DNSQueryFailedError, "name", "DNSQueryFailedError");

// node_modules/eventemitter3/index.mjs
var import_index9 = __toESM(require_eventemitter3(), 1);

// node_modules/p-queue/node_modules/p-timeout/index.js
var TimeoutError2 = class _TimeoutError extends Error {
  constructor(message2, options) {
    var _a27;
    super(message2, options);
    __publicField(this, "name", "TimeoutError");
    (_a27 = Error.captureStackTrace) == null ? void 0 : _a27.call(Error, this, _TimeoutError);
  }
};
var getAbortedReason = (signal) => signal.reason ?? new DOMException("This operation was aborted.", "AbortError");
function pTimeout(promise, options) {
  const {
    milliseconds,
    fallback,
    message: message2,
    customTimers = { setTimeout, clearTimeout },
    signal
  } = options;
  let timer;
  let abortHandler;
  const wrappedPromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (signal == null ? void 0 : signal.aborted) {
      reject(getAbortedReason(signal));
      return;
    }
    if (signal) {
      abortHandler = () => {
        reject(getAbortedReason(signal));
      };
      signal.addEventListener("abort", abortHandler, { once: true });
    }
    promise.then(resolve, reject);
    if (milliseconds === Number.POSITIVE_INFINITY) {
      return;
    }
    const timeoutError = new TimeoutError2();
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback) {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      if (message2 === false) {
        resolve();
      } else if (message2 instanceof Error) {
        reject(message2);
      } else {
        timeoutError.message = message2 ?? `Promise timed out after ${milliseconds} milliseconds`;
        reject(timeoutError);
      }
    }, milliseconds);
  });
  const cancelablePromise = wrappedPromise.finally(() => {
    cancelablePromise.clear();
    if (abortHandler && signal) {
      signal.removeEventListener("abort", abortHandler);
    }
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}

// node_modules/p-queue/dist/lower-bound.js
function lowerBound(array, value, comparator) {
  let first = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first + step;
    if (comparator(array[it], value) <= 0) {
      first = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first;
}

// node_modules/p-queue/dist/priority-queue.js
var _queue;
var PriorityQueue = class {
  constructor() {
    __privateAdd(this, _queue, []);
  }
  enqueue(run, options) {
    const { priority = 0, id } = options ?? {};
    const element = {
      priority,
      id,
      run
    };
    if (this.size === 0 || __privateGet(this, _queue)[this.size - 1].priority >= priority) {
      __privateGet(this, _queue).push(element);
      return;
    }
    const index = lowerBound(__privateGet(this, _queue), element, (a2, b) => b.priority - a2.priority);
    __privateGet(this, _queue).splice(index, 0, element);
  }
  setPriority(id, priority) {
    const index = __privateGet(this, _queue).findIndex((element) => element.id === id);
    if (index === -1) {
      throw new ReferenceError(`No promise function with the id "${id}" exists in the queue.`);
    }
    const [item] = __privateGet(this, _queue).splice(index, 1);
    this.enqueue(item.run, { priority, id });
  }
  dequeue() {
    const item = __privateGet(this, _queue).shift();
    return item == null ? void 0 : item.run;
  }
  filter(options) {
    return __privateGet(this, _queue).filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return __privateGet(this, _queue).length;
  }
};
_queue = new WeakMap();

// node_modules/p-queue/dist/index.js
var _carryoverIntervalCount, _isIntervalIgnored, _intervalCount, _intervalCap, _rateLimitedInInterval, _rateLimitFlushScheduled, _interval, _intervalEnd, _lastExecutionTime, _intervalId, _timeoutId, _strict, _strictTicks, _strictTicksStartIndex, _queue2, _queueClass, _pending, _concurrency, _isPaused, _idAssigner, _runningTasks, _PQueue_instances, cleanupStrictTicks_fn, consumeIntervalSlot_fn, rollbackIntervalSlot_fn, getActiveTicksCount_fn, doesIntervalAllowAnother_get, doesConcurrentAllowAnother_get, next_fn, onResumeInterval_fn, isIntervalPausedAt_fn, createIntervalTimeout_fn, clearIntervalTimer_fn, clearTimeoutTimer_fn, tryToStartAnother_fn, initializeIntervalIfNeeded_fn, onInterval_fn, processQueue_fn, onEvent_fn, setupRateLimitTracking_fn, scheduleRateLimitUpdate_fn, rollbackIntervalConsumption_fn, updateRateLimitState_fn;
var PQueue = class extends import_index9.default {
  constructor(options) {
    var _a27, _b14;
    super();
    __privateAdd(this, _PQueue_instances);
    __privateAdd(this, _carryoverIntervalCount);
    __privateAdd(this, _isIntervalIgnored);
    __privateAdd(this, _intervalCount, 0);
    __privateAdd(this, _intervalCap);
    __privateAdd(this, _rateLimitedInInterval, false);
    __privateAdd(this, _rateLimitFlushScheduled, false);
    __privateAdd(this, _interval);
    __privateAdd(this, _intervalEnd, 0);
    __privateAdd(this, _lastExecutionTime, 0);
    __privateAdd(this, _intervalId);
    __privateAdd(this, _timeoutId);
    __privateAdd(this, _strict);
    // Circular buffer implementation for better performance
    __privateAdd(this, _strictTicks, []);
    __privateAdd(this, _strictTicksStartIndex, 0);
    __privateAdd(this, _queue2);
    __privateAdd(this, _queueClass);
    __privateAdd(this, _pending, 0);
    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194
    __privateAdd(this, _concurrency);
    __privateAdd(this, _isPaused);
    // Use to assign a unique identifier to a promise function, if not explicitly specified
    __privateAdd(this, _idAssigner, 1n);
    // Track currently running tasks for debugging
    __privateAdd(this, _runningTasks, /* @__PURE__ */ new Map());
    /**
        Get or set the default timeout for all tasks. Can be changed at runtime.
    
        Operations will throw a `TimeoutError` if they don't complete within the specified time.
    
        The timeout begins when the operation is dequeued and starts execution, not while it's waiting in the queue.
    
        @example
        ```
        const queue = new PQueue({timeout: 5000});
    
        // Change timeout for all future tasks
        queue.timeout = 10000;
        ```
        */
    __publicField(this, "timeout");
    options = {
      carryoverIntervalCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: PriorityQueue,
      strict: false,
      ...options
    };
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${((_a27 = options.intervalCap) == null ? void 0 : _a27.toString()) ?? ""}\` (${typeof options.intervalCap})`);
    }
    if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${((_b14 = options.interval) == null ? void 0 : _b14.toString()) ?? ""}\` (${typeof options.interval})`);
    }
    if (options.strict && options.interval === 0) {
      throw new TypeError("The `strict` option requires a non-zero `interval`");
    }
    if (options.strict && options.intervalCap === Number.POSITIVE_INFINITY) {
      throw new TypeError("The `strict` option requires a finite `intervalCap`");
    }
    __privateSet(this, _carryoverIntervalCount, options.carryoverIntervalCount ?? options.carryoverConcurrencyCount ?? false);
    __privateSet(this, _isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0);
    __privateSet(this, _intervalCap, options.intervalCap);
    __privateSet(this, _interval, options.interval);
    __privateSet(this, _strict, options.strict);
    __privateSet(this, _queue2, new options.queueClass());
    __privateSet(this, _queueClass, options.queueClass);
    this.concurrency = options.concurrency;
    if (options.timeout !== void 0 && !(Number.isFinite(options.timeout) && options.timeout > 0)) {
      throw new TypeError(`Expected \`timeout\` to be a positive finite number, got \`${options.timeout}\` (${typeof options.timeout})`);
    }
    this.timeout = options.timeout;
    __privateSet(this, _isPaused, options.autoStart === false);
    __privateMethod(this, _PQueue_instances, setupRateLimitTracking_fn).call(this);
  }
  get concurrency() {
    return __privateGet(this, _concurrency);
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    __privateSet(this, _concurrency, newConcurrency);
    __privateMethod(this, _PQueue_instances, processQueue_fn).call(this);
  }
  /**
      Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.
  
      For example, this can be used to prioritize a promise function to run earlier.
  
      ```js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 1});
  
      queue.add(async () => '', {priority: 1});
      queue.add(async () => '', {priority: 0, id: ''});
      queue.add(async () => '', {priority: 1});
      queue.add(async () => '', {priority: 1});
  
      queue.setPriority('', 2);
      ```
  
      In this case, the promise function with `id: ''` runs second.
  
      You can also deprioritize a promise function to delay its execution:
  
      ```js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 1});
  
      queue.add(async () => '', {priority: 1});
      queue.add(async () => '', {priority: 1, id: ''});
      queue.add(async () => '');
      queue.add(async () => '', {priority: 0});
  
      queue.setPriority('', -1);
      ```
      Here, the promise function with `id: ''` executes last.
      */
  setPriority(id, priority) {
    if (typeof priority !== "number" || !Number.isFinite(priority)) {
      throw new TypeError(`Expected \`priority\` to be a finite number, got \`${priority}\` (${typeof priority})`);
    }
    __privateGet(this, _queue2).setPriority(id, priority);
  }
  async add(function_, options = {}) {
    options = {
      timeout: this.timeout,
      ...options,
      // Assign unique ID if not provided
      id: options.id ?? (__privateWrapper(this, _idAssigner)._++).toString()
    };
    return new Promise((resolve, reject) => {
      const taskSymbol = Symbol(`task-${options.id}`);
      __privateGet(this, _queue2).enqueue(async () => {
        var _a27, _b14;
        __privateWrapper(this, _pending)._++;
        __privateGet(this, _runningTasks).set(taskSymbol, {
          id: options.id,
          priority: options.priority ?? 0,
          // Match priority-queue default
          startTime: Date.now(),
          timeout: options.timeout
        });
        let eventListener;
        try {
          try {
            (_a27 = options.signal) == null ? void 0 : _a27.throwIfAborted();
          } catch (error) {
            __privateMethod(this, _PQueue_instances, rollbackIntervalConsumption_fn).call(this);
            __privateGet(this, _runningTasks).delete(taskSymbol);
            throw error;
          }
          __privateSet(this, _lastExecutionTime, Date.now());
          let operation = function_({ signal: options.signal });
          if (options.timeout) {
            operation = pTimeout(Promise.resolve(operation), {
              milliseconds: options.timeout,
              message: `Task timed out after ${options.timeout}ms (queue has ${__privateGet(this, _pending)} running, ${__privateGet(this, _queue2).size} waiting)`
            });
          }
          if (options.signal) {
            const { signal } = options;
            operation = Promise.race([operation, new Promise((_resolve, reject2) => {
              eventListener = () => {
                reject2(signal.reason);
              };
              signal.addEventListener("abort", eventListener, { once: true });
            })]);
          }
          const result = await operation;
          resolve(result);
          this.emit("completed", result);
        } catch (error) {
          reject(error);
          this.emit("error", error);
        } finally {
          if (eventListener) {
            (_b14 = options.signal) == null ? void 0 : _b14.removeEventListener("abort", eventListener);
          }
          __privateGet(this, _runningTasks).delete(taskSymbol);
          queueMicrotask(() => {
            __privateMethod(this, _PQueue_instances, next_fn).call(this);
          });
        }
      }, options);
      this.emit("add");
      __privateMethod(this, _PQueue_instances, tryToStartAnother_fn).call(this);
    });
  }
  async addAll(functions, options) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    if (!__privateGet(this, _isPaused)) {
      return this;
    }
    __privateSet(this, _isPaused, false);
    __privateMethod(this, _PQueue_instances, processQueue_fn).call(this);
    return this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    __privateSet(this, _isPaused, true);
  }
  /**
  Clear the queue.
  */
  clear() {
    __privateSet(this, _queue2, new (__privateGet(this, _queueClass))());
    __privateMethod(this, _PQueue_instances, clearIntervalTimer_fn).call(this);
    __privateMethod(this, _PQueue_instances, updateRateLimitState_fn).call(this);
    this.emit("empty");
    if (__privateGet(this, _pending) === 0) {
      __privateMethod(this, _PQueue_instances, clearTimeoutTimer_fn).call(this);
      this.emit("idle");
    }
    this.emit("next");
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (__privateGet(this, _queue2).size === 0) {
      return;
    }
    await __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(limit) {
    if (__privateGet(this, _queue2).size < limit) {
      return;
    }
    await __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "next", () => __privateGet(this, _queue2).size < limit);
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    if (__privateGet(this, _pending) === 0 && __privateGet(this, _queue2).size === 0) {
      return;
    }
    await __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "idle");
  }
  /**
      The difference with `.onIdle` is that `.onPendingZero` only waits for currently running tasks to finish, ignoring queued tasks.
  
      @returns A promise that settles when all currently running tasks have completed; `queue.pending === 0`.
      */
  async onPendingZero() {
    if (__privateGet(this, _pending) === 0) {
      return;
    }
    await __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "pendingZero");
  }
  /**
  @returns A promise that settles when the queue becomes rate-limited due to intervalCap.
  */
  async onRateLimit() {
    if (this.isRateLimited) {
      return;
    }
    await __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "rateLimit");
  }
  /**
  @returns A promise that settles when the queue is no longer rate-limited.
  */
  async onRateLimitCleared() {
    if (!this.isRateLimited) {
      return;
    }
    await __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "rateLimitCleared");
  }
  /**
      @returns A promise that rejects when any task in the queue errors.
  
      Use with `Promise.race([queue.onError(), queue.onIdle()])` to fail fast on the first error while still resolving normally when the queue goes idle.
  
      Important: The promise returned by `add()` still rejects. You must handle each `add()` promise (for example, `.catch(() => {})`) to avoid unhandled rejections.
  
      @example
      ```
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 2});
  
      queue.add(() => fetchData(1)).catch(() => {});
      queue.add(() => fetchData(2)).catch(() => {});
      queue.add(() => fetchData(3)).catch(() => {});
  
      // Stop processing on first error
      try {
          await Promise.race([
              queue.onError(),
              queue.onIdle()
          ]);
      } catch (error) {
          queue.pause(); // Stop processing remaining tasks
          console.error('Queue failed:', error);
      }
      ```
      */
  // eslint-disable-next-line @typescript-eslint/promise-function-async
  onError() {
    return new Promise((_resolve, reject) => {
      const handleError = (error) => {
        this.off("error", handleError);
        reject(error);
      };
      this.on("error", handleError);
    });
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return __privateGet(this, _queue2).size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(options) {
    return __privateGet(this, _queue2).filter(options).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return __privateGet(this, _pending);
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return __privateGet(this, _isPaused);
  }
  /**
  Whether the queue is currently rate-limited due to intervalCap.
  */
  get isRateLimited() {
    return __privateGet(this, _rateLimitedInInterval);
  }
  /**
      Whether the queue is saturated. Returns `true` when:
      - All concurrency slots are occupied and tasks are waiting, OR
      - The queue is rate-limited and tasks are waiting
  
      Useful for detecting backpressure and potential hanging tasks.
  
      ```js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 2});
  
      // Backpressure handling
      if (queue.isSaturated) {
          console.log('Queue is saturated, waiting for capacity...');
          await queue.onSizeLessThan(queue.concurrency);
      }
  
      // Monitoring for stuck tasks
      setInterval(() => {
          if (queue.isSaturated) {
              console.warn(`Queue saturated: ${queue.pending} running, ${queue.size} waiting`);
          }
      }, 60000);
      ```
      */
  get isSaturated() {
    return __privateGet(this, _pending) === __privateGet(this, _concurrency) && __privateGet(this, _queue2).size > 0 || this.isRateLimited && __privateGet(this, _queue2).size > 0;
  }
  /**
      The tasks currently being executed. Each task includes its `id`, `priority`, `startTime`, and `timeout` (if set).
  
      Returns an array of task info objects.
  
      ```js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 2});
  
      // Add tasks with IDs for better debugging
      queue.add(() => fetchUser(123), {id: 'user-123'});
      queue.add(() => fetchPosts(456), {id: 'posts-456', priority: 1});
  
      // Check what's running
      console.log(queue.runningTasks);
      // => [{
      //   id: 'user-123',
      //   priority: 0,
      //   startTime: 1759253001716,
      //   timeout: undefined
      // }, {
      //   id: 'posts-456',
      //   priority: 1,
      //   startTime: 1759253001916,
      //   timeout: undefined
      // }]
      ```
      */
  get runningTasks() {
    return [...__privateGet(this, _runningTasks).values()].map((task) => ({ ...task }));
  }
};
_carryoverIntervalCount = new WeakMap();
_isIntervalIgnored = new WeakMap();
_intervalCount = new WeakMap();
_intervalCap = new WeakMap();
_rateLimitedInInterval = new WeakMap();
_rateLimitFlushScheduled = new WeakMap();
_interval = new WeakMap();
_intervalEnd = new WeakMap();
_lastExecutionTime = new WeakMap();
_intervalId = new WeakMap();
_timeoutId = new WeakMap();
_strict = new WeakMap();
_strictTicks = new WeakMap();
_strictTicksStartIndex = new WeakMap();
_queue2 = new WeakMap();
_queueClass = new WeakMap();
_pending = new WeakMap();
_concurrency = new WeakMap();
_isPaused = new WeakMap();
_idAssigner = new WeakMap();
_runningTasks = new WeakMap();
_PQueue_instances = new WeakSet();
cleanupStrictTicks_fn = function(now) {
  while (__privateGet(this, _strictTicksStartIndex) < __privateGet(this, _strictTicks).length) {
    const oldestTick = __privateGet(this, _strictTicks)[__privateGet(this, _strictTicksStartIndex)];
    if (oldestTick !== void 0 && now - oldestTick >= __privateGet(this, _interval)) {
      __privateWrapper(this, _strictTicksStartIndex)._++;
    } else {
      break;
    }
  }
  const shouldCompact = __privateGet(this, _strictTicksStartIndex) > 100 && __privateGet(this, _strictTicksStartIndex) > __privateGet(this, _strictTicks).length / 2 || __privateGet(this, _strictTicksStartIndex) === __privateGet(this, _strictTicks).length;
  if (shouldCompact) {
    __privateSet(this, _strictTicks, __privateGet(this, _strictTicks).slice(__privateGet(this, _strictTicksStartIndex)));
    __privateSet(this, _strictTicksStartIndex, 0);
  }
};
// Helper methods for interval consumption
consumeIntervalSlot_fn = function(now) {
  if (__privateGet(this, _strict)) {
    __privateGet(this, _strictTicks).push(now);
  } else {
    __privateWrapper(this, _intervalCount)._++;
  }
};
rollbackIntervalSlot_fn = function() {
  if (__privateGet(this, _strict)) {
    if (__privateGet(this, _strictTicks).length > __privateGet(this, _strictTicksStartIndex)) {
      __privateGet(this, _strictTicks).pop();
    }
  } else if (__privateGet(this, _intervalCount) > 0) {
    __privateWrapper(this, _intervalCount)._--;
  }
};
getActiveTicksCount_fn = function() {
  return __privateGet(this, _strictTicks).length - __privateGet(this, _strictTicksStartIndex);
};
doesIntervalAllowAnother_get = function() {
  if (__privateGet(this, _isIntervalIgnored)) {
    return true;
  }
  if (__privateGet(this, _strict)) {
    return __privateMethod(this, _PQueue_instances, getActiveTicksCount_fn).call(this) < __privateGet(this, _intervalCap);
  }
  return __privateGet(this, _intervalCount) < __privateGet(this, _intervalCap);
};
doesConcurrentAllowAnother_get = function() {
  return __privateGet(this, _pending) < __privateGet(this, _concurrency);
};
next_fn = function() {
  __privateWrapper(this, _pending)._--;
  if (__privateGet(this, _pending) === 0) {
    this.emit("pendingZero");
  }
  __privateMethod(this, _PQueue_instances, tryToStartAnother_fn).call(this);
  this.emit("next");
};
onResumeInterval_fn = function() {
  __privateSet(this, _timeoutId, void 0);
  __privateMethod(this, _PQueue_instances, onInterval_fn).call(this);
  __privateMethod(this, _PQueue_instances, initializeIntervalIfNeeded_fn).call(this);
};
isIntervalPausedAt_fn = function(now) {
  if (__privateGet(this, _strict)) {
    __privateMethod(this, _PQueue_instances, cleanupStrictTicks_fn).call(this, now);
    const activeTicksCount = __privateMethod(this, _PQueue_instances, getActiveTicksCount_fn).call(this);
    if (activeTicksCount >= __privateGet(this, _intervalCap)) {
      const oldestTick = __privateGet(this, _strictTicks)[__privateGet(this, _strictTicksStartIndex)];
      const delay3 = __privateGet(this, _interval) - (now - oldestTick);
      __privateMethod(this, _PQueue_instances, createIntervalTimeout_fn).call(this, delay3);
      return true;
    }
    return false;
  }
  if (__privateGet(this, _intervalId) === void 0) {
    const delay3 = __privateGet(this, _intervalEnd) - now;
    if (delay3 < 0) {
      if (__privateGet(this, _lastExecutionTime) > 0) {
        const timeSinceLastExecution = now - __privateGet(this, _lastExecutionTime);
        if (timeSinceLastExecution < __privateGet(this, _interval)) {
          __privateMethod(this, _PQueue_instances, createIntervalTimeout_fn).call(this, __privateGet(this, _interval) - timeSinceLastExecution);
          return true;
        }
      }
      __privateSet(this, _intervalCount, __privateGet(this, _carryoverIntervalCount) ? __privateGet(this, _pending) : 0);
    } else {
      __privateMethod(this, _PQueue_instances, createIntervalTimeout_fn).call(this, delay3);
      return true;
    }
  }
  return false;
};
createIntervalTimeout_fn = function(delay3) {
  if (__privateGet(this, _timeoutId) !== void 0) {
    return;
  }
  __privateSet(this, _timeoutId, setTimeout(() => {
    __privateMethod(this, _PQueue_instances, onResumeInterval_fn).call(this);
  }, delay3));
};
clearIntervalTimer_fn = function() {
  if (__privateGet(this, _intervalId)) {
    clearInterval(__privateGet(this, _intervalId));
    __privateSet(this, _intervalId, void 0);
  }
};
clearTimeoutTimer_fn = function() {
  if (__privateGet(this, _timeoutId)) {
    clearTimeout(__privateGet(this, _timeoutId));
    __privateSet(this, _timeoutId, void 0);
  }
};
tryToStartAnother_fn = function() {
  if (__privateGet(this, _queue2).size === 0) {
    __privateMethod(this, _PQueue_instances, clearIntervalTimer_fn).call(this);
    this.emit("empty");
    if (__privateGet(this, _pending) === 0) {
      __privateMethod(this, _PQueue_instances, clearTimeoutTimer_fn).call(this);
      if (__privateGet(this, _strict) && __privateGet(this, _strictTicksStartIndex) > 0) {
        const now = Date.now();
        __privateMethod(this, _PQueue_instances, cleanupStrictTicks_fn).call(this, now);
      }
      this.emit("idle");
    }
    return false;
  }
  let taskStarted = false;
  if (!__privateGet(this, _isPaused)) {
    const now = Date.now();
    const canInitializeInterval = !__privateMethod(this, _PQueue_instances, isIntervalPausedAt_fn).call(this, now);
    if (__privateGet(this, _PQueue_instances, doesIntervalAllowAnother_get) && __privateGet(this, _PQueue_instances, doesConcurrentAllowAnother_get)) {
      const job = __privateGet(this, _queue2).dequeue();
      if (!__privateGet(this, _isIntervalIgnored)) {
        __privateMethod(this, _PQueue_instances, consumeIntervalSlot_fn).call(this, now);
        __privateMethod(this, _PQueue_instances, scheduleRateLimitUpdate_fn).call(this);
      }
      this.emit("active");
      job();
      if (canInitializeInterval) {
        __privateMethod(this, _PQueue_instances, initializeIntervalIfNeeded_fn).call(this);
      }
      taskStarted = true;
    }
  }
  return taskStarted;
};
initializeIntervalIfNeeded_fn = function() {
  if (__privateGet(this, _isIntervalIgnored) || __privateGet(this, _intervalId) !== void 0) {
    return;
  }
  if (__privateGet(this, _strict)) {
    return;
  }
  __privateSet(this, _intervalId, setInterval(() => {
    __privateMethod(this, _PQueue_instances, onInterval_fn).call(this);
  }, __privateGet(this, _interval)));
  __privateSet(this, _intervalEnd, Date.now() + __privateGet(this, _interval));
};
onInterval_fn = function() {
  if (!__privateGet(this, _strict)) {
    if (__privateGet(this, _intervalCount) === 0 && __privateGet(this, _pending) === 0 && __privateGet(this, _intervalId)) {
      __privateMethod(this, _PQueue_instances, clearIntervalTimer_fn).call(this);
    }
    __privateSet(this, _intervalCount, __privateGet(this, _carryoverIntervalCount) ? __privateGet(this, _pending) : 0);
  }
  __privateMethod(this, _PQueue_instances, processQueue_fn).call(this);
  __privateMethod(this, _PQueue_instances, scheduleRateLimitUpdate_fn).call(this);
};
/**
Executes all queued functions until it reaches the limit.
*/
processQueue_fn = function() {
  while (__privateMethod(this, _PQueue_instances, tryToStartAnother_fn).call(this)) {
  }
};
onEvent_fn = async function(event, filter2) {
  return new Promise((resolve) => {
    const listener = () => {
      if (filter2 && !filter2()) {
        return;
      }
      this.off(event, listener);
      resolve();
    };
    this.on(event, listener);
  });
};
setupRateLimitTracking_fn = function() {
  if (__privateGet(this, _isIntervalIgnored)) {
    return;
  }
  this.on("add", () => {
    if (__privateGet(this, _queue2).size > 0) {
      __privateMethod(this, _PQueue_instances, scheduleRateLimitUpdate_fn).call(this);
    }
  });
  this.on("next", () => {
    __privateMethod(this, _PQueue_instances, scheduleRateLimitUpdate_fn).call(this);
  });
};
scheduleRateLimitUpdate_fn = function() {
  if (__privateGet(this, _isIntervalIgnored) || __privateGet(this, _rateLimitFlushScheduled)) {
    return;
  }
  __privateSet(this, _rateLimitFlushScheduled, true);
  queueMicrotask(() => {
    __privateSet(this, _rateLimitFlushScheduled, false);
    __privateMethod(this, _PQueue_instances, updateRateLimitState_fn).call(this);
  });
};
rollbackIntervalConsumption_fn = function() {
  if (__privateGet(this, _isIntervalIgnored)) {
    return;
  }
  __privateMethod(this, _PQueue_instances, rollbackIntervalSlot_fn).call(this);
  __privateMethod(this, _PQueue_instances, scheduleRateLimitUpdate_fn).call(this);
};
updateRateLimitState_fn = function() {
  const previous = __privateGet(this, _rateLimitedInInterval);
  if (__privateGet(this, _isIntervalIgnored) || __privateGet(this, _queue2).size === 0) {
    if (previous) {
      __privateSet(this, _rateLimitedInInterval, false);
      this.emit("rateLimitCleared");
    }
    return;
  }
  let count;
  if (__privateGet(this, _strict)) {
    const now = Date.now();
    __privateMethod(this, _PQueue_instances, cleanupStrictTicks_fn).call(this, now);
    count = __privateMethod(this, _PQueue_instances, getActiveTicksCount_fn).call(this);
  } else {
    count = __privateGet(this, _intervalCount);
  }
  const shouldBeRateLimited = count >= __privateGet(this, _intervalCap);
  if (shouldBeRateLimited !== previous) {
    __privateSet(this, _rateLimitedInInterval, shouldBeRateLimited);
    this.emit(shouldBeRateLimited ? "rateLimit" : "rateLimitCleared");
  }
};

// node_modules/@multiformats/dns/dist/src/utils/get-types.js
function getTypes(types) {
  const DEFAULT_TYPES = [
    RecordType.A
  ];
  if (types == null) {
    return DEFAULT_TYPES;
  }
  if (Array.isArray(types)) {
    if (types.length === 0) {
      return DEFAULT_TYPES;
    }
    return types;
  }
  return [
    types
  ];
}

// node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js
var DEFAULT_TTL = 60;
function toDNSResponse(obj) {
  return {
    Status: obj.Status ?? 0,
    TC: obj.TC ?? obj.flag_tc ?? false,
    RD: obj.RD ?? obj.flag_rd ?? false,
    RA: obj.RA ?? obj.flag_ra ?? false,
    AD: obj.AD ?? obj.flag_ad ?? false,
    CD: obj.CD ?? obj.flag_cd ?? false,
    Question: (obj.Question ?? obj.questions ?? []).map((question) => {
      return {
        name: question.name,
        type: RecordType[question.type]
      };
    }),
    Answer: (obj.Answer ?? obj.answers ?? []).map((answer) => {
      return {
        name: answer.name,
        type: RecordType[answer.type],
        TTL: answer.TTL ?? answer.ttl ?? DEFAULT_TTL,
        data: answer.data instanceof Uint8Array ? toString2(answer.data) : answer.data
      };
    })
  };
}

// node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.js
var DEFAULT_QUERY_CONCURRENCY = 4;
function dnsJsonOverHttps(url, init = {}) {
  const httpQueue = new PQueue({
    concurrency: init.queryConcurrency ?? DEFAULT_QUERY_CONCURRENCY
  });
  return async (fqdn, options = {}) => {
    var _a27, _b14;
    const log41 = (_a27 = options == null ? void 0 : options.logger) == null ? void 0 : _a27.forComponent("dns:dns-json-over-https");
    const searchParams = new URLSearchParams();
    searchParams.set("name", fqdn);
    getTypes(options.types).forEach((type) => {
      searchParams.append("type", RecordType[type]);
    });
    (_b14 = options.onProgress) == null ? void 0 : _b14.call(options, new CustomProgressEvent("dns:query", fqdn));
    log41 == null ? void 0 : log41("GET %s", `${url}?${searchParams}`);
    const response = await httpQueue.add(async () => {
      var _a28;
      const res = await fetch(`${url}?${searchParams}`, {
        headers: {
          accept: "application/dns-json"
        },
        signal: options == null ? void 0 : options.signal
      });
      log41 == null ? void 0 : log41("GET %s %d", res.url, res.status);
      if (res.status !== 200) {
        throw new Error(`Unexpected HTTP status: ${res.status} - ${res.statusText}`);
      }
      const response2 = toDNSResponse(await res.json());
      (_a28 = options.onProgress) == null ? void 0 : _a28.call(options, new CustomProgressEvent("dns:response", response2));
      return response2;
    }, {
      signal: options.signal
    });
    if (response == null) {
      throw new Error("No DNS response received");
    }
    return response;
  };
}

// node_modules/@multiformats/dns/dist/src/resolvers/default.browser.js
function defaultResolver() {
  return [
    dnsJsonOverHttps("https://cloudflare-dns.com/dns-query"),
    dnsJsonOverHttps("https://dns.google/resolve")
  ];
}

// node_modules/@multiformats/dns/dist/src/utils/cache.js
var import_hashlru = __toESM(require_hashlru(), 1);
var CachedAnswers = class {
  constructor(maxSize) {
    __publicField(this, "lru");
    this.lru = (0, import_hashlru.default)(maxSize);
  }
  get(fqdn, types) {
    let foundAllAnswers = true;
    const answers = [];
    for (const type of types) {
      const cached = this.getAnswers(fqdn, type);
      if (cached.length === 0) {
        foundAllAnswers = false;
        break;
      }
      answers.push(...cached);
    }
    if (foundAllAnswers) {
      return toDNSResponse({ answers });
    }
  }
  getAnswers(domain, type) {
    const key = `${domain.toLowerCase()}-${type}`;
    const answers = this.lru.get(key);
    if (answers != null) {
      const cachedAnswers = answers.filter((entry) => {
        return entry.expires > Date.now();
      }).map(({ expires, value }) => ({
        ...value,
        TTL: Math.round((expires - Date.now()) / 1e3),
        type: RecordType[value.type]
      }));
      if (cachedAnswers.length === 0) {
        this.lru.remove(key);
      }
      return cachedAnswers;
    }
    return [];
  }
  add(domain, answer) {
    const key = `${domain.toLowerCase()}-${answer.type}`;
    const answers = this.lru.get(key) ?? [];
    answers.push({
      expires: Date.now() + (answer.TTL ?? DEFAULT_TTL) * 1e3,
      value: answer
    });
    this.lru.set(key, answers);
  }
  remove(domain, type) {
    const key = `${domain.toLowerCase()}-${type}`;
    this.lru.remove(key);
  }
  clear() {
    this.lru.clear();
  }
};
function cache2(size) {
  return new CachedAnswers(size);
}

// node_modules/@multiformats/dns/dist/src/dns.js
var DEFAULT_ANSWER_CACHE_SIZE = 1e3;
var DNS5 = class {
  constructor(init) {
    __publicField(this, "resolvers");
    __publicField(this, "cache");
    __publicField(this, "logger");
    this.resolvers = {};
    this.cache = cache2(init.cacheSize ?? DEFAULT_ANSWER_CACHE_SIZE);
    this.logger = init.logger;
    Object.entries(init.resolvers ?? {}).forEach(([tld, resolver]) => {
      if (!Array.isArray(resolver)) {
        resolver = [resolver];
      }
      if (!tld.endsWith(".")) {
        tld = `${tld}.`;
      }
      this.resolvers[tld] = resolver;
    });
    if (this.resolvers["."] == null) {
      this.resolvers["."] = defaultResolver();
    }
  }
  /**
   * Queries DNS resolvers for the passed record types for the passed domain.
   *
   * If cached records exist for all desired types they will be returned
   * instead.
   *
   * Any new responses will be added to the cache for subsequent requests.
   */
  async query(domain, options = {}) {
    var _a27, _b14, _c3;
    const types = getTypes(options.types);
    const cached = options.cached !== false ? this.cache.get(domain, types) : void 0;
    if (cached != null) {
      (_a27 = options.onProgress) == null ? void 0 : _a27.call(options, new CustomProgressEvent("dns:cache", cached));
      return cached;
    }
    const tld = `${domain.split(".").pop()}.`;
    const resolvers2 = (this.resolvers[tld] ?? this.resolvers["."]).sort(() => {
      return Math.random() > 0.5 ? -1 : 1;
    });
    const errors = [];
    for (const resolver of resolvers2) {
      if (((_b14 = options.signal) == null ? void 0 : _b14.aborted) === true) {
        break;
      }
      try {
        const result = await resolver(domain, {
          ...options,
          logger: this.logger,
          types
        });
        for (const answer of result.Answer) {
          this.cache.add(domain, answer);
        }
        return result;
      } catch (err) {
        errors.push(err);
        (_c3 = options.onProgress) == null ? void 0 : _c3.call(options, new CustomProgressEvent("dns:error", err));
      }
    }
    throw new DNSQueryFailedError(errors, `DNS lookup of ${domain} ${types} failed`);
  }
};

// node_modules/@multiformats/dns/dist/src/index.js
var RecordType;
(function(RecordType2) {
  RecordType2[RecordType2["A"] = 1] = "A";
  RecordType2[RecordType2["CNAME"] = 5] = "CNAME";
  RecordType2[RecordType2["TXT"] = 16] = "TXT";
  RecordType2[RecordType2["AAAA"] = 28] = "AAAA";
})(RecordType || (RecordType = {}));
function dns(init = {}) {
  return new DNS5(init);
}

// node_modules/@multiformats/multiaddr/dist/src/protocols-table.js
var V2 = -1;
var names2 = {};
var codes = {};
var table = [
  [4, 32, "ip4"],
  [6, 16, "tcp"],
  [33, 16, "dccp"],
  [41, 128, "ip6"],
  [42, V2, "ip6zone"],
  [43, 8, "ipcidr"],
  [53, V2, "dns", true],
  [54, V2, "dns4", true],
  [55, V2, "dns6", true],
  [56, V2, "dnsaddr", true],
  [132, 16, "sctp"],
  [273, 16, "udp"],
  [275, 0, "p2p-webrtc-star"],
  [276, 0, "p2p-webrtc-direct"],
  [277, 0, "p2p-stardust"],
  [280, 0, "webrtc-direct"],
  [281, 0, "webrtc"],
  [290, 0, "p2p-circuit"],
  [301, 0, "udt"],
  [302, 0, "utp"],
  [400, V2, "unix", false, true],
  // `ipfs` is added before `p2p` for legacy support.
  // All text representations will default to `p2p`, but `ipfs` will
  // still be supported
  [421, V2, "ipfs"],
  // `p2p` is the preferred name for 421, and is now the default
  [421, V2, "p2p"],
  [443, 0, "https"],
  [444, 96, "onion"],
  [445, 296, "onion3"],
  [446, V2, "garlic64"],
  [448, 0, "tls"],
  [449, V2, "sni"],
  [460, 0, "quic"],
  [461, 0, "quic-v1"],
  [465, 0, "webtransport"],
  [466, V2, "certhash"],
  [477, 0, "ws"],
  [478, 0, "wss"],
  [479, 0, "p2p-websocket-star"],
  [480, 0, "http"],
  [481, V2, "http-path"],
  [777, V2, "memory"]
];
table.forEach((row) => {
  const proto = createProtocol(...row);
  codes[proto.code] = proto;
  names2[proto.name] = proto;
});
function createProtocol(code2, size, name3, resolvable, path) {
  return {
    code: code2,
    size,
    name: name3,
    resolvable: Boolean(resolvable),
    path: Boolean(path)
  };
}
function getProtocol(proto) {
  if (typeof proto === "number") {
    if (codes[proto] != null) {
      return codes[proto];
    }
    throw new Error(`no protocol with code: ${proto}`);
  } else if (typeof proto === "string") {
    if (names2[proto] != null) {
      return names2[proto];
    }
    throw new Error(`no protocol with name: ${proto}`);
  }
  throw new Error(`invalid protocol id type: ${typeof proto}`);
}

// node_modules/@multiformats/multiaddr/dist/src/resolvers/dnsaddr.js
var MAX_RECURSIVE_DEPTH = 32;
var { code: dnsaddrCode } = getProtocol("dnsaddr");
var RecursionLimitError = class extends Error {
  constructor(message2 = "Max recursive depth reached") {
    super(message2);
    this.name = "RecursionLimitError";
  }
};
var dnsaddrResolver = async function dnsaddrResolver2(ma, options = {}) {
  const recursionLimit = options.maxRecursiveDepth ?? MAX_RECURSIVE_DEPTH;
  if (recursionLimit === 0) {
    throw new RecursionLimitError("Max recursive depth reached");
  }
  const [, hostname] = ma.stringTuples().find(([proto]) => proto === dnsaddrCode) ?? [];
  const resolver = (options == null ? void 0 : options.dns) ?? dns();
  const result = await resolver.query(`_dnsaddr.${hostname}`, {
    signal: options == null ? void 0 : options.signal,
    types: [
      RecordType.TXT
    ]
  });
  const peerId2 = ma.getPeerId();
  const output = [];
  for (const answer of result.Answer) {
    const addr = answer.data.replace(/["']/g, "").trim().split("=")[1];
    if (addr == null) {
      continue;
    }
    if (peerId2 != null && !addr.includes(peerId2)) {
      continue;
    }
    const ma2 = multiaddr(addr);
    if (addr.startsWith("/dnsaddr")) {
      const resolved = await ma2.resolve({
        ...options,
        maxRecursiveDepth: recursionLimit - 1
      });
      output.push(...resolved.map((ma3) => ma3.toString()));
    } else {
      output.push(ma2.toString());
    }
  }
  return output;
};

// node_modules/libp2p/dist/src/config.js
var DefaultConfig = {
  addresses: {
    listen: [],
    announce: [],
    noAnnounce: [],
    announceFilter: (multiaddrs) => multiaddrs
  },
  connectionManager: {
    resolvers: {
      dnsaddr: dnsaddrResolver
    }
  },
  transportManager: {
    faultTolerance: FaultTolerance.FATAL_ALL
  }
};
async function validateConfig(opts) {
  var _a27, _b14;
  const resultingOptions = mergeOptions(DefaultConfig, opts);
  if (resultingOptions.connectionProtector === null && ((_b14 = (_a27 = globalThis.process) == null ? void 0 : _a27.env) == null ? void 0 : _b14.LIBP2P_FORCE_PNET) != null) {
    throw new InvalidParametersError("Private network is enforced, but no protector was provided");
  }
  return resultingOptions;
}

// node_modules/weald/node_modules/ms/dist/index.js
var e = 1e3;
var t = e * 60;
var n = t * 60;
var r = n * 24;
var i = r * 7;
var a = r * 365.25;
var o = a / 12;
function s(e2, t2) {
  if (typeof e2 == `string`) return l(e2);
  if (typeof e2 == `number`) return p(e2, t2);
  throw Error(`Value provided to ms() must be a string or number. value=${JSON.stringify(e2)}`);
}
var c = s;
function l(s2) {
  if (typeof s2 != `string` || s2.length === 0 || s2.length > 100) throw Error(`Value provided to ms.parse() must be a string with length between 1 and 99. value=${JSON.stringify(s2)}`);
  let c2 = /^(?<value>-?\d*\.?\d+) *(?<unit>milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)?$/i.exec(s2);
  if (!(c2 == null ? void 0 : c2.groups)) return NaN;
  let { value: l2, unit: u = `ms` } = c2.groups, d2 = parseFloat(l2), f3 = u.toLowerCase();
  switch (f3) {
    case `years`:
    case `year`:
    case `yrs`:
    case `yr`:
    case `y`:
      return d2 * a;
    case `months`:
    case `month`:
    case `mo`:
      return d2 * o;
    case `weeks`:
    case `week`:
    case `w`:
      return d2 * i;
    case `days`:
    case `day`:
    case `d`:
      return d2 * r;
    case `hours`:
    case `hour`:
    case `hrs`:
    case `hr`:
    case `h`:
      return d2 * n;
    case `minutes`:
    case `minute`:
    case `mins`:
    case `min`:
    case `m`:
      return d2 * t;
    case `seconds`:
    case `second`:
    case `secs`:
    case `sec`:
    case `s`:
      return d2 * e;
    case `milliseconds`:
    case `millisecond`:
    case `msecs`:
    case `msec`:
    case `ms`:
      return d2;
    default:
      throw Error(`Unknown unit "${f3}" provided to ms.parse(). value=${JSON.stringify(s2)}`);
  }
}
function d(s2) {
  let c2 = Math.abs(s2);
  return c2 >= a ? `${Math.round(s2 / a)}y` : c2 >= o ? `${Math.round(s2 / o)}mo` : c2 >= i ? `${Math.round(s2 / i)}w` : c2 >= r ? `${Math.round(s2 / r)}d` : c2 >= n ? `${Math.round(s2 / n)}h` : c2 >= t ? `${Math.round(s2 / t)}m` : c2 >= e ? `${Math.round(s2 / e)}s` : `${s2}ms`;
}
function f2(s2) {
  let c2 = Math.abs(s2);
  return c2 >= a ? m(s2, c2, a, `year`) : c2 >= o ? m(s2, c2, o, `month`) : c2 >= i ? m(s2, c2, i, `week`) : c2 >= r ? m(s2, c2, r, `day`) : c2 >= n ? m(s2, c2, n, `hour`) : c2 >= t ? m(s2, c2, t, `minute`) : c2 >= e ? m(s2, c2, e, `second`) : `${s2} ms`;
}
function p(e2, t2) {
  if (typeof e2 != `number` || !Number.isFinite(e2)) throw Error(`Value provided to ms.format() must be of type number.`);
  return (t2 == null ? void 0 : t2.long) ? f2(e2) : d(e2);
}
function m(e2, t2, n2, r2) {
  let i2 = t2 >= n2 * 1.5;
  return `${Math.round(e2 / n2)} ${r2}${i2 ? `s` : ``}`;
}

// node_modules/weald/dist/src/common.js
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce2;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = c;
  createDebug.destroy = destroy;
  Object.keys(env).forEach((key) => {
    createDebug[key] = env[key];
  });
  createDebug.names = [];
  createDebug.skips = [];
  createDebug.formatters = {};
  function selectColor(namespace) {
    let hash = 0;
    for (let i2 = 0; i2 < namespace.length; i2++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i2);
      hash |= 0;
    }
    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;
  function createDebug(namespace, options) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug2(...args) {
      if (!debug2.enabled) {
        return;
      }
      const self2 = debug2;
      const curr = Number(/* @__PURE__ */ new Date());
      const ms = curr - (prevTime || curr);
      self2.diff = ms;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
        if (match === "%%") {
          return "%";
        }
        index++;
        const formatter = createDebug.formatters[format2];
        if (typeof formatter === "function") {
          const val = args[index];
          match = formatter.call(self2, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      createDebug.formatArgs.call(self2, args);
      if ((options == null ? void 0 : options.onLog) != null) {
        options.onLog(...args);
      }
      const logFn = self2.log || createDebug.log;
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace;
    debug2.useColors = createDebug.useColors();
    debug2.color = createDebug.selectColor(namespace);
    debug2.extend = extend;
    debug2.destroy = createDebug.destroy;
    Object.defineProperty(debug2, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });
    if (typeof createDebug.init === "function") {
      createDebug.init(debug2);
    }
    return debug2;
  }
  function extend(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    let i2;
    const split3 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    const len = split3.length;
    for (i2 = 0; i2 < len; i2++) {
      if (!split3[i2]) {
        continue;
      }
      namespaces = split3[i2].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    const namespaces = [
      ...createDebug.names.map(toNamespace),
      ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
    ].join(",");
    createDebug.enable("");
    return namespaces;
  }
  function enabled(name3) {
    if (name3[name3.length - 1] === "*") {
      return true;
    }
    let i2;
    let len;
    for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
      if (createDebug.skips[i2].test(name3)) {
        return false;
      }
    }
    for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
      if (createDebug.names[i2].test(name3)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce2(val) {
    if (val instanceof Error) {
      return val.stack ?? val.message;
    }
    return val;
  }
  function destroy() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug.setupFormatters(createDebug.formatters);
  createDebug.enable(createDebug.load());
  return createDebug;
}

// node_modules/weald/dist/src/browser.js
var storage = localstorage();
var colors = [
  "#0000CC",
  "#0000FF",
  "#0033CC",
  "#0033FF",
  "#0066CC",
  "#0066FF",
  "#0099CC",
  "#0099FF",
  "#00CC00",
  "#00CC33",
  "#00CC66",
  "#00CC99",
  "#00CCCC",
  "#00CCFF",
  "#3300CC",
  "#3300FF",
  "#3333CC",
  "#3333FF",
  "#3366CC",
  "#3366FF",
  "#3399CC",
  "#3399FF",
  "#33CC00",
  "#33CC33",
  "#33CC66",
  "#33CC99",
  "#33CCCC",
  "#33CCFF",
  "#6600CC",
  "#6600FF",
  "#6633CC",
  "#6633FF",
  "#66CC00",
  "#66CC33",
  "#9900CC",
  "#9900FF",
  "#9933CC",
  "#9933FF",
  "#99CC00",
  "#99CC33",
  "#CC0000",
  "#CC0033",
  "#CC0066",
  "#CC0099",
  "#CC00CC",
  "#CC00FF",
  "#CC3300",
  "#CC3333",
  "#CC3366",
  "#CC3399",
  "#CC33CC",
  "#CC33FF",
  "#CC6600",
  "#CC6633",
  "#CC9900",
  "#CC9933",
  "#CCCC00",
  "#CCCC33",
  "#FF0000",
  "#FF0033",
  "#FF0066",
  "#FF0099",
  "#FF00CC",
  "#FF00FF",
  "#FF3300",
  "#FF3333",
  "#FF3366",
  "#FF3399",
  "#FF33CC",
  "#FF33FF",
  "#FF6600",
  "#FF6633",
  "#FF9900",
  "#FF9933",
  "#FFCC00",
  "#FFCC33"
];
function useColors() {
  var _a27, _b14, _c3, _d2, _e;
  if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
    return true;
  }
  if (typeof navigator !== "undefined" && ((_a27 = navigator.userAgent) == null ? void 0 : _a27.toLowerCase().match(/(edge|trident)\/(\d+)/)) != null) {
    return false;
  }
  return typeof document !== "undefined" && ((_c3 = (_b14 = document.documentElement) == null ? void 0 : _b14.style) == null ? void 0 : _c3.WebkitAppearance) || // Is firebug? http://stackoverflow.com/a/398120/376773
  // @ts-expect-error window.console.firebug and window.console.exception are not in the types
  typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== "undefined" && ((_d2 = navigator.userAgent) == null ? void 0 : _d2.toLowerCase().match(/firefox\/(\d+)/)) != null && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== "undefined" && ((_e = navigator.userAgent) == null ? void 0 : _e.toLowerCase().match(/applewebkit\/(\d+)/));
}
function formatArgs(args) {
  args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + c(this.diff);
  if (!this.useColors) {
    return;
  }
  const c2 = "color: " + this.color;
  args.splice(1, 0, c2, "color: inherit");
  let index = 0;
  let lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, (match) => {
    if (match === "%%") {
      return;
    }
    index++;
    if (match === "%c") {
      lastC = index;
    }
  });
  args.splice(lastC, 0, c2);
}
var log22 = console.debug ?? console.log ?? (() => {
});
function save(namespaces) {
  try {
    if (namespaces) {
      storage == null ? void 0 : storage.setItem("debug", namespaces);
    } else {
      storage == null ? void 0 : storage.removeItem("debug");
    }
  } catch (error) {
  }
}
function load() {
  let r2;
  try {
    r2 = storage == null ? void 0 : storage.getItem("debug");
  } catch (error) {
  }
  if (!r2 && typeof globalThis.process !== "undefined" && "env" in globalThis.process) {
    r2 = globalThis.process.env.DEBUG;
  }
  return r2;
}
function localstorage() {
  try {
    return localStorage;
  } catch (error) {
  }
}
function setupFormatters(formatters) {
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
}
var browser_default = setup({ formatArgs, save, load, useColors, setupFormatters, colors, storage, log: log22 });

// node_modules/weald/dist/src/index.js
var src_default4 = browser_default;

// node_modules/@libp2p/logger/dist/src/index.js
src_default4.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc.baseEncode(v);
};
src_default4.formatters.t = (v) => {
  return v == null ? "undefined" : base32.baseEncode(v);
};
src_default4.formatters.m = (v) => {
  return v == null ? "undefined" : base64.baseEncode(v);
};
src_default4.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default4.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default4.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default4.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default4.formatters.e = (v) => {
  return v == null ? "undefined" : notEmpty(v.stack) ?? notEmpty(v.message) ?? v.toString();
};
function createDisabledLogger(namespace) {
  const logger4 = () => {
  };
  logger4.enabled = false;
  logger4.color = "";
  logger4.diff = 0;
  logger4.log = () => {
  };
  logger4.namespace = namespace;
  logger4.destroy = () => true;
  logger4.extend = () => logger4;
  return logger4;
}
function defaultLogger() {
  return {
    forComponent(name3) {
      return logger(name3);
    }
  };
}
function logger(name3) {
  let trace = createDisabledLogger(`${name3}:trace`);
  if (src_default4.enabled(`${name3}:trace`) && src_default4.names.map((r2) => r2.toString()).find((n2) => n2.includes(":trace")) != null) {
    trace = src_default4(`${name3}:trace`);
  }
  return Object.assign(src_default4(name3), {
    error: src_default4(`${name3}:error`),
    trace,
    newScope: (scope) => logger(`${name3}:${scope}`)
  });
}
function notEmpty(str) {
  if (str == null) {
    return;
  }
  str = str.trim();
  if (str.length === 0) {
    return;
  }
  return str;
}

// node_modules/@libp2p/peer-collections/dist/src/util.js
function mapIterable(iter, map2) {
  const iterator = {
    [Symbol.iterator]: () => {
      return iterator;
    },
    next: () => {
      const next = iter.next();
      const val = next.value;
      if (next.done === true || val == null) {
        const result = {
          done: true,
          value: void 0
        };
        return result;
      }
      return {
        done: false,
        value: map2(val)
      };
    }
  };
  return iterator;
}
function peerIdFromString2(str) {
  const multihash = decode6(base58btc.decode(`z${str}`));
  return peerIdFromMultihash(multihash);
}

// node_modules/@libp2p/peer-collections/dist/src/map.js
var PeerMap = class {
  constructor(map2) {
    __publicField(this, "map");
    this.map = /* @__PURE__ */ new Map();
    if (map2 != null) {
      for (const [key, value] of map2.entries()) {
        this.map.set(key.toString(), { key, value });
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  clear() {
    this.map.clear();
  }
  delete(peer) {
    return this.map.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.map.entries(), (val) => {
      return [val[1].key, val[1].value];
    });
  }
  forEach(fn) {
    this.map.forEach((value, key) => {
      fn(value.value, value.key, this);
    });
  }
  get(peer) {
    var _a27;
    return (_a27 = this.map.get(peer.toString())) == null ? void 0 : _a27.value;
  }
  has(peer) {
    return this.map.has(peer.toString());
  }
  set(peer, value) {
    this.map.set(peer.toString(), { key: peer, value });
  }
  keys() {
    return mapIterable(this.map.values(), (val) => {
      return val.key;
    });
  }
  values() {
    return mapIterable(this.map.values(), (val) => val.value);
  }
  get size() {
    return this.map.size;
  }
};

// node_modules/@libp2p/peer-collections/dist/src/set.js
var PeerSet = class _PeerSet {
  constructor(set) {
    __publicField(this, "set");
    this.set = /* @__PURE__ */ new Set();
    if (set != null) {
      for (const key of set) {
        this.set.add(key.toString());
      }
    }
  }
  get size() {
    return this.set.size;
  }
  [Symbol.iterator]() {
    return this.values();
  }
  add(peer) {
    this.set.add(peer.toString());
  }
  clear() {
    this.set.clear();
  }
  delete(peer) {
    this.set.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.set.entries(), (val) => {
      const peerId2 = peerIdFromString2(val[0]);
      return [peerId2, peerId2];
    });
  }
  forEach(predicate) {
    this.set.forEach((str) => {
      const peerId2 = peerIdFromString2(str);
      predicate(peerId2, peerId2, this);
    });
  }
  has(peer) {
    return this.set.has(peer.toString());
  }
  values() {
    return mapIterable(this.set.values(), (val) => {
      return peerIdFromString2(val);
    });
  }
  intersection(other) {
    const output = new _PeerSet();
    for (const peerId2 of other) {
      if (this.has(peerId2)) {
        output.add(peerId2);
      }
    }
    return output;
  }
  difference(other) {
    const output = new _PeerSet();
    for (const peerId2 of this) {
      if (!other.has(peerId2)) {
        output.add(peerId2);
      }
    }
    return output;
  }
  union(other) {
    const output = new _PeerSet();
    for (const peerId2 of other) {
      output.add(peerId2);
    }
    for (const peerId2 of this) {
      output.add(peerId2);
    }
    return output;
  }
};

// node_modules/@sindresorhus/fnv1a/index.js
var FNV_PRIMES = {
  32: 16777619n,
  64: 1099511628211n,
  128: 309485009821345068724781371n,
  256: 374144419156711147060143317175368453031918731002211n,
  512: 35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,
  1024: 5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n
};
var FNV_OFFSETS = {
  32: 2166136261n,
  64: 14695981039346656037n,
  128: 144066263297769815596495629667062367629n,
  256: 100029257958052580907070968620625704837092796014241193945225284501741471925557n,
  512: 9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,
  1024: 14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n
};
var cachedEncoder = new globalThis.TextEncoder();
function fnv1aUint8Array(uint8Array, size) {
  const fnvPrime = FNV_PRIMES[size];
  let hash = FNV_OFFSETS[size];
  for (let index = 0; index < uint8Array.length; index++) {
    hash ^= BigInt(uint8Array[index]);
    hash = BigInt.asUintN(size, hash * fnvPrime);
  }
  return hash;
}
function fnv1aEncodeInto(string3, size, utf8Buffer) {
  if (utf8Buffer.length === 0) {
    throw new Error("The `utf8Buffer` option must have a length greater than zero");
  }
  const fnvPrime = FNV_PRIMES[size];
  let hash = FNV_OFFSETS[size];
  let remaining = string3;
  while (remaining.length > 0) {
    const result = cachedEncoder.encodeInto(remaining, utf8Buffer);
    remaining = remaining.slice(result.read);
    for (let index = 0; index < result.written; index++) {
      hash ^= BigInt(utf8Buffer[index]);
      hash = BigInt.asUintN(size, hash * fnvPrime);
    }
  }
  return hash;
}
function fnv1a(value, { size = 32, utf8Buffer } = {}) {
  if (!FNV_PRIMES[size]) {
    throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");
  }
  if (typeof value === "string") {
    if (utf8Buffer) {
      return fnv1aEncodeInto(value, size, utf8Buffer);
    }
    value = cachedEncoder.encode(value);
  }
  return fnv1aUint8Array(value, size);
}

// node_modules/@libp2p/utils/dist/src/filters/hashes.js
var fnv1a2 = {
  hash: (input) => {
    return Number(fnv1a(input, {
      size: 32
    }));
  },
  hashV: (input, seed) => {
    return numberToBuffer(fnv1a2.hash(input, seed));
  }
};
function numberToBuffer(num3) {
  let hex = num3.toString(16);
  if (hex.length % 2 === 1) {
    hex = `0${hex}`;
  }
  return fromString2(hex, "base16");
}

// node_modules/@libp2p/utils/dist/src/filters/bloom-filter.js
var LN2_SQUARED = Math.LN2 * Math.LN2;

// node_modules/@libp2p/utils/dist/src/filters/fingerprint.js
var MAX_FINGERPRINT_SIZE = 64;
var Fingerprint = class {
  constructor(buf, hash, seed, fingerprintSize = 2) {
    __publicField(this, "fp");
    __publicField(this, "h");
    __publicField(this, "seed");
    if (fingerprintSize > MAX_FINGERPRINT_SIZE) {
      throw new TypeError("Invalid Fingerprint Size");
    }
    const fnv = hash.hashV(buf, seed);
    const fp = alloc(fingerprintSize);
    for (let i2 = 0; i2 < fp.length; i2++) {
      fp[i2] = fnv[i2];
    }
    if (fp.length === 0) {
      fp[0] = 7;
    }
    this.fp = fp;
    this.h = hash;
    this.seed = seed;
  }
  hash() {
    return this.h.hash(this.fp, this.seed);
  }
  equals(other) {
    if (!((other == null ? void 0 : other.fp) instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.fp, other.fp);
  }
};

// node_modules/@libp2p/utils/dist/src/filters/utils.js
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
}

// node_modules/@libp2p/utils/dist/src/filters/bucket.js
var Bucket = class {
  constructor(size) {
    __publicField(this, "contents");
    this.contents = new Array(size).fill(null);
  }
  has(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    return this.contents.some((fp) => {
      return fingerprint.equals(fp);
    });
  }
  add(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    for (let i2 = 0; i2 < this.contents.length; i2++) {
      if (this.contents[i2] == null) {
        this.contents[i2] = fingerprint;
        return true;
      }
    }
    return true;
  }
  swap(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    const i2 = getRandomInt(0, this.contents.length - 1);
    const current = this.contents[i2];
    this.contents[i2] = fingerprint;
    return current;
  }
  remove(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    const found = this.contents.findIndex((fp) => {
      return fingerprint.equals(fp);
    });
    if (found > -1) {
      this.contents[found] = null;
      return true;
    } else {
      return false;
    }
  }
};

// node_modules/@libp2p/utils/dist/src/filters/cuckoo-filter.js
var maxCuckooCount = 500;
var CuckooFilter = class {
  constructor(init) {
    __publicField(this, "bucketSize");
    __publicField(this, "filterSize");
    __publicField(this, "fingerprintSize");
    __publicField(this, "buckets");
    __publicField(this, "count");
    __publicField(this, "hash");
    __publicField(this, "seed");
    this.filterSize = init.filterSize;
    this.bucketSize = init.bucketSize ?? 4;
    this.fingerprintSize = init.fingerprintSize ?? 2;
    this.count = 0;
    this.buckets = [];
    this.hash = init.hash ?? fnv1a2;
    this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10));
  }
  add(item) {
    if (typeof item === "string") {
      item = fromString2(item);
    }
    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
    const j = this.hash.hash(item, this.seed) % this.filterSize;
    const k = (j ^ fingerprint.hash()) % this.filterSize;
    if (this.buckets[j] == null) {
      this.buckets[j] = new Bucket(this.bucketSize);
    }
    if (this.buckets[k] == null) {
      this.buckets[k] = new Bucket(this.bucketSize);
    }
    if (this.buckets[j].add(fingerprint) || this.buckets[k].add(fingerprint)) {
      this.count++;
      return true;
    }
    const rand = [j, k];
    let i2 = rand[getRandomInt(0, rand.length - 1)];
    if (this.buckets[i2] == null) {
      this.buckets[i2] = new Bucket(this.bucketSize);
    }
    for (let n2 = 0; n2 < maxCuckooCount; n2++) {
      const swapped = this.buckets[i2].swap(fingerprint);
      if (swapped == null) {
        continue;
      }
      i2 = (i2 ^ swapped.hash()) % this.filterSize;
      if (this.buckets[i2] == null) {
        this.buckets[i2] = new Bucket(this.bucketSize);
      }
      if (this.buckets[i2].add(swapped)) {
        this.count++;
        return true;
      } else {
        continue;
      }
    }
    return false;
  }
  has(item) {
    var _a27, _b14;
    if (typeof item === "string") {
      item = fromString2(item);
    }
    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
    const j = this.hash.hash(item, this.seed) % this.filterSize;
    const inJ = ((_a27 = this.buckets[j]) == null ? void 0 : _a27.has(fingerprint)) ?? false;
    if (inJ) {
      return inJ;
    }
    const k = (j ^ fingerprint.hash()) % this.filterSize;
    return ((_b14 = this.buckets[k]) == null ? void 0 : _b14.has(fingerprint)) ?? false;
  }
  remove(item) {
    var _a27, _b14;
    if (typeof item === "string") {
      item = fromString2(item);
    }
    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
    const j = this.hash.hash(item, this.seed) % this.filterSize;
    const inJ = ((_a27 = this.buckets[j]) == null ? void 0 : _a27.remove(fingerprint)) ?? false;
    if (inJ) {
      this.count--;
      return inJ;
    }
    const k = (j ^ fingerprint.hash()) % this.filterSize;
    const inK = ((_b14 = this.buckets[k]) == null ? void 0 : _b14.remove(fingerprint)) ?? false;
    if (inK) {
      this.count--;
    }
    return inK;
  }
  get reliable() {
    return Math.floor(100 * (this.count / this.filterSize)) <= 90;
  }
};
var MAX_LOAD = {
  1: 0.5,
  2: 0.84,
  4: 0.95,
  8: 0.98
};
function calculateBucketSize(errorRate = 1e-3) {
  if (errorRate > 2e-3) {
    return 2;
  }
  if (errorRate > 1e-5) {
    return 4;
  }
  return 8;
}
function optimize(maxItems, errorRate = 1e-3) {
  const bucketSize = calculateBucketSize(errorRate);
  const load2 = MAX_LOAD[bucketSize];
  const filterSize = Math.round(maxItems / load2);
  const fingerprintSize = Math.min(Math.ceil(Math.log2(1 / errorRate) + Math.log2(2 * bucketSize)), MAX_FINGERPRINT_SIZE);
  return {
    filterSize,
    bucketSize,
    fingerprintSize
  };
}

// node_modules/@libp2p/utils/dist/src/filters/scalable-cuckoo-filter.js
var ScalableCuckooFilter = class {
  constructor(init) {
    __publicField(this, "filterSize");
    __publicField(this, "bucketSize");
    __publicField(this, "fingerprintSize");
    __publicField(this, "scale");
    __publicField(this, "filterSeries");
    __publicField(this, "hash");
    __publicField(this, "seed");
    this.bucketSize = init.bucketSize ?? 4;
    this.filterSize = init.filterSize ?? (1 << 18) / this.bucketSize;
    this.fingerprintSize = init.fingerprintSize ?? 2;
    this.scale = init.scale ?? 2;
    this.hash = init.hash ?? fnv1a2;
    this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10));
    this.filterSeries = [
      new CuckooFilter({
        filterSize: this.filterSize,
        bucketSize: this.bucketSize,
        fingerprintSize: this.fingerprintSize,
        hash: this.hash,
        seed: this.seed
      })
    ];
  }
  add(item) {
    if (typeof item === "string") {
      item = fromString2(item);
    }
    if (this.has(item)) {
      return true;
    }
    let current = this.filterSeries.find((cuckoo) => {
      return cuckoo.reliable;
    });
    if (current == null) {
      const curSize = this.filterSize * Math.pow(this.scale, this.filterSeries.length);
      current = new CuckooFilter({
        filterSize: curSize,
        bucketSize: this.bucketSize,
        fingerprintSize: this.fingerprintSize,
        hash: this.hash,
        seed: this.seed
      });
      this.filterSeries.push(current);
    }
    return current.add(item);
  }
  has(item) {
    if (typeof item === "string") {
      item = fromString2(item);
    }
    for (let i2 = 0; i2 < this.filterSeries.length; i2++) {
      if (this.filterSeries[i2].has(item)) {
        return true;
      }
    }
    return false;
  }
  remove(item) {
    if (typeof item === "string") {
      item = fromString2(item);
    }
    for (let i2 = 0; i2 < this.filterSeries.length; i2++) {
      if (this.filterSeries[i2].remove(item)) {
        return true;
      }
    }
    return false;
  }
  get count() {
    return this.filterSeries.reduce((acc, curr) => {
      return acc + curr.count;
    }, 0);
  }
};
function createScalableCuckooFilter(maxItems, errorRate = 1e-3, options) {
  return new ScalableCuckooFilter({
    ...optimize(maxItems, errorRate),
    ...options ?? {}
  });
}

// node_modules/@libp2p/peer-collections/dist/src/tracked-map.js
var TrackedPeerMap = class extends PeerMap {
  constructor(init) {
    super();
    __publicField(this, "metric");
    const { name: name3, metrics } = init;
    this.metric = metrics.registerMetric(name3);
    this.updateComponentMetric();
  }
  set(key, value) {
    super.set(key, value);
    this.updateComponentMetric();
    return this;
  }
  delete(key) {
    const deleted = super.delete(key);
    this.updateComponentMetric();
    return deleted;
  }
  clear() {
    super.clear();
    this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metric.update(this.size);
  }
};
function trackedPeerMap(config) {
  const { name: name3, metrics } = config;
  let map2;
  if (metrics != null) {
    map2 = new TrackedPeerMap({ name: name3, metrics });
  } else {
    map2 = new PeerMap();
  }
  return map2;
}

// node_modules/abort-error/dist/src/index.js
var AbortError4 = class extends Error {
  constructor(message2 = "The operation was aborted", ...rest) {
    super(message2, ...rest);
    __publicField(this, "name", "AbortError");
  }
};
__publicField(AbortError4, "name", "AbortError");

// node_modules/race-event/dist/src/index.js
async function raceEvent(emitter, eventName, signal, opts) {
  const error = new AbortError4(opts == null ? void 0 : opts.errorMessage);
  if ((opts == null ? void 0 : opts.errorCode) != null) {
    error.code = opts.errorCode;
  }
  const errorEvent = (opts == null ? void 0 : opts.errorEvent) ?? "error";
  if ((signal == null ? void 0 : signal.aborted) === true) {
    return Promise.reject(error);
  }
  return new Promise((resolve, reject) => {
    function removeListeners() {
      removeListener(signal, "abort", abortListener);
      removeListener(emitter, eventName, eventListener);
      removeListener(emitter, errorEvent, errorEventListener);
    }
    const eventListener = (evt) => {
      var _a27;
      try {
        if (((_a27 = opts == null ? void 0 : opts.filter) == null ? void 0 : _a27.call(opts, evt)) === false) {
          return;
        }
      } catch (err) {
        removeListeners();
        reject(err);
        return;
      }
      removeListeners();
      resolve(evt);
    };
    const errorEventListener = (evt) => {
      removeListeners();
      if (evt instanceof Error) {
        reject(evt);
        return;
      }
      reject(evt.detail ?? (opts == null ? void 0 : opts.error) ?? new Error(`The "${opts == null ? void 0 : opts.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`));
    };
    const abortListener = () => {
      removeListeners();
      reject(error);
    };
    addListener(signal, "abort", abortListener);
    addListener(emitter, eventName, eventListener);
    addListener(emitter, errorEvent, errorEventListener);
  });
}
function addListener(emitter, event, listener) {
  if (emitter == null) {
    return;
  }
  if (isEventTarget(emitter)) {
    emitter.addEventListener(event, listener);
  } else {
    emitter.addListener(event, listener);
  }
}
function removeListener(emitter, event, listener) {
  if (emitter == null) {
    return;
  }
  if (isEventTarget(emitter)) {
    emitter.removeEventListener(event, listener);
  } else {
    emitter.removeListener(event, listener);
  }
}
function isEventTarget(emitter) {
  return typeof emitter.addEventListener === "function" && typeof emitter.removeEventListener === "function";
}

// node_modules/it-queue/dist/src/errors.js
var QueueFullError2 = class extends Error {
  constructor(message2 = "The queue was full") {
    super(message2);
    this.name = "QueueFullError";
  }
};
__publicField(QueueFullError2, "name", "QueueFullError");

// node_modules/it-queue/node_modules/race-signal/dist/src/index.js
function defaultTranslate3(signal) {
  return signal.reason;
}
async function raceSignal4(promise, signal, opts) {
  if (signal == null) {
    return promise;
  }
  const translateError = (opts == null ? void 0 : opts.translateError) ?? defaultTranslate3;
  if (signal.aborted) {
    promise.catch(() => {
    });
    return Promise.reject(translateError(signal));
  }
  let listener;
  try {
    return await Promise.race([
      promise,
      new Promise((resolve, reject) => {
        listener = () => {
          reject(translateError(signal));
        };
        signal.addEventListener("abort", listener);
      })
    ]);
  } finally {
    if (listener != null) {
      signal.removeEventListener("abort", listener);
    }
  }
}

// node_modules/it-queue/dist/src/recipient.js
var JobRecipient = class {
  constructor(signal) {
    __publicField(this, "deferred");
    __publicField(this, "signal");
    var _a27;
    this.signal = signal;
    this.deferred = Promise.withResolvers();
    this.onAbort = this.onAbort.bind(this);
    (_a27 = this.signal) == null ? void 0 : _a27.addEventListener("abort", this.onAbort);
  }
  onAbort() {
    var _a27;
    this.deferred.reject(((_a27 = this.signal) == null ? void 0 : _a27.reason) ?? new AbortError4());
  }
  cleanup() {
    var _a27;
    (_a27 = this.signal) == null ? void 0 : _a27.removeEventListener("abort", this.onAbort);
  }
};

// node_modules/it-queue/dist/src/job.js
function randomId() {
  return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
}
var Job = class {
  constructor(fn, options) {
    __publicField(this, "id");
    __publicField(this, "fn");
    __publicField(this, "options");
    __publicField(this, "recipients");
    __publicField(this, "status");
    __publicField(this, "timeline");
    __publicField(this, "controller");
    this.id = randomId();
    this.status = "queued";
    this.fn = fn;
    this.options = options;
    this.recipients = [];
    this.timeline = {
      created: Date.now()
    };
    this.controller = new AbortController();
    setMaxListeners(Infinity, this.controller.signal);
    this.onAbort = this.onAbort.bind(this);
  }
  abort(err) {
    this.controller.abort(err);
  }
  onAbort() {
    const allAborted = this.recipients.reduce((acc, curr) => {
      var _a27;
      return acc && ((_a27 = curr.signal) == null ? void 0 : _a27.aborted) === true;
    }, true);
    if (allAborted) {
      this.controller.abort(new AbortError4());
      this.cleanup();
    }
  }
  async join(options = {}) {
    var _a27;
    const recipient = new JobRecipient(options.signal);
    this.recipients.push(recipient);
    (_a27 = options.signal) == null ? void 0 : _a27.addEventListener("abort", this.onAbort);
    return recipient.deferred.promise;
  }
  async run() {
    this.status = "running";
    this.timeline.started = Date.now();
    try {
      this.controller.signal.throwIfAborted();
      const result = await raceSignal4(this.fn({
        ...this.options ?? {},
        signal: this.controller.signal
      }), this.controller.signal);
      this.recipients.forEach((recipient) => {
        recipient.deferred.resolve(result);
      });
      this.status = "complete";
    } catch (err) {
      this.recipients.forEach((recipient) => {
        recipient.deferred.reject(err);
      });
      this.status = "errored";
    } finally {
      this.timeline.finished = Date.now();
      this.cleanup();
    }
  }
  cleanup() {
    this.recipients.forEach((recipient) => {
      var _a27;
      recipient.cleanup();
      (_a27 = recipient.signal) == null ? void 0 : _a27.removeEventListener("abort", this.onAbort);
    });
  }
};

// node_modules/it-queue/dist/src/utils.js
function debounce3(func2, wait2) {
  let timeout2;
  const output = function() {
    const later = function() {
      timeout2 = void 0;
      void func2();
    };
    clearTimeout(timeout2);
    timeout2 = setTimeout(later, wait2);
  };
  output.start = () => {
  };
  output.stop = () => {
    clearTimeout(timeout2);
  };
  return output;
}

// node_modules/it-queue/dist/src/index.js
var Queue = class extends TypedEventEmitter {
  constructor(init = {}) {
    super();
    __publicField(this, "concurrency");
    __publicField(this, "maxSize");
    __publicField(this, "queue");
    __publicField(this, "pending");
    __publicField(this, "sort");
    __publicField(this, "autoStart");
    this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;
    this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY;
    this.pending = 0;
    this.autoStart = init.autoStart ?? true;
    this.sort = init.sort;
    this.queue = [];
    this.emitEmpty = debounce3(this.emitEmpty.bind(this), 1);
    this.emitIdle = debounce3(this.emitIdle.bind(this), 1);
  }
  [Symbol.asyncIterator]() {
    return this.toGenerator();
  }
  emitEmpty() {
    if (this.size !== 0) {
      return;
    }
    this.safeDispatchEvent("empty");
  }
  emitIdle() {
    if (this.running !== 0) {
      return;
    }
    this.safeDispatchEvent("idle");
  }
  tryToStartAnother() {
    if (this.size === 0) {
      this.emitEmpty();
      if (this.running === 0) {
        this.emitIdle();
      }
      return false;
    }
    if (this.pending < this.concurrency) {
      let job;
      for (const j of this.queue) {
        if (j.status === "queued") {
          job = j;
          break;
        }
      }
      if (job == null) {
        return false;
      }
      this.safeDispatchEvent("active");
      this.pending++;
      void job.run().finally(() => {
        for (let i2 = 0; i2 < this.queue.length; i2++) {
          if (this.queue[i2] === job) {
            this.queue.splice(i2, 1);
            break;
          }
        }
        this.pending--;
        this.safeDispatchEvent("next");
        if (this.autoStart) {
          this.tryToStartAnother();
        }
      });
      return true;
    }
    return false;
  }
  enqueue(job) {
    this.queue.push(job);
    if (this.sort != null) {
      this.queue.sort(this.sort);
    }
  }
  /**
   * Start the queue. If the `autoStart` parameter passed to the constructor was
   * not `false` this is a no-op
   */
  start() {
    if (this.autoStart !== false) {
      return;
    }
    this.autoStart = true;
    this.tryToStartAnother();
  }
  /**
   * Prevent further jobs from running - call `.start` to start the queue again
   */
  pause() {
    this.autoStart = false;
  }
  /**
   * Adds a sync or async task to the queue. Always returns a promise.
   */
  async add(fn, options) {
    var _a27;
    (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
    if (this.size === this.maxSize) {
      throw new QueueFullError2();
    }
    const job = new Job(fn, options);
    this.enqueue(job);
    this.safeDispatchEvent("add");
    if (this.autoStart) {
      this.tryToStartAnother();
    }
    return job.join(options).then((result) => {
      this.safeDispatchEvent("success", { detail: { job, result } });
      return result;
    }).catch((err) => {
      if (job.status === "queued") {
        for (let i2 = 0; i2 < this.queue.length; i2++) {
          if (this.queue[i2] === job) {
            this.queue.splice(i2, 1);
            break;
          }
        }
      }
      this.safeDispatchEvent("failure", { detail: { job, error: err } });
      throw err;
    });
  }
  /**
   * Clear the queue
   */
  clear() {
    this.queue.splice(0, this.queue.length);
  }
  /**
   * Abort all jobs in the queue and clear it
   */
  abort() {
    this.queue.forEach((job) => {
      job.abort(new AbortError4());
    });
    this.clear();
  }
  /**
   * Can be called multiple times. Useful if you for example add additional items at a later time.
   *
   * @returns A promise that settles when the queue becomes empty.
   */
  async onEmpty(options) {
    if (this.size === 0) {
      return;
    }
    await raceEvent(this, "empty", options == null ? void 0 : options.signal);
  }
  /**
   * @returns A promise that settles when the queue size is less than the given
   * limit: `queue.size < limit`.
   *
   * If you want to avoid having the queue grow beyond a certain size you can
   * `await queue.onSizeLessThan()` before adding a new item.
   *
   * Note that this only limits the number of items waiting to start. There
   * could still be up to `concurrency` jobs already running that this call does
   * not include in its calculation.
   */
  async onSizeLessThan(limit, options) {
    if (this.size < limit) {
      return;
    }
    await raceEvent(this, "next", options == null ? void 0 : options.signal, {
      filter: () => this.size < limit
    });
  }
  /**
   * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
   * from the queue has finished. `.onEmpty` merely signals that the queue is
   * empty, but it could mean that some promises haven't completed yet.
   *
   * @returns A promise that settles when the queue becomes empty, and all
   * promises have completed; `queue.size === 0 && queue.pending === 0`.
   */
  async onIdle(options) {
    if (this.pending === 0 && this.size === 0) {
      return;
    }
    await raceEvent(this, "idle", options == null ? void 0 : options.signal);
  }
  /**
   * Size of the queue including running items
   */
  get size() {
    return this.queue.length;
  }
  /**
   * The number of queued items waiting to run.
   */
  get queued() {
    return this.queue.length - this.pending;
  }
  /**
   * The number of items currently running.
   */
  get running() {
    return this.pending;
  }
  /**
   * Returns an async generator that makes it easy to iterate over the results
   * of jobs added to the queue.
   *
   * The generator will end when the queue becomes idle, that is there are no
   * jobs running and no jobs that have yet to run.
   *
   * If you need to keep the queue open indefinitely, consider using it-pushable
   * instead.
   */
  async *toGenerator(options) {
    var _a27, _b14, _c3;
    (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
    const stream = pushable({
      objectMode: true
    });
    const cleanup = (err) => {
      if (err != null) {
        this.abort();
      } else {
        this.clear();
      }
      stream.end(err);
    };
    const onQueueJobComplete = (evt) => {
      if (evt.detail != null) {
        stream.push(evt.detail.result);
      }
    };
    const onQueueError = (evt) => {
      cleanup(evt.detail.error);
    };
    const onQueueIdle = () => {
      cleanup();
    };
    const onSignalAbort = () => {
      cleanup(new AbortError4("Queue aborted"));
    };
    this.addEventListener("success", onQueueJobComplete);
    this.addEventListener("failure", onQueueError);
    this.addEventListener("idle", onQueueIdle);
    (_b14 = options == null ? void 0 : options.signal) == null ? void 0 : _b14.addEventListener("abort", onSignalAbort);
    try {
      yield* stream;
    } finally {
      this.removeEventListener("success", onQueueJobComplete);
      this.removeEventListener("failure", onQueueError);
      this.removeEventListener("idle", onQueueIdle);
      (_c3 = options == null ? void 0 : options.signal) == null ? void 0 : _c3.removeEventListener("abort", onSignalAbort);
      cleanup();
    }
  }
};

// node_modules/mortice/dist/src/constants.js
var WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
var WORKER_ABORT_READ_LOCK_REQUEST = "lock:worker:abort-read-request";
var WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
var MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
var MASTER_READ_LOCK_ERROR = "lock:master:error-read";
var WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
var WORKER_ABORT_WRITE_LOCK_REQUEST = "lock:worker:abort-write-request";
var WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
var MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";
var MASTER_WRITE_LOCK_ERROR = "lock:master:error-write";
var WORKER_FINALIZE = "lock:worker:finalize";
var BROADCAST_CHANNEL_NAME = "mortice";
var defaultOptions = {
  singleProcess: false
};

// node_modules/mortice/dist/src/main/channel.js
var handleChannelWorkerLockRequest = (emitter, channel, masterEvent, abortMasterEvent, requestType, abortType, errorType, releaseType, grantType) => {
  return (event) => {
    if (event.data == null) {
      return;
    }
    const requestEvent = {
      type: event.data.type,
      name: event.data.name,
      identifier: event.data.identifier
    };
    if (requestEvent.type === requestType) {
      emitter.safeDispatchEvent(masterEvent, {
        detail: {
          name: requestEvent.name,
          identifier: requestEvent.identifier,
          handler: async () => {
            channel.postMessage({
              type: grantType,
              name: requestEvent.name,
              identifier: requestEvent.identifier
            });
            await new Promise((resolve) => {
              const releaseEventListener = (event2) => {
                if ((event2 == null ? void 0 : event2.data) == null) {
                  return;
                }
                const releaseEvent = {
                  type: event2.data.type,
                  name: event2.data.name,
                  identifier: event2.data.identifier
                };
                if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                  channel.removeEventListener("message", releaseEventListener);
                  resolve();
                }
              };
              channel.addEventListener("message", releaseEventListener);
            });
          },
          onError: (err) => {
            channel.postMessage({
              type: errorType,
              name: requestEvent.name,
              identifier: requestEvent.identifier,
              error: {
                message: err.message,
                name: err.name,
                stack: err.stack
              }
            });
          }
        }
      });
    }
    if (requestEvent.type === abortType) {
      emitter.safeDispatchEvent(abortMasterEvent, {
        detail: {
          name: requestEvent.name,
          identifier: requestEvent.identifier
        }
      });
    }
    if (requestEvent.type === WORKER_FINALIZE) {
      emitter.safeDispatchEvent("finalizeRequest", {
        detail: {
          name: requestEvent.name
        }
      });
    }
  };
};

// node_modules/mortice/dist/src/utils.js
var nanoid = (size = 10) => {
  return Math.random().toString().substring(2, size + 2);
};

// node_modules/mortice/dist/src/workers/channel.js
var MorticeChannelWorker = class {
  constructor(name3) {
    __publicField(this, "name");
    __publicField(this, "channel");
    this.name = name3;
    this.channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);
  }
  readLock(options) {
    return this.sendRequest(WORKER_REQUEST_READ_LOCK, WORKER_ABORT_READ_LOCK_REQUEST, MASTER_GRANT_READ_LOCK, MASTER_READ_LOCK_ERROR, WORKER_RELEASE_READ_LOCK, options);
  }
  writeLock(options) {
    return this.sendRequest(WORKER_REQUEST_WRITE_LOCK, WORKER_ABORT_WRITE_LOCK_REQUEST, MASTER_GRANT_WRITE_LOCK, MASTER_WRITE_LOCK_ERROR, WORKER_RELEASE_WRITE_LOCK, options);
  }
  finalize() {
    this.channel.postMessage({
      type: WORKER_FINALIZE,
      name: this.name
    });
    this.channel.close();
  }
  async sendRequest(requestType, abortType, grantType, errorType, releaseType, options) {
    var _a27;
    (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
    const id = nanoid();
    this.channel.postMessage({
      type: requestType,
      identifier: id,
      name: this.name
    });
    return new Promise((resolve, reject) => {
      var _a28;
      const abortListener = () => {
        this.channel.postMessage({
          type: abortType,
          identifier: id,
          name: this.name
        });
      };
      (_a28 = options == null ? void 0 : options.signal) == null ? void 0 : _a28.addEventListener("abort", abortListener, {
        once: true
      });
      const listener = (event) => {
        var _a29, _b14, _c3, _d2;
        if (((_a29 = event.data) == null ? void 0 : _a29.identifier) !== id) {
          return;
        }
        if (((_b14 = event.data) == null ? void 0 : _b14.type) === grantType) {
          this.channel.removeEventListener("message", listener);
          (_c3 = options == null ? void 0 : options.signal) == null ? void 0 : _c3.removeEventListener("abort", abortListener);
          resolve(() => {
            this.channel.postMessage({
              type: releaseType,
              identifier: id,
              name: this.name
            });
          });
        }
        if (event.data.type === errorType) {
          this.channel.removeEventListener("message", listener);
          (_d2 = options == null ? void 0 : options.signal) == null ? void 0 : _d2.removeEventListener("abort", abortListener);
          const err = new Error();
          if (event.data.error != null) {
            err.message = event.data.error.message;
            err.name = event.data.error.name;
            err.stack = event.data.error.stack;
          }
          reject(err);
        }
      };
      this.channel.addEventListener("message", listener);
    });
  }
};

// node_modules/mortice/dist/src/browser.js
var browser_default2 = (options) => {
  options = Object.assign({}, defaultOptions, options);
  const isPrimary = Boolean(globalThis.document) || options.singleProcess;
  if (isPrimary) {
    const channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);
    const emitter = new TypedEventEmitter();
    channel.addEventListener("message", handleChannelWorkerLockRequest(emitter, channel, "requestReadLock", "abortReadLockRequest", WORKER_REQUEST_READ_LOCK, WORKER_ABORT_READ_LOCK_REQUEST, MASTER_READ_LOCK_ERROR, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
    channel.addEventListener("message", handleChannelWorkerLockRequest(emitter, channel, "requestWriteLock", "abortWriteLockRequest", WORKER_REQUEST_WRITE_LOCK, WORKER_ABORT_WRITE_LOCK_REQUEST, MASTER_WRITE_LOCK_ERROR, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
    return emitter;
  }
  return new MorticeChannelWorker(options.name);
};

// node_modules/mortice/dist/src/mortice.js
var mutexes = /* @__PURE__ */ new Map();
var implementation;
function isMortice(obj) {
  return typeof (obj == null ? void 0 : obj.readLock) === "function" && typeof (obj == null ? void 0 : obj.writeLock) === "function";
}
function getImplementation(opts) {
  if (implementation == null) {
    implementation = browser_default2(opts);
    if (!isMortice(implementation)) {
      const emitter = implementation;
      emitter.addEventListener("requestReadLock", (event) => {
        const mutexName = event.detail.name;
        const identifier = event.detail.identifier;
        const mutex = mutexes.get(mutexName);
        if (mutex == null) {
          return;
        }
        const abortController = new AbortController();
        const abortListener = (event2) => {
          if (event2.detail.name !== mutexName || event2.detail.identifier !== identifier) {
            return;
          }
          abortController.abort();
        };
        emitter.addEventListener("abortReadLockRequest", abortListener);
        void mutex.readLock({
          signal: abortController.signal
        }).then(async (release) => {
          await event.detail.handler().finally(() => {
            release();
          });
        }).catch((err) => {
          event.detail.onError(err);
        }).finally(() => {
          emitter.removeEventListener("abortReadLockRequest", abortListener);
        });
      });
      emitter.addEventListener("requestWriteLock", (event) => {
        const mutexName = event.detail.name;
        const identifier = event.detail.identifier;
        const mutex = mutexes.get(mutexName);
        if (mutex == null) {
          return;
        }
        const abortController = new AbortController();
        const abortListener = (event2) => {
          if (event2.detail.name !== mutexName || event2.detail.identifier !== identifier) {
            return;
          }
          abortController.abort();
        };
        emitter.addEventListener("abortWriteLockRequest", abortListener);
        void mutex.writeLock({
          signal: abortController.signal
        }).then(async (release) => {
          await event.detail.handler().finally(() => {
            release();
          });
        }).catch((err) => {
          event.detail.onError(err);
        }).finally(() => {
          emitter.removeEventListener("abortWriteLockRequest", abortListener);
        });
      });
      emitter.addEventListener("finalizeRequest", (event) => {
        const mutexName = event.detail.name;
        const mutex = mutexes.get(mutexName);
        if (mutex == null) {
          return;
        }
        mutex.finalize();
      });
    }
  }
  return implementation;
}
async function createReleasable(queue, options) {
  var _a27;
  let res;
  let rej;
  const p2 = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  const listener = () => {
    rej(new AbortError4());
  };
  (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.addEventListener("abort", listener, {
    once: true
  });
  queue.add(async () => {
    await new Promise((resolve) => {
      res(() => {
        var _a28;
        (_a28 = options == null ? void 0 : options.signal) == null ? void 0 : _a28.removeEventListener("abort", listener);
        resolve();
      });
    });
  }, {
    signal: options == null ? void 0 : options.signal
  }).catch((err) => {
    rej(err);
  });
  return p2;
}
var createMutex = (name3, options) => {
  let mutex = mutexes.get(name3);
  if (mutex != null) {
    return mutex;
  }
  const implementation2 = getImplementation(options);
  if (isMortice(implementation2)) {
    mutex = implementation2;
    mutexes.set(name3, mutex);
    return mutex;
  }
  const masterQueue = new Queue({
    concurrency: 1
  });
  let readQueue;
  mutex = {
    async readLock(opts) {
      if (readQueue != null) {
        return createReleasable(readQueue, opts);
      }
      readQueue = new Queue({
        concurrency: options.concurrency,
        autoStart: false
      });
      const localReadQueue = readQueue;
      const readPromise = createReleasable(readQueue, opts);
      void masterQueue.add(async () => {
        localReadQueue.start();
        await localReadQueue.onIdle().then(() => {
          if (readQueue === localReadQueue) {
            readQueue = null;
          }
        });
      });
      return readPromise;
    },
    async writeLock(opts) {
      readQueue = null;
      return createReleasable(masterQueue, opts);
    },
    finalize: () => {
      mutexes.delete(name3);
    },
    queue: masterQueue
  };
  mutexes.set(name3, mutex);
  if (options.autoFinalize === true) {
    masterQueue.addEventListener("idle", () => {
      mutex.finalize();
    }, {
      once: true
    });
  }
  return mutex;
};

// node_modules/mortice/dist/src/index.js
var defaultOptions2 = {
  name: "lock",
  concurrency: Infinity,
  singleProcess: false,
  autoFinalize: false
};
function createMortice(options) {
  const opts = Object.assign({}, defaultOptions2, options);
  return createMutex(opts.name, opts);
}

// node_modules/@libp2p/peer-store/dist/src/constants.js
var MAX_ADDRESS_AGE = 36e5;
var MAX_PEER_AGE = 216e5;

// node_modules/@libp2p/peer-store/dist/src/pb/peer.js
var Peer;
(function(Peer2) {
  let Peer$metadataEntry;
  (function(Peer$metadataEntry2) {
    let _codec2;
    Peer$metadataEntry2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.key != null && obj.key !== "") {
            w.uint32(10);
            w.string(obj.key);
          }
          if (obj.value != null && obj.value.byteLength > 0) {
            w.uint32(18);
            w.bytes(obj.value);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length3, opts = {}) => {
          const obj = {
            key: "",
            value: alloc(0)
          };
          const end = length3 == null ? reader.len : reader.pos + length3;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.key = reader.string();
                break;
              }
              case 2: {
                obj.value = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer$metadataEntry2.encode = (obj) => {
      return encodeMessage(obj, Peer$metadataEntry2.codec());
    };
    Peer$metadataEntry2.decode = (buf, opts) => {
      return decodeMessage(buf, Peer$metadataEntry2.codec(), opts);
    };
  })(Peer$metadataEntry = Peer2.Peer$metadataEntry || (Peer2.Peer$metadataEntry = {}));
  let Peer$tagsEntry;
  (function(Peer$tagsEntry2) {
    let _codec2;
    Peer$tagsEntry2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.key != null && obj.key !== "") {
            w.uint32(10);
            w.string(obj.key);
          }
          if (obj.value != null) {
            w.uint32(18);
            Tag.codec().encode(obj.value, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length3, opts = {}) => {
          var _a27;
          const obj = {
            key: ""
          };
          const end = length3 == null ? reader.len : reader.pos + length3;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.key = reader.string();
                break;
              }
              case 2: {
                obj.value = Tag.codec().decode(reader, reader.uint32(), {
                  limits: (_a27 = opts.limits) == null ? void 0 : _a27.value
                });
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer$tagsEntry2.encode = (obj) => {
      return encodeMessage(obj, Peer$tagsEntry2.codec());
    };
    Peer$tagsEntry2.decode = (buf, opts) => {
      return decodeMessage(buf, Peer$tagsEntry2.codec(), opts);
    };
  })(Peer$tagsEntry = Peer2.Peer$tagsEntry || (Peer2.Peer$tagsEntry = {}));
  let _codec;
  Peer2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.addresses != null) {
          for (const value of obj.addresses) {
            w.uint32(10);
            Address.codec().encode(value, w);
          }
        }
        if (obj.protocols != null) {
          for (const value of obj.protocols) {
            w.uint32(18);
            w.string(value);
          }
        }
        if (obj.publicKey != null) {
          w.uint32(34);
          w.bytes(obj.publicKey);
        }
        if (obj.peerRecordEnvelope != null) {
          w.uint32(42);
          w.bytes(obj.peerRecordEnvelope);
        }
        if (obj.metadata != null && obj.metadata.size !== 0) {
          for (const [key, value] of obj.metadata.entries()) {
            w.uint32(50);
            Peer2.Peer$metadataEntry.codec().encode({ key, value }, w);
          }
        }
        if (obj.tags != null && obj.tags.size !== 0) {
          for (const [key, value] of obj.tags.entries()) {
            w.uint32(58);
            Peer2.Peer$tagsEntry.codec().encode({ key, value }, w);
          }
        }
        if (obj.updated != null) {
          w.uint32(64);
          w.uint64Number(obj.updated);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        var _a27, _b14, _c3, _d2, _e, _f;
        const obj = {
          addresses: [],
          protocols: [],
          metadata: /* @__PURE__ */ new Map(),
          tags: /* @__PURE__ */ new Map()
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (((_a27 = opts.limits) == null ? void 0 : _a27.addresses) != null && obj.addresses.length === opts.limits.addresses) {
                throw new MaxLengthError('Decode error - map field "addresses" had too many elements');
              }
              obj.addresses.push(Address.codec().decode(reader, reader.uint32(), {
                limits: (_b14 = opts.limits) == null ? void 0 : _b14.addresses$
              }));
              break;
            }
            case 2: {
              if (((_c3 = opts.limits) == null ? void 0 : _c3.protocols) != null && obj.protocols.length === opts.limits.protocols) {
                throw new MaxLengthError('Decode error - map field "protocols" had too many elements');
              }
              obj.protocols.push(reader.string());
              break;
            }
            case 4: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 5: {
              obj.peerRecordEnvelope = reader.bytes();
              break;
            }
            case 6: {
              if (((_d2 = opts.limits) == null ? void 0 : _d2.metadata) != null && obj.metadata.size === opts.limits.metadata) {
                throw new MaxSizeError('Decode error - map field "metadata" had too many elements');
              }
              const entry = Peer2.Peer$metadataEntry.codec().decode(reader, reader.uint32());
              obj.metadata.set(entry.key, entry.value);
              break;
            }
            case 7: {
              if (((_e = opts.limits) == null ? void 0 : _e.tags) != null && obj.tags.size === opts.limits.tags) {
                throw new MaxSizeError('Decode error - map field "tags" had too many elements');
              }
              const entry = Peer2.Peer$tagsEntry.codec().decode(reader, reader.uint32(), {
                limits: {
                  value: (_f = opts.limits) == null ? void 0 : _f.tags$value
                }
              });
              obj.tags.set(entry.key, entry.value);
              break;
            }
            case 8: {
              obj.updated = reader.uint64Number();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer2.encode = (obj) => {
    return encodeMessage(obj, Peer2.codec());
  };
  Peer2.decode = (buf, opts) => {
    return decodeMessage(buf, Peer2.codec(), opts);
  };
})(Peer || (Peer = {}));
var Address;
(function(Address2) {
  let _codec;
  Address2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.multiaddr);
        }
        if (obj.isCertified != null) {
          w.uint32(16);
          w.bool(obj.isCertified);
        }
        if (obj.observed != null) {
          w.uint32(24);
          w.uint64Number(obj.observed);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          multiaddr: alloc(0)
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.multiaddr = reader.bytes();
              break;
            }
            case 2: {
              obj.isCertified = reader.bool();
              break;
            }
            case 3: {
              obj.observed = reader.uint64Number();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Address2.encode = (obj) => {
    return encodeMessage(obj, Address2.codec());
  };
  Address2.decode = (buf, opts) => {
    return decodeMessage(buf, Address2.codec(), opts);
  };
})(Address || (Address = {}));
var Tag;
(function(Tag2) {
  let _codec;
  Tag2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.value != null && obj.value !== 0) {
          w.uint32(8);
          w.uint32(obj.value);
        }
        if (obj.expiry != null) {
          w.uint32(16);
          w.uint64(obj.expiry);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          value: 0
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.value = reader.uint32();
              break;
            }
            case 2: {
              obj.expiry = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Tag2.encode = (obj) => {
    return encodeMessage(obj, Tag2.codec());
  };
  Tag2.decode = (buf, opts) => {
    return decodeMessage(buf, Tag2.codec(), opts);
  };
})(Tag || (Tag = {}));

// node_modules/@libp2p/peer-store/dist/src/utils/bytes-to-peer.js
function populatePublicKey(peerId2, protobuf) {
  if (peerId2.publicKey != null || protobuf.publicKey == null) {
    return peerId2;
  }
  let digest2;
  if (peerId2.type === "RSA") {
    digest2 = peerId2.toMultihash();
  }
  const publicKey = publicKeyFromProtobuf(protobuf.publicKey, digest2);
  return peerIdFromPublicKey(publicKey);
}
function bytesToPeer(peerId2, buf, maxAddressAge) {
  const peer = Peer.decode(buf);
  return pbToPeer(peerId2, peer, maxAddressAge);
}
function pbToPeer(peerId2, peer, maxAddressAge) {
  const tags = /* @__PURE__ */ new Map();
  const now = BigInt(Date.now());
  for (const [key, tag] of peer.tags.entries()) {
    if (tag.expiry != null && tag.expiry < now) {
      continue;
    }
    tags.set(key, tag);
  }
  return {
    ...peer,
    id: populatePublicKey(peerId2, peer),
    addresses: peer.addresses.filter(({ observed }) => observed != null && observed > Date.now() - maxAddressAge).map(({ multiaddr: ma, isCertified }) => {
      return {
        multiaddr: multiaddr(ma),
        isCertified: isCertified ?? false
      };
    }),
    metadata: peer.metadata,
    peerRecordEnvelope: peer.peerRecordEnvelope ?? void 0,
    tags
  };
}

// node_modules/@libp2p/peer-store/dist/src/utils/peer-equals.js
function peerEquals(peerA, peerB) {
  return addressesEqual(peerA.addresses, peerB.addresses) && protocolsEqual(peerA.protocols, peerB.protocols) && publicKeyEqual(peerA.publicKey, peerB.publicKey) && peerRecordEnvelope(peerA.peerRecordEnvelope, peerB.peerRecordEnvelope) && metadataEqual(peerA.metadata, peerB.metadata) && tagsEqual(peerA.tags, peerB.tags);
}
function addressesEqual(addressesA, addressesB) {
  return compareArrays(addressesA, addressesB, (a2, b) => {
    if (a2.isCertified !== b.isCertified) {
      return false;
    }
    if (!equals3(a2.multiaddr, b.multiaddr)) {
      return false;
    }
    return true;
  });
}
function protocolsEqual(protocolsA, protocolsB) {
  return compareArrays(protocolsA, protocolsB, (a2, b) => a2 === b);
}
function publicKeyEqual(publicKeyA, publicKeyB) {
  return compareOptionalUint8Arrays(publicKeyA, publicKeyB);
}
function peerRecordEnvelope(envelopeA, envelopeB) {
  return compareOptionalUint8Arrays(envelopeA, envelopeB);
}
function metadataEqual(metadataA, metadataB) {
  return compareMaps(metadataA, metadataB, (a2, b) => equals3(a2, b));
}
function tagsEqual(metadataA, metadataB) {
  return compareMaps(metadataA, metadataB, (a2, b) => a2.value === b.value && a2.expiry === b.expiry);
}
function compareOptionalUint8Arrays(arrA, arrB) {
  if (arrA == null && arrB == null) {
    return true;
  }
  if (arrA != null && arrB != null) {
    return equals3(arrA, arrB);
  }
  return false;
}
function compareArrays(arrA, arrB, compare2) {
  if (arrA.length !== arrB.length) {
    return false;
  }
  for (let i2 = 0; i2 < arrA.length; i2++) {
    if (!compare2(arrA[i2], arrB[i2])) {
      return false;
    }
  }
  return true;
}
function compareMaps(mapA, mapB, compare2) {
  if (mapA.size !== mapB.size) {
    return false;
  }
  for (const [key, value] of mapA.entries()) {
    const valueB = mapB.get(key);
    if (valueB == null) {
      return false;
    }
    if (!compare2(value, valueB)) {
      return false;
    }
  }
  return true;
}

// node_modules/interface-datastore/dist/src/key.js
var pathSepS = "/";
var pathSepB = new TextEncoder().encode(pathSepS);
var pathSep = pathSepB[0];
var Key = class _Key {
  /**
   * @param {string | Uint8Array} s
   * @param {boolean} [clean]
   */
  constructor(s2, clean4) {
    __publicField(this, "_buf");
    if (typeof s2 === "string") {
      this._buf = fromString2(s2);
    } else if (s2 instanceof Uint8Array) {
      this._buf = s2;
    } else {
      throw new Error("Invalid key, should be String of Uint8Array");
    }
    if (clean4 == null) {
      clean4 = true;
    }
    if (clean4) {
      this.clean();
    }
    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
      throw new Error("Invalid key");
    }
  }
  /**
   * Convert to the string representation
   *
   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding] - The encoding to use.
   * @returns {string}
   */
  toString(encoding = "utf8") {
    return toString2(this._buf, encoding);
  }
  /**
   * Return the Uint8Array representation of the key
   *
   * @returns {Uint8Array}
   */
  uint8Array() {
    return this._buf;
  }
  /**
   * Return string representation of the key
   *
   * @returns {string}
   */
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  /**
   * Constructs a key out of a namespace array.
   *
   * @param {Array<string>} list - The array of namespaces
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.withNamespaces(['one', 'two'])
   * // => Key('/one/two')
   * ```
   */
  static withNamespaces(list) {
    return new _Key(list.join(pathSepS));
  }
  /**
   * Returns a randomly (uuid) generated key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.random()
   * // => Key('/344502982398')
   * ```
   */
  static random() {
    return new _Key(Math.random().toString().substring(2));
  }
  /**
   * @param {*} other
   */
  static asKey(other) {
    if (other instanceof Uint8Array || typeof other === "string") {
      return new _Key(other);
    }
    if (typeof other.uint8Array === "function") {
      return new _Key(other.uint8Array());
    }
    return null;
  }
  /**
   * Cleanup the current key
   *
   * @returns {void}
   */
  clean() {
    if (this._buf == null || this._buf.byteLength === 0) {
      this._buf = pathSepB;
    }
    if (this._buf[0] !== pathSep) {
      const bytes = new Uint8Array(this._buf.byteLength + 1);
      bytes.fill(pathSep, 0, 1);
      bytes.set(this._buf, 1);
      this._buf = bytes;
    }
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
      this._buf = this._buf.subarray(0, -1);
    }
  }
  /**
   * Check if the given key is sorted lower than ourself.
   *
   * @param {Key} key - The other Key to check against
   * @returns {boolean}
   */
  less(key) {
    const list1 = this.list();
    const list2 = key.list();
    for (let i2 = 0; i2 < list1.length; i2++) {
      if (list2.length < i2 + 1) {
        return false;
      }
      const c1 = list1[i2];
      const c2 = list2[i2];
      if (c1 < c2) {
        return true;
      } else if (c1 > c2) {
        return false;
      }
    }
    return list1.length < list2.length;
  }
  /**
   * Returns the key with all parts in reversed order.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
   * ```
   */
  reverse() {
    return _Key.withNamespaces(this.list().slice().reverse());
  }
  /**
   * Returns the `namespaces` making up this Key.
   *
   * @returns {Array<string>}
   */
  namespaces() {
    return this.list();
  }
  /**
   * Returns the "base" namespace of this key.
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
   * // => 'Actor:JohnCleese'
   * ```
   */
  baseNamespace() {
    const ns = this.namespaces();
    return ns[ns.length - 1];
  }
  /**
   * Returns the `list` representation of this key.
   *
   * @returns {Array<string>}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
   * ```
   */
  list() {
    return this.toString().split(pathSepS).slice(1);
  }
  /**
   * Returns the "type" of this key (value of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
   * // => 'Actor'
   * ```
   */
  type() {
    return namespaceType(this.baseNamespace());
  }
  /**
   * Returns the "name" of this key (field of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
   * // => 'JohnCleese'
   * ```
   */
  name() {
    return namespaceValue(this.baseNamespace());
  }
  /**
   * Returns an "instance" of this type key (appends value to namespace).
   *
   * @param {string} s - The string to append.
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  instance(s2) {
    return new _Key(this.toString() + ":" + s2);
  }
  /**
   * Returns the "path" of this key (parent + type).
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
   * // => Key('/Comedy/MontyPython/Actor')
   * ```
   */
  path() {
    let p2 = this.parent().toString();
    if (!p2.endsWith(pathSepS)) {
      p2 += pathSepS;
    }
    p2 += this.type();
    return new _Key(p2);
  }
  /**
   * Returns the `parent` Key of this Key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
   * // => Key("/Comedy/MontyPython")
   * ```
   */
  parent() {
    const list = this.list();
    if (list.length === 1) {
      return new _Key(pathSepS);
    }
    return new _Key(list.slice(0, -1).join(pathSepS));
  }
  /**
   * Returns the `child` Key of this Key.
   *
   * @param {Key} key - The child Key to add
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  child(key) {
    if (this.toString() === pathSepS) {
      return key;
    } else if (key.toString() === pathSepS) {
      return this;
    }
    return new _Key(this.toString() + key.toString(), false);
  }
  /**
   * Returns whether this key is a prefix of `other`
   *
   * @param {Key} other - The other key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
   * // => true
   * ```
   */
  isAncestorOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return other.toString().startsWith(this.toString());
  }
  /**
   * Returns whether this key is a contains another as prefix.
   *
   * @param {Key} other - The other Key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
   * // => true
   * ```
   */
  isDecendantOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return this.toString().startsWith(other.toString());
  }
  /**
   * Checks if this key has only one namespace.
   *
   * @returns {boolean}
   */
  isTopLevel() {
    return this.list().length === 1;
  }
  /**
   * Concats one or more Keys into one new Key.
   *
   * @param {Array<Key>} keys - The array of keys to concatenate
   * @returns {Key}
   */
  concat(...keys) {
    return _Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key) => key.namespaces()))]);
  }
};
function namespaceType(ns) {
  const parts = ns.split(":");
  if (parts.length < 2) {
    return "";
  }
  return parts.slice(0, -1).join(":");
}
function namespaceValue(ns) {
  const parts = ns.split(":");
  return parts[parts.length - 1];
}
function flatten(arr) {
  return [].concat(...arr);
}

// node_modules/@libp2p/peer-store/dist/src/utils/peer-id-to-datastore-key.js
var NAMESPACE_COMMON = "/peers/";
function peerIdToDatastoreKey(peerId2) {
  if (!isPeerId(peerId2) || peerId2.type == null) {
    throw new InvalidParametersError("Invalid PeerId");
  }
  const b32key = peerId2.toCID().toString();
  return new Key(`${NAMESPACE_COMMON}${b32key}`);
}

// node_modules/@libp2p/peer-store/dist/src/utils/dedupe-addresses.js
async function dedupeFilterAndSortAddresses(peerId2, filter2, addresses, existingAddresses, options) {
  const addressMap = /* @__PURE__ */ new Map();
  for (const addr of addresses) {
    if (addr == null) {
      continue;
    }
    if (addr.multiaddr instanceof Uint8Array) {
      addr.multiaddr = multiaddr(addr.multiaddr);
    }
    if (!isMultiaddr(addr.multiaddr)) {
      throw new InvalidParametersError("Multiaddr was invalid");
    }
    if (!await filter2(peerId2, addr.multiaddr, options)) {
      continue;
    }
    const isCertified = addr.isCertified ?? false;
    const maStr = addr.multiaddr.toString();
    const existingAddr = addressMap.get(maStr);
    if (existingAddr != null) {
      addr.isCertified = existingAddr.isCertified || isCertified;
    } else {
      addressMap.set(maStr, {
        multiaddr: addr.multiaddr,
        isCertified
      });
    }
  }
  return [...addressMap.values()].sort((a2, b) => {
    return a2.multiaddr.toString().localeCompare(b.multiaddr.toString());
  }).map(({ isCertified, multiaddr: ma }) => {
    const addrPeer = ma.getPeerId();
    if (peerId2.equals(addrPeer)) {
      ma = ma.decapsulate(multiaddr(`/p2p/${peerId2}`));
    }
    return {
      isCertified,
      multiaddr: ma.bytes
    };
  });
}

// node_modules/@libp2p/peer-store/dist/src/utils/to-peer-pb.js
async function toPeerPB(peerId2, data, strategy, options) {
  var _a27, _b14;
  if (data == null) {
    throw new InvalidParametersError("Invalid PeerData");
  }
  if (data.publicKey != null && peerId2.publicKey != null && !data.publicKey.equals(peerId2.publicKey)) {
    throw new InvalidParametersError("publicKey bytes do not match peer id publicKey bytes");
  }
  const existingPeer = (_a27 = options.existingPeer) == null ? void 0 : _a27.peer;
  if (existingPeer != null && !peerId2.equals(existingPeer.id)) {
    throw new InvalidParametersError("peer id did not match existing peer id");
  }
  let addresses = (existingPeer == null ? void 0 : existingPeer.addresses) ?? [];
  let protocols2 = new Set((existingPeer == null ? void 0 : existingPeer.protocols) ?? []);
  let metadata = (existingPeer == null ? void 0 : existingPeer.metadata) ?? /* @__PURE__ */ new Map();
  let tags = (existingPeer == null ? void 0 : existingPeer.tags) ?? /* @__PURE__ */ new Map();
  let peerRecordEnvelope2 = existingPeer == null ? void 0 : existingPeer.peerRecordEnvelope;
  if (strategy === "patch") {
    if (data.multiaddrs != null || data.addresses != null) {
      addresses = [];
      if (data.multiaddrs != null) {
        addresses.push(...data.multiaddrs.map((multiaddr2) => ({
          isCertified: false,
          multiaddr: multiaddr2
        })));
      }
      if (data.addresses != null) {
        addresses.push(...data.addresses);
      }
    }
    if (data.protocols != null) {
      protocols2 = new Set(data.protocols);
    }
    if (data.metadata != null) {
      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
      metadata = createSortedMap(metadataEntries, {
        validate: validateMetadata
      });
    }
    if (data.tags != null) {
      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
      tags = createSortedMap(tagsEntries, {
        validate: validateTag,
        map: mapTag
      });
    }
    if (data.peerRecordEnvelope != null) {
      peerRecordEnvelope2 = data.peerRecordEnvelope;
    }
  }
  if (strategy === "merge") {
    if (data.multiaddrs != null) {
      addresses.push(...data.multiaddrs.map((multiaddr2) => ({
        isCertified: false,
        multiaddr: multiaddr2
      })));
    }
    if (data.addresses != null) {
      addresses.push(...data.addresses);
    }
    if (data.protocols != null) {
      protocols2 = /* @__PURE__ */ new Set([...protocols2, ...data.protocols]);
    }
    if (data.metadata != null) {
      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
      for (const [key, value] of metadataEntries) {
        if (value == null) {
          metadata.delete(key);
        } else {
          metadata.set(key, value);
        }
      }
      metadata = createSortedMap([...metadata.entries()], {
        validate: validateMetadata
      });
    }
    if (data.tags != null) {
      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
      const mergedTags = new Map(tags);
      for (const [key, value] of tagsEntries) {
        if (value == null) {
          mergedTags.delete(key);
        } else {
          mergedTags.set(key, value);
        }
      }
      tags = createSortedMap([...mergedTags.entries()], {
        validate: validateTag,
        map: mapTag
      });
    }
    if (data.peerRecordEnvelope != null) {
      peerRecordEnvelope2 = data.peerRecordEnvelope;
    }
  }
  let publicKey;
  if ((existingPeer == null ? void 0 : existingPeer.id.publicKey) != null) {
    publicKey = publicKeyToProtobuf(existingPeer.id.publicKey);
  } else if (data.publicKey != null) {
    publicKey = publicKeyToProtobuf(data.publicKey);
  } else if (peerId2.publicKey != null) {
    publicKey = publicKeyToProtobuf(peerId2.publicKey);
  }
  const output = {
    addresses: await dedupeFilterAndSortAddresses(peerId2, options.addressFilter ?? (async () => true), addresses, (_b14 = options.existingPeer) == null ? void 0 : _b14.peerPB.addresses, options),
    protocols: [...protocols2.values()].sort((a2, b) => {
      return a2.localeCompare(b);
    }),
    metadata,
    tags,
    publicKey,
    peerRecordEnvelope: peerRecordEnvelope2
  };
  output.addresses.forEach((addr) => {
    var _a28, _b15, _c3;
    addr.observed = ((_c3 = (_b15 = (_a28 = options.existingPeer) == null ? void 0 : _a28.peerPB.addresses) == null ? void 0 : _b15.find((addr2) => equals3(addr2.multiaddr, addr2.multiaddr))) == null ? void 0 : _c3.observed) ?? Date.now();
  });
  if (peerId2.type !== "RSA") {
    delete output.publicKey;
  }
  return output;
}
function createSortedMap(entries, options) {
  var _a27;
  const output = /* @__PURE__ */ new Map();
  for (const [key, value] of entries) {
    if (value == null) {
      continue;
    }
    options.validate(key, value);
  }
  for (const [key, value] of entries.sort(([a2], [b]) => {
    return a2.localeCompare(b);
  })) {
    if (value != null) {
      output.set(key, ((_a27 = options.map) == null ? void 0 : _a27.call(options, key, value)) ?? value);
    }
  }
  return output;
}
function validateMetadata(key, value) {
  if (typeof key !== "string") {
    throw new InvalidParametersError("Metadata key must be a string");
  }
  if (!(value instanceof Uint8Array)) {
    throw new InvalidParametersError("Metadata value must be a Uint8Array");
  }
}
function validateTag(key, tag) {
  if (typeof key !== "string") {
    throw new InvalidParametersError("Tag name must be a string");
  }
  if (tag.value != null) {
    if (parseInt(`${tag.value}`, 10) !== tag.value) {
      throw new InvalidParametersError("Tag value must be an integer");
    }
    if (tag.value < 0 || tag.value > 100) {
      throw new InvalidParametersError("Tag value must be between 0-100");
    }
  }
  if (tag.ttl != null) {
    if (parseInt(`${tag.ttl}`, 10) !== tag.ttl) {
      throw new InvalidParametersError("Tag ttl must be an integer");
    }
    if (tag.ttl < 0) {
      throw new InvalidParametersError("Tag ttl must be between greater than 0");
    }
  }
}
function mapTag(key, tag) {
  let expiry;
  if (tag.expiry != null) {
    expiry = tag.expiry;
  }
  if (tag.ttl != null) {
    expiry = BigInt(Date.now() + Number(tag.ttl));
  }
  const output = {
    value: tag.value ?? 0
  };
  if (expiry != null) {
    output.expiry = expiry;
  }
  return output;
}

// node_modules/@libp2p/peer-store/dist/src/store.js
function keyToPeerId(key) {
  const base32Str = key.toString().split("/")[2];
  const buf = CID.parse(base32Str, base32);
  return peerIdFromCID(buf);
}
function decodePeer(key, value, maxAddressAge) {
  const peerId2 = keyToPeerId(key);
  return bytesToPeer(peerId2, value, maxAddressAge);
}
function mapQuery(query, maxAddressAge) {
  return {
    prefix: NAMESPACE_COMMON,
    filters: (query.filters ?? []).map((fn) => ({ key, value }) => {
      return fn(decodePeer(key, value, maxAddressAge));
    }),
    orders: (query.orders ?? []).map((fn) => (a2, b) => {
      return fn(decodePeer(a2.key, a2.value, maxAddressAge), decodePeer(b.key, b.value, maxAddressAge));
    })
  };
}
var _PersistentStore_instances, findExistingPeer_fn, saveIfDifferent_fn, peerIsExpired_fn;
var PersistentStore = class {
  constructor(components, init = {}) {
    __privateAdd(this, _PersistentStore_instances);
    __publicField(this, "peerId");
    __publicField(this, "datastore");
    __publicField(this, "locks");
    __publicField(this, "addressFilter");
    __publicField(this, "log");
    __publicField(this, "maxAddressAge");
    __publicField(this, "maxPeerAge");
    this.log = components.logger.forComponent("libp2p:peer-store");
    this.peerId = components.peerId;
    this.datastore = components.datastore;
    this.addressFilter = init.addressFilter;
    this.locks = trackedPeerMap({
      name: "libp2p_peer_store_locks",
      metrics: components.metrics
    });
    this.maxAddressAge = init.maxAddressAge ?? MAX_ADDRESS_AGE;
    this.maxPeerAge = init.maxPeerAge ?? MAX_PEER_AGE;
  }
  getLock(peerId2) {
    let lock = this.locks.get(peerId2);
    if (lock == null) {
      lock = {
        refs: 0,
        lock: createMortice({
          name: peerId2.toString(),
          singleProcess: true
        })
      };
      this.locks.set(peerId2, lock);
    }
    lock.refs++;
    return lock;
  }
  maybeRemoveLock(peerId2, lock) {
    lock.refs--;
    if (lock.refs === 0) {
      lock.lock.finalize();
      this.locks.delete(peerId2);
    }
  }
  async getReadLock(peerId2, options) {
    const lock = this.getLock(peerId2);
    try {
      const release = await lock.lock.readLock(options);
      return () => {
        release();
        this.maybeRemoveLock(peerId2, lock);
      };
    } catch (err) {
      this.maybeRemoveLock(peerId2, lock);
      throw err;
    }
  }
  async getWriteLock(peerId2, options) {
    const lock = this.getLock(peerId2);
    try {
      const release = await lock.lock.writeLock(options);
      return () => {
        release();
        this.maybeRemoveLock(peerId2, lock);
      };
    } catch (err) {
      this.maybeRemoveLock(peerId2, lock);
      throw err;
    }
  }
  async has(peerId2, options) {
    try {
      await this.load(peerId2, options);
      return true;
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    return false;
  }
  async delete(peerId2, options) {
    if (this.peerId.equals(peerId2)) {
      return;
    }
    await this.datastore.delete(peerIdToDatastoreKey(peerId2), options);
  }
  async load(peerId2, options) {
    const key = peerIdToDatastoreKey(peerId2);
    const buf = await this.datastore.get(key, options);
    const peer = Peer.decode(buf);
    if (__privateMethod(this, _PersistentStore_instances, peerIsExpired_fn).call(this, peerId2, peer)) {
      await this.datastore.delete(key, options);
      throw new NotFoundError();
    }
    return pbToPeer(peerId2, peer, this.peerId.equals(peerId2) ? Infinity : this.maxAddressAge);
  }
  async save(peerId2, data, options) {
    const existingPeer = await __privateMethod(this, _PersistentStore_instances, findExistingPeer_fn).call(this, peerId2, options);
    const peerPb = await toPeerPB(peerId2, data, "patch", {
      ...options,
      addressFilter: this.addressFilter
    });
    return __privateMethod(this, _PersistentStore_instances, saveIfDifferent_fn).call(this, peerId2, peerPb, existingPeer);
  }
  async patch(peerId2, data, options) {
    const existingPeer = await __privateMethod(this, _PersistentStore_instances, findExistingPeer_fn).call(this, peerId2, options);
    const peerPb = await toPeerPB(peerId2, data, "patch", {
      ...options,
      addressFilter: this.addressFilter,
      existingPeer
    });
    return __privateMethod(this, _PersistentStore_instances, saveIfDifferent_fn).call(this, peerId2, peerPb, existingPeer);
  }
  async merge(peerId2, data, options) {
    const existingPeer = await __privateMethod(this, _PersistentStore_instances, findExistingPeer_fn).call(this, peerId2, options);
    const peerPb = await toPeerPB(peerId2, data, "merge", {
      addressFilter: this.addressFilter,
      existingPeer
    });
    return __privateMethod(this, _PersistentStore_instances, saveIfDifferent_fn).call(this, peerId2, peerPb, existingPeer);
  }
  async *all(options) {
    for await (const { key, value } of this.datastore.query(mapQuery(options ?? {}, this.maxAddressAge), options)) {
      const peerId2 = keyToPeerId(key);
      if (peerId2.equals(this.peerId)) {
        continue;
      }
      const peer = Peer.decode(value);
      if (__privateMethod(this, _PersistentStore_instances, peerIsExpired_fn).call(this, peerId2, peer)) {
        await this.datastore.delete(key, options);
        continue;
      }
      yield pbToPeer(peerId2, peer, this.peerId.equals(peerId2) ? Infinity : this.maxAddressAge);
    }
  }
};
_PersistentStore_instances = new WeakSet();
findExistingPeer_fn = async function(peerId2, options) {
  try {
    const key = peerIdToDatastoreKey(peerId2);
    const buf = await this.datastore.get(key, options);
    const peerPB = Peer.decode(buf);
    if (__privateMethod(this, _PersistentStore_instances, peerIsExpired_fn).call(this, peerId2, peerPB)) {
      await this.datastore.delete(key, options);
      throw new NotFoundError();
    }
    return {
      peerPB,
      peer: pbToPeer(peerId2, peerPB, this.maxAddressAge)
    };
  } catch (err) {
    if (err.name !== "NotFoundError") {
      this.log.error("invalid peer data found in peer store - %e", err);
    }
  }
};
saveIfDifferent_fn = async function(peerId2, peer, existingPeer, options) {
  peer.updated = Date.now();
  const buf = Peer.encode(peer);
  await this.datastore.put(peerIdToDatastoreKey(peerId2), buf, options);
  return {
    peer: pbToPeer(peerId2, peer, this.maxAddressAge),
    previous: existingPeer == null ? void 0 : existingPeer.peer,
    updated: existingPeer == null || !peerEquals(peer, existingPeer.peerPB)
  };
};
peerIsExpired_fn = function(peerId2, peer) {
  if (peer.updated == null) {
    return true;
  }
  if (this.peerId.equals(peerId2)) {
    return false;
  }
  const expired = peer.updated < Date.now() - this.maxPeerAge;
  const minAddressObserved = Date.now() - this.maxAddressAge;
  const addrs = peer.addresses.filter((addr) => {
    return addr.observed != null && addr.observed > minAddressObserved;
  });
  return expired && addrs.length === 0;
};

// node_modules/@libp2p/peer-store/dist/src/index.js
var _a14, _PersistentPeerStore_instances, emitIfUpdated_fn;
_a14 = Symbol.toStringTag;
var PersistentPeerStore = class {
  constructor(components, init = {}) {
    __privateAdd(this, _PersistentPeerStore_instances);
    __publicField(this, "store");
    __publicField(this, "events");
    __publicField(this, "peerId");
    __publicField(this, "log");
    __publicField(this, _a14, "@libp2p/peer-store");
    this.log = components.logger.forComponent("libp2p:peer-store");
    this.events = components.events;
    this.peerId = components.peerId;
    this.store = new PersistentStore(components, init);
  }
  async forEach(fn, query) {
    for await (const peer of this.store.all(query)) {
      fn(peer);
    }
  }
  async all(query) {
    return src_default(this.store.all(query));
  }
  async delete(peerId2, options) {
    const release = await this.store.getReadLock(peerId2, options);
    try {
      await this.store.delete(peerId2, options);
    } finally {
      release();
    }
  }
  async has(peerId2, options) {
    const release = await this.store.getReadLock(peerId2, options);
    try {
      return await this.store.has(peerId2, options);
    } finally {
      this.log.trace("has release read lock");
      release == null ? void 0 : release();
    }
  }
  async get(peerId2, options) {
    const release = await this.store.getReadLock(peerId2, options);
    try {
      return await this.store.load(peerId2, options);
    } finally {
      release == null ? void 0 : release();
    }
  }
  async getInfo(peerId2, options) {
    const peer = await this.get(peerId2, options);
    return {
      id: peer.id,
      multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
    };
  }
  async save(id, data, options) {
    const release = await this.store.getWriteLock(id, options);
    try {
      const result = await this.store.save(id, data, options);
      __privateMethod(this, _PersistentPeerStore_instances, emitIfUpdated_fn).call(this, id, result);
      return result.peer;
    } finally {
      release == null ? void 0 : release();
    }
  }
  async patch(id, data, options) {
    const release = await this.store.getWriteLock(id, options);
    try {
      const result = await this.store.patch(id, data, options);
      __privateMethod(this, _PersistentPeerStore_instances, emitIfUpdated_fn).call(this, id, result);
      return result.peer;
    } finally {
      release == null ? void 0 : release();
    }
  }
  async merge(id, data, options) {
    const release = await this.store.getWriteLock(id, options);
    try {
      const result = await this.store.merge(id, data, options);
      __privateMethod(this, _PersistentPeerStore_instances, emitIfUpdated_fn).call(this, id, result);
      return result.peer;
    } finally {
      release == null ? void 0 : release();
    }
  }
  async consumePeerRecord(buf, arg1, arg2) {
    const expectedPeer = isPeerId(arg1) ? arg1 : isPeerId(arg1 == null ? void 0 : arg1.expectedPeer) ? arg1.expectedPeer : void 0;
    const options = isPeerId(arg1) ? arg2 : arg1 === void 0 ? arg2 : arg1;
    const envelope = await RecordEnvelope.openAndCertify(buf, PeerRecord2.DOMAIN, options);
    const peerId2 = peerIdFromCID(envelope.publicKey.toCID());
    if ((expectedPeer == null ? void 0 : expectedPeer.equals(peerId2)) === false) {
      this.log("envelope peer id was not the expected peer id - expected: %p received: %p", expectedPeer, peerId2);
      return false;
    }
    const peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
    let peer;
    try {
      peer = await this.get(peerId2, options);
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    if ((peer == null ? void 0 : peer.peerRecordEnvelope) != null) {
      const storedEnvelope = RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);
      const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
      if (storedRecord.seqNumber >= peerRecord.seqNumber) {
        this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
        return false;
      }
    }
    await this.patch(peerRecord.peerId, {
      peerRecordEnvelope: buf,
      addresses: peerRecord.multiaddrs.map((multiaddr2) => ({
        isCertified: true,
        multiaddr: multiaddr2
      }))
    }, options);
    return true;
  }
};
_PersistentPeerStore_instances = new WeakSet();
emitIfUpdated_fn = function(id, result) {
  if (!result.updated) {
    return;
  }
  if (this.peerId.equals(id)) {
    this.events.safeDispatchEvent("self:peer:update", { detail: result });
  } else {
    this.events.safeDispatchEvent("peer:update", { detail: result });
  }
};
function persistentPeerStore(components, init = {}) {
  return new PersistentPeerStore(components, init);
}

// node_modules/interface-store/dist/src/errors.js
var _NotFoundError = class _NotFoundError extends Error {
  constructor(message2 = "Not Found") {
    super(message2);
    __publicField(this, "name", _NotFoundError.name);
    __publicField(this, "code", _NotFoundError.code);
  }
};
__publicField(_NotFoundError, "name", "NotFoundError");
__publicField(_NotFoundError, "code", "ERR_NOT_FOUND");
var NotFoundError2 = _NotFoundError;

// node_modules/it-peekable/dist/src/index.js
function peekable(iterable) {
  const [iterator, symbol3] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
  const queue = [];
  return {
    peek: () => {
      return iterator.next();
    },
    push: (value) => {
      queue.push(value);
    },
    next: () => {
      if (queue.length > 0) {
        return {
          done: false,
          value: queue.shift()
        };
      }
      return iterator.next();
    },
    [symbol3]() {
      return this;
    }
  };
}
var src_default5 = peekable;

// node_modules/it-filter/dist/src/index.js
function isAsyncIterable7(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function filter(source, fn) {
  let index = 0;
  if (isAsyncIterable7(source)) {
    return async function* () {
      for await (const entry of source) {
        if (await fn(entry, index++)) {
          yield entry;
        }
      }
    }();
  }
  const peekable2 = src_default5(source);
  const { value, done } = peekable2.next();
  if (done === true) {
    return function* () {
    }();
  }
  const res = fn(value, index++);
  if (typeof res.then === "function") {
    return async function* () {
      if (await res) {
        yield value;
      }
      for (const entry of peekable2) {
        if (await fn(entry, index++)) {
          yield entry;
        }
      }
    }();
  }
  const func2 = fn;
  return function* () {
    if (res === true) {
      yield value;
    }
    for (const entry of peekable2) {
      if (func2(entry, index++)) {
        yield entry;
      }
    }
  }();
}
var src_default6 = filter;

// node_modules/it-sort/dist/src/index.js
function isAsyncIterable8(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function sort(source, sorter) {
  if (isAsyncIterable8(source)) {
    return async function* () {
      const arr = await src_default(source);
      yield* arr.sort(sorter);
    }();
  }
  return function* () {
    const arr = src_default(source);
    yield* arr.sort(sorter);
  }();
}
var src_default7 = sort;

// node_modules/it-take/dist/src/index.js
function isAsyncIterable9(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function take(source, limit) {
  if (isAsyncIterable9(source)) {
    return async function* () {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for await (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    }();
  }
  return function* () {
    let items = 0;
    if (limit < 1) {
      return;
    }
    for (const entry of source) {
      yield entry;
      items++;
      if (items === limit) {
        return;
      }
    }
  }();
}
var src_default8 = take;

// node_modules/datastore-core/dist/src/base.js
var BaseDatastore = class {
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options);
      yield key;
    }
  }
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield {
        key,
        value: await this.get(key, options)
      };
    }
  }
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({ key, value });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await src_default3(this.putMany(puts, options));
        puts = [];
        await src_default3(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  /**
   * Extending classes should override `query` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  /**
   * Extending classes should override `queryKeys` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = src_default6(it, (e2) => e2.key.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f3) => src_default6(it2, f3), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f3) => src_default7(it2, f3), it);
    }
    if (q.offset != null) {
      let i2 = 0;
      const offset = q.offset;
      it = src_default6(it, () => i2++ >= offset);
    }
    if (q.limit != null) {
      it = src_default8(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = src_default6(it, (key) => key.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f3) => src_default6(it2, f3), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f3) => src_default7(it2, f3), it);
    }
    if (q.offset != null) {
      const offset = q.offset;
      let i2 = 0;
      it = src_default6(it, () => i2++ >= offset);
    }
    if (q.limit != null) {
      it = src_default8(it, q.limit);
    }
    return it;
  }
};

// node_modules/datastore-core/dist/src/memory.js
var MemoryDatastore = class extends BaseDatastore {
  constructor() {
    super();
    __publicField(this, "data");
    this.data = /* @__PURE__ */ new Map();
  }
  put(key, val, options) {
    var _a27;
    (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
    this.data.set(key.toString(), val);
    return key;
  }
  get(key, options) {
    var _a27;
    (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
    const result = this.data.get(key.toString());
    if (result == null) {
      throw new NotFoundError2();
    }
    return result;
  }
  has(key, options) {
    var _a27;
    (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
    return this.data.has(key.toString());
  }
  delete(key, options) {
    var _a27;
    (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
    this.data.delete(key.toString());
  }
  *_all(q, options) {
    var _a27, _b14;
    (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
    for (const [key, value] of this.data.entries()) {
      yield { key: new Key(key), value };
      (_b14 = options == null ? void 0 : options.signal) == null ? void 0 : _b14.throwIfAborted();
    }
  }
  *_allKeys(q, options) {
    var _a27, _b14;
    (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
    for (const key of this.data.keys()) {
      yield new Key(key);
      (_b14 = options == null ? void 0 : options.signal) == null ? void 0 : _b14.throwIfAborted();
    }
  }
};

// node_modules/@libp2p/utils/dist/src/tracked-map.js
var TrackedMap = class extends Map {
  constructor(init) {
    super();
    __publicField(this, "metric");
    const { name: name3, metrics } = init;
    this.metric = metrics.registerMetric(name3);
    this.updateComponentMetric();
  }
  set(key, value) {
    super.set(key, value);
    this.updateComponentMetric();
    return this;
  }
  delete(key) {
    const deleted = super.delete(key);
    this.updateComponentMetric();
    return deleted;
  }
  clear() {
    super.clear();
    this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metric.update(this.size);
  }
};
function trackedMap(config) {
  const { name: name3, metrics } = config;
  let map2;
  if (metrics != null) {
    map2 = new TrackedMap({ name: name3, metrics });
  } else {
    map2 = /* @__PURE__ */ new Map();
  }
  return map2;
}

// node_modules/libp2p/dist/src/address-manager/dns-mappings.js
var MAX_DATE = 864e13;
var CODEC_TLS = 448;
var CODEC_SNI = 449;
var CODEC_DNS = 53;
var CODEC_DNS4 = 54;
var CODEC_DNS6 = 55;
var CODEC_DNSADDR = 56;
var DNSMappings = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "mappings");
    this.log = components.logger.forComponent("libp2p:address-manager:dns-mappings");
    this.mappings = trackedMap({
      name: "libp2p_address_manager_dns_mappings",
      metrics: components.metrics
    });
  }
  has(ma) {
    const host = this.findHost(ma);
    for (const mapping of this.mappings.values()) {
      if (mapping.domain === host) {
        return true;
      }
    }
    return false;
  }
  add(domain, addresses) {
    addresses.forEach((ip) => {
      this.log("add DNS mapping %s to %s", ip, domain);
      const verified = isPrivateIp(ip) === true;
      this.mappings.set(ip, {
        domain,
        verified,
        expires: verified ? MAX_DATE - Date.now() : 0,
        lastVerified: verified ? MAX_DATE - Date.now() : void 0
      });
    });
  }
  remove(ma) {
    const host = this.findHost(ma);
    let wasConfident = false;
    for (const [ip, mapping] of this.mappings.entries()) {
      if (mapping.domain === host) {
        this.log("removing %s to %s DNS mapping %e", ip, mapping.domain, new Error("where"));
        this.mappings.delete(ip);
        wasConfident = wasConfident || mapping.verified;
      }
    }
    return wasConfident;
  }
  getAll(addresses) {
    const dnsMappedAddresses = [];
    for (let i2 = 0; i2 < addresses.length; i2++) {
      const address = addresses[i2];
      const tuples = address.multiaddr.stringTuples();
      const host = tuples[0][1];
      if (host == null) {
        continue;
      }
      for (const [ip, mapping] of this.mappings.entries()) {
        if (host !== ip) {
          continue;
        }
        const mappedIp = this.maybeAddSNITuple(tuples, mapping.domain);
        if (mappedIp) {
          addresses.splice(i2, 1);
          i2--;
          dnsMappedAddresses.push({
            multiaddr: multiaddr(`/${tuples.map((tuple) => {
              return [
                protocols(tuple[0]).name,
                tuple[1]
              ].join("/");
            }).join("/")}`),
            verified: mapping.verified,
            type: "dns-mapping",
            expires: mapping.expires,
            lastVerified: mapping.lastVerified
          });
        }
      }
    }
    return dnsMappedAddresses;
  }
  maybeAddSNITuple(tuples, domain) {
    var _a27;
    for (let j = 0; j < tuples.length; j++) {
      if (tuples[j][0] === CODEC_TLS && ((_a27 = tuples[j + 1]) == null ? void 0 : _a27[0]) !== CODEC_SNI) {
        tuples.splice(j + 1, 0, [CODEC_SNI, domain]);
        return true;
      }
    }
    return false;
  }
  confirm(ma, ttl) {
    const host = this.findHost(ma);
    let startingConfidence = false;
    for (const [ip, mapping] of this.mappings.entries()) {
      if (mapping.domain === host) {
        this.log("marking %s to %s DNS mapping as verified", ip, mapping.domain);
        startingConfidence = mapping.verified;
        mapping.verified = true;
        mapping.expires = Date.now() + ttl;
        mapping.lastVerified = Date.now();
      }
    }
    return startingConfidence;
  }
  unconfirm(ma, ttl) {
    const host = this.findHost(ma);
    let wasConfident = false;
    for (const [ip, mapping] of this.mappings.entries()) {
      if (mapping.domain === host) {
        this.log("removing verification of %s to %s DNS mapping", ip, mapping.domain);
        wasConfident = wasConfident || mapping.verified;
        mapping.verified = false;
        mapping.expires = Date.now() + ttl;
      }
    }
    return wasConfident;
  }
  findHost(ma) {
    for (const tuple of ma.stringTuples()) {
      if (tuple[0] === CODEC_SNI) {
        return tuple[1];
      }
      if (tuple[0] === CODEC_DNS || tuple[0] === CODEC_DNS4 || tuple[0] === CODEC_DNS6 || tuple[0] === CODEC_DNSADDR) {
        return tuple[1];
      }
    }
  }
};

// node_modules/libp2p/dist/src/address-manager/ip-mappings.js
var CODEC_IP4 = 4;
var CODEC_IP6 = 41;
var CODEC_TCP = 6;
var CODEC_UDP = 273;
var IPMappings = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "mappings");
    this.log = components.logger.forComponent("libp2p:address-manager:ip-mappings");
    this.mappings = trackedMap({
      name: "libp2p_address_manager_ip_mappings",
      metrics: components.metrics
    });
  }
  has(ma) {
    const tuples = ma.stringTuples();
    for (const mappings of this.mappings.values()) {
      for (const mapping of mappings) {
        if (mapping.externalIp === tuples[0][1]) {
          return true;
        }
      }
    }
    return false;
  }
  add(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
    const key = `${internalIp}-${internalPort}-${protocol}`;
    const mappings = this.mappings.get(key) ?? [];
    const mapping = {
      internalIp,
      internalPort,
      externalIp,
      externalPort,
      externalFamily: isIPv4(externalIp) ? 4 : 6,
      protocol,
      verified: false,
      expires: 0
    };
    mappings.push(mapping);
    this.mappings.set(key, mappings);
  }
  remove(ma) {
    const tuples = ma.stringTuples();
    const host = tuples[0][1] ?? "";
    const protocol = tuples[1][0] === CODEC_TCP ? "tcp" : "udp";
    const port = parseInt(tuples[1][1] ?? "0");
    let wasConfident = false;
    for (const [key, mappings] of this.mappings.entries()) {
      for (let i2 = 0; i2 < mappings.length; i2++) {
        const mapping = mappings[i2];
        if (mapping.externalIp === host && mapping.externalPort === port && mapping.protocol === protocol) {
          this.log("removing %s:%s to %s:%s %s IP mapping", mapping.externalIp, mapping.externalPort, host, port, protocol);
          wasConfident = wasConfident || mapping.verified;
          mappings.splice(i2, 1);
          i2--;
        }
      }
      if (mappings.length === 0) {
        this.mappings.delete(key);
      }
    }
    return wasConfident;
  }
  getAll(addresses) {
    const ipMappedAddresses = [];
    for (const { multiaddr: ma } of addresses) {
      const tuples = ma.stringTuples();
      let tuple;
      if ((tuples[0][0] === CODEC_IP4 || tuples[0][0] === CODEC_IP6) && tuples[1][0] === CODEC_TCP) {
        tuple = `${tuples[0][1]}-${tuples[1][1]}-tcp`;
      } else if ((tuples[0][0] === CODEC_IP4 || tuples[0][0] === CODEC_IP6) && tuples[1][0] === CODEC_UDP) {
        tuple = `${tuples[0][1]}-${tuples[1][1]}-udp`;
      }
      if (tuple == null) {
        continue;
      }
      const mappings = this.mappings.get(tuple);
      if (mappings == null) {
        continue;
      }
      for (const mapping of mappings) {
        tuples[0][0] = mapping.externalFamily === 4 ? CODEC_IP4 : CODEC_IP6;
        tuples[0][1] = mapping.externalIp;
        tuples[1][1] = `${mapping.externalPort}`;
        ipMappedAddresses.push({
          multiaddr: multiaddr(`/${tuples.map((tuple2) => {
            return [
              protocols(tuple2[0]).name,
              tuple2[1]
            ].join("/");
          }).join("/")}`),
          verified: mapping.verified,
          type: "ip-mapping",
          expires: mapping.expires,
          lastVerified: mapping.lastVerified
        });
      }
    }
    return ipMappedAddresses;
  }
  confirm(ma, ttl) {
    const tuples = ma.stringTuples();
    const host = tuples[0][1];
    let startingConfidence = false;
    for (const mappings of this.mappings.values()) {
      for (const mapping of mappings) {
        if (mapping.externalIp === host) {
          this.log("marking %s to %s IP mapping as verified", mapping.internalIp, mapping.externalIp);
          startingConfidence = mapping.verified;
          mapping.verified = true;
          mapping.expires = Date.now() + ttl;
          mapping.lastVerified = Date.now();
        }
      }
    }
    return startingConfidence;
  }
  unconfirm(ma, ttl) {
    const tuples = ma.stringTuples();
    const host = tuples[0][1] ?? "";
    const protocol = tuples[1][0] === CODEC_TCP ? "tcp" : "udp";
    const port = parseInt(tuples[1][1] ?? "0");
    let wasConfident = false;
    for (const mappings of this.mappings.values()) {
      for (let i2 = 0; i2 < mappings.length; i2++) {
        const mapping = mappings[i2];
        if (mapping.externalIp === host && mapping.externalPort === port && mapping.protocol === protocol) {
          this.log("removing verification of %s:%s to %s:%s %s IP mapping", mapping.externalIp, mapping.externalPort, host, port, protocol);
          wasConfident = wasConfident || mapping.verified;
          mapping.verified = false;
          mapping.expires = Date.now() + ttl;
        }
      }
    }
    return wasConfident;
  }
};

// node_modules/@libp2p/utils/dist/src/multiaddr/is-link-local.js
function isLinkLocal(ma) {
  try {
    for (const { code: code2, value } of ma.getComponents()) {
      if (code2 === CODE_IP6ZONE) {
        continue;
      }
      if (value == null) {
        continue;
      }
      if (code2 === CODE_IP4) {
        return value.startsWith("169.254.");
      }
      if (code2 === CODE_IP6) {
        return value.toLowerCase().startsWith("fe80");
      }
    }
  } catch {
  }
  return false;
}

// node_modules/libp2p/dist/src/address-manager/observed-addresses.js
var defaultValues2 = {
  maxObservedAddresses: 10
};
var ObservedAddresses = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "addresses");
    __publicField(this, "maxObservedAddresses");
    this.log = components.logger.forComponent("libp2p:address-manager:observed-addresses");
    this.addresses = trackedMap({
      name: "libp2p_address_manager_observed_addresses",
      metrics: components.metrics
    });
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues2.maxObservedAddresses;
  }
  has(ma) {
    return this.addresses.has(ma.toString());
  }
  removePrefixed(prefix) {
    for (const key of this.addresses.keys()) {
      if (key.toString().startsWith(prefix)) {
        this.addresses.delete(key);
      }
    }
  }
  add(ma) {
    if (this.addresses.size === this.maxObservedAddresses) {
      return;
    }
    if (isPrivate(ma) || isLinkLocal(ma)) {
      return;
    }
    this.log("adding observed address %a", ma);
    this.addresses.set(ma.toString(), {
      verified: false,
      expires: 0
    });
  }
  getAll() {
    return Array.from(this.addresses).map(([ma, metadata]) => ({
      multiaddr: multiaddr(ma),
      verified: metadata.verified,
      type: "observed",
      expires: metadata.expires,
      lastVerified: metadata.lastVerified
    }));
  }
  remove(ma) {
    var _a27;
    const startingConfidence = ((_a27 = this.addresses.get(ma.toString())) == null ? void 0 : _a27.verified) ?? false;
    this.log("removing observed address %a", ma);
    this.addresses.delete(ma.toString());
    return startingConfidence;
  }
  confirm(ma, ttl) {
    const addrString = ma.toString();
    const metadata = this.addresses.get(addrString) ?? {
      verified: false,
      expires: Date.now() + ttl,
      lastVerified: Date.now()
    };
    const startingConfidence = metadata.verified;
    metadata.verified = true;
    metadata.expires = Date.now() + ttl;
    metadata.lastVerified = Date.now();
    this.log("marking observed address %a as verified", addrString);
    this.addresses.set(addrString, metadata);
    return startingConfidence;
  }
};

// node_modules/@libp2p/utils/dist/src/multiaddr/is-network-address.js
var NETWORK_CODECS = [
  CODE_IP4,
  CODE_IP6,
  CODE_DNS,
  CODE_DNS4,
  CODE_DNS6,
  CODE_DNSADDR
];
function isNetworkAddress(ma) {
  try {
    for (const { code: code2 } of ma.getComponents()) {
      if (code2 === CODE_IP6ZONE) {
        continue;
      }
      return NETWORK_CODECS.includes(code2);
    }
  } catch {
  }
  return false;
}

// node_modules/libp2p/dist/src/address-manager/transport-addresses.js
var defaultValues3 = {
  maxObservedAddresses: 10
};
var TransportAddresses = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "addresses");
    __publicField(this, "maxObservedAddresses");
    this.log = components.logger.forComponent("libp2p:address-manager:observed-addresses");
    this.addresses = trackedMap({
      name: "libp2p_address_manager_transport_addresses",
      metrics: components.metrics
    });
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues3.maxObservedAddresses;
  }
  get(multiaddr2, ttl) {
    if (isPrivate(multiaddr2)) {
      return {
        multiaddr: multiaddr2,
        verified: true,
        type: "transport",
        expires: Date.now() + ttl,
        lastVerified: Date.now()
      };
    }
    const key = this.toKey(multiaddr2);
    let metadata = this.addresses.get(key);
    if (metadata == null) {
      metadata = {
        verified: !isNetworkAddress(multiaddr2),
        expires: 0
      };
      this.addresses.set(key, metadata);
    }
    return {
      multiaddr: multiaddr2,
      verified: metadata.verified,
      type: "transport",
      expires: metadata.expires,
      lastVerified: metadata.lastVerified
    };
  }
  has(ma) {
    const key = this.toKey(ma);
    return this.addresses.has(key);
  }
  remove(ma) {
    var _a27;
    const key = this.toKey(ma);
    const startingConfidence = ((_a27 = this.addresses.get(key)) == null ? void 0 : _a27.verified) ?? false;
    this.log("removing observed address %a", ma);
    this.addresses.delete(key);
    return startingConfidence;
  }
  confirm(ma, ttl) {
    const key = this.toKey(ma);
    const metadata = this.addresses.get(key) ?? {
      verified: false,
      expires: 0,
      lastVerified: 0
    };
    const startingConfidence = metadata.verified;
    metadata.verified = true;
    metadata.expires = Date.now() + ttl;
    metadata.lastVerified = Date.now();
    this.addresses.set(key, metadata);
    return startingConfidence;
  }
  unconfirm(ma, ttl) {
    const key = this.toKey(ma);
    const metadata = this.addresses.get(key) ?? {
      verified: false,
      expires: 0
    };
    const startingConfidence = metadata.verified;
    metadata.verified = false;
    metadata.expires = Date.now() + ttl;
    this.addresses.set(key, metadata);
    return startingConfidence;
  }
  toKey(ma) {
    if (isNetworkAddress(ma)) {
      const options = ma.toOptions();
      return `${options.host}-${options.port}-${options.transport}`;
    }
    return ma.toString();
  }
};

// node_modules/libp2p/dist/src/address-manager/index.js
var ONE_MINUTE = 6e4;
var defaultValues4 = {
  maxObservedAddresses: 10,
  addressVerificationTTL: ONE_MINUTE * 10,
  addressVerificationRetry: ONE_MINUTE * 5
};
var defaultAddressFilter = (addrs) => addrs;
function stripPeerId(ma, peerId2) {
  const observedPeerIdStr = ma.getPeerId();
  if (observedPeerIdStr != null) {
    const observedPeerId = peerIdFromString(observedPeerIdStr);
    if (observedPeerId.equals(peerId2)) {
      ma = ma.decapsulate(multiaddr(`/p2p/${peerId2.toString()}`));
    }
  }
  return ma;
}
var _a15;
_a15 = Symbol.toStringTag;
var AddressManager = class {
  /**
   * Responsible for managing the peer addresses.
   * Peers can specify their listen and announce addresses.
   * The listen addresses will be used by the libp2p transports to listen for new connections,
   * while the announce addresses will be used for the peer addresses' to other peers in the network.
   */
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "components");
    // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`
    __publicField(this, "listen");
    __publicField(this, "announce");
    __publicField(this, "appendAnnounce");
    __publicField(this, "announceFilter");
    __publicField(this, "observed");
    __publicField(this, "dnsMappings");
    __publicField(this, "ipMappings");
    __publicField(this, "transportAddresses");
    __publicField(this, "observedAddressFilter");
    __publicField(this, "addressVerificationTTL");
    __publicField(this, "addressVerificationRetry");
    __publicField(this, _a15, "@libp2p/address-manager");
    const { listen = [], announce = [], appendAnnounce = [] } = init;
    this.components = components;
    this.log = components.logger.forComponent("libp2p:address-manager");
    this.listen = listen.map((ma) => ma.toString());
    this.announce = new Set(announce.map((ma) => ma.toString()));
    this.appendAnnounce = new Set(appendAnnounce.map((ma) => ma.toString()));
    this.observed = new ObservedAddresses(components, init);
    this.dnsMappings = new DNSMappings(components, init);
    this.ipMappings = new IPMappings(components, init);
    this.transportAddresses = new TransportAddresses(components, init);
    this.announceFilter = init.announceFilter ?? defaultAddressFilter;
    this.observedAddressFilter = createScalableCuckooFilter(1024);
    this.addressVerificationTTL = init.addressVerificationTTL ?? defaultValues4.addressVerificationTTL;
    this.addressVerificationRetry = init.addressVerificationRetry ?? defaultValues4.addressVerificationRetry;
    this._updatePeerStoreAddresses = debounce2(this._updatePeerStoreAddresses.bind(this), 1e3);
    components.events.addEventListener("transport:listening", () => {
      this._updatePeerStoreAddresses();
    });
    components.events.addEventListener("transport:close", () => {
      this._updatePeerStoreAddresses();
    });
  }
  _updatePeerStoreAddresses() {
    const addrs = this.getAddresses().map((ma) => {
      if (ma.getPeerId() === this.components.peerId.toString()) {
        return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`);
      }
      return ma;
    });
    this.components.peerStore.patch(this.components.peerId, {
      multiaddrs: addrs
    }).catch((err) => {
      this.log.error("error updating addresses", err);
    });
  }
  /**
   * Get peer listen multiaddrs
   */
  getListenAddrs() {
    return Array.from(this.listen).map((a2) => multiaddr(a2));
  }
  /**
   * Get peer announcing multiaddrs
   */
  getAnnounceAddrs() {
    return Array.from(this.announce).map((a2) => multiaddr(a2));
  }
  /**
   * Get peer announcing multiaddrs
   */
  getAppendAnnounceAddrs() {
    return Array.from(this.appendAnnounce).map((a2) => multiaddr(a2));
  }
  /**
   * Get observed multiaddrs
   */
  getObservedAddrs() {
    return this.observed.getAll().map((addr) => addr.multiaddr);
  }
  /**
   * Add peer observed addresses
   */
  addObservedAddr(addr) {
    const tuples = addr.stringTuples();
    const socketAddress = `${tuples[0][1]}:${tuples[1][1]}`;
    if (this.observedAddressFilter.has(socketAddress)) {
      return;
    }
    this.observedAddressFilter.add(socketAddress);
    addr = stripPeerId(addr, this.components.peerId);
    if (this.ipMappings.has(addr)) {
      return;
    }
    if (this.dnsMappings.has(addr)) {
      return;
    }
    this.observed.add(addr);
  }
  confirmObservedAddr(addr, options) {
    addr = stripPeerId(addr, this.components.peerId);
    let startingConfidence = true;
    if ((options == null ? void 0 : options.type) === "transport" || this.transportAddresses.has(addr)) {
      const transportStartingConfidence = this.transportAddresses.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
      if (!transportStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if ((options == null ? void 0 : options.type) === "dns-mapping" || this.dnsMappings.has(addr)) {
      const dnsMappingStartingConfidence = this.dnsMappings.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
      if (!dnsMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if ((options == null ? void 0 : options.type) === "ip-mapping" || this.ipMappings.has(addr)) {
      const ipMappingStartingConfidence = this.ipMappings.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
      if (!ipMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if ((options == null ? void 0 : options.type) === "observed" || this.observed.has(addr)) {
      if (this.maybeUpgradeToIPMapping(addr)) {
        this.ipMappings.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
        startingConfidence = false;
      } else {
        const observedStartingConfidence = this.observed.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
        if (!observedStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
    }
    if (!startingConfidence) {
      this._updatePeerStoreAddresses();
    }
  }
  removeObservedAddr(addr, options) {
    addr = stripPeerId(addr, this.components.peerId);
    let startingConfidence = false;
    if (this.observed.has(addr)) {
      const observedStartingConfidence = this.observed.remove(addr);
      if (!observedStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (this.transportAddresses.has(addr)) {
      const transportStartingConfidence = this.transportAddresses.unconfirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationRetry);
      if (!transportStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (this.dnsMappings.has(addr)) {
      const dnsMappingStartingConfidence = this.dnsMappings.unconfirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationRetry);
      if (!dnsMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (this.ipMappings.has(addr)) {
      const ipMappingStartingConfidence = this.ipMappings.unconfirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationRetry);
      if (!ipMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (startingConfidence) {
      this._updatePeerStoreAddresses();
    }
  }
  getAddresses() {
    const addresses = /* @__PURE__ */ new Set();
    const multiaddrs = this.getAddressesWithMetadata().filter((addr) => {
      if (!addr.verified) {
        return false;
      }
      const maStr = addr.multiaddr.toString();
      if (addresses.has(maStr)) {
        return false;
      }
      addresses.add(maStr);
      return true;
    }).map((address) => address.multiaddr);
    return this.announceFilter(multiaddrs.map((str) => {
      const ma = multiaddr(str);
      const lastComponent = ma.getComponents().pop();
      if ((lastComponent == null ? void 0 : lastComponent.value) === this.components.peerId.toString()) {
        return ma;
      }
      return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`);
    }));
  }
  getAddressesWithMetadata() {
    const announceMultiaddrs = this.getAnnounceAddrs();
    if (announceMultiaddrs.length > 0) {
      this.components.transportManager.getListeners().forEach((listener) => {
        listener.updateAnnounceAddrs(announceMultiaddrs);
      });
      return announceMultiaddrs.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        verified: true,
        type: "announce",
        expires: Date.now() + this.addressVerificationTTL,
        lastVerified: Date.now()
      }));
    }
    let addresses = [];
    addresses = addresses.concat(this.components.transportManager.getAddrs().map((multiaddr2) => this.transportAddresses.get(multiaddr2, this.addressVerificationTTL)));
    const appendAnnounceMultiaddrs = this.getAppendAnnounceAddrs();
    if (appendAnnounceMultiaddrs.length > 0) {
      this.components.transportManager.getListeners().forEach((listener) => {
        listener.updateAnnounceAddrs(appendAnnounceMultiaddrs);
      });
      addresses = addresses.concat(appendAnnounceMultiaddrs.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        verified: true,
        type: "announce",
        expires: Date.now() + this.addressVerificationTTL,
        lastVerified: Date.now()
      })));
    }
    addresses = addresses.concat(this.observed.getAll());
    addresses = addresses.concat(this.ipMappings.getAll(addresses));
    addresses = addresses.concat(this.dnsMappings.getAll(addresses));
    return addresses;
  }
  addDNSMapping(domain, addresses) {
    this.dnsMappings.add(domain, addresses);
  }
  removeDNSMapping(domain) {
    if (this.dnsMappings.remove(multiaddr(`/dns/${domain}`))) {
      this._updatePeerStoreAddresses();
    }
  }
  addPublicAddressMapping(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
    this.ipMappings.add(internalIp, internalPort, externalIp, externalPort, protocol);
    this.observed.removePrefixed(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`);
  }
  removePublicAddressMapping(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
    if (this.ipMappings.remove(multiaddr(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`))) {
      this._updatePeerStoreAddresses();
    }
  }
  /**
   * Where an external service (router, gateway, etc) is forwarding traffic to
   * us, attempt to add an IP mapping for the external address - this will
   * include the observed mapping in the address list where we also have a DNS
   * mapping for the external IP.
   *
   * Returns true if we added a new mapping
   */
  maybeUpgradeToIPMapping(ma) {
    if (this.ipMappings.has(ma)) {
      return false;
    }
    const maOptions = ma.toOptions();
    if (maOptions.family === 6 || maOptions.host === "127.0.0.1" || isPrivateIp(maOptions.host) === true) {
      return false;
    }
    const listeners = this.components.transportManager.getListeners();
    const transportMatchers = [
      (ma2) => WebSockets2.exactMatch(ma2) || WebSocketsSecure2.exactMatch(ma2),
      (ma2) => TCP2.exactMatch(ma2),
      (ma2) => QUICV12.exactMatch(ma2)
    ];
    for (const matcher of transportMatchers) {
      if (!matcher(ma)) {
        continue;
      }
      const transportListeners = listeners.filter((listener) => {
        return listener.getAddrs().filter((ma2) => {
          return ma2.toOptions().family === 4 && matcher(ma2);
        }).length > 0;
      });
      if (transportListeners.length !== 1) {
        continue;
      }
      const linkLocalAddr = transportListeners[0].getAddrs().filter((ma2) => {
        return ma2.toOptions().host !== "127.0.0.1";
      }).pop();
      if (linkLocalAddr == null) {
        continue;
      }
      const linkLocalOptions = linkLocalAddr.toOptions();
      this.observed.remove(ma);
      this.ipMappings.add(linkLocalOptions.host, linkLocalOptions.port, maOptions.host, maOptions.port, maOptions.transport);
      return true;
    }
    return false;
  }
};

// node_modules/libp2p/dist/src/errors.js
var messages;
(function(messages2) {
  messages2["NOT_STARTED_YET"] = "The libp2p node is not started yet";
  messages2["NOT_FOUND"] = "Not found";
})(messages || (messages = {}));
var MissingServiceError = class extends Error {
  constructor(message2 = "Missing service") {
    super(message2);
    this.name = "MissingServiceError";
  }
};
var UnmetServiceDependenciesError = class extends Error {
  constructor(message2 = "Unmet service dependencies") {
    super(message2);
    this.name = "UnmetServiceDependenciesError";
  }
};
var NoContentRoutersError = class extends Error {
  constructor(message2 = "No content routers available") {
    super(message2);
    this.name = "NoContentRoutersError";
  }
};
var NoPeerRoutersError = class extends Error {
  constructor(message2 = "No peer routers available") {
    super(message2);
    this.name = "NoPeerRoutersError";
  }
};
var QueriedForSelfError = class extends Error {
  constructor(message2 = "Should not try to find self") {
    super(message2);
    this.name = "QueriedForSelfError";
  }
};
var UnhandledProtocolError = class extends Error {
  constructor(message2 = "Unhandled protocol error") {
    super(message2);
    this.name = "UnhandledProtocolError";
  }
};
var DuplicateProtocolHandlerError = class extends Error {
  constructor(message2 = "Duplicate protocol handler error") {
    super(message2);
    this.name = "DuplicateProtocolHandlerError";
  }
};
var DialDeniedError = class extends Error {
  constructor(message2 = "Dial denied error") {
    super(message2);
    this.name = "DialDeniedError";
  }
};
var UnsupportedListenAddressError = class extends Error {
  constructor(message2 = "No transport was configured to listen on this address") {
    super(message2);
    this.name = "UnsupportedListenAddressError";
  }
};
var UnsupportedListenAddressesError = class extends Error {
  constructor(message2 = "Configured listen addresses could not be listened on") {
    super(message2);
    this.name = "UnsupportedListenAddressesError";
  }
};
var NoValidAddressesError = class extends Error {
  constructor(message2 = "No valid addresses") {
    super(message2);
    this.name = "NoValidAddressesError";
  }
};
var ConnectionInterceptedError = class extends Error {
  constructor(message2 = "Connection intercepted") {
    super(message2);
    this.name = "ConnectionInterceptedError";
  }
};
var ConnectionDeniedError = class extends Error {
  constructor(message2 = "Connection denied") {
    super(message2);
    this.name = "ConnectionDeniedError";
  }
};
var MuxerUnavailableError = class extends Error {
  constructor(message2 = "Stream is not multiplexed") {
    super(message2);
    this.name = "MuxerUnavailableError";
  }
};
var EncryptionFailedError = class extends Error {
  constructor(message2 = "Encryption failed") {
    super(message2);
    this.name = "EncryptionFailedError";
  }
};
var TransportUnavailableError = class extends Error {
  constructor(message2 = "Transport unavailable") {
    super(message2);
    this.name = "TransportUnavailableError";
  }
};

// node_modules/libp2p/dist/src/components.js
var DefaultComponents = class {
  constructor(init = {}) {
    __publicField(this, "components", {});
    __publicField(this, "_started", false);
    this.components = {};
    for (const [key, value] of Object.entries(init)) {
      this.components[key] = value;
    }
    if (this.components.logger == null) {
      this.components.logger = defaultLogger();
    }
  }
  isStarted() {
    return this._started;
  }
  async _invokeStartableMethod(methodName) {
    await Promise.all(Object.values(this.components).filter((obj) => isStartable(obj)).map(async (startable) => {
      var _a27;
      await ((_a27 = startable[methodName]) == null ? void 0 : _a27.call(startable));
    }));
  }
  async beforeStart() {
    await this._invokeStartableMethod("beforeStart");
  }
  async start() {
    await this._invokeStartableMethod("start");
    this._started = true;
  }
  async afterStart() {
    await this._invokeStartableMethod("afterStart");
  }
  async beforeStop() {
    await this._invokeStartableMethod("beforeStop");
  }
  async stop() {
    await this._invokeStartableMethod("stop");
    this._started = false;
  }
  async afterStop() {
    await this._invokeStartableMethod("afterStop");
  }
};
var OPTIONAL_SERVICES = [
  "metrics",
  "connectionProtector",
  "dns"
];
var NON_SERVICE_PROPERTIES = [
  "components",
  "isStarted",
  "beforeStart",
  "start",
  "afterStart",
  "beforeStop",
  "stop",
  "afterStop",
  "then",
  "_invokeStartableMethod"
];
function defaultComponents(init = {}) {
  const components = new DefaultComponents(init);
  const proxy = new Proxy(components, {
    get(target, prop, receiver) {
      if (typeof prop === "string" && !NON_SERVICE_PROPERTIES.includes(prop)) {
        const service = components.components[prop];
        if (service == null && !OPTIONAL_SERVICES.includes(prop)) {
          throw new MissingServiceError(`${prop} not set`);
        }
        return service;
      }
      return Reflect.get(target, prop, receiver);
    },
    set(target, prop, value) {
      if (typeof prop === "string") {
        components.components[prop] = value;
      } else {
        Reflect.set(target, prop, value);
      }
      return true;
    }
  });
  return proxy;
}
function checkServiceDependencies(components) {
  const serviceCapabilities4 = {};
  for (const service of Object.values(components.components)) {
    for (const capability of getServiceCapabilities(service)) {
      serviceCapabilities4[capability] = true;
    }
  }
  for (const service of Object.values(components.components)) {
    for (const capability of getServiceDependencies(service)) {
      if (serviceCapabilities4[capability] !== true) {
        throw new UnmetServiceDependenciesError(`Service "${getServiceName(service)}" required capability "${capability}" but it was not provided by any component, you may need to add additional configuration when creating your node.`);
      }
    }
  }
}
function getServiceCapabilities(service) {
  if (Array.isArray(service == null ? void 0 : service[serviceCapabilities])) {
    return service[serviceCapabilities];
  }
  return [];
}
function getServiceDependencies(service) {
  if (Array.isArray(service == null ? void 0 : service[serviceDependencies])) {
    return service[serviceDependencies];
  }
  return [];
}
function getServiceName(service) {
  return (service == null ? void 0 : service[Symbol.toStringTag]) ?? (service == null ? void 0 : service.toString()) ?? "unknown";
}

// node_modules/libp2p/dist/src/config/connection-gater.browser.js
var CODEC_IP42 = 4;
var CODEC_IP62 = 41;
function connectionGater(gater = {}) {
  return {
    denyDialPeer: async () => false,
    denyDialMultiaddr: async (multiaddr2) => {
      if (WebSockets2.matches(multiaddr2)) {
        return false;
      }
      const tuples = multiaddr2.stringTuples();
      if (tuples[0][0] === CODEC_IP42 || tuples[0][0] === CODEC_IP62) {
        return Boolean(isPrivateIp(`${tuples[0][1]}`));
      }
      return false;
    },
    denyInboundConnection: async () => false,
    denyOutboundConnection: async () => false,
    denyInboundEncryptedConnection: async () => false,
    denyOutboundEncryptedConnection: async () => false,
    denyInboundUpgradedConnection: async () => false,
    denyOutboundUpgradedConnection: async () => false,
    filterMultiaddrForPeer: async () => true,
    ...gater
  };
}

// node_modules/libp2p/dist/src/get-peer.js
function getPeerAddress(peer) {
  if (isPeerId(peer)) {
    return { peerId: peer, multiaddrs: [] };
  }
  let multiaddrs = Array.isArray(peer) ? peer : [peer];
  let peerId2;
  if (multiaddrs.length > 0) {
    const peerIdStr = multiaddrs[0].getPeerId();
    peerId2 = peerIdStr == null ? void 0 : peerIdFromString(peerIdStr);
    multiaddrs.forEach((ma) => {
      if (!isMultiaddr(ma)) {
        throw new InvalidMultiaddrError("Invalid multiaddr");
      }
      const maPeerIdStr = ma.getPeerId();
      if (maPeerIdStr == null) {
        if (peerId2 != null) {
          throw new InvalidParametersError("Multiaddrs must all have the same peer id or have no peer id");
        }
      } else {
        const maPeerId = peerIdFromString(maPeerIdStr);
        if ((peerId2 == null ? void 0 : peerId2.equals(maPeerId)) !== true) {
          throw new InvalidParametersError("Multiaddrs must all have the same peer id or have no peer id");
        }
      }
    });
  }
  multiaddrs = multiaddrs.filter((ma) => {
    return !PEER_ID.exactMatch(ma);
  });
  return {
    peerId: peerId2,
    multiaddrs
  };
}

// node_modules/@libp2p/utils/dist/src/close.js
var DEFAULT_CLOSABLE_PROTOCOLS = [
  // identify
  "/ipfs/id/1.0.0",
  // identify-push
  "/ipfs/id/push/1.0.0",
  // autonat
  "/libp2p/autonat/1.0.0",
  // dcutr
  "/libp2p/dcutr"
];
async function safelyCloseConnectionIfUnused(connection, options) {
  var _a27;
  const streamProtocols = ((_a27 = connection == null ? void 0 : connection.streams) == null ? void 0 : _a27.map((stream) => stream.protocol)) ?? [];
  const closableProtocols = (options == null ? void 0 : options.closableProtocols) ?? DEFAULT_CLOSABLE_PROTOCOLS;
  if (streamProtocols.filter((proto) => proto != null && !closableProtocols.includes(proto)).length > 0) {
    return;
  }
  try {
    await (connection == null ? void 0 : connection.close(options));
  } catch (err) {
    connection == null ? void 0 : connection.abort(err);
  }
}

// node_modules/libp2p/dist/src/connection-manager/utils.js
async function resolveMultiaddrs(ma, options) {
  let resolvable = false;
  for (const key of resolvers.keys()) {
    resolvable = ma.protoNames().includes(key);
    if (resolvable) {
      break;
    }
  }
  if (!resolvable) {
    return [ma];
  }
  const output = await ma.resolve(options);
  options.log("resolved %s to", ma, output.map((ma2) => ma2.toString()));
  return output;
}
function multiaddrToIpNet(ma) {
  try {
    let parsedMa;
    if (typeof ma === "string") {
      parsedMa = multiaddr(ma);
    } else {
      parsedMa = ma;
    }
    if (!parsedMa.protoNames().includes("ipcidr")) {
      const isIPv62 = parsedMa.protoNames().includes("ip6");
      const cidr = isIPv62 ? "/ipcidr/128" : "/ipcidr/32";
      parsedMa = parsedMa.encapsulate(cidr);
    }
    return convertToIpNet(parsedMa);
  } catch (error) {
    throw new Error(`Can't convert to IpNet, Invalid multiaddr format: ${ma}`);
  }
}

// node_modules/libp2p/dist/src/connection-manager/connection-pruner.js
var ConnectionPruner = class {
  constructor(components, init = {}) {
    __publicField(this, "connectionManager");
    __publicField(this, "peerStore");
    __publicField(this, "allow");
    __publicField(this, "events");
    __publicField(this, "log");
    this.allow = (init.allow ?? []).map((ma) => multiaddrToIpNet(ma));
    this.connectionManager = components.connectionManager;
    this.peerStore = components.peerStore;
    this.events = components.events;
    this.log = components.logger.forComponent("libp2p:connection-manager:connection-pruner");
    this.maybePruneConnections = this.maybePruneConnections.bind(this);
  }
  start() {
    this.events.addEventListener("connection:open", this.maybePruneConnections);
  }
  stop() {
    this.events.removeEventListener("connection:open", this.maybePruneConnections);
  }
  maybePruneConnections() {
    this._maybePruneConnections().catch((err) => {
      this.log.error("error while pruning connections %e", err);
    });
  }
  /**
   * If we have more connections than our maximum, select some excess connections
   * to prune based on peer value
   */
  async _maybePruneConnections() {
    const connections = this.connectionManager.getConnections();
    const numConnections = connections.length;
    const maxConnections = this.connectionManager.getMaxConnections();
    this.log("checking max connections limit %d/%d", numConnections, maxConnections);
    if (numConnections <= maxConnections) {
      return;
    }
    const peerValues = new PeerMap();
    for (const connection of connections) {
      const remotePeer = connection.remotePeer;
      if (peerValues.has(remotePeer)) {
        continue;
      }
      peerValues.set(remotePeer, 0);
      try {
        const peer = await this.peerStore.get(remotePeer);
        peerValues.set(remotePeer, [...peer.tags.values()].reduce((acc, curr) => {
          return acc + curr.value;
        }, 0));
      } catch (err) {
        if (err.name !== "NotFoundError") {
          this.log.error("error loading peer tags", err);
        }
      }
    }
    const sortedConnections = this.sortConnections(connections, peerValues);
    const toPrune = Math.max(numConnections - maxConnections, 0);
    const toClose = [];
    for (const connection of sortedConnections) {
      this.log("too many connections open - closing a connection to %p", connection.remotePeer);
      const connectionInAllowList = this.allow.some((ipNet) => {
        return ipNet.contains(connection.remoteAddr.nodeAddress().address);
      });
      if (!connectionInAllowList) {
        toClose.push(connection);
      }
      if (toClose.length === toPrune) {
        break;
      }
    }
    await Promise.all(toClose.map(async (connection) => {
      await safelyCloseConnectionIfUnused(connection, {
        signal: AbortSignal.timeout(1e3)
      });
    }));
    this.events.safeDispatchEvent("connection:prune", { detail: toClose });
  }
  sortConnections(connections, peerValues) {
    return connections.sort((a2, b) => {
      const connectionALifespan = a2.timeline.open;
      const connectionBLifespan = b.timeline.open;
      if (connectionALifespan < connectionBLifespan) {
        return 1;
      }
      if (connectionALifespan > connectionBLifespan) {
        return -1;
      }
      return 0;
    }).sort((a2, b) => {
      if (a2.direction === "outbound" && b.direction === "inbound") {
        return 1;
      }
      if (a2.direction === "inbound" && b.direction === "outbound") {
        return -1;
      }
      return 0;
    }).sort((a2, b) => {
      if (a2.streams.length > b.streams.length) {
        return 1;
      }
      if (a2.streams.length < b.streams.length) {
        return -1;
      }
      return 0;
    }).sort((a2, b) => {
      const peerAValue = peerValues.get(a2.remotePeer) ?? 0;
      const peerBValue = peerValues.get(b.remotePeer) ?? 0;
      if (peerAValue > peerBValue) {
        return 1;
      }
      if (peerAValue < peerBValue) {
        return -1;
      }
      return 0;
    });
  }
};

// node_modules/libp2p/dist/src/connection-manager/constants.defaults.js
var DIAL_TIMEOUT = 1e4;
var INBOUND_UPGRADE_TIMEOUT = 1e4;
var PROTOCOL_NEGOTIATION_TIMEOUT = 1e4;
var MAX_PEER_ADDRS_TO_DIAL = 25;
var INBOUND_CONNECTION_THRESHOLD = 5;
var MAX_INCOMING_PENDING_CONNECTIONS = 10;
var MAX_PARALLEL_RECONNECTS = 5;
var LAST_DIAL_FAILURE_KEY = "last-dial-failure";
var LAST_DIAL_SUCCESS_KEY = "last-dial-success";
var MAX_DIAL_QUEUE_LENGTH = 500;

// node_modules/libp2p/dist/src/connection-manager/constants.browser.js
var MAX_CONNECTIONS = 100;
var MAX_PARALLEL_DIALS = 50;

// node_modules/@libp2p/utils/dist/src/queue/recipient.js
var JobRecipient2 = class {
  constructor(signal) {
    __publicField(this, "deferred");
    __publicField(this, "signal");
    var _a27;
    this.signal = signal;
    this.deferred = pDefer();
    this.onAbort = this.onAbort.bind(this);
    (_a27 = this.signal) == null ? void 0 : _a27.addEventListener("abort", this.onAbort);
  }
  onAbort() {
    var _a27;
    this.deferred.reject(((_a27 = this.signal) == null ? void 0 : _a27.reason) ?? new AbortError());
  }
  cleanup() {
    var _a27;
    (_a27 = this.signal) == null ? void 0 : _a27.removeEventListener("abort", this.onAbort);
  }
};

// node_modules/@libp2p/utils/dist/src/queue/job.js
function randomId2() {
  return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
}
var Job2 = class {
  constructor(fn, options) {
    __publicField(this, "id");
    __publicField(this, "fn");
    __publicField(this, "options");
    __publicField(this, "recipients");
    __publicField(this, "status");
    __publicField(this, "timeline");
    __publicField(this, "controller");
    this.id = randomId2();
    this.status = "queued";
    this.fn = fn;
    this.options = options;
    this.recipients = [];
    this.timeline = {
      created: Date.now()
    };
    this.controller = new AbortController();
    setMaxListeners(Infinity, this.controller.signal);
    this.onAbort = this.onAbort.bind(this);
  }
  abort(err) {
    this.controller.abort(err);
  }
  onAbort() {
    const allAborted = this.recipients.reduce((acc, curr) => {
      var _a27;
      return acc && ((_a27 = curr.signal) == null ? void 0 : _a27.aborted) === true;
    }, true);
    if (allAborted) {
      this.controller.abort(new AbortError());
      this.cleanup();
    }
  }
  async join(options = {}) {
    var _a27;
    const recipient = new JobRecipient2(options.signal);
    this.recipients.push(recipient);
    (_a27 = options.signal) == null ? void 0 : _a27.addEventListener("abort", this.onAbort);
    return recipient.deferred.promise;
  }
  async run() {
    this.status = "running";
    this.timeline.started = Date.now();
    try {
      this.controller.signal.throwIfAborted();
      const result = await raceSignal3(this.fn({
        ...this.options ?? {},
        signal: this.controller.signal
      }), this.controller.signal);
      this.recipients.forEach((recipient) => {
        recipient.deferred.resolve(result);
      });
      this.status = "complete";
    } catch (err) {
      this.recipients.forEach((recipient) => {
        recipient.deferred.reject(err);
      });
      this.status = "errored";
    } finally {
      this.timeline.finished = Date.now();
      this.cleanup();
    }
  }
  cleanup() {
    this.recipients.forEach((recipient) => {
      var _a27;
      recipient.cleanup();
      (_a27 = recipient.signal) == null ? void 0 : _a27.removeEventListener("abort", this.onAbort);
    });
  }
};

// node_modules/@libp2p/utils/dist/src/queue/index.js
var Queue2 = class extends TypedEventEmitter {
  constructor(init = {}) {
    var _a27;
    super();
    __publicField(this, "concurrency");
    __publicField(this, "maxSize");
    __publicField(this, "queue");
    __publicField(this, "pending");
    __publicField(this, "sort");
    this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;
    this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY;
    this.pending = 0;
    if (init.metricName != null) {
      (_a27 = init.metrics) == null ? void 0 : _a27.registerMetricGroup(init.metricName, {
        calculate: () => {
          return {
            size: this.queue.length,
            running: this.pending,
            queued: this.queue.length - this.pending
          };
        }
      });
    }
    this.sort = init.sort;
    this.queue = [];
    this.emitEmpty = debounce2(this.emitEmpty.bind(this), 1);
    this.emitIdle = debounce2(this.emitIdle.bind(this), 1);
  }
  emitEmpty() {
    if (this.size !== 0) {
      return;
    }
    this.safeDispatchEvent("empty");
  }
  emitIdle() {
    if (this.running !== 0) {
      return;
    }
    this.safeDispatchEvent("idle");
  }
  tryToStartAnother() {
    if (this.size === 0) {
      this.emitEmpty();
      if (this.running === 0) {
        this.emitIdle();
      }
      return false;
    }
    if (this.pending < this.concurrency) {
      let job;
      for (const j of this.queue) {
        if (j.status === "queued") {
          job = j;
          break;
        }
      }
      if (job == null) {
        return false;
      }
      this.safeDispatchEvent("active");
      this.pending++;
      void job.run().finally(() => {
        for (let i2 = 0; i2 < this.queue.length; i2++) {
          if (this.queue[i2] === job) {
            this.queue.splice(i2, 1);
            break;
          }
        }
        this.pending--;
        this.tryToStartAnother();
        this.safeDispatchEvent("next");
      });
      return true;
    }
    return false;
  }
  enqueue(job) {
    this.queue.push(job);
    if (this.sort != null) {
      this.queue.sort(this.sort);
    }
  }
  /**
   * Adds a sync or async task to the queue. Always returns a promise.
   */
  async add(fn, options) {
    var _a27;
    (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
    if (this.size === this.maxSize) {
      throw new QueueFullError();
    }
    const job = new Job2(fn, options);
    this.enqueue(job);
    this.safeDispatchEvent("add");
    this.tryToStartAnother();
    return job.join(options).then((result) => {
      this.safeDispatchEvent("completed", { detail: result });
      this.safeDispatchEvent("success", { detail: { job, result } });
      return result;
    }).catch((err) => {
      if (job.status === "queued") {
        for (let i2 = 0; i2 < this.queue.length; i2++) {
          if (this.queue[i2] === job) {
            this.queue.splice(i2, 1);
            break;
          }
        }
      }
      this.safeDispatchEvent("failure", { detail: { job, error: err } });
      throw err;
    });
  }
  /**
   * Clear the queue
   */
  clear() {
    this.queue.splice(0, this.queue.length);
  }
  /**
   * Abort all jobs in the queue and clear it
   */
  abort() {
    this.queue.forEach((job) => {
      job.abort(new AbortError());
    });
    this.clear();
  }
  /**
   * Can be called multiple times. Useful if you for example add additional items at a later time.
   *
   * @returns A promise that settles when the queue becomes empty.
   */
  async onEmpty(options) {
    if (this.size === 0) {
      return;
    }
    await raceEvent(this, "empty", options == null ? void 0 : options.signal);
  }
  /**
   * @returns A promise that settles when the queue size is less than the given
   * limit: `queue.size < limit`.
   *
   * If you want to avoid having the queue grow beyond a certain size you can
   * `await queue.onSizeLessThan()` before adding a new item.
   *
   * Note that this only limits the number of items waiting to start. There
   * could still be up to `concurrency` jobs already running that this call does
   * not include in its calculation.
   */
  async onSizeLessThan(limit, options) {
    if (this.size < limit) {
      return;
    }
    await raceEvent(this, "next", options == null ? void 0 : options.signal, {
      filter: () => this.size < limit
    });
  }
  /**
   * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
   * from the queue has finished. `.onEmpty` merely signals that the queue is
   * empty, but it could mean that some promises haven't completed yet.
   *
   * @returns A promise that settles when the queue becomes empty, and all
   * promises have completed; `queue.size === 0 && queue.pending === 0`.
   */
  async onIdle(options) {
    if (this.pending === 0 && this.size === 0) {
      return;
    }
    await raceEvent(this, "idle", options == null ? void 0 : options.signal);
  }
  /**
   * Size of the queue including running items
   */
  get size() {
    return this.queue.length;
  }
  /**
   * The number of queued items waiting to run.
   */
  get queued() {
    return this.queue.length - this.pending;
  }
  /**
   * The number of items currently running.
   */
  get running() {
    return this.pending;
  }
  /**
   * Returns an async generator that makes it easy to iterate over the results
   * of jobs added to the queue.
   *
   * The generator will end when the queue becomes idle, that is there are no
   * jobs running and no jobs that have yet to run.
   *
   * If you need to keep the queue open indefinitely, consider using it-pushable
   * instead.
   */
  async *toGenerator(options) {
    var _a27, _b14, _c3;
    (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
    const stream = pushable({
      objectMode: true
    });
    const cleanup = (err) => {
      if (err != null) {
        this.abort();
      } else {
        this.clear();
      }
      stream.end(err);
    };
    const onQueueJobComplete = (evt) => {
      if (evt.detail != null) {
        stream.push(evt.detail);
      }
    };
    const onQueueFailure = (evt) => {
      cleanup(evt.detail.error);
    };
    const onQueueIdle = () => {
      cleanup();
    };
    const onSignalAbort = () => {
      cleanup(new AbortError("Queue aborted"));
    };
    this.addEventListener("completed", onQueueJobComplete);
    this.addEventListener("failure", onQueueFailure);
    this.addEventListener("idle", onQueueIdle);
    (_b14 = options == null ? void 0 : options.signal) == null ? void 0 : _b14.addEventListener("abort", onSignalAbort);
    try {
      yield* stream;
    } finally {
      this.removeEventListener("completed", onQueueJobComplete);
      this.removeEventListener("failure", onQueueFailure);
      this.removeEventListener("idle", onQueueIdle);
      (_c3 = options == null ? void 0 : options.signal) == null ? void 0 : _c3.removeEventListener("abort", onSignalAbort);
      cleanup();
    }
  }
};

// node_modules/@libp2p/utils/dist/src/priority-queue.js
var PriorityQueue2 = class extends Queue2 {
  constructor(init = {}) {
    super({
      ...init,
      sort: (a2, b) => {
        if (a2.options.priority > b.options.priority) {
          return -1;
        }
        if (a2.options.priority < b.options.priority) {
          return 1;
        }
        return 0;
      }
    });
  }
};

// node_modules/any-signal/dist/src/index.js
function anySignal(signals) {
  const controller = new globalThis.AbortController();
  function onAbort() {
    const reason = signals.filter((s2) => (s2 == null ? void 0 : s2.aborted) === true).map((s2) => s2 == null ? void 0 : s2.reason).pop();
    controller.abort(reason);
    for (const signal2 of signals) {
      if ((signal2 == null ? void 0 : signal2.removeEventListener) != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  for (const signal2 of signals) {
    if ((signal2 == null ? void 0 : signal2.aborted) === true) {
      onAbort();
      break;
    }
    if ((signal2 == null ? void 0 : signal2.addEventListener) != null) {
      signal2.addEventListener("abort", onAbort);
    }
  }
  function clear() {
    for (const signal2 of signals) {
      if ((signal2 == null ? void 0 : signal2.removeEventListener) != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  const signal = controller.signal;
  signal.clear = clear;
  return signal;
}

// node_modules/is-loopback-addr/dist/src/index.js
function isLoopbackAddr(ip) {
  return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(ip) || /^::1$/.test(ip);
}

// node_modules/@libp2p/utils/dist/src/multiaddr/is-loopback.js
function isLoopback(ma) {
  if (!isIpBased(ma)) {
    return false;
  }
  const { address } = ma.nodeAddress();
  return isLoopbackAddr(address);
}

// node_modules/libp2p/dist/src/connection-manager/address-sorter.js
function reliableTransportsFirst(a2, b) {
  const isATcp = TCP2.exactMatch(a2.multiaddr);
  const isBTcp = TCP2.exactMatch(b.multiaddr);
  if (isATcp && !isBTcp) {
    return -1;
  }
  if (!isATcp && isBTcp) {
    return 1;
  }
  const isAWebSocketSecure = WebSocketsSecure2.exactMatch(a2.multiaddr);
  const isBWebSocketSecure = WebSocketsSecure2.exactMatch(b.multiaddr);
  if (isAWebSocketSecure && !isBWebSocketSecure) {
    return -1;
  }
  if (!isAWebSocketSecure && isBWebSocketSecure) {
    return 1;
  }
  const isAWebSocket = WebSockets2.exactMatch(a2.multiaddr);
  const isBWebSocket = WebSockets2.exactMatch(b.multiaddr);
  if (isAWebSocket && !isBWebSocket) {
    return -1;
  }
  if (!isAWebSocket && isBWebSocket) {
    return 1;
  }
  const isAWebRTC = WebRTC2.exactMatch(a2.multiaddr);
  const isBWebRTC = WebRTC2.exactMatch(b.multiaddr);
  if (isAWebRTC && !isBWebRTC) {
    return -1;
  }
  if (!isAWebRTC && isBWebRTC) {
    return 1;
  }
  const isAWebRTCDirect = WebRTCDirect2.exactMatch(a2.multiaddr);
  const isBWebRTCDirect = WebRTCDirect2.exactMatch(b.multiaddr);
  if (isAWebRTCDirect && !isBWebRTCDirect) {
    return -1;
  }
  if (!isAWebRTCDirect && isBWebRTCDirect) {
    return 1;
  }
  const isAWebTransport = WebTransport2.exactMatch(a2.multiaddr);
  const isBWebTransport = WebTransport2.exactMatch(b.multiaddr);
  if (isAWebTransport && !isBWebTransport) {
    return -1;
  }
  if (!isAWebTransport && isBWebTransport) {
    return 1;
  }
  return 0;
}
function loopbackAddressLast(a2, b) {
  const isALoopback = isLoopback(a2.multiaddr);
  const isBLoopback = isLoopback(b.multiaddr);
  if (isALoopback && !isBLoopback) {
    return 1;
  } else if (!isALoopback && isBLoopback) {
    return -1;
  }
  return 0;
}
function publicAddressesFirst(a2, b) {
  const isAPrivate = isPrivate(a2.multiaddr);
  const isBPrivate = isPrivate(b.multiaddr);
  if (isAPrivate && !isBPrivate) {
    return 1;
  } else if (!isAPrivate && isBPrivate) {
    return -1;
  }
  return 0;
}
function certifiedAddressesFirst(a2, b) {
  if (a2.isCertified && !b.isCertified) {
    return -1;
  } else if (!a2.isCertified && b.isCertified) {
    return 1;
  }
  return 0;
}
function circuitRelayAddressesLast(a2, b) {
  const isACircuit = Circuit2.exactMatch(a2.multiaddr);
  const isBCircuit = Circuit2.exactMatch(b.multiaddr);
  if (isACircuit && !isBCircuit) {
    return 1;
  } else if (!isACircuit && isBCircuit) {
    return -1;
  }
  return 0;
}
function defaultAddressSorter(addresses) {
  return addresses.sort(reliableTransportsFirst).sort(certifiedAddressesFirst).sort(circuitRelayAddressesLast).sort(publicAddressesFirst).sort(loopbackAddressLast);
}

// node_modules/libp2p/dist/src/connection-manager/dial-queue.js
var defaultOptions3 = {
  maxParallelDials: MAX_PARALLEL_DIALS,
  maxDialQueueLength: MAX_DIAL_QUEUE_LENGTH,
  maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,
  dialTimeout: DIAL_TIMEOUT,
  resolvers: {
    dnsaddr: dnsaddrResolver
  }
};
var DialQueue = class {
  constructor(components, init = {}) {
    __publicField(this, "queue");
    __publicField(this, "components");
    __publicField(this, "addressSorter");
    __publicField(this, "maxPeerAddrsToDial");
    __publicField(this, "maxDialQueueLength");
    __publicField(this, "dialTimeout");
    __publicField(this, "shutDownController");
    __publicField(this, "connections");
    __publicField(this, "log");
    this.addressSorter = init.addressSorter;
    this.maxPeerAddrsToDial = init.maxPeerAddrsToDial ?? defaultOptions3.maxPeerAddrsToDial;
    this.maxDialQueueLength = init.maxDialQueueLength ?? defaultOptions3.maxDialQueueLength;
    this.dialTimeout = init.dialTimeout ?? defaultOptions3.dialTimeout;
    this.connections = init.connections ?? new PeerMap();
    this.log = components.logger.forComponent("libp2p:connection-manager:dial-queue");
    this.components = components;
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
    for (const [key, value] of Object.entries(init.resolvers ?? {})) {
      resolvers.set(key, value);
    }
    this.queue = new PriorityQueue2({
      concurrency: init.maxParallelDials ?? defaultOptions3.maxParallelDials,
      metricName: "libp2p_dial_queue",
      metrics: components.metrics
    });
    this.queue.addEventListener("error", (event) => {
      var _a27;
      if (((_a27 = event.detail) == null ? void 0 : _a27.name) !== AbortError.name) {
        this.log.error("error in dial queue - %e", event.detail);
      }
    });
  }
  start() {
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
  }
  /**
   * Clears any pending dials
   */
  stop() {
    this.shutDownController.abort();
    this.queue.abort();
  }
  /**
   * Connects to a given peer, multiaddr or list of multiaddrs.
   *
   * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or
   * multiaddrs are passed only those will be dialled.
   *
   * Where a list of multiaddrs is passed, if any contain a peer id then all
   * multiaddrs in the list must contain the same peer id.
   *
   * The dial to the first address that is successfully able to upgrade a
   * connection will be used, all other dials will be aborted when that happens.
   */
  async dial(peerIdOrMultiaddr, options = {}) {
    var _a27, _b14, _c3;
    const { peerId: peerId2, multiaddrs } = getPeerAddress(peerIdOrMultiaddr);
    const existingConnection = Array.from(this.connections.values()).flat().find((conn) => {
      if (options.force === true) {
        return false;
      }
      if (conn.remotePeer.equals(peerId2)) {
        return true;
      }
      return multiaddrs.find((addr) => {
        return addr.equals(conn.remoteAddr);
      });
    });
    if ((existingConnection == null ? void 0 : existingConnection.status) === "open") {
      this.log("already connected to %a", existingConnection.remoteAddr);
      (_a27 = options.onProgress) == null ? void 0 : _a27.call(options, new CustomProgressEvent("dial-queue:already-connected"));
      return existingConnection;
    }
    const existingDial = this.queue.queue.find((job) => {
      if ((peerId2 == null ? void 0 : peerId2.equals(job.options.peerId)) === true) {
        return true;
      }
      const addresses = job.options.multiaddrs;
      if (addresses == null) {
        return false;
      }
      for (const multiaddr2 of multiaddrs) {
        if (addresses.has(multiaddr2.toString())) {
          return true;
        }
      }
      return false;
    });
    if (existingDial != null) {
      this.log("joining existing dial target for %p", peerId2);
      for (const multiaddr2 of multiaddrs) {
        existingDial.options.multiaddrs.add(multiaddr2.toString());
      }
      (_b14 = options.onProgress) == null ? void 0 : _b14.call(options, new CustomProgressEvent("dial-queue:already-in-dial-queue"));
      return existingDial.join(options);
    }
    if (this.queue.size >= this.maxDialQueueLength) {
      throw new DialError("Dial queue is full");
    }
    this.log("creating dial target for %p", peerId2, multiaddrs.map((ma) => ma.toString()));
    (_c3 = options.onProgress) == null ? void 0 : _c3.call(options, new CustomProgressEvent("dial-queue:add-to-dial-queue"));
    return this.queue.add(async (options2) => {
      var _a28;
      (_a28 = options2.onProgress) == null ? void 0 : _a28.call(options2, new CustomProgressEvent("dial-queue:start-dial"));
      const signal = anySignal([
        this.shutDownController.signal,
        options2.signal
      ]);
      setMaxListeners(Infinity, signal);
      try {
        return await this.dialPeer(options2, signal);
      } finally {
        signal.clear();
      }
    }, {
      peerId: peerId2,
      priority: options.priority ?? DEFAULT_DIAL_PRIORITY,
      multiaddrs: new Set(multiaddrs.map((ma) => ma.toString())),
      signal: options.signal ?? AbortSignal.timeout(this.dialTimeout),
      onProgress: options.onProgress
    });
  }
  async dialPeer(options, signal) {
    var _a27;
    const peerId2 = options.peerId;
    const multiaddrs = options.multiaddrs;
    const failedMultiaddrs = /* @__PURE__ */ new Set();
    let forcePeerLookup = options.multiaddrs.size === 0;
    let dialed = 0;
    let dialIteration = 0;
    const errors = [];
    this.log("starting dial to %p", peerId2);
    while (forcePeerLookup || multiaddrs.size > 0) {
      dialIteration++;
      forcePeerLookup = false;
      const addrsToDial = [];
      const addrs = new Set(options.multiaddrs);
      multiaddrs.clear();
      this.log("calculating addrs to dial %p from %s", peerId2, [...addrs]);
      const calculatedAddrs = await this.calculateMultiaddrs(peerId2, addrs, {
        ...options,
        signal
      });
      for (const addr of calculatedAddrs) {
        if (failedMultiaddrs.has(addr.multiaddr.toString())) {
          this.log.trace("skipping previously failed multiaddr %a while dialing %p", addr.multiaddr, peerId2);
          continue;
        }
        addrsToDial.push(addr);
      }
      this.log("%s dial to %p with %s", dialIteration === 1 ? "starting" : "continuing", peerId2, addrsToDial.map((ma) => ma.multiaddr.toString()));
      (_a27 = options == null ? void 0 : options.onProgress) == null ? void 0 : _a27.call(options, new CustomProgressEvent("dial-queue:calculated-addresses", addrsToDial));
      for (const address of addrsToDial) {
        if (dialed === this.maxPeerAddrsToDial) {
          this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others", dialed, options.peerId);
          throw new DialError("Peer had more than maxPeerAddrsToDial");
        }
        dialed++;
        try {
          const conn = await this.components.transportManager.dial(address.multiaddr, {
            ...options,
            signal
          });
          this.log("dial to %a succeeded", address.multiaddr);
          try {
            await this.components.peerStore.merge(conn.remotePeer, {
              multiaddrs: [
                conn.remoteAddr
              ],
              metadata: {
                [LAST_DIAL_SUCCESS_KEY]: fromString2(Date.now().toString())
              }
            });
          } catch (err) {
            this.log.error("could not update last dial failure key for %p", peerId2, err);
          }
          return conn;
        } catch (err) {
          this.log.error("dial failed to %a", address.multiaddr, err);
          failedMultiaddrs.add(address.multiaddr.toString());
          if (peerId2 != null) {
            try {
              await this.components.peerStore.merge(peerId2, {
                metadata: {
                  [LAST_DIAL_FAILURE_KEY]: fromString2(Date.now().toString())
                }
              });
            } catch (err2) {
              this.log.error("could not update last dial failure key for %p", peerId2, err2);
            }
          }
          if (signal.aborted) {
            throw new TimeoutError(err.message);
          }
          errors.push(err);
        }
      }
    }
    if (errors.length === 1) {
      throw errors[0];
    }
    throw new AggregateError(errors, "All multiaddr dials failed");
  }
  // eslint-disable-next-line complexity
  async calculateMultiaddrs(peerId2, multiaddrs = /* @__PURE__ */ new Set(), options = {}) {
    var _a27, _b14;
    const addrs = [...multiaddrs].map((ma) => ({
      multiaddr: multiaddr(ma),
      isCertified: false
    }));
    if (peerId2 != null) {
      if (this.components.peerId.equals(peerId2)) {
        throw new DialError("Tried to dial self");
      }
      if (await ((_b14 = (_a27 = this.components.connectionGater).denyDialPeer) == null ? void 0 : _b14.call(_a27, peerId2)) === true) {
        throw new DialDeniedError("The dial request is blocked by gater.allowDialPeer");
      }
      if (addrs.length === 0) {
        this.log("loading multiaddrs for %p", peerId2);
        try {
          const peer = await this.components.peerStore.get(peerId2);
          addrs.push(...peer.addresses);
          this.log("loaded multiaddrs for %p", peerId2, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
        } catch (err) {
          if (err.name !== "NotFoundError") {
            throw err;
          }
        }
      }
      if (addrs.length === 0) {
        this.log("looking up multiaddrs for %p in the peer routing", peerId2);
        try {
          const peerInfo = await this.components.peerRouting.findPeer(peerId2, options);
          this.log("found multiaddrs for %p in the peer routing", peerId2, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
          addrs.push(...peerInfo.multiaddrs.map((multiaddr2) => ({
            multiaddr: multiaddr2,
            isCertified: false
          })));
        } catch (err) {
          if (err.name === "NoPeerRoutersError") {
            this.log("no peer routers configured", peerId2);
          } else {
            this.log.error("looking up multiaddrs for %p in the peer routing failed - %e", peerId2, err);
          }
        }
      }
    }
    let resolvedAddresses = (await Promise.all(addrs.map(async (addr) => {
      const result = await resolveMultiaddrs(addr.multiaddr, {
        dns: this.components.dns,
        ...options,
        log: this.log
      });
      if (result.length === 1 && result[0].equals(addr.multiaddr)) {
        return addr;
      }
      return result.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        isCertified: false
      }));
    }))).flat();
    if (peerId2 != null) {
      const peerIdMultiaddr = `/p2p/${peerId2.toString()}`;
      resolvedAddresses = resolvedAddresses.map((addr) => {
        const lastComponent = addr.multiaddr.getComponents().pop();
        if ((lastComponent == null ? void 0 : lastComponent.name) !== "p2p") {
          return {
            multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),
            isCertified: addr.isCertified
          };
        }
        return addr;
      });
    }
    const filteredAddrs = resolvedAddresses.filter((addr) => {
      if (this.components.transportManager.dialTransportForMultiaddr(addr.multiaddr) == null) {
        return false;
      }
      const addrPeerId = addr.multiaddr.getPeerId();
      if (peerId2 != null && addrPeerId != null) {
        return peerId2.equals(addrPeerId);
      }
      return true;
    });
    const dedupedAddrs = /* @__PURE__ */ new Map();
    for (const addr of filteredAddrs) {
      const maStr = addr.multiaddr.toString();
      const existing = dedupedAddrs.get(maStr);
      if (existing != null) {
        existing.isCertified = existing.isCertified || addr.isCertified || false;
        continue;
      }
      dedupedAddrs.set(maStr, addr);
    }
    const dedupedMultiaddrs = [...dedupedAddrs.values()];
    if (dedupedMultiaddrs.length === 0) {
      throw new NoValidAddressesError("The dial request has no valid addresses");
    }
    const gatedAddrs = [];
    for (const addr of dedupedMultiaddrs) {
      if (this.components.connectionGater.denyDialMultiaddr != null && await this.components.connectionGater.denyDialMultiaddr(addr.multiaddr)) {
        continue;
      }
      gatedAddrs.push(addr);
    }
    const sortedGatedAddrs = this.addressSorter == null ? defaultAddressSorter(gatedAddrs) : gatedAddrs.sort(this.addressSorter);
    if (sortedGatedAddrs.length === 0) {
      throw new DialDeniedError("The connection gater denied all addresses in the dial request");
    }
    this.log.trace("addresses for %p before filtering", peerId2 ?? "unknown peer", resolvedAddresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    this.log.trace("addresses for %p after filtering", peerId2 ?? "unknown peer", sortedGatedAddrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    return sortedGatedAddrs;
  }
  async isDialable(multiaddr2, options = {}) {
    if (!Array.isArray(multiaddr2)) {
      multiaddr2 = [multiaddr2];
    }
    try {
      const addresses = await this.calculateMultiaddrs(void 0, new Set(multiaddr2.map((ma) => ma.toString())), options);
      if (options.runOnLimitedConnection === false) {
        return addresses.find((addr) => {
          return !Circuit2.matches(addr.multiaddr);
        }) != null;
      }
      return true;
    } catch (err) {
      this.log.trace("error calculating if multiaddr(s) were dialable", err);
    }
    return false;
  }
};

// node_modules/@libp2p/utils/dist/src/peer-queue.js
var PeerQueue = class extends Queue2 {
  has(peerId2) {
    return this.find(peerId2) != null;
  }
  find(peerId2) {
    return this.queue.find((job) => {
      return peerId2.equals(job.options.peerId);
    });
  }
};

// node_modules/p-retry/index.js
var import_retry = __toESM(require_retry2());

// node_modules/is-network-error/index.js
var objectToString = Object.prototype.toString;
var isError = (value) => objectToString.call(value) === "[object Error]";
var errorMessages = /* @__PURE__ */ new Set([
  "network error",
  // Chrome
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari 16
  "Network request failed",
  // `cross-fetch`
  "fetch failed",
  // Undici (Node.js)
  "terminated",
  // Undici (Node.js)
  " A network error occurred.",
  // Bun (WebKit)
  "Network connection lost"
  // Cloudflare Workers (fetch)
]);
function isNetworkError(error) {
  const isValid = error && isError(error) && error.name === "TypeError" && typeof error.message === "string";
  if (!isValid) {
    return false;
  }
  const { message: message2, stack } = error;
  if (message2 === "Load failed") {
    return stack === void 0 || "__sentry_captured__" in error;
  }
  if (message2.startsWith("error sending request for url")) {
    return true;
  }
  return errorMessages.has(message2);
}

// node_modules/p-retry/index.js
var AbortError5 = class extends Error {
  constructor(message2) {
    super();
    if (message2 instanceof Error) {
      this.originalError = message2;
      ({ message: message2 } = message2);
    } else {
      this.originalError = new Error(message2);
      this.originalError.stack = this.stack;
    }
    this.name = "AbortError";
    this.message = message2;
  }
};
var decorateErrorWithCounts = (error, attemptNumber, options) => {
  const retriesLeft = options.retries - (attemptNumber - 1);
  error.attemptNumber = attemptNumber;
  error.retriesLeft = retriesLeft;
  return error;
};
async function pRetry(input, options) {
  return new Promise((resolve, reject) => {
    options = { ...options };
    options.onFailedAttempt ?? (options.onFailedAttempt = () => {
    });
    options.shouldRetry ?? (options.shouldRetry = () => true);
    options.retries ?? (options.retries = 10);
    const operation = import_retry.default.operation(options);
    const abortHandler = () => {
      var _a27;
      operation.stop();
      reject((_a27 = options.signal) == null ? void 0 : _a27.reason);
    };
    if (options.signal && !options.signal.aborted) {
      options.signal.addEventListener("abort", abortHandler, { once: true });
    }
    const cleanUp = () => {
      var _a27;
      (_a27 = options.signal) == null ? void 0 : _a27.removeEventListener("abort", abortHandler);
      operation.stop();
    };
    operation.attempt(async (attemptNumber) => {
      try {
        const result = await input(attemptNumber);
        cleanUp();
        resolve(result);
      } catch (error) {
        try {
          if (!(error instanceof Error)) {
            throw new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`);
          }
          if (error instanceof AbortError5) {
            throw error.originalError;
          }
          if (error instanceof TypeError && !isNetworkError(error)) {
            throw error;
          }
          decorateErrorWithCounts(error, attemptNumber, options);
          if (!await options.shouldRetry(error)) {
            operation.stop();
            reject(error);
          }
          await options.onFailedAttempt(error);
          if (!operation.retry(error)) {
            throw operation.mainError();
          }
        } catch (finalError) {
          decorateErrorWithCounts(finalError, attemptNumber, options);
          cleanUp();
          reject(finalError);
        }
      }
    });
  });
}

// node_modules/libp2p/dist/src/connection-manager/reconnect-queue.js
var ReconnectQueue = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "queue");
    __publicField(this, "started");
    __publicField(this, "peerStore");
    __publicField(this, "retries");
    __publicField(this, "retryInterval");
    __publicField(this, "backoffFactor");
    __publicField(this, "connectionManager");
    __publicField(this, "events");
    this.log = components.logger.forComponent("libp2p:reconnect-queue");
    this.peerStore = components.peerStore;
    this.connectionManager = components.connectionManager;
    this.queue = new PeerQueue({
      concurrency: init.maxParallelReconnects ?? MAX_PARALLEL_RECONNECTS,
      metricName: "libp2p_reconnect_queue",
      metrics: components.metrics
    });
    this.started = false;
    this.retries = init.retries ?? 5;
    this.backoffFactor = init.backoffFactor;
    this.retryInterval = init.retryInterval;
    this.events = components.events;
    components.events.addEventListener("peer:disconnect", (evt) => {
      this.maybeReconnect(evt.detail).catch((err) => {
        this.log.error("failed to maybe reconnect to %p - %e", evt.detail, err);
      });
    });
  }
  async maybeReconnect(peerId2) {
    if (!this.started) {
      return;
    }
    const peer = await this.peerStore.get(peerId2);
    if (!hasKeepAliveTag(peer)) {
      return;
    }
    if (this.queue.has(peerId2)) {
      return;
    }
    this.queue.add(async (options) => {
      await pRetry(async (attempt) => {
        if (!this.started) {
          return;
        }
        try {
          await this.connectionManager.openConnection(peerId2, {
            signal: options == null ? void 0 : options.signal
          });
        } catch (err) {
          this.log("reconnecting to %p attempt %d of %d failed - %e", peerId2, attempt, this.retries, err);
          throw err;
        }
      }, {
        signal: options == null ? void 0 : options.signal,
        retries: this.retries,
        factor: this.backoffFactor,
        minTimeout: this.retryInterval
      });
    }, {
      peerId: peerId2
    }).catch(async (err) => {
      this.log.error("failed to reconnect to %p - %e", peerId2, err);
      const tags = {};
      [...peer.tags.keys()].forEach((key) => {
        if (key.startsWith(KEEP_ALIVE)) {
          tags[key] = void 0;
        }
      });
      await this.peerStore.merge(peerId2, {
        tags
      });
      this.events.safeDispatchEvent("peer:reconnect-failure", {
        detail: peerId2
      });
    }).catch(async (err) => {
      this.log.error("failed to remove keep-alive tag from %p - %e", peerId2, err);
    });
  }
  start() {
    this.started = true;
  }
  async afterStart() {
    void Promise.resolve().then(async () => {
      const keepAlivePeers = await this.peerStore.all({
        filters: [
          (peer) => hasKeepAliveTag(peer)
        ]
      });
      await Promise.all(keepAlivePeers.map(async (peer) => {
        await this.connectionManager.openConnection(peer.id).catch((err) => {
          this.log.error(err);
        });
      }));
    }).catch((err) => {
      this.log.error(err);
    });
  }
  stop() {
    this.started = false;
    this.queue.abort();
  }
};
function hasKeepAliveTag(peer) {
  for (const tag of peer.tags.keys()) {
    if (tag.startsWith(KEEP_ALIVE)) {
      return true;
    }
  }
  return false;
}

// node_modules/libp2p/dist/src/connection-manager/index.js
var DEFAULT_DIAL_PRIORITY = 50;
var defaultOptions4 = {
  maxConnections: MAX_CONNECTIONS,
  inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,
  maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS
};
var _a16;
_a16 = Symbol.toStringTag;
var DefaultConnectionManager = class {
  constructor(components, init = {}) {
    __publicField(this, "started");
    __publicField(this, "connections");
    __publicField(this, "allow");
    __publicField(this, "deny");
    __publicField(this, "maxIncomingPendingConnections");
    __publicField(this, "incomingPendingConnections");
    __publicField(this, "outboundPendingConnections");
    __publicField(this, "maxConnections");
    __publicField(this, "dialQueue");
    __publicField(this, "reconnectQueue");
    __publicField(this, "connectionPruner");
    __publicField(this, "inboundConnectionRateLimiter");
    __publicField(this, "peerStore");
    __publicField(this, "metrics");
    __publicField(this, "events");
    __publicField(this, "log");
    __publicField(this, "peerId");
    __publicField(this, _a16, "@libp2p/connection-manager");
    var _a27;
    this.maxConnections = init.maxConnections ?? defaultOptions4.maxConnections;
    if (this.maxConnections < 1) {
      throw new InvalidParametersError("Connection Manager maxConnections must be greater than 0");
    }
    this.connections = new PeerMap();
    this.started = false;
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.metrics = components.metrics;
    this.events = components.events;
    this.log = components.logger.forComponent("libp2p:connection-manager");
    this.onConnect = this.onConnect.bind(this);
    this.onDisconnect = this.onDisconnect.bind(this);
    this.allow = (init.allow ?? []).map((str) => multiaddrToIpNet(str));
    this.deny = (init.deny ?? []).map((str) => multiaddrToIpNet(str));
    this.incomingPendingConnections = 0;
    this.maxIncomingPendingConnections = init.maxIncomingPendingConnections ?? defaultOptions4.maxIncomingPendingConnections;
    this.outboundPendingConnections = 0;
    this.inboundConnectionRateLimiter = new RateLimiter({
      points: init.inboundConnectionThreshold ?? defaultOptions4.inboundConnectionThreshold,
      duration: 1
    });
    this.connectionPruner = new ConnectionPruner({
      connectionManager: this,
      peerStore: components.peerStore,
      events: components.events,
      logger: components.logger
    }, {
      allow: (_a27 = init.allow) == null ? void 0 : _a27.map((a2) => multiaddr(a2))
    });
    this.dialQueue = new DialQueue(components, {
      addressSorter: init.addressSorter,
      maxParallelDials: init.maxParallelDials ?? MAX_PARALLEL_DIALS,
      maxDialQueueLength: init.maxDialQueueLength ?? MAX_DIAL_QUEUE_LENGTH,
      maxPeerAddrsToDial: init.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,
      dialTimeout: init.dialTimeout ?? DIAL_TIMEOUT,
      resolvers: init.resolvers ?? {
        dnsaddr: dnsaddrResolver
      },
      connections: this.connections
    });
    this.reconnectQueue = new ReconnectQueue({
      events: components.events,
      peerStore: components.peerStore,
      logger: components.logger,
      connectionManager: this
    }, {
      retries: init.reconnectRetries,
      retryInterval: init.reconnectRetryInterval,
      backoffFactor: init.reconnectBackoffFactor,
      maxParallelReconnects: init.maxParallelReconnects
    });
  }
  /**
   * Starts the Connection Manager. If Metrics are not enabled on libp2p
   * only event loop and connection limits will be monitored.
   */
  async start() {
    var _a27, _b14, _c3;
    (_a27 = this.metrics) == null ? void 0 : _a27.registerMetricGroup("libp2p_connection_manager_connections", {
      calculate: () => {
        const metric = {
          inbound: 0,
          "inbound pending": this.incomingPendingConnections,
          outbound: 0,
          "outbound pending": this.outboundPendingConnections
        };
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            metric[conn.direction]++;
          }
        }
        return metric;
      }
    });
    (_b14 = this.metrics) == null ? void 0 : _b14.registerMetricGroup("libp2p_protocol_streams_total", {
      label: "protocol",
      calculate: () => {
        const metric = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            for (const stream of conn.streams) {
              const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
              metric[key] = (metric[key] ?? 0) + 1;
            }
          }
        }
        return metric;
      }
    });
    (_c3 = this.metrics) == null ? void 0 : _c3.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile", {
      label: "protocol",
      calculate: () => {
        const allStreams = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            const streams = {};
            for (const stream of conn.streams) {
              const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
              streams[key] = (streams[key] ?? 0) + 1;
            }
            for (const [protocol, count] of Object.entries(streams)) {
              allStreams[protocol] = allStreams[protocol] ?? [];
              allStreams[protocol].push(count);
            }
          }
        }
        const metric = {};
        for (let [protocol, counts] of Object.entries(allStreams)) {
          counts = counts.sort((a2, b) => a2 - b);
          const index = Math.floor(counts.length * 0.9);
          metric[protocol] = counts[index];
        }
        return metric;
      }
    });
    this.events.addEventListener("connection:open", this.onConnect);
    this.events.addEventListener("connection:close", this.onDisconnect);
    await start(this.dialQueue, this.reconnectQueue, this.connectionPruner);
    this.started = true;
    this.log("started");
  }
  /**
   * Stops the Connection Manager
   */
  async stop() {
    this.events.removeEventListener("connection:open", this.onConnect);
    this.events.removeEventListener("connection:close", this.onDisconnect);
    await stop(this.reconnectQueue, this.dialQueue, this.connectionPruner);
    const tasks = [];
    for (const connectionList of this.connections.values()) {
      for (const connection of connectionList) {
        tasks.push((async () => {
          try {
            await connection.close();
          } catch (err) {
            this.log.error(err);
          }
        })());
      }
    }
    this.log("closing %d connections", tasks.length);
    await Promise.all(tasks);
    this.connections.clear();
    this.log("stopped");
  }
  getMaxConnections() {
    return this.maxConnections;
  }
  setMaxConnections(maxConnections) {
    if (this.maxConnections < 1) {
      throw new InvalidParametersError("Connection Manager maxConnections must be greater than 0");
    }
    let needsPrune = false;
    if (maxConnections < this.maxConnections) {
      needsPrune = true;
    }
    this.maxConnections = maxConnections;
    if (needsPrune) {
      this.connectionPruner.maybePruneConnections();
    }
  }
  onConnect(evt) {
    void this._onConnect(evt).catch((err) => {
      this.log.error(err);
    });
  }
  /**
   * Tracks the incoming connection and check the connection limit
   */
  async _onConnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      await connection.close();
      return;
    }
    if (connection.status !== "open") {
      return;
    }
    const peerId2 = connection.remotePeer;
    const isNewPeer = !this.connections.has(peerId2);
    const storedConns = this.connections.get(peerId2) ?? [];
    storedConns.push(connection);
    this.connections.set(peerId2, storedConns);
    if (peerId2.publicKey != null && peerId2.type === "RSA") {
      await this.peerStore.patch(peerId2, {
        publicKey: peerId2.publicKey
      });
    }
    if (isNewPeer) {
      this.events.safeDispatchEvent("peer:connect", { detail: connection.remotePeer });
    }
  }
  /**
   * Removes the connection from tracking
   */
  onDisconnect(evt) {
    const { detail: connection } = evt;
    const peerId2 = connection.remotePeer;
    const peerConns = this.connections.get(peerId2) ?? [];
    const filteredPeerConns = peerConns.filter((conn) => conn.id !== connection.id);
    this.connections.set(peerId2, filteredPeerConns);
    if (filteredPeerConns.length === 0) {
      this.log("onDisconnect remove all connections for peer %p", peerId2);
      this.connections.delete(peerId2);
      this.events.safeDispatchEvent("peer:disconnect", { detail: connection.remotePeer });
    }
  }
  getConnections(peerId2) {
    if (peerId2 != null) {
      return this.connections.get(peerId2) ?? [];
    }
    let conns = [];
    for (const c2 of this.connections.values()) {
      conns = conns.concat(c2);
    }
    return conns;
  }
  getConnectionsMap() {
    return this.connections;
  }
  async openConnection(peerIdOrMultiaddr, options = {}) {
    var _a27, _b14;
    if (!this.started) {
      throw new NotStartedError("Not started");
    }
    this.outboundPendingConnections++;
    try {
      (_a27 = options.signal) == null ? void 0 : _a27.throwIfAborted();
      const { peerId: peerId2 } = getPeerAddress(peerIdOrMultiaddr);
      if (this.peerId.equals(peerId2)) {
        throw new InvalidPeerIdError("Can not dial self");
      }
      if (peerId2 != null && options.force !== true) {
        this.log("dial %p", peerId2);
        const existingConnection = this.getConnections(peerId2).find((conn) => conn.limits == null);
        if (existingConnection != null) {
          this.log("had an existing non-limited connection to %p", peerId2);
          (_b14 = options.onProgress) == null ? void 0 : _b14.call(options, new CustomProgressEvent("dial-queue:already-connected"));
          return existingConnection;
        }
      }
      const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {
        ...options,
        priority: options.priority ?? DEFAULT_DIAL_PRIORITY
      });
      if (connection.status !== "open") {
        throw new ConnectionClosedError("Remote closed connection during opening");
      }
      let peerConnections = this.connections.get(connection.remotePeer);
      if (peerConnections == null) {
        peerConnections = [];
        this.connections.set(connection.remotePeer, peerConnections);
      }
      let trackedConnection = false;
      for (const conn of peerConnections) {
        if (conn.id === connection.id) {
          trackedConnection = true;
        }
        if (options.force !== true && conn.id !== connection.id && conn.remoteAddr.equals(connection.remoteAddr)) {
          connection.abort(new InvalidMultiaddrError("Duplicate multiaddr connection"));
          return conn;
        }
      }
      if (!trackedConnection) {
        peerConnections.push(connection);
      }
      return connection;
    } finally {
      this.outboundPendingConnections--;
    }
  }
  async closeConnections(peerId2, options = {}) {
    const connections = this.connections.get(peerId2) ?? [];
    await Promise.all(connections.map(async (connection) => {
      try {
        await connection.close(options);
      } catch (err) {
        connection.abort(err);
      }
    }));
  }
  async acceptIncomingConnection(maConn) {
    const denyConnection = this.deny.some((ma) => {
      return ma.contains(maConn.remoteAddr.nodeAddress().address);
    });
    if (denyConnection) {
      this.log("connection from %a refused - connection remote address was in deny list", maConn.remoteAddr);
      return false;
    }
    const allowConnection = this.allow.some((ipNet) => {
      return ipNet.contains(maConn.remoteAddr.nodeAddress().address);
    });
    if (allowConnection) {
      this.incomingPendingConnections++;
      return true;
    }
    if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {
      this.log("connection from %a refused - incomingPendingConnections exceeded by host", maConn.remoteAddr);
      return false;
    }
    if (maConn.remoteAddr.isThinWaistAddress()) {
      const host = maConn.remoteAddr.nodeAddress().address;
      try {
        await this.inboundConnectionRateLimiter.consume(host, 1);
      } catch {
        this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s", maConn.remoteAddr, host);
        return false;
      }
    }
    if (this.getConnections().length < this.maxConnections) {
      this.incomingPendingConnections++;
      return true;
    }
    this.log("connection from %a refused - maxConnections exceeded", maConn.remoteAddr);
    return false;
  }
  afterUpgradeInbound() {
    this.incomingPendingConnections--;
  }
  getDialQueue() {
    const statusMap = {
      queued: "queued",
      running: "active",
      errored: "error",
      complete: "success"
    };
    return this.dialQueue.queue.queue.map((job) => {
      return {
        id: job.id,
        status: statusMap[job.status],
        peerId: job.options.peerId,
        multiaddrs: [...job.options.multiaddrs].map((ma) => multiaddr(ma))
      };
    });
  }
  async isDialable(multiaddr2, options = {}) {
    return this.dialQueue.isDialable(multiaddr2, options);
  }
};

// node_modules/@libp2p/utils/dist/src/moving-average.js
var MovingAverage = class {
  constructor(timeSpan) {
    __publicField(this, "movingAverage");
    __publicField(this, "variance");
    __publicField(this, "deviation");
    __publicField(this, "forecast");
    __publicField(this, "timeSpan");
    __publicField(this, "previousTime");
    this.timeSpan = timeSpan;
    this.movingAverage = 0;
    this.variance = 0;
    this.deviation = 0;
    this.forecast = 0;
  }
  alpha(t2, pt) {
    return 1 - Math.exp(-(t2 - pt) / this.timeSpan);
  }
  push(value, time = Date.now()) {
    if (this.previousTime != null) {
      const a2 = this.alpha(time, this.previousTime);
      const diff = value - this.movingAverage;
      const incr = a2 * diff;
      this.movingAverage = a2 * value + (1 - a2) * this.movingAverage;
      this.variance = (1 - a2) * (this.variance + diff * incr);
      this.deviation = Math.sqrt(this.variance);
      this.forecast = this.movingAverage + a2 * diff;
    } else {
      this.movingAverage = value;
    }
    this.previousTime = time;
  }
};

// node_modules/@libp2p/utils/dist/src/adaptive-timeout.js
var DEFAULT_TIMEOUT_MULTIPLIER = 1.2;
var DEFAULT_FAILURE_MULTIPLIER = 2;
var DEFAULT_MIN_TIMEOUT = 5e3;
var DEFAULT_MAX_TIMEOUT = 6e4;
var DEFAULT_INTERVAL = 5e3;
var AdaptiveTimeout = class {
  constructor(init = {}) {
    __publicField(this, "success");
    __publicField(this, "failure");
    __publicField(this, "next");
    __publicField(this, "metric");
    __publicField(this, "timeoutMultiplier");
    __publicField(this, "failureMultiplier");
    __publicField(this, "minTimeout");
    __publicField(this, "maxTimeout");
    var _a27;
    const interval = init.interval ?? DEFAULT_INTERVAL;
    this.success = new MovingAverage(interval);
    this.failure = new MovingAverage(interval);
    this.next = new MovingAverage(interval);
    this.failureMultiplier = init.failureMultiplier ?? DEFAULT_FAILURE_MULTIPLIER;
    this.timeoutMultiplier = init.timeoutMultiplier ?? DEFAULT_TIMEOUT_MULTIPLIER;
    this.minTimeout = init.minTimeout ?? DEFAULT_MIN_TIMEOUT;
    this.maxTimeout = init.maxTimeout ?? DEFAULT_MAX_TIMEOUT;
    if (init.metricName != null) {
      this.metric = (_a27 = init.metrics) == null ? void 0 : _a27.registerMetricGroup(init.metricName);
    }
  }
  getTimeoutSignal(options = {}) {
    let timeout2 = Math.round(this.next.movingAverage * (options.timeoutFactor ?? this.timeoutMultiplier));
    if (timeout2 < this.minTimeout) {
      timeout2 = this.minTimeout;
    }
    if (timeout2 > this.maxTimeout) {
      timeout2 = this.maxTimeout;
    }
    const sendTimeout = AbortSignal.timeout(timeout2);
    const timeoutSignal = anySignal([options.signal, sendTimeout]);
    setMaxListeners(Infinity, timeoutSignal, sendTimeout);
    timeoutSignal.start = Date.now();
    timeoutSignal.timeout = timeout2;
    return timeoutSignal;
  }
  cleanUp(signal) {
    var _a27, _b14;
    const time = Date.now() - signal.start;
    if (signal.aborted) {
      this.failure.push(time);
      this.next.push(time * this.failureMultiplier);
      (_a27 = this.metric) == null ? void 0 : _a27.update({
        failureMovingAverage: this.failure.movingAverage,
        failureDeviation: this.failure.deviation,
        failureForecast: this.failure.forecast,
        failureVariance: this.failure.variance,
        failure: time
      });
    } else {
      this.success.push(time);
      this.next.push(time);
      (_b14 = this.metric) == null ? void 0 : _b14.update({
        successMovingAverage: this.success.movingAverage,
        successDeviation: this.success.deviation,
        successForecast: this.success.forecast,
        successVariance: this.success.variance,
        success: time
      });
    }
  }
};

// node_modules/libp2p/dist/src/connection-monitor.js
var DEFAULT_PING_INTERVAL_MS = 1e4;
var PROTOCOL_VERSION2 = "1.0.0";
var PROTOCOL_NAME2 = "ping";
var PROTOCOL_PREFIX2 = "ipfs";
var PING_LENGTH2 = 32;
var DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE = true;
var _a17, _b10;
_b10 = Symbol.toStringTag, _a17 = serviceCapabilities;
var ConnectionMonitor = class {
  constructor(components, init = {}) {
    __publicField(this, "protocol");
    __publicField(this, "components");
    __publicField(this, "log");
    __publicField(this, "heartbeatInterval");
    __publicField(this, "pingIntervalMs");
    __publicField(this, "abortController");
    __publicField(this, "timeout");
    __publicField(this, "abortConnectionOnPingFailure");
    __publicField(this, _b10, "@libp2p/connection-monitor");
    __publicField(this, _a17, [
      "@libp2p/connection-monitor"
    ]);
    this.components = components;
    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX2}/${PROTOCOL_NAME2}/${PROTOCOL_VERSION2}`;
    this.log = components.logger.forComponent("libp2p:connection-monitor");
    this.pingIntervalMs = init.pingInterval ?? DEFAULT_PING_INTERVAL_MS;
    this.abortConnectionOnPingFailure = init.abortConnectionOnPingFailure ?? DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE;
    this.timeout = new AdaptiveTimeout({
      ...init.pingTimeout ?? {},
      metrics: components.metrics,
      metricName: "libp2p_connection_monitor_ping_time_milliseconds"
    });
  }
  start() {
    this.abortController = new AbortController();
    setMaxListeners(Infinity, this.abortController.signal);
    this.heartbeatInterval = setInterval(() => {
      this.components.connectionManager.getConnections().forEach((conn) => {
        Promise.resolve().then(async () => {
          var _a27;
          let start2 = Date.now();
          try {
            const signal = this.timeout.getTimeoutSignal({
              signal: (_a27 = this.abortController) == null ? void 0 : _a27.signal
            });
            const stream = await conn.newStream(this.protocol, {
              signal,
              runOnLimitedConnection: true
            });
            const bs = byteStream(stream);
            start2 = Date.now();
            await Promise.all([
              bs.write(randomBytes3(PING_LENGTH2), {
                signal
              }),
              bs.read({
                bytes: PING_LENGTH2,
                signal
              })
            ]);
            conn.rtt = Date.now() - start2;
            await bs.unwrap().close({
              signal
            });
          } catch (err) {
            if (err.name !== "UnsupportedProtocolError") {
              throw err;
            }
            conn.rtt = (Date.now() - start2) / 2;
          }
        }).catch((err) => {
          this.log.error("error during heartbeat", err);
          if (this.abortConnectionOnPingFailure) {
            this.log.error("aborting connection due to ping failure");
            conn.abort(err);
          } else {
            this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag");
          }
        });
      });
    }, this.pingIntervalMs);
  }
  stop() {
    var _a27;
    (_a27 = this.abortController) == null ? void 0 : _a27.abort();
    if (this.heartbeatInterval != null) {
      clearInterval(this.heartbeatInterval);
    }
  }
};

// node_modules/libp2p/dist/src/content-routing.js
var _a18;
_a18 = Symbol.toStringTag;
var CompoundContentRouting = class {
  constructor(components, init) {
    __publicField(this, "routers");
    __publicField(this, "started");
    __publicField(this, "components");
    __publicField(this, _a18, "@libp2p/content-routing");
    var _a27, _b14, _c3, _d2, _e;
    this.routers = init.routers ?? [];
    this.started = false;
    this.components = components;
    this.findProviders = ((_a27 = components.metrics) == null ? void 0 : _a27.traceFunction("libp2p.contentRouting.findProviders", this.findProviders.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([cid], attrs) => {
        return {
          ...attrs,
          cid: cid.toString()
        };
      },
      getAttributesFromYieldedValue: (value, attrs) => {
        return {
          ...attrs,
          providers: [...Array.isArray(attrs.providers) ? attrs.providers : [], value.id.toString()]
        };
      }
    })) ?? this.findProviders;
    this.provide = ((_b14 = components.metrics) == null ? void 0 : _b14.traceFunction("libp2p.contentRouting.provide", this.provide.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([cid], attrs) => {
        return {
          ...attrs,
          cid: cid.toString()
        };
      }
    })) ?? this.provide;
    this.cancelReprovide = ((_c3 = components.metrics) == null ? void 0 : _c3.traceFunction("libp2p.contentRouting.cancelReprovide", this.cancelReprovide.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([cid], attrs) => {
        return {
          ...attrs,
          cid: cid.toString()
        };
      }
    })) ?? this.cancelReprovide;
    this.put = ((_d2 = components.metrics) == null ? void 0 : _d2.traceFunction("libp2p.contentRouting.put", this.put.bind(this), {
      optionsIndex: 2,
      getAttributesFromArgs: ([key]) => {
        return {
          key: toString2(key, "base36")
        };
      }
    })) ?? this.put;
    this.get = ((_e = components.metrics) == null ? void 0 : _e.traceFunction("libp2p.contentRouting.get", this.get.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([key]) => {
        return {
          key: toString2(key, "base36")
        };
      }
    })) ?? this.get;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
  }
  /**
   * Iterates over all content routers in parallel to find providers of the given key
   */
  async *findProviders(key, options = {}) {
    if (this.routers.length === 0) {
      throw new NoContentRoutersError("No content routers available");
    }
    const self2 = this;
    const seen = new PeerSet();
    for await (const peer of src_default2(...self2.routers.filter((router) => router.findProviders instanceof Function).map((router) => router.findProviders(key, options)))) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.components.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        }, options);
      }
      if (seen.has(peer.id)) {
        continue;
      }
      seen.add(peer.id);
      yield peer;
    }
  }
  /**
   * Iterates over all content routers in parallel to notify it is
   * a provider of the given key
   */
  async provide(key, options = {}) {
    if (this.routers.length === 0) {
      throw new NoContentRoutersError("No content routers available");
    }
    await Promise.all(this.routers.filter((router) => router.provide instanceof Function).map(async (router) => {
      await router.provide(key, options);
    }));
  }
  async cancelReprovide(key, options = {}) {
    if (this.routers.length === 0) {
      throw new NoContentRoutersError("No content routers available");
    }
    await Promise.all(this.routers.filter((router) => router.cancelReprovide instanceof Function).map(async (router) => {
      await router.cancelReprovide(key, options);
    }));
  }
  /**
   * Store the given key/value pair in the available content routings
   */
  async put(key, value, options) {
    if (!this.isStarted()) {
      throw new NotStartedError();
    }
    await Promise.all(this.routers.filter((router) => router.put instanceof Function).map(async (router) => {
      await router.put(key, value, options);
    }));
  }
  /**
   * Get the value to the given key.
   * Times out after 1 minute by default.
   */
  async get(key, options) {
    if (!this.isStarted()) {
      throw new NotStartedError();
    }
    return Promise.any(this.routers.filter((router) => router.get instanceof Function).map(async (router) => {
      return router.get(key, options);
    }));
  }
};

// node_modules/libp2p/dist/src/peer-routing.js
var _a19;
_a19 = Symbol.toStringTag;
var DefaultPeerRouting = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "peerId");
    __publicField(this, "peerStore");
    __publicField(this, "routers");
    __publicField(this, _a19, "@libp2p/peer-routing");
    var _a27, _b14;
    this.log = components.logger.forComponent("libp2p:peer-routing");
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.routers = init.routers ?? [];
    this.findPeer = ((_a27 = components.metrics) == null ? void 0 : _a27.traceFunction("libp2p.peerRouting.findPeer", this.findPeer.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([peer], attrs) => {
        return {
          ...attrs,
          peer: peer.toString()
        };
      }
    })) ?? this.findPeer;
    this.getClosestPeers = ((_b14 = components.metrics) == null ? void 0 : _b14.traceFunction("libp2p.peerRouting.getClosestPeers", this.getClosestPeers.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([key], attrs) => {
        return {
          ...attrs,
          key: toString2(key, "base36")
        };
      },
      getAttributesFromYieldedValue: (value, attrs) => {
        return {
          ...attrs,
          peers: [...Array.isArray(attrs.peers) ? attrs.peers : [], value.id.toString()]
        };
      }
    })) ?? this.getClosestPeers;
  }
  /**
   * Iterates over all peer routers in parallel to find the given peer
   */
  async findPeer(id, options) {
    if (this.routers.length === 0) {
      throw new NoPeerRoutersError("No peer routers available");
    }
    if (id.toString() === this.peerId.toString()) {
      throw new QueriedForSelfError("Should not try to find self");
    }
    const self2 = this;
    const source = src_default2(...this.routers.filter((router) => router.findPeer instanceof Function).map((router) => async function* () {
      try {
        yield await router.findPeer(id, options);
      } catch (err) {
        self2.log.error(err);
      }
    }()));
    for await (const peer of source) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        }, options);
      }
      return peer;
    }
    throw new NotFoundError();
  }
  /**
   * Attempt to find the closest peers on the network to the given key
   */
  async *getClosestPeers(key, options = {}) {
    if (this.routers.length === 0) {
      throw new NoPeerRoutersError("No peer routers available");
    }
    const self2 = this;
    const seen = createScalableCuckooFilter(1024);
    for await (const peer of parallel(async function* () {
      const source = src_default2(...self2.routers.filter((router) => router.getClosestPeers instanceof Function).map((router) => router.getClosestPeers(key, options)));
      for await (let peer2 of source) {
        yield async () => {
          if (peer2.multiaddrs.length === 0) {
            try {
              peer2 = await self2.findPeer(peer2.id, {
                ...options,
                useCache: false
              });
            } catch (err) {
              self2.log.error("could not find peer multiaddrs", err);
              return;
            }
          }
          return peer2;
        };
      }
    }())) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        }, options);
      }
      if (seen.has(peer.id.toMultihash().bytes)) {
        continue;
      }
      seen.add(peer.id.toMultihash().bytes);
      yield peer;
    }
  }
};

// node_modules/libp2p/dist/src/random-walk.js
var _a20, _b11;
var RandomWalk = class extends (_b11 = TypedEventEmitter, _a20 = Symbol.toStringTag, _b11) {
  constructor(components) {
    super();
    __publicField(this, "peerRouting");
    __publicField(this, "log");
    __publicField(this, "walking");
    __publicField(this, "walkers");
    __publicField(this, "shutdownController");
    __publicField(this, "walkController");
    __publicField(this, "needNext");
    __publicField(this, _a20, "@libp2p/random-walk");
    this.log = components.logger.forComponent("libp2p:random-walk");
    this.peerRouting = components.peerRouting;
    this.walkers = 0;
    this.walking = false;
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
  }
  start() {
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
  }
  stop() {
    this.shutdownController.abort();
  }
  async *walk(options) {
    var _a27, _b14;
    if (!this.walking) {
      this.startWalk();
    }
    this.walkers++;
    const signal = anySignal([this.shutdownController.signal, options == null ? void 0 : options.signal]);
    setMaxListeners(Infinity, signal);
    try {
      while (true) {
        (_a27 = this.needNext) == null ? void 0 : _a27.resolve();
        this.needNext = pDefer();
        const event = await raceEvent(this, "walk:peer", signal, {
          errorEvent: "walk:error"
        });
        yield event.detail;
      }
    } finally {
      signal.clear();
      this.walkers--;
      if (this.walkers === 0) {
        (_b14 = this.walkController) == null ? void 0 : _b14.abort();
        this.walkController = void 0;
      }
    }
  }
  startWalk() {
    this.walking = true;
    this.walkController = new AbortController();
    setMaxListeners(Infinity, this.walkController.signal);
    const signal = anySignal([this.walkController.signal, this.shutdownController.signal]);
    setMaxListeners(Infinity, signal);
    const start2 = Date.now();
    let found = 0;
    Promise.resolve().then(async () => {
      this.log("start walk");
      while (this.walkers > 0) {
        try {
          const data = randomBytes3(32);
          let s2 = Date.now();
          for await (const peer of this.peerRouting.getClosestPeers(data, { signal })) {
            if (signal.aborted) {
              this.log("aborting walk");
            }
            signal.throwIfAborted();
            this.log("found peer %p after %dms for %d walkers", peer.id, Date.now() - s2, this.walkers);
            found++;
            this.safeDispatchEvent("walk:peer", {
              detail: peer
            });
            if (this.walkers === 1 && this.needNext != null) {
              this.log("wait for need next");
              await raceSignal3(this.needNext.promise, signal);
            }
            s2 = Date.now();
          }
          this.log("walk iteration for %b and %d walkers finished, found %d peers", data, this.walkers, found);
        } catch (err) {
          this.log.error("random walk errored", err);
          this.safeDispatchEvent("walk:error", {
            detail: err
          });
        }
      }
      this.log("no walkers left, ended walk");
    }).catch((err) => {
      this.log.error("random walk errored", err);
    }).finally(() => {
      this.log("finished walk, found %d peers after %dms", found, Date.now() - start2);
      this.walking = false;
    });
  }
};

// node_modules/libp2p/dist/src/registrar.js
var DEFAULT_MAX_INBOUND_STREAMS = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS = 64;
var _a21;
_a21 = Symbol.toStringTag;
var Registrar = class {
  constructor(components) {
    __publicField(this, "log");
    __publicField(this, "topologies");
    __publicField(this, "handlers");
    __publicField(this, "components");
    __publicField(this, _a21, "@libp2p/registrar");
    var _a27;
    this.components = components;
    this.log = components.logger.forComponent("libp2p:registrar");
    this.topologies = /* @__PURE__ */ new Map();
    (_a27 = components.metrics) == null ? void 0 : _a27.registerMetricGroup("libp2p_registrar_topologies", {
      calculate: () => {
        const output = {};
        for (const [key, value] of this.topologies) {
          output[key] = value.size;
        }
        return output;
      }
    });
    this.handlers = trackedMap({
      name: "libp2p_registrar_protocol_handlers",
      metrics: components.metrics
    });
    this._onDisconnect = this._onDisconnect.bind(this);
    this._onPeerUpdate = this._onPeerUpdate.bind(this);
    this._onPeerIdentify = this._onPeerIdentify.bind(this);
    this.components.events.addEventListener("peer:disconnect", this._onDisconnect);
    this.components.events.addEventListener("peer:update", this._onPeerUpdate);
    this.components.events.addEventListener("peer:identify", this._onPeerIdentify);
  }
  getProtocols() {
    return Array.from(/* @__PURE__ */ new Set([
      ...this.handlers.keys()
    ])).sort();
  }
  getHandler(protocol) {
    const handler = this.handlers.get(protocol);
    if (handler == null) {
      throw new UnhandledProtocolError(`No handler registered for protocol ${protocol}`);
    }
    return handler;
  }
  getTopologies(protocol) {
    const topologies = this.topologies.get(protocol);
    if (topologies == null) {
      return [];
    }
    return [
      ...topologies.values()
    ];
  }
  /**
   * Registers the `handler` for each protocol
   */
  async handle(protocol, handler, opts) {
    if (this.handlers.has(protocol) && (opts == null ? void 0 : opts.force) !== true) {
      throw new DuplicateProtocolHandlerError(`Handler already registered for protocol ${protocol}`);
    }
    const options = mergeOptions.bind({ ignoreUndefined: true })({
      maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,
      maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS
    }, opts);
    this.handlers.set(protocol, {
      handler,
      options
    });
    await this.components.peerStore.merge(this.components.peerId, {
      protocols: [protocol]
    }, opts);
  }
  /**
   * Removes the handler for each protocol. The protocol
   * will no longer be supported on streams.
   */
  async unhandle(protocols2, options) {
    const protocolList = Array.isArray(protocols2) ? protocols2 : [protocols2];
    protocolList.forEach((protocol) => {
      this.handlers.delete(protocol);
    });
    await this.components.peerStore.patch(this.components.peerId, {
      protocols: this.getProtocols()
    }, options);
  }
  /**
   * Register handlers for a set of multicodecs given
   */
  async register(protocol, topology) {
    if (topology == null) {
      throw new InvalidParametersError("invalid topology");
    }
    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
    let topologies = this.topologies.get(protocol);
    if (topologies == null) {
      topologies = /* @__PURE__ */ new Map();
      this.topologies.set(protocol, topologies);
    }
    topologies.set(id, topology);
    return id;
  }
  /**
   * Unregister topology
   */
  unregister(id) {
    for (const [protocol, topologies] of this.topologies.entries()) {
      if (topologies.has(id)) {
        topologies.delete(id);
        if (topologies.size === 0) {
          this.topologies.delete(protocol);
        }
      }
    }
  }
  /**
   * Remove a disconnected peer from the record
   */
  _onDisconnect(evt) {
    const remotePeer = evt.detail;
    const options = {
      signal: AbortSignal.timeout(5e3)
    };
    void this.components.peerStore.get(remotePeer, options).then((peer) => {
      var _a27, _b14, _c3;
      for (const protocol of peer.protocols) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        for (const topology of topologies.values()) {
          if (((_a27 = topology.filter) == null ? void 0 : _a27.has(remotePeer)) === false) {
            continue;
          }
          (_b14 = topology.filter) == null ? void 0 : _b14.remove(remotePeer);
          (_c3 = topology.onDisconnect) == null ? void 0 : _c3.call(topology, remotePeer);
        }
      }
    }).catch((err) => {
      if (err.name === "NotFoundError") {
        return;
      }
      this.log.error("could not inform topologies of disconnecting peer %p", remotePeer, err);
    });
  }
  /**
   * When a peer is updated, if they have removed supported protocols notify any
   * topologies interested in the removed protocols.
   */
  _onPeerUpdate(evt) {
    var _a27, _b14, _c3;
    const { peer, previous } = evt.detail;
    const removed = ((previous == null ? void 0 : previous.protocols) ?? []).filter((protocol) => !peer.protocols.includes(protocol));
    for (const protocol of removed) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        if (((_a27 = topology.filter) == null ? void 0 : _a27.has(peer.id)) === false) {
          continue;
        }
        (_b14 = topology.filter) == null ? void 0 : _b14.remove(peer.id);
        (_c3 = topology.onDisconnect) == null ? void 0 : _c3.call(topology, peer.id);
      }
    }
  }
  /**
   * After identify has completed and we have received the list of supported
   * protocols, notify any topologies interested in those protocols.
   */
  _onPeerIdentify(evt) {
    var _a27, _b14, _c3;
    const protocols2 = evt.detail.protocols;
    const connection = evt.detail.connection;
    const peerId2 = evt.detail.peerId;
    for (const protocol of protocols2) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        if (connection.limits != null && topology.notifyOnLimitedConnection !== true) {
          continue;
        }
        if (((_a27 = topology.filter) == null ? void 0 : _a27.has(peerId2)) === true) {
          continue;
        }
        (_b14 = topology.filter) == null ? void 0 : _b14.add(peerId2);
        (_c3 = topology.onConnect) == null ? void 0 : _c3.call(topology, peerId2, connection);
      }
    }
  }
};

// node_modules/libp2p/dist/src/transport-manager.js
var _a22;
_a22 = Symbol.toStringTag;
var DefaultTransportManager = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "components");
    __publicField(this, "transports");
    __publicField(this, "listeners");
    __publicField(this, "faultTolerance");
    __publicField(this, "started");
    __publicField(this, _a22, "@libp2p/transport-manager");
    this.log = components.logger.forComponent("libp2p:transports");
    this.components = components;
    this.started = false;
    this.transports = trackedMap({
      name: "libp2p_transport_manager_transports",
      metrics: this.components.metrics
    });
    this.listeners = trackedMap({
      name: "libp2p_transport_manager_listeners",
      metrics: this.components.metrics
    });
    this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL;
  }
  /**
   * Adds a `Transport` to the manager
   */
  add(transport) {
    const tag = transport[Symbol.toStringTag];
    if (tag == null) {
      throw new InvalidParametersError("Transport must have a valid tag");
    }
    if (this.transports.has(tag)) {
      throw new InvalidParametersError(`There is already a transport with the tag ${tag}`);
    }
    this.log("adding transport %s", tag);
    this.transports.set(tag, transport);
    if (!this.listeners.has(tag)) {
      this.listeners.set(tag, []);
    }
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  async afterStart() {
    const addrs = this.components.addressManager.getListenAddrs();
    await this.listen(addrs);
  }
  /**
   * Stops all listeners
   */
  async stop() {
    const tasks = [];
    for (const [key, listeners] of this.listeners) {
      this.log("closing listeners for %s", key);
      while (listeners.length > 0) {
        const listener = listeners.pop();
        if (listener == null) {
          continue;
        }
        tasks.push(listener.close());
      }
    }
    await Promise.all(tasks);
    this.log("all listeners closed");
    for (const key of this.listeners.keys()) {
      this.listeners.set(key, []);
    }
    this.started = false;
  }
  /**
   * Dials the given Multiaddr over it's supported transport
   */
  async dial(ma, options) {
    var _a27;
    const transport = this.dialTransportForMultiaddr(ma);
    if (transport == null) {
      throw new TransportUnavailableError(`No transport available for address ${String(ma)}`);
    }
    (_a27 = options == null ? void 0 : options.onProgress) == null ? void 0 : _a27.call(options, new CustomProgressEvent("transport-manager:selected-transport", transport[Symbol.toStringTag]));
    return transport.dial(ma, {
      ...options,
      upgrader: this.components.upgrader
    });
  }
  /**
   * Returns all Multiaddr's the listeners are using
   */
  getAddrs() {
    let addrs = [];
    for (const listeners of this.listeners.values()) {
      for (const listener of listeners) {
        addrs = [...addrs, ...listener.getAddrs()];
      }
    }
    return addrs;
  }
  /**
   * Returns all the transports instances
   */
  getTransports() {
    return Array.of(...this.transports.values());
  }
  /**
   * Returns all the listener instances
   */
  getListeners() {
    return Array.of(...this.listeners.values()).flat();
  }
  /**
   * Finds a transport that matches the given Multiaddr
   */
  dialTransportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.dialFilter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  /**
   * Finds a transport that matches the given Multiaddr
   */
  listenTransportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.listenFilter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  /**
   * Starts listeners for each listen Multiaddr
   */
  async listen(addrs) {
    if (!this.isStarted()) {
      throw new NotStartedError("Not started");
    }
    if (addrs == null || addrs.length === 0) {
      this.log("no addresses were provided for listening, this node is dial only");
      return;
    }
    const listenStats = {
      errors: /* @__PURE__ */ new Map(),
      ipv4: {
        success: 0,
        attempts: 0
      },
      ipv6: {
        success: 0,
        attempts: 0
      }
    };
    addrs.forEach((ma) => {
      listenStats.errors.set(ma.toString(), new UnsupportedListenAddressError());
    });
    const tasks = [];
    for (const [key, transport] of this.transports.entries()) {
      const supportedAddrs = transport.listenFilter(addrs);
      for (const addr of supportedAddrs) {
        this.log("creating listener for %s on %a", key, addr);
        const listener = transport.createListener({
          upgrader: this.components.upgrader
        });
        let listeners = this.listeners.get(key) ?? [];
        if (listeners == null) {
          listeners = [];
          this.listeners.set(key, listeners);
        }
        listeners.push(listener);
        listener.addEventListener("listening", () => {
          this.components.events.safeDispatchEvent("transport:listening", {
            detail: listener
          });
        });
        listener.addEventListener("close", () => {
          const index = listeners.findIndex((l2) => l2 === listener);
          listeners.splice(index, 1);
          this.components.events.safeDispatchEvent("transport:close", {
            detail: listener
          });
        });
        if (IP4.matches(addr)) {
          listenStats.ipv4.attempts++;
        } else if (IP6.matches(addr)) {
          listenStats.ipv6.attempts++;
        }
        tasks.push(listener.listen(addr).then(() => {
          listenStats.errors.delete(addr.toString());
          if (IP4.matches(addr)) {
            listenStats.ipv4.success++;
          }
          if (IP6.matches(addr)) {
            listenStats.ipv6.success++;
          }
        }, (err) => {
          this.log.error("transport %s could not listen on address %a - %e", key, addr, err);
          listenStats.errors.set(addr.toString(), err);
          throw err;
        }));
      }
    }
    const results = await Promise.allSettled(tasks);
    if (results.length > 0 && results.every((res) => res.status === "fulfilled")) {
      return;
    }
    if (this.ipv6Unsupported(listenStats)) {
      this.log("all IPv4 addresses succeed but all IPv6 failed");
      return;
    }
    if (this.faultTolerance === FaultTolerance.NO_FATAL) {
      this.log("failed to listen on any address but fault tolerance allows this");
      return;
    }
    throw new UnsupportedListenAddressesError(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...listenStats.errors.entries()].map(([addr, err]) => {
      return `
  ${addr}: ${`${err.stack ?? err}`.split("\n").join("\n  ")}
`;
    }).join("")}`);
  }
  ipv6Unsupported(listenStats) {
    if (listenStats.ipv4.attempts === 0 || listenStats.ipv6.attempts === 0) {
      return false;
    }
    const allIpv4Succeeded = listenStats.ipv4.attempts === listenStats.ipv4.success;
    const allIpv6Failed = listenStats.ipv6.success === 0;
    return allIpv4Succeeded && allIpv6Failed;
  }
  /**
   * Removes the given transport from the manager.
   * If a transport has any running listeners, they will be closed.
   */
  async remove(key) {
    const listeners = this.listeners.get(key) ?? [];
    this.log.trace("removing transport %s", key);
    const tasks = [];
    this.log.trace("closing listeners for %s", key);
    while (listeners.length > 0) {
      const listener = listeners.pop();
      if (listener == null) {
        continue;
      }
      tasks.push(listener.close());
    }
    await Promise.all(tasks);
    this.transports.delete(key);
    this.listeners.delete(key);
  }
  /**
   * Removes all transports from the manager.
   * If any listeners are running, they will be closed.
   *
   * @async
   */
  async removeAll() {
    const tasks = [];
    for (const key of this.transports.keys()) {
      tasks.push(this.remove(key));
    }
    await Promise.all(tasks);
  }
};

// node_modules/@libp2p/multistream-select/dist/src/constants.js
var PROTOCOL_ID = "/multistream/1.0.0";
var MAX_PROTOCOL_LENGTH = 1024;

// node_modules/@libp2p/multistream-select/dist/src/multistream.js
var NewLine = fromString2("\n");
async function write2(writer, buffer, options) {
  await writer.write(buffer, options);
}
async function writeAll(writer, buffers, options) {
  await writer.writeV(buffers, options);
}
async function read3(reader, options) {
  const buf = await reader.read(options);
  if (buf.byteLength === 0 || buf.get(buf.byteLength - 1) !== NewLine[0]) {
    options.log.error("Invalid mss message - missing newline", buf);
    throw new InvalidMessageError("Missing newline");
  }
  return buf.sublist(0, -1);
}
async function readString(reader, options) {
  const buf = await read3(reader, options);
  return toString2(buf.subarray());
}

// node_modules/@libp2p/multistream-select/dist/src/select.js
async function select(stream, protocols2, options) {
  protocols2 = Array.isArray(protocols2) ? [...protocols2] : [protocols2];
  if (protocols2.length === 1 && options.negotiateFully === false) {
    return optimisticSelect(stream, protocols2[0], options);
  }
  const lp = lpStream(stream, {
    ...options,
    maxDataLength: MAX_PROTOCOL_LENGTH
  });
  const protocol = protocols2.shift();
  if (protocol == null) {
    throw new Error("At least one protocol must be specified");
  }
  options.log.trace('select: write ["%s", "%s"]', PROTOCOL_ID, protocol);
  const p1 = fromString2(`${PROTOCOL_ID}
`);
  const p2 = fromString2(`${protocol}
`);
  await writeAll(lp, [p1, p2], options);
  options.log.trace("select: reading multistream-select header");
  let response = await readString(lp, options);
  options.log.trace('select: read "%s"', response);
  if (response === PROTOCOL_ID) {
    options.log.trace("select: reading protocol response");
    response = await readString(lp, options);
    options.log.trace('select: read "%s"', response);
  }
  if (response === protocol) {
    return { stream: lp.unwrap(), protocol };
  }
  for (const protocol2 of protocols2) {
    options.log.trace('select: write "%s"', protocol2);
    await write2(lp, fromString2(`${protocol2}
`), options);
    options.log.trace("select: reading protocol response");
    const response2 = await readString(lp, options);
    options.log.trace('select: read "%s" for "%s"', response2, protocol2);
    if (response2 === protocol2) {
      return { stream: lp.unwrap(), protocol: protocol2 };
    }
  }
  throw new UnsupportedProtocolError("protocol selection failed");
}
function optimisticSelect(stream, protocol, options) {
  const originalSink = stream.sink.bind(stream);
  const originalSource = stream.source;
  let negotiated = false;
  let negotiating = false;
  const doneNegotiating = pDefer();
  let sentProtocol = false;
  let sendingProtocol = false;
  const doneSendingProtocol = pDefer();
  let readProtocol = false;
  let readingProtocol = false;
  const doneReadingProtocol = pDefer();
  const lp = lpStream({
    sink: originalSink,
    source: originalSource
  }, {
    ...options,
    maxDataLength: MAX_PROTOCOL_LENGTH
  });
  stream.sink = async (source) => {
    const { sink } = lp.unwrap();
    await sink(async function* () {
      let sentData = false;
      for await (const buf of source) {
        if (sendingProtocol) {
          await doneSendingProtocol.promise;
        }
        if (!sentProtocol) {
          sendingProtocol = true;
          options.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink', PROTOCOL_ID, protocol, buf.byteLength);
          const protocolString = `${protocol}
`;
          yield new Uint8ArrayList(
            Uint8Array.from([19]),
            // length of PROTOCOL_ID plus newline
            fromString2(`${PROTOCOL_ID}
`),
            encode(protocolString.length),
            fromString2(protocolString),
            buf
          ).subarray();
          options.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink', PROTOCOL_ID, protocol, buf.byteLength);
          sentProtocol = true;
          sendingProtocol = false;
          doneSendingProtocol.resolve();
          negotiate().catch((err) => {
            options.log.error("could not finish optimistic protocol negotiation of %s", protocol, err);
          });
        } else {
          yield buf;
        }
        sentData = true;
      }
      if (!sentData) {
        await negotiate();
      }
    }());
  };
  async function negotiate() {
    if (negotiating) {
      options.log.trace("optimistic: already negotiating %s stream", protocol);
      await doneNegotiating.promise;
      return;
    }
    negotiating = true;
    try {
      if (!sentProtocol) {
        options.log.trace("optimistic: doing send protocol for %s stream", protocol);
        await doSendProtocol();
      }
      if (!readProtocol) {
        options.log.trace("optimistic: doing read protocol for %s stream", protocol);
        await doReadProtocol();
      }
    } finally {
      negotiating = false;
      negotiated = true;
      doneNegotiating.resolve();
    }
  }
  async function doSendProtocol() {
    if (sendingProtocol) {
      await doneSendingProtocol.promise;
      return;
    }
    sendingProtocol = true;
    try {
      options.log.trace('optimistic: write ["%s", "%s", data] in source', PROTOCOL_ID, protocol);
      await lp.writeV([
        fromString2(`${PROTOCOL_ID}
`),
        fromString2(`${protocol}
`)
      ]);
      options.log.trace('optimistic: wrote ["%s", "%s", data] in source', PROTOCOL_ID, protocol);
    } finally {
      sentProtocol = true;
      sendingProtocol = false;
      doneSendingProtocol.resolve();
    }
  }
  async function doReadProtocol() {
    if (readingProtocol) {
      await doneReadingProtocol.promise;
      return;
    }
    readingProtocol = true;
    try {
      options.log.trace("optimistic: reading multistream select header");
      let response = await readString(lp, options);
      options.log.trace('optimistic: read multistream select header "%s"', response);
      if (response === PROTOCOL_ID) {
        response = await readString(lp, options);
      }
      options.log.trace('optimistic: read protocol "%s", expecting "%s"', response, protocol);
      if (response !== protocol) {
        throw new UnsupportedProtocolError("protocol selection failed");
      }
    } finally {
      readProtocol = true;
      readingProtocol = false;
      doneReadingProtocol.resolve();
    }
  }
  stream.source = async function* () {
    await negotiate();
    options.log.trace('optimistic: reading data from "%s" stream', protocol);
    yield* lp.unwrap().source;
  }();
  if (stream.closeRead != null) {
    const originalCloseRead = stream.closeRead.bind(stream);
    stream.closeRead = async (opts) => {
      if (!negotiated) {
        await negotiate().catch((err) => {
          options.log.error("could not negotiate protocol before close read", err);
        });
      }
      await originalCloseRead(opts);
    };
  }
  if (stream.closeWrite != null) {
    const originalCloseWrite = stream.closeWrite.bind(stream);
    stream.closeWrite = async (opts) => {
      if (!negotiated) {
        await negotiate().catch((err) => {
          options.log.error("could not negotiate protocol before close write", err);
        });
      }
      await originalCloseWrite(opts);
    };
  }
  if (stream.close != null) {
    const originalClose = stream.close.bind(stream);
    stream.close = async (opts) => {
      const tasks = [];
      if (sendingProtocol) {
        tasks.push(doneSendingProtocol.promise);
      }
      if (readingProtocol) {
        tasks.push(doneReadingProtocol.promise);
      }
      if (tasks.length > 0) {
        await raceSignal3(Promise.all(tasks), opts == null ? void 0 : opts.signal);
      } else {
        negotiated = true;
        negotiating = false;
        doneNegotiating.resolve();
      }
      await originalClose(opts);
    };
  }
  return {
    stream,
    protocol
  };
}

// node_modules/@libp2p/multistream-select/dist/src/handle.js
async function handle(stream, protocols2, options) {
  protocols2 = Array.isArray(protocols2) ? protocols2 : [protocols2];
  options.log.trace("handle: available protocols %s", protocols2);
  const lp = lpStream(stream, {
    ...options,
    maxDataLength: MAX_PROTOCOL_LENGTH,
    maxLengthLength: 2
    // 2 bytes is enough to length-prefix MAX_PROTOCOL_LENGTH
  });
  while (true) {
    options.log.trace("handle: reading incoming string");
    const protocol = await readString(lp, options);
    options.log.trace('handle: read "%s"', protocol);
    if (protocol === PROTOCOL_ID) {
      options.log.trace('handle: respond with "%s" for "%s"', PROTOCOL_ID, protocol);
      await write2(lp, fromString2(`${PROTOCOL_ID}
`), options);
      options.log.trace('handle: responded with "%s" for "%s"', PROTOCOL_ID, protocol);
      continue;
    }
    if (protocols2.includes(protocol)) {
      options.log.trace('handle: respond with "%s" for "%s"', protocol, protocol);
      await write2(lp, fromString2(`${protocol}
`), options);
      options.log.trace('handle: responded with "%s" for "%s"', protocol, protocol);
      return { stream: lp.unwrap(), protocol };
    }
    if (protocol === "ls") {
      const protos = new Uint8ArrayList(...protocols2.map((p2) => encode7.single(fromString2(`${p2}
`))), fromString2("\n"));
      options.log.trace('handle: respond with "%s" for %s', protocols2, protocol);
      await write2(lp, protos, options);
      options.log.trace('handle: responded with "%s" for %s', protocols2, protocol);
      continue;
    }
    options.log.trace('handle: respond with "na" for "%s"', protocol);
    await write2(lp, fromString2("na\n"), options);
    options.log('handle: responded with "na" for "%s"', protocol);
  }
}

// node_modules/libp2p/dist/src/connection/index.js
var CLOSE_TIMEOUT3 = 500;
var _a23, _b12;
_b12 = Symbol.toStringTag, _a23 = connectionSymbol;
var ConnectionImpl = class {
  /**
   * An implementation of the js-libp2p connection.
   * Any libp2p transport should use an upgrader to return this connection.
   */
  constructor(init) {
    /**
     * Connection identifier.
     */
    __publicField(this, "id");
    /**
     * Observed multiaddr of the remote peer
     */
    __publicField(this, "remoteAddr");
    /**
     * Remote peer id
     */
    __publicField(this, "remotePeer");
    __publicField(this, "direction");
    __publicField(this, "timeline");
    __publicField(this, "multiplexer");
    __publicField(this, "encryption");
    __publicField(this, "status");
    __publicField(this, "limits");
    __publicField(this, "log");
    /**
     * User provided tags
     *
     */
    __publicField(this, "tags");
    /**
     * Reference to the new stream function of the multiplexer
     */
    __publicField(this, "_newStream");
    /**
     * Reference to the close function of the raw connection
     */
    __publicField(this, "_close");
    __publicField(this, "_abort");
    /**
     * Reference to the getStreams function of the muxer
     */
    __publicField(this, "_getStreams");
    __publicField(this, _b12, "Connection");
    __publicField(this, _a23, true);
    const { remoteAddr, remotePeer, newStream, close, abort, getStreams } = init;
    this.id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;
    this.remoteAddr = remoteAddr;
    this.remotePeer = remotePeer;
    this.direction = init.direction;
    this.status = "open";
    this.timeline = init.timeline;
    this.multiplexer = init.multiplexer;
    this.encryption = init.encryption;
    this.limits = init.limits;
    this.log = init.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`);
    if (this.remoteAddr.getPeerId() == null) {
      this.remoteAddr = this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`);
    }
    this._newStream = newStream;
    this._close = close;
    this._abort = abort;
    this._getStreams = getStreams;
    this.tags = [];
  }
  /**
   * Get all the streams of the muxer
   */
  get streams() {
    return this._getStreams();
  }
  /**
   * Create a new stream from this connection
   */
  async newStream(protocols2, options) {
    if (this.status === "closing") {
      throw new ConnectionClosingError("the connection is being closed");
    }
    if (this.status === "closed") {
      throw new ConnectionClosedError("the connection is closed");
    }
    if (!Array.isArray(protocols2)) {
      protocols2 = [protocols2];
    }
    if (this.limits != null && (options == null ? void 0 : options.runOnLimitedConnection) !== true) {
      throw new LimitedConnectionError("Cannot open protocol stream on limited connection");
    }
    const stream = await this._newStream(protocols2, options);
    stream.direction = "outbound";
    return stream;
  }
  /**
   * Close the connection
   */
  async close(options = {}) {
    if (this.status === "closed" || this.status === "closing") {
      return;
    }
    this.log("closing connection to %a", this.remoteAddr);
    this.status = "closing";
    if (options.signal == null) {
      const signal = AbortSignal.timeout(CLOSE_TIMEOUT3);
      setMaxListeners(Infinity, signal);
      options = {
        ...options,
        signal
      };
    }
    try {
      this.log.trace("closing underlying transport");
      await this._close(options);
      this.log.trace("updating timeline with close time");
      this.status = "closed";
      this.timeline.close = Date.now();
    } catch (err) {
      this.log.error("error encountered during graceful close of connection to %a", this.remoteAddr, err);
      this.abort(err);
    }
  }
  abort(err) {
    if (this.status === "closed") {
      return;
    }
    this.log.error("aborting connection to %a due to error", this.remoteAddr, err);
    this.status = "closing";
    this._abort(err);
    this.status = "closed";
    this.timeline.close = Date.now();
  }
};
function createConnection(init) {
  return new ConnectionImpl(init);
}

// node_modules/libp2p/dist/src/upgrader.js
function findIncomingStreamLimit(protocol, registrar) {
  try {
    const { options } = registrar.getHandler(protocol);
    return options.maxInboundStreams;
  } catch (err) {
    if (err.name !== "UnhandledProtocolError") {
      throw err;
    }
  }
  return DEFAULT_MAX_INBOUND_STREAMS;
}
function findOutgoingStreamLimit(protocol, registrar, options = {}) {
  try {
    const { options: options2 } = registrar.getHandler(protocol);
    if (options2.maxOutboundStreams != null) {
      return options2.maxOutboundStreams;
    }
  } catch (err) {
    if (err.name !== "UnhandledProtocolError") {
      throw err;
    }
  }
  return options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;
}
function countStreams(protocol, direction, connection) {
  let streamCount = 0;
  connection.streams.forEach((stream) => {
    if (stream.direction === direction && stream.protocol === protocol) {
      streamCount++;
    }
  });
  return streamCount;
}
var _a24;
_a24 = Symbol.toStringTag;
var Upgrader = class {
  constructor(components, init) {
    __publicField(this, "components");
    __publicField(this, "connectionEncrypters");
    __publicField(this, "streamMuxers");
    __publicField(this, "inboundUpgradeTimeout");
    __publicField(this, "inboundStreamProtocolNegotiationTimeout");
    __publicField(this, "outboundStreamProtocolNegotiationTimeout");
    __publicField(this, "events");
    __publicField(this, "metrics");
    __publicField(this, _a24, "@libp2p/upgrader");
    var _a27, _b14, _c3, _d2;
    this.components = components;
    this.connectionEncrypters = trackedMap({
      name: "libp2p_upgrader_connection_encrypters",
      metrics: this.components.metrics
    });
    init.connectionEncrypters.forEach((encrypter) => {
      this.connectionEncrypters.set(encrypter.protocol, encrypter);
    });
    this.streamMuxers = trackedMap({
      name: "libp2p_upgrader_stream_multiplexers",
      metrics: this.components.metrics
    });
    init.streamMuxers.forEach((muxer) => {
      this.streamMuxers.set(muxer.protocol, muxer);
    });
    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout ?? INBOUND_UPGRADE_TIMEOUT;
    this.inboundStreamProtocolNegotiationTimeout = init.inboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
    this.outboundStreamProtocolNegotiationTimeout = init.outboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
    this.events = components.events;
    this.metrics = {
      dials: (_a27 = components.metrics) == null ? void 0 : _a27.registerCounterGroup("libp2p_connection_manager_dials_total"),
      errors: (_b14 = components.metrics) == null ? void 0 : _b14.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),
      inboundErrors: (_c3 = components.metrics) == null ? void 0 : _c3.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),
      outboundErrors: (_d2 = components.metrics) == null ? void 0 : _d2.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")
    };
  }
  async shouldBlockConnection(method, ...args) {
    const denyOperation = this.components.connectionGater[method];
    if (denyOperation == null) {
      return;
    }
    const result = await denyOperation.apply(this.components.connectionGater, args);
    if (result === true) {
      throw new ConnectionInterceptedError(`The multiaddr connection is blocked by gater.${method}`);
    }
  }
  createInboundAbortSignal(signal) {
    const output = anySignal([
      AbortSignal.timeout(this.inboundUpgradeTimeout),
      signal
    ]);
    setMaxListeners(Infinity, output);
    return output;
  }
  /**
   * Upgrades an inbound connection
   */
  async upgradeInbound(maConn, opts) {
    var _a27, _b14, _c3;
    let accepted = false;
    const signal = this.createInboundAbortSignal(opts.signal);
    try {
      (_a27 = this.metrics.dials) == null ? void 0 : _a27.increment({
        inbound: true
      });
      accepted = await raceSignal3(this.components.connectionManager.acceptIncomingConnection(maConn), signal);
      if (!accepted) {
        throw new ConnectionDeniedError("Connection denied");
      }
      await raceSignal3(this.shouldBlockConnection("denyInboundConnection", maConn), signal);
      await this._performUpgrade(maConn, "inbound", {
        ...opts,
        signal
      });
    } catch (err) {
      (_b14 = this.metrics.errors) == null ? void 0 : _b14.increment({
        inbound: true
      });
      (_c3 = this.metrics.inboundErrors) == null ? void 0 : _c3.increment({
        [err.name ?? "Error"]: true
      });
      throw err;
    } finally {
      signal.clear();
      if (accepted) {
        this.components.connectionManager.afterUpgradeInbound();
      }
    }
  }
  /**
   * Upgrades an outbound connection
   */
  async upgradeOutbound(maConn, opts) {
    var _a27, _b14, _c3;
    try {
      (_a27 = this.metrics.dials) == null ? void 0 : _a27.increment({
        outbound: true
      });
      const idStr = maConn.remoteAddr.getPeerId();
      let remotePeerId;
      if (idStr != null) {
        remotePeerId = peerIdFromString(idStr);
        await raceSignal3(this.shouldBlockConnection("denyOutboundConnection", remotePeerId, maConn), opts.signal);
      }
      let direction = "outbound";
      if (opts.initiator === false) {
        direction = "inbound";
      }
      return await this._performUpgrade(maConn, direction, opts);
    } catch (err) {
      (_b14 = this.metrics.errors) == null ? void 0 : _b14.increment({
        outbound: true
      });
      (_c3 = this.metrics.outboundErrors) == null ? void 0 : _c3.increment({
        [err.name ?? "Error"]: true
      });
      throw err;
    }
  }
  async _performUpgrade(maConn, direction, opts) {
    var _a27, _b14, _c3;
    let encryptedConn;
    let remotePeer;
    let upgradedConn;
    let muxerFactory;
    let cryptoProtocol;
    (_a27 = this.components.metrics) == null ? void 0 : _a27.trackMultiaddrConnection(maConn);
    maConn.log.trace("starting the %s connection upgrade", direction);
    let protectedConn = maConn;
    if ((opts == null ? void 0 : opts.skipProtection) !== true) {
      const protector = this.components.connectionProtector;
      if (protector != null) {
        maConn.log("protecting the %s connection", direction);
        protectedConn = await protector.protect(maConn, opts);
      }
    }
    try {
      encryptedConn = protectedConn;
      if ((opts == null ? void 0 : opts.skipEncryption) !== true) {
        (_b14 = opts == null ? void 0 : opts.onProgress) == null ? void 0 : _b14.call(opts, new CustomProgressEvent(`upgrader:encrypt-${direction}-connection`));
        ({
          conn: encryptedConn,
          remotePeer,
          protocol: cryptoProtocol,
          streamMuxer: muxerFactory
        } = await (direction === "inbound" ? this._encryptInbound(protectedConn, opts) : this._encryptOutbound(protectedConn, opts)));
        const maConn2 = {
          ...protectedConn,
          ...encryptedConn
        };
        await this.shouldBlockConnection(direction === "inbound" ? "denyInboundEncryptedConnection" : "denyOutboundEncryptedConnection", remotePeer, maConn2);
      } else {
        const idStr = maConn.remoteAddr.getPeerId();
        if (idStr == null) {
          throw new InvalidMultiaddrError(`${direction} connection that skipped encryption must have a peer id`);
        }
        const remotePeerId = peerIdFromString(idStr);
        cryptoProtocol = "native";
        remotePeer = remotePeerId;
      }
      if (remotePeer.equals(this.components.peerId)) {
        const err = new InvalidPeerIdError("Can not dial self");
        maConn.abort(err);
        throw err;
      }
      upgradedConn = encryptedConn;
      if ((opts == null ? void 0 : opts.muxerFactory) != null) {
        muxerFactory = opts.muxerFactory;
      } else if (muxerFactory == null && this.streamMuxers.size > 0) {
        (_c3 = opts == null ? void 0 : opts.onProgress) == null ? void 0 : _c3.call(opts, new CustomProgressEvent(`upgrader:multiplex-${direction}-connection`));
        const multiplexed = await (direction === "inbound" ? this._multiplexInbound({
          ...protectedConn,
          ...encryptedConn
        }, this.streamMuxers, opts) : this._multiplexOutbound({
          ...protectedConn,
          ...encryptedConn
        }, this.streamMuxers, opts));
        muxerFactory = multiplexed.muxerFactory;
        upgradedConn = multiplexed.stream;
      }
    } catch (err) {
      maConn.log.error("failed to upgrade inbound connection %s %a - %e", direction === "inbound" ? "from" : "to", maConn.remoteAddr, err);
      throw err;
    }
    await this.shouldBlockConnection(direction === "inbound" ? "denyInboundUpgradedConnection" : "denyOutboundUpgradedConnection", remotePeer, maConn);
    maConn.log("successfully upgraded %s connection", direction);
    return this._createConnection({
      cryptoProtocol,
      direction,
      maConn,
      upgradedConn,
      muxerFactory,
      remotePeer,
      limits: opts == null ? void 0 : opts.limits
    });
  }
  /**
   * A convenience method for generating a new `Connection`
   */
  _createConnection(opts) {
    const { cryptoProtocol, direction, maConn, upgradedConn, remotePeer, muxerFactory, limits } = opts;
    let muxer;
    let newStream;
    let connection;
    if (muxerFactory != null) {
      muxer = muxerFactory.createStreamMuxer({
        direction,
        // Run anytime a remote stream is created
        onIncomingStream: (muxedStream) => {
          if (connection == null) {
            return;
          }
          const signal = AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);
          setMaxListeners(Infinity, signal);
          void Promise.resolve().then(async () => {
            var _a27;
            const protocols2 = this.components.registrar.getProtocols();
            const { stream, protocol } = await handle(muxedStream, protocols2, {
              signal,
              log: muxedStream.log,
              yieldBytes: false
            });
            if (connection == null) {
              return;
            }
            connection.log("incoming stream opened on %s", protocol);
            const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar);
            const streamCount = countStreams(protocol, "inbound", connection);
            if (streamCount === incomingLimit) {
              const err = new TooManyInboundProtocolStreamsError(`Too many inbound protocol streams for protocol "${protocol}" - limit ${incomingLimit}`);
              muxedStream.abort(err);
              throw err;
            }
            muxedStream.source = stream.source;
            muxedStream.sink = stream.sink;
            muxedStream.protocol = protocol;
            if (stream.closeWrite != null) {
              muxedStream.closeWrite = stream.closeWrite;
            }
            if (stream.closeRead != null) {
              muxedStream.closeRead = stream.closeRead;
            }
            if (stream.close != null) {
              muxedStream.close = stream.close;
            }
            await this.components.peerStore.merge(remotePeer, {
              protocols: [protocol]
            }, {
              signal
            });
            (_a27 = this.components.metrics) == null ? void 0 : _a27.trackProtocolStream(muxedStream, connection);
            this._onStream({ connection, stream: muxedStream, protocol });
          }).catch(async (err) => {
            connection.log.error("error handling incoming stream id %s - %e", muxedStream.id, err);
            if (muxedStream.timeline.close == null) {
              await muxedStream.close({
                signal
              }).catch((err2) => muxedStream.abort(err2));
            }
          });
        }
      });
      newStream = async (protocols2, options = {}) => {
        var _a27;
        if (muxer == null) {
          throw new MuxerUnavailableError("Connection is not multiplexed");
        }
        connection.log.trace("starting new stream for protocols %s", protocols2);
        const muxedStream = await muxer.newStream();
        connection.log.trace("started new stream %s for protocols %s", muxedStream.id, protocols2);
        try {
          if (options.signal == null) {
            muxedStream.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout", protocols2);
            const signal = AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);
            setMaxListeners(Infinity, signal);
            options = {
              ...options,
              signal
            };
          }
          muxedStream.log.trace("selecting protocol from protocols %s", protocols2);
          const { stream, protocol } = await select(muxedStream, protocols2, {
            ...options,
            log: muxedStream.log,
            yieldBytes: true
          });
          muxedStream.log.trace("selected protocol %s", protocol);
          const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.registrar, options);
          const streamCount = countStreams(protocol, "outbound", connection);
          if (streamCount >= outgoingLimit) {
            const err = new TooManyOutboundProtocolStreamsError(`Too many outbound protocol streams for protocol "${protocol}" - ${streamCount}/${outgoingLimit}`);
            muxedStream.abort(err);
            throw err;
          }
          await this.components.peerStore.merge(remotePeer, {
            protocols: [protocol]
          });
          muxedStream.source = stream.source;
          muxedStream.sink = stream.sink;
          muxedStream.protocol = protocol;
          if (stream.closeWrite != null) {
            muxedStream.closeWrite = stream.closeWrite;
          }
          if (stream.closeRead != null) {
            muxedStream.closeRead = stream.closeRead;
          }
          if (stream.close != null) {
            muxedStream.close = stream.close;
          }
          (_a27 = this.components.metrics) == null ? void 0 : _a27.trackProtocolStream(muxedStream, connection);
          return muxedStream;
        } catch (err) {
          connection.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e", direction === "inbound" ? "from" : "to", opts.maConn.remoteAddr, protocols2, err);
          if (muxedStream.timeline.close == null) {
            muxedStream.abort(err);
          }
          throw err;
        }
      };
      void Promise.all([
        muxer.sink(upgradedConn.source),
        upgradedConn.sink(muxer.source)
      ]).catch((err) => {
        connection.log.error("error piping data through muxer - %e", err);
      });
    }
    const _timeline = maConn.timeline;
    maConn.timeline = new Proxy(_timeline, {
      set: (...args) => {
        if (args[1] === "close" && args[2] != null && _timeline.close == null) {
          (async () => {
            try {
              if (connection.status === "open") {
                await connection.close();
              }
            } catch (err) {
              connection.log.error("error closing connection after timeline close %e", err);
            } finally {
              this.events.safeDispatchEvent("connection:close", {
                detail: connection
              });
            }
          })().catch((err) => {
            connection.log.error("error thrown while dispatching connection:close event %e", err);
          });
        }
        return Reflect.set(...args);
      }
    });
    maConn.timeline.upgraded = Date.now();
    const errConnectionNotMultiplexed = () => {
      throw new MuxerUnavailableError("Connection is not multiplexed");
    };
    connection = createConnection({
      remoteAddr: maConn.remoteAddr,
      remotePeer,
      status: "open",
      direction,
      timeline: maConn.timeline,
      multiplexer: muxer == null ? void 0 : muxer.protocol,
      encryption: cryptoProtocol,
      limits,
      logger: this.components.logger,
      newStream: newStream ?? errConnectionNotMultiplexed,
      getStreams: () => {
        return (muxer == null ? void 0 : muxer.streams) ?? [];
      },
      close: async (options) => {
        await (muxer == null ? void 0 : muxer.close(options));
        await maConn.close(options);
      },
      abort: (err) => {
        maConn.abort(err);
        muxer == null ? void 0 : muxer.abort(err);
      }
    });
    this.events.safeDispatchEvent("connection:open", {
      detail: connection
    });
    connection.__maConnTimeline = _timeline;
    return connection;
  }
  /**
   * Routes incoming streams to the correct handler
   */
  _onStream(opts) {
    const { connection, stream, protocol } = opts;
    const { handler, options } = this.components.registrar.getHandler(protocol);
    if (connection.limits != null && options.runOnLimitedConnection !== true) {
      throw new LimitedConnectionError("Cannot open protocol stream on limited connection");
    }
    handler({ connection, stream });
  }
  /**
   * Attempts to encrypt the incoming `connection` with the provided `cryptos`
   */
  async _encryptInbound(connection, options) {
    const protocols2 = Array.from(this.connectionEncrypters.keys());
    try {
      const { stream, protocol } = await handle(connection, protocols2, {
        ...options,
        log: connection.log
      });
      const encrypter = this.connectionEncrypters.get(protocol);
      if (encrypter == null) {
        throw new EncryptionFailedError(`no crypto module found for ${protocol}`);
      }
      connection.log("encrypting inbound connection to %a using %s", connection.remoteAddr, protocol);
      return {
        ...await encrypter.secureInbound(stream, options),
        protocol
      };
    } catch (err) {
      connection.log.error("encrypting inbound connection from %a failed", connection.remoteAddr, err);
      throw new EncryptionFailedError(err.message);
    }
  }
  /**
   * Attempts to encrypt the given `connection` with the provided connection encrypters.
   * The first `ConnectionEncrypter` module to succeed will be used
   */
  async _encryptOutbound(connection, options) {
    const protocols2 = Array.from(this.connectionEncrypters.keys());
    try {
      connection.log.trace("selecting encrypter from %s", protocols2);
      const { stream, protocol } = await select(connection, protocols2, {
        ...options,
        log: connection.log,
        yieldBytes: true
      });
      const encrypter = this.connectionEncrypters.get(protocol);
      if (encrypter == null) {
        throw new EncryptionFailedError(`no crypto module found for ${protocol}`);
      }
      connection.log("encrypting outbound connection to %a using %s", connection.remoteAddr, protocol);
      return {
        ...await encrypter.secureOutbound(stream, options),
        protocol
      };
    } catch (err) {
      connection.log.error("encrypting outbound connection to %a failed", connection.remoteAddr, err);
      throw new EncryptionFailedError(err.message);
    }
  }
  /**
   * Selects one of the given muxers via multistream-select. That
   * muxer will be used for all future streams on the connection.
   */
  async _multiplexOutbound(connection, muxers, options) {
    const protocols2 = Array.from(muxers.keys());
    connection.log("outbound selecting muxer %s", protocols2);
    try {
      connection.log.trace("selecting stream muxer from %s", protocols2);
      const { stream, protocol } = await select(connection, protocols2, {
        ...options,
        log: connection.log,
        yieldBytes: true
      });
      connection.log("selected %s as muxer protocol", protocol);
      const muxerFactory = muxers.get(protocol);
      return { stream, muxerFactory };
    } catch (err) {
      connection.log.error("error multiplexing outbound connection", err);
      throw new MuxerUnavailableError(String(err));
    }
  }
  /**
   * Registers support for one of the given muxers via multistream-select. The
   * selected muxer will be used for all future streams on the connection.
   */
  async _multiplexInbound(connection, muxers, options) {
    const protocols2 = Array.from(muxers.keys());
    connection.log("inbound handling muxers %s", protocols2);
    try {
      const { stream, protocol } = await handle(connection, protocols2, {
        ...options,
        log: connection.log
      });
      const muxerFactory = muxers.get(protocol);
      return { stream, muxerFactory };
    } catch (err) {
      connection.log.error("error multiplexing inbound connection", err);
      throw new MuxerUnavailableError(String(err));
    }
  }
  getConnectionEncrypters() {
    return this.connectionEncrypters;
  }
  getStreamMuxers() {
    return this.streamMuxers;
  }
};

// node_modules/libp2p/dist/src/version.js
var version = "2.8.11";
var name2 = "js-libp2p";

// node_modules/libp2p/dist/src/user-agent.browser.js
function userAgent(name3, version5) {
  return `${name3 ?? name2}/${version5 ?? version} browser/${globalThis.navigator.userAgent}`;
}

// node_modules/libp2p/dist/src/libp2p.js
var _Libp2p_instances, onDiscoveryPeer_fn;
var Libp2p = class extends TypedEventEmitter {
  // eslint-disable-next-line complexity
  constructor(init) {
    var _a27, _b14, _c3, _d2, _e, _f, _g, _h, _i, _j, _k, _l;
    super();
    __privateAdd(this, _Libp2p_instances);
    __publicField(this, "peerId");
    __publicField(this, "peerStore");
    __publicField(this, "contentRouting");
    __publicField(this, "peerRouting");
    __publicField(this, "metrics");
    __publicField(this, "services");
    __publicField(this, "logger");
    __publicField(this, "status");
    __publicField(this, "components");
    __publicField(this, "log");
    this.status = "stopped";
    const events = new TypedEventEmitter();
    const originalDispatch = events.dispatchEvent.bind(events);
    events.dispatchEvent = (evt) => {
      const internalResult = originalDispatch(evt);
      const externalResult = this.dispatchEvent(new CustomEvent(evt.type, { detail: evt.detail }));
      return internalResult || externalResult;
    };
    setMaxListeners(Infinity, events);
    this.peerId = init.peerId;
    this.logger = init.logger ?? defaultLogger();
    this.log = this.logger.forComponent("libp2p");
    this.services = {};
    const nodeInfoName = ((_a27 = init.nodeInfo) == null ? void 0 : _a27.name) ?? name2;
    const nodeInfoVersion = ((_b14 = init.nodeInfo) == null ? void 0 : _b14.version) ?? version;
    const components = this.components = defaultComponents({
      peerId: init.peerId,
      privateKey: init.privateKey,
      nodeInfo: {
        name: nodeInfoName,
        version: nodeInfoVersion,
        userAgent: ((_c3 = init.nodeInfo) == null ? void 0 : _c3.userAgent) ?? userAgent(nodeInfoName, nodeInfoVersion)
      },
      logger: this.logger,
      events,
      datastore: init.datastore ?? new MemoryDatastore(),
      connectionGater: connectionGater(init.connectionGater),
      dns: init.dns
    });
    if (init.metrics != null) {
      this.metrics = this.configureComponent("metrics", init.metrics(this.components));
    }
    this.peerStore = this.configureComponent("peerStore", persistentPeerStore(components, {
      addressFilter: this.components.connectionGater.filterMultiaddrForPeer,
      ...init.peerStore
    }));
    components.events.addEventListener("peer:update", (evt) => {
      if (evt.detail.previous == null) {
        const peerInfo = {
          id: evt.detail.peer.id,
          multiaddrs: evt.detail.peer.addresses.map((a2) => a2.multiaddr)
        };
        components.events.safeDispatchEvent("peer:discovery", { detail: peerInfo });
      }
    });
    if (init.connectionProtector != null) {
      this.configureComponent("connectionProtector", init.connectionProtector(components));
    }
    this.components.upgrader = new Upgrader(this.components, {
      connectionEncrypters: (init.connectionEncrypters ?? []).map((fn, index) => this.configureComponent(`connection-encryption-${index}`, fn(this.components))),
      streamMuxers: (init.streamMuxers ?? []).map((fn, index) => this.configureComponent(`stream-muxers-${index}`, fn(this.components))),
      inboundUpgradeTimeout: (_d2 = init.connectionManager) == null ? void 0 : _d2.inboundUpgradeTimeout,
      inboundStreamProtocolNegotiationTimeout: ((_e = init.connectionManager) == null ? void 0 : _e.inboundStreamProtocolNegotiationTimeout) ?? ((_f = init.connectionManager) == null ? void 0 : _f.protocolNegotiationTimeout),
      outboundStreamProtocolNegotiationTimeout: ((_g = init.connectionManager) == null ? void 0 : _g.outboundStreamProtocolNegotiationTimeout) ?? ((_h = init.connectionManager) == null ? void 0 : _h.protocolNegotiationTimeout)
    });
    this.configureComponent("transportManager", new DefaultTransportManager(this.components, init.transportManager));
    this.configureComponent("connectionManager", new DefaultConnectionManager(this.components, init.connectionManager));
    if (((_i = init.connectionMonitor) == null ? void 0 : _i.enabled) !== false) {
      this.configureComponent("connectionMonitor", new ConnectionMonitor(this.components, init.connectionMonitor));
    }
    this.configureComponent("registrar", new Registrar(this.components));
    this.configureComponent("addressManager", new AddressManager(this.components, init.addresses));
    const peerRouters = (init.peerRouters ?? []).map((fn, index) => this.configureComponent(`peer-router-${index}`, fn(this.components)));
    this.peerRouting = this.components.peerRouting = this.configureComponent("peerRouting", new DefaultPeerRouting(this.components, {
      routers: peerRouters
    }));
    const contentRouters = (init.contentRouters ?? []).map((fn, index) => this.configureComponent(`content-router-${index}`, fn(this.components)));
    this.contentRouting = this.components.contentRouting = this.configureComponent("contentRouting", new CompoundContentRouting(this.components, {
      routers: contentRouters
    }));
    this.configureComponent("randomWalk", new RandomWalk(this.components));
    (init.peerDiscovery ?? []).forEach((fn, index) => {
      const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components));
      service.addEventListener("peer", (evt) => {
        __privateMethod(this, _Libp2p_instances, onDiscoveryPeer_fn).call(this, evt);
      });
    });
    (_j = init.transports) == null ? void 0 : _j.forEach((fn, index) => {
      this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)));
    });
    if (init.services != null) {
      for (const name3 of Object.keys(init.services)) {
        const createService = init.services[name3];
        const service = createService(this.components);
        if (service == null) {
          this.log.error("service factory %s returned null or undefined instance", name3);
          continue;
        }
        this.services[name3] = service;
        this.configureComponent(name3, service);
        if (service[contentRoutingSymbol] != null) {
          this.log("registering service %s for content routing", name3);
          contentRouters.push(service[contentRoutingSymbol]);
        }
        if (service[peerRoutingSymbol] != null) {
          this.log("registering service %s for peer routing", name3);
          peerRouters.push(service[peerRoutingSymbol]);
        }
        if (service[peerDiscoverySymbol] != null) {
          this.log("registering service %s for peer discovery", name3);
          (_l = (_k = service[peerDiscoverySymbol]).addEventListener) == null ? void 0 : _l.call(_k, "peer", (evt) => {
            __privateMethod(this, _Libp2p_instances, onDiscoveryPeer_fn).call(this, evt);
          });
        }
      }
    }
    checkServiceDependencies(components);
  }
  configureComponent(name3, component) {
    if (component == null) {
      this.log.error("component %s was null or undefined", name3);
    }
    this.components[name3] = component;
    return component;
  }
  /**
   * Starts the libp2p node and all its subsystems
   */
  async start() {
    var _a27, _b14, _c3, _d2;
    if (this.status !== "stopped") {
      return;
    }
    this.status = "starting";
    this.log("libp2p is starting");
    try {
      await ((_b14 = (_a27 = this.components).beforeStart) == null ? void 0 : _b14.call(_a27));
      await this.components.start();
      await ((_d2 = (_c3 = this.components).afterStart) == null ? void 0 : _d2.call(_c3));
      this.status = "started";
      this.safeDispatchEvent("start", { detail: this });
      this.log("libp2p has started");
    } catch (err) {
      this.log.error("An error occurred starting libp2p", err);
      this.status = "started";
      await this.stop();
      throw err;
    }
  }
  /**
   * Stop the libp2p node by closing its listeners and open connections
   */
  async stop() {
    var _a27, _b14, _c3, _d2;
    if (this.status !== "started") {
      return;
    }
    this.log("libp2p is stopping");
    this.status = "stopping";
    await ((_b14 = (_a27 = this.components).beforeStop) == null ? void 0 : _b14.call(_a27));
    await this.components.stop();
    await ((_d2 = (_c3 = this.components).afterStop) == null ? void 0 : _d2.call(_c3));
    this.status = "stopped";
    this.safeDispatchEvent("stop", { detail: this });
    this.log("libp2p has stopped");
  }
  getConnections(peerId2) {
    return this.components.connectionManager.getConnections(peerId2);
  }
  getDialQueue() {
    return this.components.connectionManager.getDialQueue();
  }
  getPeers() {
    const peerSet2 = new PeerSet();
    for (const conn of this.components.connectionManager.getConnections()) {
      peerSet2.add(conn.remotePeer);
    }
    return Array.from(peerSet2);
  }
  async dial(peer, options = {}) {
    return this.components.connectionManager.openConnection(peer, {
      // ensure any userland dials take top priority in the queue
      priority: 75,
      ...options
    });
  }
  async dialProtocol(peer, protocols2, options = {}) {
    if (protocols2 == null) {
      throw new InvalidParametersError("no protocols were provided to open a stream");
    }
    protocols2 = Array.isArray(protocols2) ? protocols2 : [protocols2];
    if (protocols2.length === 0) {
      throw new InvalidParametersError("no protocols were provided to open a stream");
    }
    const connection = await this.dial(peer, options);
    return connection.newStream(protocols2, options);
  }
  getMultiaddrs() {
    return this.components.addressManager.getAddresses();
  }
  getProtocols() {
    return this.components.registrar.getProtocols();
  }
  async hangUp(peer, options = {}) {
    if (isMultiaddr(peer)) {
      peer = peerIdFromString(peer.getPeerId() ?? "");
    }
    await this.components.connectionManager.closeConnections(peer, options);
  }
  async getPublicKey(peer, options = {}) {
    this.log("getPublicKey %p", peer);
    if (peer.publicKey != null) {
      return peer.publicKey;
    }
    try {
      const peerInfo = await this.peerStore.get(peer, options);
      if (peerInfo.id.publicKey != null) {
        return peerInfo.id.publicKey;
      }
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    const peerKey = concat2([
      fromString2("/pk/"),
      peer.toMultihash().bytes
    ]);
    const bytes = await this.contentRouting.get(peerKey, options);
    const publicKey = publicKeyFromProtobuf(bytes);
    await this.peerStore.patch(peer, {
      publicKey
    }, options);
    return publicKey;
  }
  async handle(protocols2, handler, options) {
    if (!Array.isArray(protocols2)) {
      protocols2 = [protocols2];
    }
    await Promise.all(protocols2.map(async (protocol) => {
      await this.components.registrar.handle(protocol, handler, options);
    }));
  }
  async unhandle(protocols2, options) {
    if (!Array.isArray(protocols2)) {
      protocols2 = [protocols2];
    }
    await Promise.all(protocols2.map(async (protocol) => {
      await this.components.registrar.unhandle(protocol, options);
    }));
  }
  async register(protocol, topology, options) {
    return this.components.registrar.register(protocol, topology, options);
  }
  unregister(id) {
    this.components.registrar.unregister(id);
  }
  async isDialable(multiaddr2, options = {}) {
    return this.components.connectionManager.isDialable(multiaddr2, options);
  }
};
_Libp2p_instances = new WeakSet();
/**
 * Called whenever peer discovery services emit `peer` events and adds peers
 * to the peer store.
 */
onDiscoveryPeer_fn = function(evt) {
  const { detail: peer } = evt;
  if (peer.id.toString() === this.peerId.toString()) {
    this.log.error("peer discovery mechanism discovered self");
    return;
  }
  void this.components.peerStore.merge(peer.id, {
    multiaddrs: peer.multiaddrs
  }).catch((err) => {
    this.log.error(err);
  });
};

// node_modules/libp2p/dist/src/index.js
async function createLibp2p(options = {}) {
  options.privateKey ?? (options.privateKey = await generateKeyPair("Ed25519"));
  const node = new Libp2p({
    ...await validateConfig(options),
    peerId: peerIdFromPrivateKey(options.privateKey)
  });
  if (options.start !== false) {
    await node.start();
  }
  return node;
}

// node_modules/@waku/sdk/dist/env.js
function isTestEnvironment() {
  try {
    return false;
  } catch (_e) {
    return false;
  }
}

// node_modules/@waku/discovery/dist/dns/constants.js
var enrTree = {
  SANDBOX: "enrtree://AIRVQ5DDA4FFWLRBCHJWUWOO6X6S4ZTZ5B667LQ6AJU6PEYDLRD5O@sandbox.waku.nodes.status.im",
  TEST: "enrtree://AOGYWMBYOUIMOENHXCHILPKY3ZRFEULMFI4DOM442QSZ73TT2A7VI@test.waku.nodes.status.im"
};
var DEFAULT_BOOTSTRAP_TAG_NAME2 = Tags.BOOTSTRAP;
var DEFAULT_BOOTSTRAP_TAG_VALUE2 = 50;
var DEFAULT_BOOTSTRAP_TAG_TTL = 1e8;

// node_modules/@waku/enr/dist/constants.js
var ERR_INVALID_ID = "Invalid record id";
var MULTIADDR_LENGTH_SIZE = 2;

// node_modules/@noble/secp256k1/lib/esm/index.js
var nodeCrypto = __toESM(require_crypto());
var _0n15 = BigInt(0);
var _1n14 = BigInt(1);
var _2n11 = BigInt(2);
var _3n6 = BigInt(3);
var _8n7 = BigInt(8);
var CURVE = Object.freeze({
  a: _0n15,
  b: BigInt(7),
  P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: _1n14,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
});
var divNearest2 = (a2, b) => (a2 + b / _2n11) / b;
var endo = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  splitScalar(k) {
    const { n: n2 } = CURVE;
    const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
    const b1 = -_1n14 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
    const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
    const b2 = a1;
    const POW_2_128 = BigInt("0x100000000000000000000000000000000");
    const c1 = divNearest2(b2 * k, n2);
    const c2 = divNearest2(-b1 * k, n2);
    let k1 = mod3(k - c1 * a1 - c2 * a2, n2);
    let k2 = mod3(-c1 * b1 - c2 * b2, n2);
    const k1neg = k1 > POW_2_128;
    const k2neg = k2 > POW_2_128;
    if (k1neg)
      k1 = n2 - k1;
    if (k2neg)
      k2 = n2 - k2;
    if (k1 > POW_2_128 || k2 > POW_2_128) {
      throw new Error("splitScalarEndo: Endomorphism failed, k=" + k);
    }
    return { k1neg, k1, k2neg, k2 };
  }
};
var fieldLen = 32;
var groupLen = 32;
var hashLen = 32;
var compressedLen = fieldLen + 1;
var uncompressedLen = 2 * fieldLen + 1;
function weierstrass2(x) {
  const { a: a2, b } = CURVE;
  const x2 = mod3(x * x);
  const x3 = mod3(x2 * x);
  return mod3(x3 + a2 * x + b);
}
var USE_ENDOMORPHISM = CURVE.a === _0n15;
var ShaError = class extends Error {
  constructor(message2) {
    super(message2);
  }
};
function assertJacPoint(other) {
  if (!(other instanceof JacobianPoint))
    throw new TypeError("JacobianPoint expected");
}
var JacobianPoint = class _JacobianPoint {
  constructor(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  static fromAffine(p2) {
    if (!(p2 instanceof Point)) {
      throw new TypeError("JacobianPoint#fromAffine: expected Point");
    }
    if (p2.equals(Point.ZERO))
      return _JacobianPoint.ZERO;
    return new _JacobianPoint(p2.x, p2.y, _1n14);
  }
  static toAffineBatch(points) {
    const toInv = invertBatch(points.map((p2) => p2.z));
    return points.map((p2, i2) => p2.toAffine(toInv[i2]));
  }
  static normalizeZ(points) {
    return _JacobianPoint.toAffineBatch(points).map(_JacobianPoint.fromAffine);
  }
  equals(other) {
    assertJacPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    const Z1Z1 = mod3(Z1 * Z1);
    const Z2Z2 = mod3(Z2 * Z2);
    const U1 = mod3(X1 * Z2Z2);
    const U2 = mod3(X2 * Z1Z1);
    const S1 = mod3(mod3(Y1 * Z2) * Z2Z2);
    const S2 = mod3(mod3(Y2 * Z1) * Z1Z1);
    return U1 === U2 && S1 === S2;
  }
  negate() {
    return new _JacobianPoint(this.x, mod3(-this.y), this.z);
  }
  double() {
    const { x: X1, y: Y1, z: Z1 } = this;
    const A = mod3(X1 * X1);
    const B = mod3(Y1 * Y1);
    const C = mod3(B * B);
    const x1b = X1 + B;
    const D = mod3(_2n11 * (mod3(x1b * x1b) - A - C));
    const E = mod3(_3n6 * A);
    const F = mod3(E * E);
    const X3 = mod3(F - _2n11 * D);
    const Y3 = mod3(E * (D - X3) - _8n7 * C);
    const Z3 = mod3(_2n11 * Y1 * Z1);
    return new _JacobianPoint(X3, Y3, Z3);
  }
  add(other) {
    assertJacPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    if (X2 === _0n15 || Y2 === _0n15)
      return this;
    if (X1 === _0n15 || Y1 === _0n15)
      return other;
    const Z1Z1 = mod3(Z1 * Z1);
    const Z2Z2 = mod3(Z2 * Z2);
    const U1 = mod3(X1 * Z2Z2);
    const U2 = mod3(X2 * Z1Z1);
    const S1 = mod3(mod3(Y1 * Z2) * Z2Z2);
    const S2 = mod3(mod3(Y2 * Z1) * Z1Z1);
    const H = mod3(U2 - U1);
    const r2 = mod3(S2 - S1);
    if (H === _0n15) {
      if (r2 === _0n15) {
        return this.double();
      } else {
        return _JacobianPoint.ZERO;
      }
    }
    const HH = mod3(H * H);
    const HHH = mod3(H * HH);
    const V3 = mod3(U1 * HH);
    const X3 = mod3(r2 * r2 - HHH - _2n11 * V3);
    const Y3 = mod3(r2 * (V3 - X3) - S1 * HHH);
    const Z3 = mod3(Z1 * Z2 * H);
    return new _JacobianPoint(X3, Y3, Z3);
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiplyUnsafe(scalar) {
    const P0 = _JacobianPoint.ZERO;
    if (typeof scalar === "bigint" && scalar === _0n15)
      return P0;
    let n2 = normalizeScalar(scalar);
    if (n2 === _1n14)
      return this;
    if (!USE_ENDOMORPHISM) {
      let p2 = P0;
      let d3 = this;
      while (n2 > _0n15) {
        if (n2 & _1n14)
          p2 = p2.add(d3);
        d3 = d3.double();
        n2 >>= _1n14;
      }
      return p2;
    }
    let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
    let k1p = P0;
    let k2p = P0;
    let d2 = this;
    while (k1 > _0n15 || k2 > _0n15) {
      if (k1 & _1n14)
        k1p = k1p.add(d2);
      if (k2 & _1n14)
        k2p = k2p.add(d2);
      d2 = d2.double();
      k1 >>= _1n14;
      k2 >>= _1n14;
    }
    if (k1neg)
      k1p = k1p.negate();
    if (k2neg)
      k2p = k2p.negate();
    k2p = new _JacobianPoint(mod3(k2p.x * endo.beta), k2p.y, k2p.z);
    return k1p.add(k2p);
  }
  precomputeWindow(W) {
    const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
    const points = [];
    let p2 = this;
    let base4 = p2;
    for (let window2 = 0; window2 < windows; window2++) {
      base4 = p2;
      points.push(base4);
      for (let i2 = 1; i2 < 2 ** (W - 1); i2++) {
        base4 = base4.add(p2);
        points.push(base4);
      }
      p2 = base4.double();
    }
    return points;
  }
  wNAF(n2, affinePoint) {
    if (!affinePoint && this.equals(_JacobianPoint.BASE))
      affinePoint = Point.BASE;
    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
    if (256 % W) {
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    }
    let precomputes = affinePoint && pointPrecomputes3.get(affinePoint);
    if (!precomputes) {
      precomputes = this.precomputeWindow(W);
      if (affinePoint && W !== 1) {
        precomputes = _JacobianPoint.normalizeZ(precomputes);
        pointPrecomputes3.set(affinePoint, precomputes);
      }
    }
    let p2 = _JacobianPoint.ZERO;
    let f3 = _JacobianPoint.BASE;
    const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
    const windowSize = 2 ** (W - 1);
    const mask = BigInt(2 ** W - 1);
    const maxNumber = 2 ** W;
    const shiftBy = BigInt(W);
    for (let window2 = 0; window2 < windows; window2++) {
      const offset = window2 * windowSize;
      let wbits = Number(n2 & mask);
      n2 >>= shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        n2 += _1n14;
      }
      const offset1 = offset;
      const offset2 = offset + Math.abs(wbits) - 1;
      const cond1 = window2 % 2 !== 0;
      const cond2 = wbits < 0;
      if (wbits === 0) {
        f3 = f3.add(constTimeNegate(cond1, precomputes[offset1]));
      } else {
        p2 = p2.add(constTimeNegate(cond2, precomputes[offset2]));
      }
    }
    return { p: p2, f: f3 };
  }
  multiply(scalar, affinePoint) {
    let n2 = normalizeScalar(scalar);
    let point;
    let fake;
    if (USE_ENDOMORPHISM) {
      const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
      let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
      let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
      k1p = constTimeNegate(k1neg, k1p);
      k2p = constTimeNegate(k2neg, k2p);
      k2p = new _JacobianPoint(mod3(k2p.x * endo.beta), k2p.y, k2p.z);
      point = k1p.add(k2p);
      fake = f1p.add(f2p);
    } else {
      const { p: p2, f: f3 } = this.wNAF(n2, affinePoint);
      point = p2;
      fake = f3;
    }
    return _JacobianPoint.normalizeZ([point, fake])[0];
  }
  toAffine(invZ) {
    const { x, y, z } = this;
    const is0 = this.equals(_JacobianPoint.ZERO);
    if (invZ == null)
      invZ = is0 ? _8n7 : invert3(z);
    const iz1 = invZ;
    const iz2 = mod3(iz1 * iz1);
    const iz3 = mod3(iz2 * iz1);
    const ax = mod3(x * iz2);
    const ay = mod3(y * iz3);
    const zz = mod3(z * iz1);
    if (is0)
      return Point.ZERO;
    if (zz !== _1n14)
      throw new Error("invZ was invalid");
    return new Point(ax, ay);
  }
};
JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n14);
JacobianPoint.ZERO = new JacobianPoint(_0n15, _1n14, _0n15);
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
var pointPrecomputes3 = /* @__PURE__ */ new WeakMap();
var Point = class _Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  _setWindowSize(windowSize) {
    this._WINDOW_SIZE = windowSize;
    pointPrecomputes3.delete(this);
  }
  hasEvenY() {
    return this.y % _2n11 === _0n15;
  }
  static fromCompressedHex(bytes) {
    const isShort = bytes.length === 32;
    const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));
    if (!isValidFieldElement(x))
      throw new Error("Point is not on curve");
    const y2 = weierstrass2(x);
    let y = sqrtMod2(y2);
    const isYOdd = (y & _1n14) === _1n14;
    if (isShort) {
      if (isYOdd)
        y = mod3(-y);
    } else {
      const isFirstByteOdd = (bytes[0] & 1) === 1;
      if (isFirstByteOdd !== isYOdd)
        y = mod3(-y);
    }
    const point = new _Point(x, y);
    point.assertValidity();
    return point;
  }
  static fromUncompressedHex(bytes) {
    const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));
    const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));
    const point = new _Point(x, y);
    point.assertValidity();
    return point;
  }
  static fromHex(hex) {
    const bytes = ensureBytes2(hex);
    const len = bytes.length;
    const header = bytes[0];
    if (len === fieldLen)
      return this.fromCompressedHex(bytes);
    if (len === compressedLen && (header === 2 || header === 3)) {
      return this.fromCompressedHex(bytes);
    }
    if (len === uncompressedLen && header === 4)
      return this.fromUncompressedHex(bytes);
    throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);
  }
  static fromPrivateKey(privateKey) {
    return _Point.BASE.multiply(normalizePrivateKey(privateKey));
  }
  static fromSignature(msgHash, signature, recovery) {
    const { r: r2, s: s2 } = normalizeSignature(signature);
    if (![0, 1, 2, 3].includes(recovery))
      throw new Error("Cannot recover: invalid recovery bit");
    const h = truncateHash(ensureBytes2(msgHash));
    const { n: n2 } = CURVE;
    const radj = recovery === 2 || recovery === 3 ? r2 + n2 : r2;
    const rinv = invert3(radj, n2);
    const u1 = mod3(-h * rinv, n2);
    const u2 = mod3(s2 * rinv, n2);
    const prefix = recovery & 1 ? "03" : "02";
    const R = _Point.fromHex(prefix + numTo32bStr(radj));
    const Q = _Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
    if (!Q)
      throw new Error("Cannot recover signature: point at infinify");
    Q.assertValidity();
    return Q;
  }
  toRawBytes(isCompressed = false) {
    return hexToBytes4(this.toHex(isCompressed));
  }
  toHex(isCompressed = false) {
    const x = numTo32bStr(this.x);
    if (isCompressed) {
      const prefix = this.hasEvenY() ? "02" : "03";
      return `${prefix}${x}`;
    } else {
      return `04${x}${numTo32bStr(this.y)}`;
    }
  }
  toHexX() {
    return this.toHex(true).slice(2);
  }
  toRawX() {
    return this.toRawBytes(true).slice(1);
  }
  assertValidity() {
    const msg = "Point is not on elliptic curve";
    const { x, y } = this;
    if (!isValidFieldElement(x) || !isValidFieldElement(y))
      throw new Error(msg);
    const left = mod3(y * y);
    const right = weierstrass2(x);
    if (mod3(left - right) !== _0n15)
      throw new Error(msg);
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
  negate() {
    return new _Point(this.x, mod3(-this.y));
  }
  double() {
    return JacobianPoint.fromAffine(this).double().toAffine();
  }
  add(other) {
    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiply(scalar) {
    return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
  }
  multiplyAndAddUnsafe(Q, a2, b) {
    const P = JacobianPoint.fromAffine(this);
    const aP = a2 === _0n15 || a2 === _1n14 || this !== _Point.BASE ? P.multiplyUnsafe(a2) : P.multiply(a2);
    const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
    const sum = aP.add(bQ);
    return sum.equals(JacobianPoint.ZERO) ? void 0 : sum.toAffine();
  }
};
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n15, _0n15);
function sliceDER(s2) {
  return Number.parseInt(s2[0], 16) >= 8 ? "00" + s2 : s2;
}
function parseDERInt(data) {
  if (data.length < 2 || data[0] !== 2) {
    throw new Error(`Invalid signature integer tag: ${bytesToHex4(data)}`);
  }
  const len = data[1];
  const res = data.subarray(2, len + 2);
  if (!len || res.length !== len) {
    throw new Error(`Invalid signature integer: wrong length`);
  }
  if (res[0] === 0 && res[1] <= 127) {
    throw new Error("Invalid signature integer: trailing length");
  }
  return { data: bytesToNumber(res), left: data.subarray(len + 2) };
}
function parseDERSignature(data) {
  if (data.length < 2 || data[0] != 48) {
    throw new Error(`Invalid signature tag: ${bytesToHex4(data)}`);
  }
  if (data[1] !== data.length - 2) {
    throw new Error("Invalid signature: incorrect length");
  }
  const { data: r2, left: sBytes } = parseDERInt(data.subarray(2));
  const { data: s2, left: rBytesLeft } = parseDERInt(sBytes);
  if (rBytesLeft.length) {
    throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex4(rBytesLeft)}`);
  }
  return { r: r2, s: s2 };
}
var Signature = class _Signature {
  constructor(r2, s2) {
    this.r = r2;
    this.s = s2;
    this.assertValidity();
  }
  static fromCompact(hex) {
    const arr = isBytes4(hex);
    const name3 = "Signature.fromCompact";
    if (typeof hex !== "string" && !arr)
      throw new TypeError(`${name3}: Expected string or Uint8Array`);
    const str = arr ? bytesToHex4(hex) : hex;
    if (str.length !== 128)
      throw new Error(`${name3}: Expected 64-byte hex`);
    return new _Signature(hexToNumber3(str.slice(0, 64)), hexToNumber3(str.slice(64, 128)));
  }
  static fromDER(hex) {
    const arr = isBytes4(hex);
    if (typeof hex !== "string" && !arr)
      throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
    const { r: r2, s: s2 } = parseDERSignature(arr ? hex : hexToBytes4(hex));
    return new _Signature(r2, s2);
  }
  static fromHex(hex) {
    return this.fromDER(hex);
  }
  assertValidity() {
    const { r: r2, s: s2 } = this;
    if (!isWithinCurveOrder(r2))
      throw new Error("Invalid Signature: r must be 0 < r < n");
    if (!isWithinCurveOrder(s2))
      throw new Error("Invalid Signature: s must be 0 < s < n");
  }
  hasHighS() {
    const HALF = CURVE.n >> _1n14;
    return this.s > HALF;
  }
  normalizeS() {
    return this.hasHighS() ? new _Signature(this.r, mod3(-this.s, CURVE.n)) : this;
  }
  toDERRawBytes() {
    return hexToBytes4(this.toDERHex());
  }
  toDERHex() {
    const sHex = sliceDER(numberToHexUnpadded3(this.s));
    const rHex = sliceDER(numberToHexUnpadded3(this.r));
    const sHexL = sHex.length / 2;
    const rHexL = rHex.length / 2;
    const sLen = numberToHexUnpadded3(sHexL);
    const rLen = numberToHexUnpadded3(rHexL);
    const length3 = numberToHexUnpadded3(rHexL + sHexL + 4);
    return `30${length3}02${rLen}${rHex}02${sLen}${sHex}`;
  }
  toRawBytes() {
    return this.toDERRawBytes();
  }
  toHex() {
    return this.toDERHex();
  }
  toCompactRawBytes() {
    return hexToBytes4(this.toCompactHex());
  }
  toCompactHex() {
    return numTo32bStr(this.r) + numTo32bStr(this.s);
  }
};
function isBytes4(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
function abytes4(item) {
  if (!isBytes4(item))
    throw new Error("Uint8Array expected");
}
function concatBytes3(...arrays) {
  arrays.every(abytes4);
  if (arrays.length === 1)
    return arrays[0];
  const length3 = arrays.reduce((a2, arr) => a2 + arr.length, 0);
  const result = new Uint8Array(length3);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const arr = arrays[i2];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
var hexes4 = Array.from({ length: 256 }, (_2, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex4(bytes) {
  abytes4(bytes);
  let hex = "";
  for (let i2 = 0; i2 < bytes.length; i2++) {
    hex += hexes4[bytes[i2]];
  }
  return hex;
}
var asciis3 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase163(ch) {
  if (ch >= asciis3._0 && ch <= asciis3._9)
    return ch - asciis3._0;
  if (ch >= asciis3.A && ch <= asciis3.F)
    return ch - (asciis3.A - 10);
  if (ch >= asciis3.a && ch <= asciis3.f)
    return ch - (asciis3.a - 10);
  return;
}
function hexToBytes4(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase163(hex.charCodeAt(hi));
    const n2 = asciiToBase163(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
var POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
function numTo32bStr(num3) {
  if (typeof num3 !== "bigint")
    throw new Error("Expected bigint");
  if (!(_0n15 <= num3 && num3 < POW_2_256))
    throw new Error("Expected number 0 <= n < 2^256");
  return num3.toString(16).padStart(64, "0");
}
function numTo32b(num3) {
  const b = hexToBytes4(numTo32bStr(num3));
  if (b.length !== 32)
    throw new Error("Error: expected 32 bytes");
  return b;
}
function numberToHexUnpadded3(num3) {
  const hex = num3.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber3(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToNumber: expected string, got " + typeof hex);
  }
  return BigInt(`0x${hex}`);
}
function bytesToNumber(bytes) {
  return hexToNumber3(bytesToHex4(bytes));
}
function ensureBytes2(hex) {
  return isBytes4(hex) ? Uint8Array.from(hex) : hexToBytes4(hex);
}
function normalizeScalar(num3) {
  if (typeof num3 === "number" && Number.isSafeInteger(num3) && num3 > 0)
    return BigInt(num3);
  if (typeof num3 === "bigint" && isWithinCurveOrder(num3))
    return num3;
  throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
}
function mod3(a2, b = CURVE.P) {
  const result = a2 % b;
  return result >= _0n15 ? result : b + result;
}
function pow23(x, power) {
  const { P } = CURVE;
  let res = x;
  while (power-- > _0n15) {
    res *= res;
    res %= P;
  }
  return res;
}
function sqrtMod2(x) {
  const { P } = CURVE;
  const _6n = BigInt(6);
  const _11n = BigInt(11);
  const _22n = BigInt(22);
  const _23n = BigInt(23);
  const _44n = BigInt(44);
  const _88n = BigInt(88);
  const b2 = x * x * x % P;
  const b3 = b2 * b2 * x % P;
  const b6 = pow23(b3, _3n6) * b3 % P;
  const b9 = pow23(b6, _3n6) * b3 % P;
  const b11 = pow23(b9, _2n11) * b2 % P;
  const b22 = pow23(b11, _11n) * b11 % P;
  const b44 = pow23(b22, _22n) * b22 % P;
  const b88 = pow23(b44, _44n) * b44 % P;
  const b176 = pow23(b88, _88n) * b88 % P;
  const b220 = pow23(b176, _44n) * b44 % P;
  const b223 = pow23(b220, _3n6) * b3 % P;
  const t1 = pow23(b223, _23n) * b22 % P;
  const t2 = pow23(t1, _6n) * b2 % P;
  const rt = pow23(t2, _2n11);
  const xc = rt * rt % P;
  if (xc !== x)
    throw new Error("Cannot find square root");
  return rt;
}
function invert3(number2, modulo = CURVE.P) {
  if (number2 === _0n15 || modulo <= _0n15) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a2 = mod3(number2, modulo);
  let b = modulo;
  let x = _0n15, y = _1n14, u = _1n14, v = _0n15;
  while (a2 !== _0n15) {
    const q = b / a2;
    const r2 = b % a2;
    const m2 = x - u * q;
    const n2 = y - v * q;
    b = a2, a2 = r2, x = u, y = v, u = m2, v = n2;
  }
  const gcd = b;
  if (gcd !== _1n14)
    throw new Error("invert: does not exist");
  return mod3(x, modulo);
}
function invertBatch(nums, p2 = CURVE.P) {
  const scratch = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num3, i2) => {
    if (num3 === _0n15)
      return acc;
    scratch[i2] = acc;
    return mod3(acc * num3, p2);
  }, _1n14);
  const inverted = invert3(lastMultiplied, p2);
  nums.reduceRight((acc, num3, i2) => {
    if (num3 === _0n15)
      return acc;
    scratch[i2] = mod3(acc * scratch[i2], p2);
    return mod3(acc * num3, p2);
  }, inverted);
  return scratch;
}
function bits2int_2(bytes) {
  const delta = bytes.length * 8 - groupLen * 8;
  const num3 = bytesToNumber(bytes);
  return delta > 0 ? num3 >> BigInt(delta) : num3;
}
function truncateHash(hash, truncateOnly = false) {
  const h = bits2int_2(hash);
  if (truncateOnly)
    return h;
  const { n: n2 } = CURVE;
  return h >= n2 ? h - n2 : h;
}
var _sha256Sync;
var _hmacSha256Sync;
var HmacDrbg = class {
  constructor(hashLen2, qByteLen) {
    this.hashLen = hashLen2;
    this.qByteLen = qByteLen;
    if (typeof hashLen2 !== "number" || hashLen2 < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    this.v = new Uint8Array(hashLen2).fill(1);
    this.k = new Uint8Array(hashLen2).fill(0);
    this.counter = 0;
  }
  hmac(...values) {
    return utils.hmacSha256(this.k, ...values);
  }
  hmacSync(...values) {
    return _hmacSha256Sync(this.k, ...values);
  }
  checkSync() {
    if (typeof _hmacSha256Sync !== "function")
      throw new ShaError("hmacSha256Sync needs to be set");
  }
  incr() {
    if (this.counter >= 1e3)
      throw new Error("Tried 1,000 k values for sign(), all were invalid");
    this.counter += 1;
  }
  async reseed(seed = new Uint8Array()) {
    this.k = await this.hmac(this.v, Uint8Array.from([0]), seed);
    this.v = await this.hmac(this.v);
    if (seed.length === 0)
      return;
    this.k = await this.hmac(this.v, Uint8Array.from([1]), seed);
    this.v = await this.hmac(this.v);
  }
  reseedSync(seed = new Uint8Array()) {
    this.checkSync();
    this.k = this.hmacSync(this.v, Uint8Array.from([0]), seed);
    this.v = this.hmacSync(this.v);
    if (seed.length === 0)
      return;
    this.k = this.hmacSync(this.v, Uint8Array.from([1]), seed);
    this.v = this.hmacSync(this.v);
  }
  async generate() {
    this.incr();
    let len = 0;
    const out = [];
    while (len < this.qByteLen) {
      this.v = await this.hmac(this.v);
      const sl = this.v.slice();
      out.push(sl);
      len += this.v.length;
    }
    return concatBytes3(...out);
  }
  generateSync() {
    this.checkSync();
    this.incr();
    let len = 0;
    const out = [];
    while (len < this.qByteLen) {
      this.v = this.hmacSync(this.v);
      const sl = this.v.slice();
      out.push(sl);
      len += this.v.length;
    }
    return concatBytes3(...out);
  }
};
function isWithinCurveOrder(num3) {
  return _0n15 < num3 && num3 < CURVE.n;
}
function isValidFieldElement(num3) {
  return _0n15 < num3 && num3 < CURVE.P;
}
function kmdToSig(kBytes, m2, d2, lowS = true) {
  const { n: n2 } = CURVE;
  const k = truncateHash(kBytes, true);
  if (!isWithinCurveOrder(k))
    return;
  const kinv = invert3(k, n2);
  const q = Point.BASE.multiply(k);
  const r2 = mod3(q.x, n2);
  if (r2 === _0n15)
    return;
  const s2 = mod3(kinv * mod3(m2 + d2 * r2, n2), n2);
  if (s2 === _0n15)
    return;
  let sig = new Signature(r2, s2);
  let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n14);
  if (lowS && sig.hasHighS()) {
    sig = sig.normalizeS();
    recovery ^= 1;
  }
  return { sig, recovery };
}
function normalizePrivateKey(key) {
  let num3;
  if (typeof key === "bigint") {
    num3 = key;
  } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
    num3 = BigInt(key);
  } else if (typeof key === "string") {
    if (key.length !== 2 * groupLen)
      throw new Error("Expected 32 bytes of private key");
    num3 = hexToNumber3(key);
  } else if (isBytes4(key)) {
    if (key.length !== groupLen)
      throw new Error("Expected 32 bytes of private key");
    num3 = bytesToNumber(key);
  } else {
    throw new TypeError("Expected valid private key");
  }
  if (!isWithinCurveOrder(num3))
    throw new Error("Expected private key: 0 < key < n");
  return num3;
}
function normalizePublicKey(publicKey) {
  if (publicKey instanceof Point) {
    publicKey.assertValidity();
    return publicKey;
  } else {
    return Point.fromHex(publicKey);
  }
}
function normalizeSignature(signature) {
  if (signature instanceof Signature) {
    signature.assertValidity();
    return signature;
  }
  try {
    return Signature.fromDER(signature);
  } catch (error) {
    return Signature.fromCompact(signature);
  }
}
function bits2int(bytes) {
  const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;
  return bytesToNumber(slice);
}
function bits2octets(bytes) {
  const z1 = bits2int(bytes);
  const z2 = mod3(z1, CURVE.n);
  return int2octets(z2 < _0n15 ? z1 : z2);
}
function int2octets(num3) {
  return numTo32b(num3);
}
function initSigArgs(msgHash, privateKey, extraEntropy) {
  if (msgHash == null)
    throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
  const h1 = ensureBytes2(msgHash);
  const d2 = normalizePrivateKey(privateKey);
  const seedArgs = [int2octets(d2), bits2octets(h1)];
  if (extraEntropy != null) {
    if (extraEntropy === true)
      extraEntropy = utils.randomBytes(fieldLen);
    const e2 = ensureBytes2(extraEntropy);
    if (e2.length !== fieldLen)
      throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);
    seedArgs.push(e2);
  }
  const seed = concatBytes3(...seedArgs);
  const m2 = bits2int(h1);
  return { seed, m: m2, d: d2 };
}
function finalizeSig(recSig, opts) {
  const { sig, recovery } = recSig;
  const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);
  const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
  return recovered ? [hashed, recovery] : hashed;
}
async function sign(msgHash, privKey, opts = {}) {
  const { seed, m: m2, d: d2 } = initSigArgs(msgHash, privKey, opts.extraEntropy);
  const drbg = new HmacDrbg(hashLen, groupLen);
  await drbg.reseed(seed);
  let sig;
  while (!(sig = kmdToSig(await drbg.generate(), m2, d2, opts.canonical)))
    await drbg.reseed();
  return finalizeSig(sig, opts);
}
var vopts = { strict: true };
function verify(signature, msgHash, publicKey, opts = vopts) {
  let sig;
  try {
    sig = normalizeSignature(signature);
    msgHash = ensureBytes2(msgHash);
  } catch (error) {
    return false;
  }
  const { r: r2, s: s2 } = sig;
  if (opts.strict && sig.hasHighS())
    return false;
  const h = truncateHash(msgHash);
  let P;
  try {
    P = normalizePublicKey(publicKey);
  } catch (error) {
    return false;
  }
  const { n: n2 } = CURVE;
  const sinv = invert3(s2, n2);
  const u1 = mod3(h * sinv, n2);
  const u2 = mod3(r2 * sinv, n2);
  const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);
  if (!R)
    return false;
  const v = mod3(R.x, n2);
  return v === r2;
}
Point.BASE._setWindowSize(8);
var crypto3 = {
  node: nodeCrypto,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};
var TAGGED_HASH_PREFIXES2 = {};
var utils = {
  bytesToHex: bytesToHex4,
  hexToBytes: hexToBytes4,
  concatBytes: concatBytes3,
  mod: mod3,
  invert: invert3,
  isValidPrivateKey(privateKey) {
    try {
      normalizePrivateKey(privateKey);
      return true;
    } catch (error) {
      return false;
    }
  },
  _bigintTo32Bytes: numTo32b,
  _normalizePrivateKey: normalizePrivateKey,
  hashToPrivateKey: (hash) => {
    hash = ensureBytes2(hash);
    const minLen = groupLen + 8;
    if (hash.length < minLen || hash.length > 1024) {
      throw new Error(`Expected valid bytes of private key as per FIPS 186`);
    }
    const num3 = mod3(bytesToNumber(hash), CURVE.n - _1n14) + _1n14;
    return numTo32b(num3);
  },
  randomBytes: (bytesLength = 32) => {
    if (crypto3.web) {
      return crypto3.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto3.node) {
      const { randomBytes: randomBytes5 } = crypto3.node;
      return Uint8Array.from(randomBytes5(bytesLength));
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  },
  randomPrivateKey: () => utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),
  precompute(windowSize = 8, point = Point.BASE) {
    const cached = point === Point.BASE ? point : new Point(point.x, point.y);
    cached._setWindowSize(windowSize);
    cached.multiply(_3n6);
    return cached;
  },
  sha256: async (...messages2) => {
    if (crypto3.web) {
      const buffer = await crypto3.web.subtle.digest("SHA-256", concatBytes3(...messages2));
      return new Uint8Array(buffer);
    } else if (crypto3.node) {
      const { createHash } = crypto3.node;
      const hash = createHash("sha256");
      messages2.forEach((m2) => hash.update(m2));
      return Uint8Array.from(hash.digest());
    } else {
      throw new Error("The environment doesn't have sha256 function");
    }
  },
  hmacSha256: async (key, ...messages2) => {
    if (crypto3.web) {
      const ckey = await crypto3.web.subtle.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
      const message2 = concatBytes3(...messages2);
      const buffer = await crypto3.web.subtle.sign("HMAC", ckey, message2);
      return new Uint8Array(buffer);
    } else if (crypto3.node) {
      const { createHmac } = crypto3.node;
      const hash = createHmac("sha256", key);
      messages2.forEach((m2) => hash.update(m2));
      return Uint8Array.from(hash.digest());
    } else {
      throw new Error("The environment doesn't have hmac-sha256 function");
    }
  },
  sha256Sync: void 0,
  hmacSha256Sync: void 0,
  taggedHash: async (tag, ...messages2) => {
    let tagP = TAGGED_HASH_PREFIXES2[tag];
    if (tagP === void 0) {
      const tagH = await utils.sha256(Uint8Array.from(tag, (c2) => c2.charCodeAt(0)));
      tagP = concatBytes3(tagH, tagH);
      TAGGED_HASH_PREFIXES2[tag] = tagP;
    }
    return utils.sha256(tagP, ...messages2);
  },
  taggedHashSync: (tag, ...messages2) => {
    if (typeof _sha256Sync !== "function")
      throw new ShaError("sha256Sync is undefined, you need to set it");
    let tagP = TAGGED_HASH_PREFIXES2[tag];
    if (tagP === void 0) {
      const tagH = _sha256Sync(Uint8Array.from(tag, (c2) => c2.charCodeAt(0)));
      tagP = concatBytes3(tagH, tagH);
      TAGGED_HASH_PREFIXES2[tag] = tagP;
    }
    return _sha256Sync(tagP, ...messages2);
  },
  _JacobianPoint: JacobianPoint
};
Object.defineProperties(utils, {
  sha256Sync: {
    configurable: false,
    get() {
      return _sha256Sync;
    },
    set(val) {
      if (!_sha256Sync)
        _sha256Sync = val;
    }
  },
  hmacSha256Sync: {
    configurable: false,
    get() {
      return _hmacSha256Sync;
    },
    set(val) {
      if (!_hmacSha256Sync)
        _hmacSha256Sync = val;
    }
  }
});

// node_modules/@waku/enr/dist/crypto.js
var import_js_sha3 = __toESM(require_sha3(), 1);
function keccak256(input) {
  return new Uint8Array(import_js_sha3.default.keccak256.arrayBuffer(input));
}
function verifySignature(signature, message2, publicKey) {
  try {
    const _signature = Signature.fromCompact(signature.slice(0, 64));
    return verify(_signature, message2, publicKey);
  } catch {
    return false;
  }
}

// node_modules/@waku/enr/dist/multiaddr_from_fields.js
function multiaddrFromFields(ipFamily, protocol, ipBytes, protocolBytes) {
  let ma = multiaddr("/" + ipFamily + "/" + convertToString(ipFamily, ipBytes));
  ma = ma.encapsulate(multiaddr("/" + protocol + "/" + convertToString(protocol, protocolBytes)));
  return ma;
}

// node_modules/@waku/enr/dist/get_multiaddr.js
function locationMultiaddrFromEnrFields(enr, protocol) {
  switch (protocol) {
    case "udp":
      return locationMultiaddrFromEnrFields(enr, "udp4") || locationMultiaddrFromEnrFields(enr, "udp6");
    case "tcp":
      return locationMultiaddrFromEnrFields(enr, "tcp4") || locationMultiaddrFromEnrFields(enr, "tcp6");
  }
  const isIpv6 = protocol.endsWith("6");
  const ipVal = enr.get(isIpv6 ? "ip6" : "ip");
  if (!ipVal)
    return;
  const protoName = protocol.slice(0, 3);
  let protoVal;
  switch (protoName) {
    case "udp":
      protoVal = isIpv6 ? enr.get("udp6") : enr.get("udp");
      break;
    case "tcp":
      protoVal = isIpv6 ? enr.get("tcp6") : enr.get("tcp");
      break;
    default:
      return;
  }
  if (!protoVal)
    return;
  return multiaddrFromFields(isIpv6 ? "ip6" : "ip4", protoName, ipVal, protoVal);
}

// node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/rsa/der.js
var TAG_MASK2 = parseInt("11111", 2);
var LONG_LENGTH_MASK2 = parseInt("10000000", 2);
var LONG_LENGTH_BYTES_MASK2 = parseInt("01111111", 2);
var decoders3 = {
  0: readSequence2,
  1: readSequence2,
  2: readInteger2,
  3: readBitString2,
  4: readOctetString2,
  5: readNull2,
  6: readObjectIdentifier2,
  16: readSequence2,
  22: readSequence2,
  48: readSequence2
};
function decodeDer2(buf, context = { offset: 0 }) {
  const tag = buf[context.offset] & TAG_MASK2;
  context.offset++;
  if (decoders3[tag] != null) {
    return decoders3[tag](buf, context);
  }
  throw new Error("No decoder for tag " + tag);
}
function readLength2(buf, context) {
  let length3 = 0;
  if ((buf[context.offset] & LONG_LENGTH_MASK2) === LONG_LENGTH_MASK2) {
    const count = buf[context.offset] & LONG_LENGTH_BYTES_MASK2;
    let str = "0x";
    context.offset++;
    for (let i2 = 0; i2 < count; i2++, context.offset++) {
      str += buf[context.offset].toString(16).padStart(2, "0");
    }
    length3 = parseInt(str, 16);
  } else {
    length3 = buf[context.offset];
    context.offset++;
  }
  return length3;
}
function readSequence2(buf, context) {
  readLength2(buf, context);
  const entries = [];
  while (true) {
    if (context.offset >= buf.byteLength) {
      break;
    }
    const result = decodeDer2(buf, context);
    if (result === null) {
      break;
    }
    entries.push(result);
  }
  return entries;
}
function readInteger2(buf, context) {
  const length3 = readLength2(buf, context);
  const start2 = context.offset;
  const end = context.offset + length3;
  const vals = [];
  for (let i2 = start2; i2 < end; i2++) {
    if (i2 === start2 && buf[i2] === 0) {
      continue;
    }
    vals.push(buf[i2]);
  }
  context.offset += length3;
  return Uint8Array.from(vals);
}
function readObjectIdentifier2(buf, context) {
  const count = readLength2(buf, context);
  const finalOffset = context.offset + count;
  const byte = buf[context.offset];
  context.offset++;
  let val1 = 0;
  let val2 = 0;
  if (byte < 40) {
    val1 = 0;
    val2 = byte;
  } else if (byte < 80) {
    val1 = 1;
    val2 = byte - 40;
  } else {
    val1 = 2;
    val2 = byte - 80;
  }
  let oid = `${val1}.${val2}`;
  let num3 = [];
  while (context.offset < finalOffset) {
    const byte2 = buf[context.offset];
    context.offset++;
    num3.push(byte2 & 127);
    if (byte2 < 128) {
      num3.reverse();
      let val = 0;
      for (let i2 = 0; i2 < num3.length; i2++) {
        val += num3[i2] << i2 * 7;
      }
      oid += `.${val}`;
      num3 = [];
    }
  }
  return oid;
}
function readNull2(buf, context) {
  context.offset++;
  return null;
}
function readBitString2(buf, context) {
  const length3 = readLength2(buf, context);
  const unusedBits = buf[context.offset];
  context.offset++;
  const bytes = buf.subarray(context.offset, context.offset + length3 - 1);
  context.offset += length3;
  if (unusedBits !== 0) {
    throw new Error("Unused bits in bit string is unimplemented");
  }
  return bytes;
}
function readOctetString2(buf, context) {
  const length3 = readLength2(buf, context);
  const bytes = buf.subarray(context.offset, context.offset + length3);
  context.offset += length3;
  return bytes;
}
function encodeNumber2(value) {
  let number2 = value.toString(16);
  if (number2.length % 2 === 1) {
    number2 = "0" + number2;
  }
  const array = new Uint8ArrayList();
  for (let i2 = 0; i2 < number2.length; i2 += 2) {
    array.append(Uint8Array.from([parseInt(`${number2[i2]}${number2[i2 + 1]}`, 16)]));
  }
  return array;
}
function encodeLength2(bytes) {
  if (bytes.byteLength < 128) {
    return Uint8Array.from([bytes.byteLength]);
  }
  const length3 = encodeNumber2(bytes.byteLength);
  return new Uint8ArrayList(Uint8Array.from([
    length3.byteLength | LONG_LENGTH_MASK2
  ]), length3);
}
function encodeInteger2(value) {
  const contents = new Uint8ArrayList();
  const mask = 128;
  const positive2 = (value.subarray()[0] & mask) === mask;
  if (positive2) {
    contents.append(Uint8Array.from([0]));
  }
  contents.append(value);
  return new Uint8ArrayList(Uint8Array.from([2]), encodeLength2(contents), contents);
}
function encodeBitString2(value) {
  const unusedBits = Uint8Array.from([0]);
  const contents = new Uint8ArrayList(unusedBits, value);
  return new Uint8ArrayList(Uint8Array.from([3]), encodeLength2(contents), contents);
}
function encodeSequence2(values, tag = 48) {
  const output = new Uint8ArrayList();
  for (const buf of values) {
    output.append(buf);
  }
  return new Uint8ArrayList(Uint8Array.from([tag]), encodeLength2(output), output);
}

// node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/ecdsa/index.js
var ECDSA_P_256_OID2 = "1.2.840.10045.3.1.7";
var ECDSA_P_384_OID2 = "1.3.132.0.34";
var ECDSA_P_521_OID2 = "1.3.132.0.35";
async function hashAndVerify5(key, sig, msg, options) {
  var _a27, _b14;
  const publicKey = await crypto.subtle.importKey("jwk", key, {
    name: "ECDSA",
    namedCurve: key.crv ?? "P-256"
  }, false, ["verify"]);
  (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
  const result = await crypto.subtle.verify({
    name: "ECDSA",
    hash: {
      name: "SHA-256"
    }
  }, publicKey, sig, msg.subarray());
  (_b14 = options == null ? void 0 : options.signal) == null ? void 0 : _b14.throwIfAborted();
  return result;
}

// node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/ecdsa/utils.js
var OID_2562 = Uint8Array.from([6, 8, 42, 134, 72, 206, 61, 3, 1, 7]);
var OID_3842 = Uint8Array.from([6, 5, 43, 129, 4, 0, 34]);
var OID_5212 = Uint8Array.from([6, 5, 43, 129, 4, 0, 35]);
var P_256_KEY_JWK2 = {
  ext: true,
  kty: "EC",
  crv: "P-256"
};
var P_384_KEY_JWK2 = {
  ext: true,
  kty: "EC",
  crv: "P-384"
};
var P_521_KEY_JWK2 = {
  ext: true,
  kty: "EC",
  crv: "P-521"
};
var P_256_KEY_LENGTH2 = 32;
var P_384_KEY_LENGTH2 = 48;
var P_521_KEY_LENGTH2 = 66;
function pkiMessageToECDSAPublicKey2(message2) {
  const coordinates = message2[1][1][0];
  const offset = 1;
  let x;
  let y;
  if (coordinates.byteLength === P_256_KEY_LENGTH2 * 2 + 1) {
    x = toString2(coordinates.subarray(offset, offset + P_256_KEY_LENGTH2), "base64url");
    y = toString2(coordinates.subarray(offset + P_256_KEY_LENGTH2), "base64url");
    return new ECDSAPublicKey2({
      ...P_256_KEY_JWK2,
      key_ops: ["verify"],
      x,
      y
    });
  }
  if (coordinates.byteLength === P_384_KEY_LENGTH2 * 2 + 1) {
    x = toString2(coordinates.subarray(offset, offset + P_384_KEY_LENGTH2), "base64url");
    y = toString2(coordinates.subarray(offset + P_384_KEY_LENGTH2), "base64url");
    return new ECDSAPublicKey2({
      ...P_384_KEY_JWK2,
      key_ops: ["verify"],
      x,
      y
    });
  }
  if (coordinates.byteLength === P_521_KEY_LENGTH2 * 2 + 1) {
    x = toString2(coordinates.subarray(offset, offset + P_521_KEY_LENGTH2), "base64url");
    y = toString2(coordinates.subarray(offset + P_521_KEY_LENGTH2), "base64url");
    return new ECDSAPublicKey2({
      ...P_521_KEY_JWK2,
      key_ops: ["verify"],
      x,
      y
    });
  }
  throw new InvalidParametersError(`coordinates were wrong length, got ${coordinates.byteLength}, expected 65, 97 or 133`);
}
function publicKeyToPKIMessage2(publicKey) {
  return encodeSequence2([
    encodeInteger2(Uint8Array.from([1])),
    // header
    encodeSequence2([
      getOID2(publicKey.crv)
    ], 160),
    encodeSequence2([
      encodeBitString2(new Uint8ArrayList(Uint8Array.from([4]), fromString2(publicKey.x ?? "", "base64url"), fromString2(publicKey.y ?? "", "base64url")))
    ], 161)
  ]).subarray();
}
function getOID2(curve) {
  if (curve === "P-256") {
    return OID_2562;
  }
  if (curve === "P-384") {
    return OID_3842;
  }
  if (curve === "P-521") {
    return OID_5212;
  }
  throw new InvalidParametersError(`Invalid curve ${curve}`);
}

// node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/ecdsa/ecdsa.js
var ECDSAPublicKey2 = class {
  constructor(jwk) {
    __publicField(this, "type", "ECDSA");
    __publicField(this, "jwk");
    __publicField(this, "_raw");
    this.jwk = jwk;
  }
  get raw() {
    if (this._raw == null) {
      this._raw = publicKeyToPKIMessage2(this.jwk);
    }
    return this._raw;
  }
  toMultihash() {
    return identity2.digest(publicKeyToProtobuf2(this));
  }
  toCID() {
    return CID.createV1(114, this.toMultihash());
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.raw, key.raw);
  }
  async verify(data, sig, options) {
    return hashAndVerify5(this.jwk, sig, data, options);
  }
};

// node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/errors.js
var VerificationError2 = class extends Error {
  constructor(message2 = "An error occurred while verifying a message") {
    super(message2);
    this.name = "VerificationError";
  }
};
var WebCryptoMissingError2 = class extends Error {
  constructor(message2 = "Missing Web Crypto API") {
    super(message2);
    this.name = "WebCryptoMissingError";
  }
};

// node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/webcrypto/webcrypto.browser.js
var webcrypto_browser_default2 = {
  get(win = globalThis) {
    const nativeCrypto = win.crypto;
    if ((nativeCrypto == null ? void 0 : nativeCrypto.subtle) == null) {
      throw new WebCryptoMissingError2("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");
    }
    return nativeCrypto;
  }
};

// node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/webcrypto/index.js
var webcrypto_default2 = webcrypto_browser_default2;

// node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/ed25519/index.browser.js
var PUBLIC_KEY_BYTE_LENGTH3 = 32;
var ed25519Supported2;
var webCryptoEd25519SupportedPromise2 = (async () => {
  try {
    await webcrypto_default2.get().subtle.generateKey({ name: "Ed25519" }, true, ["sign", "verify"]);
    return true;
  } catch {
    return false;
  }
})();
async function hashAndVerifyWebCrypto2(publicKey, sig, msg) {
  if (publicKey.buffer instanceof ArrayBuffer) {
    const key = await webcrypto_default2.get().subtle.importKey("raw", publicKey.buffer, { name: "Ed25519" }, false, ["verify"]);
    const isValid = await webcrypto_default2.get().subtle.verify({ name: "Ed25519" }, key, sig, msg instanceof Uint8Array ? msg : msg.subarray());
    return isValid;
  }
  throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys");
}
function hashAndVerifyNoble2(publicKey, sig, msg) {
  return ed255192.verify(sig, msg instanceof Uint8Array ? msg : msg.subarray(), publicKey);
}
async function hashAndVerify6(publicKey, sig, msg) {
  if (ed25519Supported2 == null) {
    ed25519Supported2 = await webCryptoEd25519SupportedPromise2;
  }
  if (ed25519Supported2) {
    return hashAndVerifyWebCrypto2(publicKey, sig, msg);
  }
  return hashAndVerifyNoble2(publicKey, sig, msg);
}

// node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/util.js
function isPromise4(thing) {
  if (thing == null) {
    return false;
  }
  return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}

// node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/ed25519/ed25519.js
var Ed25519PublicKey2 = class {
  constructor(key) {
    __publicField(this, "type", "Ed25519");
    __publicField(this, "raw");
    this.raw = ensureEd25519Key2(key, PUBLIC_KEY_BYTE_LENGTH3);
  }
  toMultihash() {
    return identity2.digest(publicKeyToProtobuf2(this));
  }
  toCID() {
    return CID.createV1(114, this.toMultihash());
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.raw, key.raw);
  }
  verify(data, sig, options) {
    var _a27;
    (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
    const result = hashAndVerify6(this.raw, sig, data);
    if (isPromise4(result)) {
      return result.then((res) => {
        var _a28;
        (_a28 = options == null ? void 0 : options.signal) == null ? void 0 : _a28.throwIfAborted();
        return res;
      });
    }
    return result;
  }
};

// node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/ed25519/utils.js
function unmarshalEd25519PublicKey2(bytes) {
  bytes = ensureEd25519Key2(bytes, PUBLIC_KEY_BYTE_LENGTH3);
  return new Ed25519PublicKey2(bytes);
}
function ensureEd25519Key2(key, length3) {
  key = Uint8Array.from(key ?? []);
  if (key.length !== length3) {
    throw new InvalidParametersError(`Key must be a Uint8Array of length ${length3}, got ${key.length}`);
  }
  return key;
}

// node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/keys.js
var KeyType2;
(function(KeyType3) {
  KeyType3["RSA"] = "RSA";
  KeyType3["Ed25519"] = "Ed25519";
  KeyType3["secp256k1"] = "secp256k1";
  KeyType3["ECDSA"] = "ECDSA";
})(KeyType2 || (KeyType2 = {}));
var __KeyTypeValues2;
(function(__KeyTypeValues3) {
  __KeyTypeValues3[__KeyTypeValues3["RSA"] = 0] = "RSA";
  __KeyTypeValues3[__KeyTypeValues3["Ed25519"] = 1] = "Ed25519";
  __KeyTypeValues3[__KeyTypeValues3["secp256k1"] = 2] = "secp256k1";
  __KeyTypeValues3[__KeyTypeValues3["ECDSA"] = 3] = "ECDSA";
})(__KeyTypeValues2 || (__KeyTypeValues2 = {}));
(function(KeyType3) {
  KeyType3.codec = () => {
    return enumeration(__KeyTypeValues2);
  };
})(KeyType2 || (KeyType2 = {}));
var PublicKey2;
(function(PublicKey3) {
  let _codec;
  PublicKey3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType2.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {};
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.Type = KeyType2.codec().decode(reader);
              break;
            }
            case 2: {
              obj.Data = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PublicKey3.encode = (obj) => {
    return encodeMessage(obj, PublicKey3.codec());
  };
  PublicKey3.decode = (buf, opts) => {
    return decodeMessage(buf, PublicKey3.codec(), opts);
  };
})(PublicKey2 || (PublicKey2 = {}));
var PrivateKey2;
(function(PrivateKey3) {
  let _codec;
  PrivateKey3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType2.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {};
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.Type = KeyType2.codec().decode(reader);
              break;
            }
            case 2: {
              obj.Data = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PrivateKey3.encode = (obj) => {
    return encodeMessage(obj, PrivateKey3.codec());
  };
  PrivateKey3.decode = (buf, opts) => {
    return decodeMessage(buf, PrivateKey3.codec(), opts);
  };
})(PrivateKey2 || (PrivateKey2 = {}));

// node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/rsa/utils.js
var utils_exports2 = {};
__export(utils_exports2, {
  MAX_RSA_KEY_SIZE: () => MAX_RSA_KEY_SIZE2,
  generateRSAKeyPair: () => generateRSAKeyPair2,
  jwkToJWKKeyPair: () => jwkToJWKKeyPair2,
  jwkToPkcs1: () => jwkToPkcs12,
  jwkToPkix: () => jwkToPkix2,
  jwkToRSAPrivateKey: () => jwkToRSAPrivateKey2,
  pkcs1MessageToJwk: () => pkcs1MessageToJwk2,
  pkcs1MessageToRSAPrivateKey: () => pkcs1MessageToRSAPrivateKey2,
  pkcs1ToJwk: () => pkcs1ToJwk2,
  pkcs1ToRSAPrivateKey: () => pkcs1ToRSAPrivateKey2,
  pkixMessageToJwk: () => pkixMessageToJwk2,
  pkixMessageToRSAPublicKey: () => pkixMessageToRSAPublicKey2,
  pkixToJwk: () => pkixToJwk2,
  pkixToRSAPublicKey: () => pkixToRSAPublicKey2
});

// node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/rsa/rsa.js
var RSAPublicKey2 = class {
  constructor(jwk, digest2) {
    __publicField(this, "type", "RSA");
    __publicField(this, "jwk");
    __publicField(this, "_raw");
    __publicField(this, "_multihash");
    this.jwk = jwk;
    this._multihash = digest2;
  }
  get raw() {
    if (this._raw == null) {
      this._raw = utils_exports2.jwkToPkix(this.jwk);
    }
    return this._raw;
  }
  toMultihash() {
    return this._multihash;
  }
  toCID() {
    return CID.createV1(114, this._multihash);
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.raw, key.raw);
  }
  verify(data, sig, options) {
    return hashAndVerify7(this.jwk, sig, data, options);
  }
};
var RSAPrivateKey2 = class {
  constructor(jwk, publicKey) {
    __publicField(this, "type", "RSA");
    __publicField(this, "jwk");
    __publicField(this, "_raw");
    __publicField(this, "publicKey");
    this.jwk = jwk;
    this.publicKey = publicKey;
  }
  get raw() {
    if (this._raw == null) {
      this._raw = utils_exports2.jwkToPkcs1(this.jwk);
    }
    return this._raw;
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.raw, key.raw);
  }
  sign(message2, options) {
    return hashAndSign7(this.jwk, message2, options);
  }
};

// node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/rsa/utils.js
var MAX_RSA_KEY_SIZE2 = 8192;
var SHA2_256_CODE2 = 18;
var MAX_RSA_JWK_SIZE2 = 1062;
var RSA_ALGORITHM_IDENTIFIER2 = Uint8Array.from([
  48,
  13,
  6,
  9,
  42,
  134,
  72,
  134,
  247,
  13,
  1,
  1,
  1,
  5,
  0
]);
function pkcs1ToJwk2(bytes) {
  const message2 = decodeDer2(bytes);
  return pkcs1MessageToJwk2(message2);
}
function pkcs1MessageToJwk2(message2) {
  return {
    n: toString2(message2[1], "base64url"),
    e: toString2(message2[2], "base64url"),
    d: toString2(message2[3], "base64url"),
    p: toString2(message2[4], "base64url"),
    q: toString2(message2[5], "base64url"),
    dp: toString2(message2[6], "base64url"),
    dq: toString2(message2[7], "base64url"),
    qi: toString2(message2[8], "base64url"),
    kty: "RSA"
  };
}
function jwkToPkcs12(jwk) {
  if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
    throw new InvalidParametersError("JWK was missing components");
  }
  return encodeSequence2([
    encodeInteger2(Uint8Array.from([0])),
    encodeInteger2(fromString2(jwk.n, "base64url")),
    encodeInteger2(fromString2(jwk.e, "base64url")),
    encodeInteger2(fromString2(jwk.d, "base64url")),
    encodeInteger2(fromString2(jwk.p, "base64url")),
    encodeInteger2(fromString2(jwk.q, "base64url")),
    encodeInteger2(fromString2(jwk.dp, "base64url")),
    encodeInteger2(fromString2(jwk.dq, "base64url")),
    encodeInteger2(fromString2(jwk.qi, "base64url"))
  ]).subarray();
}
function pkixToJwk2(bytes) {
  const message2 = decodeDer2(bytes, {
    offset: 0
  });
  return pkixMessageToJwk2(message2);
}
function pkixMessageToJwk2(message2) {
  const keys = decodeDer2(message2[1], {
    offset: 0
  });
  return {
    kty: "RSA",
    n: toString2(keys[0], "base64url"),
    e: toString2(keys[1], "base64url")
  };
}
function jwkToPkix2(jwk) {
  if (jwk.n == null || jwk.e == null) {
    throw new InvalidParametersError("JWK was missing components");
  }
  const subjectPublicKeyInfo = encodeSequence2([
    RSA_ALGORITHM_IDENTIFIER2,
    encodeBitString2(encodeSequence2([
      encodeInteger2(fromString2(jwk.n, "base64url")),
      encodeInteger2(fromString2(jwk.e, "base64url"))
    ]))
  ]);
  return subjectPublicKeyInfo.subarray();
}
function pkcs1ToRSAPrivateKey2(bytes) {
  const message2 = decodeDer2(bytes);
  return pkcs1MessageToRSAPrivateKey2(message2);
}
function pkcs1MessageToRSAPrivateKey2(message2) {
  const jwk = pkcs1MessageToJwk2(message2);
  return jwkToRSAPrivateKey2(jwk);
}
function pkixToRSAPublicKey2(bytes, digest2) {
  if (bytes.byteLength >= MAX_RSA_JWK_SIZE2) {
    throw new InvalidPublicKeyError("Key size is too large");
  }
  const message2 = decodeDer2(bytes, {
    offset: 0
  });
  return pkixMessageToRSAPublicKey2(message2, bytes, digest2);
}
function pkixMessageToRSAPublicKey2(message2, bytes, digest2) {
  const jwk = pkixMessageToJwk2(message2);
  if (digest2 == null) {
    const hash = sha2563(PublicKey2.encode({
      Type: KeyType2.RSA,
      Data: bytes
    }));
    digest2 = create(SHA2_256_CODE2, hash);
  }
  return new RSAPublicKey2(jwk, digest2);
}
function jwkToRSAPrivateKey2(jwk) {
  if (rsaKeySize2(jwk) > MAX_RSA_KEY_SIZE2) {
    throw new InvalidParametersError("Key size is too large");
  }
  const keys = jwkToJWKKeyPair2(jwk);
  const hash = sha2563(PublicKey2.encode({
    Type: KeyType2.RSA,
    Data: jwkToPkix2(keys.publicKey)
  }));
  const digest2 = create(SHA2_256_CODE2, hash);
  return new RSAPrivateKey2(keys.privateKey, new RSAPublicKey2(keys.publicKey, digest2));
}
async function generateRSAKeyPair2(bits) {
  if (bits > MAX_RSA_KEY_SIZE2) {
    throw new InvalidParametersError("Key size is too large");
  }
  const keys = await generateRSAKey2(bits);
  const hash = sha2563(PublicKey2.encode({
    Type: KeyType2.RSA,
    Data: jwkToPkix2(keys.publicKey)
  }));
  const digest2 = create(SHA2_256_CODE2, hash);
  return new RSAPrivateKey2(keys.privateKey, new RSAPublicKey2(keys.publicKey, digest2));
}
function jwkToJWKKeyPair2(key) {
  if (key == null) {
    throw new InvalidParametersError("Missing key parameter");
  }
  return {
    privateKey: key,
    publicKey: {
      kty: key.kty,
      n: key.n,
      e: key.e
    }
  };
}

// node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/rsa/index.browser.js
var RSAES_PKCS1_V1_5_OID2 = "1.2.840.113549.1.1.1";
async function generateRSAKey2(bits, options) {
  var _a27;
  const pair2 = await webcrypto_default2.get().subtle.generateKey({
    name: "RSASSA-PKCS1-v1_5",
    modulusLength: bits,
    publicExponent: new Uint8Array([1, 0, 1]),
    hash: { name: "SHA-256" }
  }, true, ["sign", "verify"]);
  (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
  const keys = await exportKey2(pair2, options);
  return {
    privateKey: keys[0],
    publicKey: keys[1]
  };
}
async function hashAndSign7(key, msg, options) {
  var _a27, _b14;
  const privateKey = await webcrypto_default2.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["sign"]);
  (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
  const sig = await webcrypto_default2.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, msg instanceof Uint8Array ? msg : msg.subarray());
  (_b14 = options == null ? void 0 : options.signal) == null ? void 0 : _b14.throwIfAborted();
  return new Uint8Array(sig, 0, sig.byteLength);
}
async function hashAndVerify7(key, sig, msg, options) {
  var _a27, _b14;
  const publicKey = await webcrypto_default2.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["verify"]);
  (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
  const result = await webcrypto_default2.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg instanceof Uint8Array ? msg : msg.subarray());
  (_b14 = options == null ? void 0 : options.signal) == null ? void 0 : _b14.throwIfAborted();
  return result;
}
async function exportKey2(pair2, options) {
  var _a27;
  if (pair2.privateKey == null || pair2.publicKey == null) {
    throw new InvalidParametersError("Private and public key are required");
  }
  const result = await Promise.all([
    webcrypto_default2.get().subtle.exportKey("jwk", pair2.privateKey),
    webcrypto_default2.get().subtle.exportKey("jwk", pair2.publicKey)
  ]);
  (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
  return result;
}
function rsaKeySize2(jwk) {
  if (jwk.kty !== "RSA") {
    throw new InvalidParametersError("invalid key type");
  } else if (jwk.n == null) {
    throw new InvalidParametersError("invalid key modulus");
  }
  const bytes = fromString2(jwk.n, "base64url");
  return bytes.length * 8;
}

// node_modules/@noble/curves/esm/abstract/weierstrass.js
var divNearest3 = (num3, den) => (num3 + (num3 >= 0 ? den : -den) / _2n12) / den;
function _splitEndoScalar2(k, basis, n2) {
  const [[a1, b1], [a2, b2]] = basis;
  const c1 = divNearest3(b2 * k, n2);
  const c2 = divNearest3(-b1 * k, n2);
  let k1 = k - c1 * a1 - c2 * a2;
  let k2 = -c1 * b1 - c2 * b2;
  const k1neg = k1 < _0n16;
  const k2neg = k2 < _0n16;
  if (k1neg)
    k1 = -k1;
  if (k2neg)
    k2 = -k2;
  const MAX_NUM = bitMask2(Math.ceil(bitLen2(n2) / 2)) + _1n15;
  if (k1 < _0n16 || k1 >= MAX_NUM || k2 < _0n16 || k2 >= MAX_NUM) {
    throw new Error("splitScalar (endomorphism): failed, k=" + k);
  }
  return { k1neg, k1, k2neg, k2 };
}
function validateSigFormat2(format2) {
  if (!["compact", "recovered", "der"].includes(format2))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return format2;
}
function validateSigOpts2(opts, def) {
  const optsn = {};
  for (let optName of Object.keys(def)) {
    optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
  }
  _abool2(optsn.lowS, "lowS");
  _abool2(optsn.prehash, "prehash");
  if (optsn.format !== void 0)
    validateSigFormat2(optsn.format);
  return optsn;
}
var DERErr2 = class extends Error {
  constructor(m2 = "") {
    super(m2);
  }
};
var DER2 = {
  // asn.1 DER encoding utils
  Err: DERErr2,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data) => {
      const { Err: E } = DER2;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded2(dataLen);
      if (len.length / 2 & 128)
        throw new E("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded2(len.length / 2 | 128) : "";
      const t2 = numberToHexUnpadded2(tag);
      return t2 + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data) {
      const { Err: E } = DER2;
      let pos = 0;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag)
        throw new E("tlv.decode: wrong tlv");
      const first = data[pos++];
      const isLong = !!(first & 128);
      let length3 = 0;
      if (!isLong)
        length3 = first;
      else {
        const lenLen = first & 127;
        if (!lenLen)
          throw new E("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E("tlv.decode(long): zero leftmost byte");
        for (const b of lengthBytes)
          length3 = length3 << 8 | b;
        pos += lenLen;
        if (length3 < 128)
          throw new E("tlv.decode(long): not minimal encoding");
      }
      const v = data.subarray(pos, pos + length3);
      if (v.length !== length3)
        throw new E("tlv.decode: wrong value length");
      return { v, l: data.subarray(pos + length3) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num3) {
      const { Err: E } = DER2;
      if (num3 < _0n16)
        throw new E("integer: negative integers are not allowed");
      let hex = numberToHexUnpadded2(num3);
      if (Number.parseInt(hex[0], 16) & 8)
        hex = "00" + hex;
      if (hex.length & 1)
        throw new E("unexpected DER parsing assertion: unpadded hex");
      return hex;
    },
    decode(data) {
      const { Err: E } = DER2;
      if (data[0] & 128)
        throw new E("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE2(data);
    }
  },
  toSig(hex) {
    const { Err: E, _int: int, _tlv: tlv } = DER2;
    const data = ensureBytes("signature", hex);
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER2;
    const rs = tlv.encode(2, int.encode(sig.r));
    const ss = tlv.encode(2, int.encode(sig.s));
    const seq = rs + ss;
    return tlv.encode(48, seq);
  }
};
var _0n16 = BigInt(0);
var _1n15 = BigInt(1);
var _2n12 = BigInt(2);
var _3n7 = BigInt(3);
var _4n4 = BigInt(4);
function _normFnElement(Fn3, key) {
  const { BYTES: expected } = Fn3;
  let num3;
  if (typeof key === "bigint") {
    num3 = key;
  } else {
    let bytes = ensureBytes("private key", key);
    try {
      num3 = Fn3.fromBytes(bytes);
    } catch (error) {
      throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
    }
  }
  if (!Fn3.isValidNot0(num3))
    throw new Error("invalid private key: out of range [1..N-1]");
  return num3;
}
function weierstrassN(params, extraOpts = {}) {
  const validated = _createCurveFields("weierstrass", params, extraOpts);
  const { Fp: Fp3, Fn: Fn3 } = validated;
  let CURVE2 = validated.CURVE;
  const { h: cofactor, n: CURVE_ORDER } = CURVE2;
  _validateObject(extraOpts, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object",
    wrapPrivateKey: "boolean"
  });
  const { endo: endo2 } = extraOpts;
  if (endo2) {
    if (!Fp3.is0(CURVE2.a) || typeof endo2.beta !== "bigint" || !Array.isArray(endo2.basises)) {
      throw new Error('invalid endo: expected "beta": bigint and "basises": array');
    }
  }
  const lengths = getWLengths2(Fp3, Fn3);
  function assertCompressionIsSupported() {
    if (!Fp3.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function pointToBytes3(_c3, point, isCompressed) {
    const { x, y } = point.toAffine();
    const bx = Fp3.toBytes(x);
    _abool2(isCompressed, "isCompressed");
    if (isCompressed) {
      assertCompressionIsSupported();
      const hasEvenY = !Fp3.isOdd(y);
      return concatBytes(pprefix2(hasEvenY), bx);
    } else {
      return concatBytes(Uint8Array.of(4), bx, Fp3.toBytes(y));
    }
  }
  function pointFromBytes(bytes) {
    _abytes2(bytes, void 0, "Point");
    const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
    const length3 = bytes.length;
    const head = bytes[0];
    const tail = bytes.subarray(1);
    if (length3 === comp && (head === 2 || head === 3)) {
      const x = Fp3.fromBytes(tail);
      if (!Fp3.isValid(x))
        throw new Error("bad point: is not on curve, wrong x");
      const y2 = weierstrassEquation(x);
      let y;
      try {
        y = Fp3.sqrt(y2);
      } catch (sqrtError) {
        const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + err);
      }
      assertCompressionIsSupported();
      const isYOdd = Fp3.isOdd(y);
      const isHeadOdd = (head & 1) === 1;
      if (isHeadOdd !== isYOdd)
        y = Fp3.neg(y);
      return { x, y };
    } else if (length3 === uncomp && head === 4) {
      const L = Fp3.BYTES;
      const x = Fp3.fromBytes(tail.subarray(0, L));
      const y = Fp3.fromBytes(tail.subarray(L, L * 2));
      if (!isValidXY(x, y))
        throw new Error("bad point: is not on curve");
      return { x, y };
    } else {
      throw new Error(`bad point: got length ${length3}, expected compressed=${comp} or uncompressed=${uncomp}`);
    }
  }
  const encodePoint = extraOpts.toBytes || pointToBytes3;
  const decodePoint = extraOpts.fromBytes || pointFromBytes;
  function weierstrassEquation(x) {
    const x2 = Fp3.sqr(x);
    const x3 = Fp3.mul(x2, x);
    return Fp3.add(Fp3.add(x3, Fp3.mul(x, CURVE2.a)), CURVE2.b);
  }
  function isValidXY(x, y) {
    const left = Fp3.sqr(y);
    const right = weierstrassEquation(x);
    return Fp3.eql(left, right);
  }
  if (!isValidXY(CURVE2.Gx, CURVE2.Gy))
    throw new Error("bad curve params: generator point");
  const _4a3 = Fp3.mul(Fp3.pow(CURVE2.a, _3n7), _4n4);
  const _27b2 = Fp3.mul(Fp3.sqr(CURVE2.b), BigInt(27));
  if (Fp3.is0(Fp3.add(_4a3, _27b2)))
    throw new Error("bad curve params: a or b");
  function acoord(title, n2, banZero = false) {
    if (!Fp3.isValid(n2) || banZero && Fp3.is0(n2))
      throw new Error(`bad point coordinate ${title}`);
    return n2;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  function splitEndoScalarN(k) {
    if (!endo2 || !endo2.basises)
      throw new Error("no endo");
    return _splitEndoScalar2(k, endo2.basises, Fn3.ORDER);
  }
  const toAffineMemo = memoized2((p2, iz) => {
    const { X, Y, Z } = p2;
    if (Fp3.eql(Z, Fp3.ONE))
      return { x: X, y: Y };
    const is0 = p2.is0();
    if (iz == null)
      iz = is0 ? Fp3.ONE : Fp3.inv(Z);
    const x = Fp3.mul(X, iz);
    const y = Fp3.mul(Y, iz);
    const zz = Fp3.mul(Z, iz);
    if (is0)
      return { x: Fp3.ZERO, y: Fp3.ZERO };
    if (!Fp3.eql(zz, Fp3.ONE))
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized2((p2) => {
    if (p2.is0()) {
      if (extraOpts.allowInfinityPoint && !Fp3.is0(p2.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y } = p2.toAffine();
    if (!Fp3.isValid(x) || !Fp3.isValid(y))
      throw new Error("bad point: x or y not field elements");
    if (!isValidXY(x, y))
      throw new Error("bad point: equation left != right");
    if (!p2.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
    k2p = new Point2(Fp3.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
    k1p = negateCt2(k1neg, k1p);
    k2p = negateCt2(k2neg, k2p);
    return k1p.add(k2p);
  }
  class Point2 {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(X, Y, Z) {
      this.X = acoord("x", X);
      this.Y = acoord("y", Y, true);
      this.Z = acoord("z", Z);
      Object.freeze(this);
    }
    static CURVE() {
      return CURVE2;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(p2) {
      const { x, y } = p2 || {};
      if (!p2 || !Fp3.isValid(x) || !Fp3.isValid(y))
        throw new Error("invalid affine point");
      if (p2 instanceof Point2)
        throw new Error("projective point not allowed");
      if (Fp3.is0(x) && Fp3.is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp3.ONE);
    }
    static fromBytes(bytes) {
      const P = Point2.fromAffine(decodePoint(_abytes2(bytes, void 0, "point")));
      P.assertValidity();
      return P;
    }
    static fromHex(hex) {
      return Point2.fromBytes(ensureBytes("pointHex", hex));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_3n7);
      return this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (!Fp3.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !Fp3.isOdd(y);
    }
    /** Compare one point to another. */
    equals(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const U1 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X2, Z1));
      const U2 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y2, Z1));
      return U1 && U2;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new Point2(this.X, Fp3.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a2, b } = CURVE2;
      const b3 = Fp3.mul(b, _3n7);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      let t0 = Fp3.mul(X1, X1);
      let t1 = Fp3.mul(Y1, Y1);
      let t2 = Fp3.mul(Z1, Z1);
      let t3 = Fp3.mul(X1, Y1);
      t3 = Fp3.add(t3, t3);
      Z3 = Fp3.mul(X1, Z1);
      Z3 = Fp3.add(Z3, Z3);
      X3 = Fp3.mul(a2, Z3);
      Y3 = Fp3.mul(b3, t2);
      Y3 = Fp3.add(X3, Y3);
      X3 = Fp3.sub(t1, Y3);
      Y3 = Fp3.add(t1, Y3);
      Y3 = Fp3.mul(X3, Y3);
      X3 = Fp3.mul(t3, X3);
      Z3 = Fp3.mul(b3, Z3);
      t2 = Fp3.mul(a2, t2);
      t3 = Fp3.sub(t0, t2);
      t3 = Fp3.mul(a2, t3);
      t3 = Fp3.add(t3, Z3);
      Z3 = Fp3.add(t0, t0);
      t0 = Fp3.add(Z3, t0);
      t0 = Fp3.add(t0, t2);
      t0 = Fp3.mul(t0, t3);
      Y3 = Fp3.add(Y3, t0);
      t2 = Fp3.mul(Y1, Z1);
      t2 = Fp3.add(t2, t2);
      t0 = Fp3.mul(t2, t3);
      X3 = Fp3.sub(X3, t0);
      Z3 = Fp3.mul(t2, t1);
      Z3 = Fp3.add(Z3, Z3);
      Z3 = Fp3.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      const a2 = CURVE2.a;
      const b3 = Fp3.mul(CURVE2.b, _3n7);
      let t0 = Fp3.mul(X1, X2);
      let t1 = Fp3.mul(Y1, Y2);
      let t2 = Fp3.mul(Z1, Z2);
      let t3 = Fp3.add(X1, Y1);
      let t4 = Fp3.add(X2, Y2);
      t3 = Fp3.mul(t3, t4);
      t4 = Fp3.add(t0, t1);
      t3 = Fp3.sub(t3, t4);
      t4 = Fp3.add(X1, Z1);
      let t5 = Fp3.add(X2, Z2);
      t4 = Fp3.mul(t4, t5);
      t5 = Fp3.add(t0, t2);
      t4 = Fp3.sub(t4, t5);
      t5 = Fp3.add(Y1, Z1);
      X3 = Fp3.add(Y2, Z2);
      t5 = Fp3.mul(t5, X3);
      X3 = Fp3.add(t1, t2);
      t5 = Fp3.sub(t5, X3);
      Z3 = Fp3.mul(a2, t4);
      X3 = Fp3.mul(b3, t2);
      Z3 = Fp3.add(X3, Z3);
      X3 = Fp3.sub(t1, Z3);
      Z3 = Fp3.add(t1, Z3);
      Y3 = Fp3.mul(X3, Z3);
      t1 = Fp3.add(t0, t0);
      t1 = Fp3.add(t1, t0);
      t2 = Fp3.mul(a2, t2);
      t4 = Fp3.mul(b3, t4);
      t1 = Fp3.add(t1, t2);
      t2 = Fp3.sub(t0, t2);
      t2 = Fp3.mul(a2, t2);
      t4 = Fp3.add(t4, t2);
      t0 = Fp3.mul(t1, t4);
      Y3 = Fp3.add(Y3, t0);
      t0 = Fp3.mul(t5, t4);
      X3 = Fp3.mul(t3, X3);
      X3 = Fp3.sub(X3, t0);
      t0 = Fp3.mul(t3, t1);
      Z3 = Fp3.mul(t5, Z3);
      Z3 = Fp3.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo: endo3 } = extraOpts;
      if (!Fn3.isValidNot0(scalar))
        throw new Error("invalid scalar: out of range");
      let point, fake;
      const mul = (n2) => wnaf.cached(this, n2, (p2) => normalizeZ2(Point2, p2));
      if (endo3) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
        const { p: k1p, f: k1f } = mul(k1);
        const { p: k2p, f: k2f } = mul(k2);
        fake = k1f.add(k2f);
        point = finishEndo(endo3.beta, k1p, k2p, k1neg, k2neg);
      } else {
        const { p: p2, f: f3 } = mul(scalar);
        point = p2;
        fake = f3;
      }
      return normalizeZ2(Point2, [point, fake])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo: endo3 } = extraOpts;
      const p2 = this;
      if (!Fn3.isValid(sc))
        throw new Error("invalid scalar: out of range");
      if (sc === _0n16 || p2.is0())
        return Point2.ZERO;
      if (sc === _1n15)
        return p2;
      if (wnaf.hasCache(this))
        return this.multiply(sc);
      if (endo3) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
        const { p1, p2: p22 } = mulEndoUnsafe2(Point2, p2, k1, k2);
        return finishEndo(endo3.beta, p1, p22, k1neg, k2neg);
      } else {
        return wnaf.unsafe(p2, sc);
      }
    }
    multiplyAndAddUnsafe(Q, a2, b) {
      const sum = this.multiplyUnsafe(a2).add(Q.multiplyUnsafe(b));
      return sum.is0() ? void 0 : sum;
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree } = extraOpts;
      if (cofactor === _1n15)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      return wnaf.unsafe(this, CURVE_ORDER).is0();
    }
    clearCofactor() {
      const { clearCofactor } = extraOpts;
      if (cofactor === _1n15)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(cofactor);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    toBytes(isCompressed = true) {
      _abool2(isCompressed, "isCompressed");
      this.assertValidity();
      return encodePoint(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toBytes(isCompressed));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
    // TODO: remove
    get px() {
      return this.X;
    }
    get py() {
      return this.X;
    }
    get pz() {
      return this.Z;
    }
    toRawBytes(isCompressed = true) {
      return this.toBytes(isCompressed);
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    static normalizeZ(points) {
      return normalizeZ2(Point2, points);
    }
    static msm(points, scalars) {
      return pippenger2(Point2, Fn3, points, scalars);
    }
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(_normFnElement(Fn3, privateKey));
    }
  }
  Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy, Fp3.ONE);
  Point2.ZERO = new Point2(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
  Point2.Fp = Fp3;
  Point2.Fn = Fn3;
  const bits = Fn3.BITS;
  const wnaf = new wNAF2(Point2, extraOpts.endo ? Math.ceil(bits / 2) : bits);
  Point2.BASE.precompute(8);
  return Point2;
}
function pprefix2(hasEvenY) {
  return Uint8Array.of(hasEvenY ? 2 : 3);
}
function SWUFpSqrtRatio2(Fp3, Z) {
  const q = Fp3.ORDER;
  let l2 = _0n16;
  for (let o2 = q - _1n15; o2 % _2n12 === _0n16; o2 /= _2n12)
    l2 += _1n15;
  const c1 = l2;
  const _2n_pow_c1_1 = _2n12 << c1 - _1n15 - _1n15;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n12;
  const c2 = (q - _1n15) / _2n_pow_c1;
  const c3 = (c2 - _1n15) / _2n12;
  const c4 = _2n_pow_c1 - _1n15;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp3.pow(Z, c2);
  const c7 = Fp3.pow(Z, (c2 + _1n15) / _2n12);
  let sqrtRatio = (u, v) => {
    let tv1 = c6;
    let tv2 = Fp3.pow(v, c4);
    let tv3 = Fp3.sqr(tv2);
    tv3 = Fp3.mul(tv3, v);
    let tv5 = Fp3.mul(u, tv3);
    tv5 = Fp3.pow(tv5, c3);
    tv5 = Fp3.mul(tv5, tv2);
    tv2 = Fp3.mul(tv5, v);
    tv3 = Fp3.mul(tv5, u);
    let tv4 = Fp3.mul(tv3, tv2);
    tv5 = Fp3.pow(tv4, c5);
    let isQR = Fp3.eql(tv5, Fp3.ONE);
    tv2 = Fp3.mul(tv3, c7);
    tv5 = Fp3.mul(tv4, tv1);
    tv3 = Fp3.cmov(tv2, tv3, isQR);
    tv4 = Fp3.cmov(tv5, tv4, isQR);
    for (let i2 = c1; i2 > _1n15; i2--) {
      let tv52 = i2 - _2n12;
      tv52 = _2n12 << tv52 - _1n15;
      let tvv5 = Fp3.pow(tv4, tv52);
      const e1 = Fp3.eql(tvv5, Fp3.ONE);
      tv2 = Fp3.mul(tv3, tv1);
      tv1 = Fp3.mul(tv1, tv1);
      tvv5 = Fp3.mul(tv4, tv1);
      tv3 = Fp3.cmov(tv2, tv3, e1);
      tv4 = Fp3.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp3.ORDER % _4n4 === _3n7) {
    const c12 = (Fp3.ORDER - _3n7) / _4n4;
    const c22 = Fp3.sqrt(Fp3.neg(Z));
    sqrtRatio = (u, v) => {
      let tv1 = Fp3.sqr(v);
      const tv2 = Fp3.mul(u, v);
      tv1 = Fp3.mul(tv1, tv2);
      let y1 = Fp3.pow(tv1, c12);
      y1 = Fp3.mul(y1, tv2);
      const y2 = Fp3.mul(y1, c22);
      const tv3 = Fp3.mul(Fp3.sqr(y1), v);
      const isQR = Fp3.eql(tv3, u);
      let y = Fp3.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU2(Fp3, opts) {
  validateField2(Fp3);
  const { A, B, Z } = opts;
  if (!Fp3.isValid(A) || !Fp3.isValid(B) || !Fp3.isValid(Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio2(Fp3, Z);
  if (!Fp3.isOdd)
    throw new Error("Field does not have .isOdd()");
  return (u) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp3.sqr(u);
    tv1 = Fp3.mul(tv1, Z);
    tv2 = Fp3.sqr(tv1);
    tv2 = Fp3.add(tv2, tv1);
    tv3 = Fp3.add(tv2, Fp3.ONE);
    tv3 = Fp3.mul(tv3, B);
    tv4 = Fp3.cmov(Z, Fp3.neg(tv2), !Fp3.eql(tv2, Fp3.ZERO));
    tv4 = Fp3.mul(tv4, A);
    tv2 = Fp3.sqr(tv3);
    tv6 = Fp3.sqr(tv4);
    tv5 = Fp3.mul(tv6, A);
    tv2 = Fp3.add(tv2, tv5);
    tv2 = Fp3.mul(tv2, tv3);
    tv6 = Fp3.mul(tv6, tv4);
    tv5 = Fp3.mul(tv6, B);
    tv2 = Fp3.add(tv2, tv5);
    x = Fp3.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y = Fp3.mul(tv1, u);
    y = Fp3.mul(y, value);
    x = Fp3.cmov(x, tv3, isValid);
    y = Fp3.cmov(y, value, isValid);
    const e1 = Fp3.isOdd(u) === Fp3.isOdd(y);
    y = Fp3.cmov(Fp3.neg(y), y, e1);
    const tv4_inv = FpInvertBatch2(Fp3, [tv4], true)[0];
    x = Fp3.mul(x, tv4_inv);
    return { x, y };
  };
}
function getWLengths2(Fp3, Fn3) {
  return {
    secretKey: Fn3.BYTES,
    publicKey: 1 + Fp3.BYTES,
    publicKeyUncompressed: 1 + 2 * Fp3.BYTES,
    publicKeyHasPrefix: true,
    signature: 2 * Fn3.BYTES
  };
}
function ecdh2(Point2, ecdhOpts = {}) {
  const { Fn: Fn3 } = Point2;
  const randomBytes_ = ecdhOpts.randomBytes || randomBytes;
  const lengths = Object.assign(getWLengths2(Point2.Fp, Fn3), { seed: getMinHashLength2(Fn3.ORDER) });
  function isValidSecretKey(secretKey) {
    try {
      return !!_normFnElement(Fn3, secretKey);
    } catch (error) {
      return false;
    }
  }
  function isValidPublicKey(publicKey, isCompressed) {
    const { publicKey: comp, publicKeyUncompressed } = lengths;
    try {
      const l2 = publicKey.length;
      if (isCompressed === true && l2 !== comp)
        return false;
      if (isCompressed === false && l2 !== publicKeyUncompressed)
        return false;
      return !!Point2.fromBytes(publicKey);
    } catch (error) {
      return false;
    }
  }
  function randomSecretKey(seed = randomBytes_(lengths.seed)) {
    return mapHashToField2(_abytes2(seed, lengths.seed, "seed"), Fn3.ORDER);
  }
  function getPublicKey(secretKey, isCompressed = true) {
    return Point2.BASE.multiply(_normFnElement(Fn3, secretKey)).toBytes(isCompressed);
  }
  function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: getPublicKey(secretKey) };
  }
  function isProbPub(item) {
    if (typeof item === "bigint")
      return false;
    if (item instanceof Point2)
      return true;
    const { secretKey, publicKey, publicKeyUncompressed } = lengths;
    if (Fn3.allowedLengths || secretKey === publicKey)
      return void 0;
    const l2 = ensureBytes("key", item).length;
    return l2 === publicKey || l2 === publicKeyUncompressed;
  }
  function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
    if (isProbPub(secretKeyA) === true)
      throw new Error("first arg must be private key");
    if (isProbPub(publicKeyB) === false)
      throw new Error("second arg must be public key");
    const s2 = _normFnElement(Fn3, secretKeyA);
    const b = Point2.fromHex(publicKeyB);
    return b.multiply(s2).toBytes(isCompressed);
  }
  const utils2 = {
    isValidSecretKey,
    isValidPublicKey,
    randomSecretKey,
    // TODO: remove
    isValidPrivateKey: isValidSecretKey,
    randomPrivateKey: randomSecretKey,
    normPrivateKeyToScalar: (key) => _normFnElement(Fn3, key),
    precompute(windowSize = 8, point = Point2.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point: Point2, utils: utils2, lengths });
}
function ecdsa2(Point2, hash, ecdsaOpts = {}) {
  ahash(hash);
  _validateObject(ecdsaOpts, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  const randomBytes5 = ecdsaOpts.randomBytes || randomBytes;
  const hmac3 = ecdsaOpts.hmac || ((key, ...msgs) => hmac2(hash, key, concatBytes(...msgs)));
  const { Fp: Fp3, Fn: Fn3 } = Point2;
  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn3;
  const { keygen, getPublicKey, getSharedSecret, utils: utils2, lengths } = ecdh2(Point2, ecdsaOpts);
  const defaultSigOpts = {
    prehash: false,
    lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : false,
    format: void 0,
    //'compact' as ECDSASigFormat,
    extraEntropy: false
  };
  const defaultSigOpts_format = "compact";
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n15;
    return number2 > HALF;
  }
  function validateRS(title, num3) {
    if (!Fn3.isValidNot0(num3))
      throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
    return num3;
  }
  function validateSigLength(bytes, format2) {
    validateSigFormat2(format2);
    const size = lengths.signature;
    const sizer = format2 === "compact" ? size : format2 === "recovered" ? size + 1 : void 0;
    return _abytes2(bytes, sizer, `${format2} signature`);
  }
  class Signature2 {
    constructor(r2, s2, recovery) {
      this.r = validateRS("r", r2);
      this.s = validateRS("s", s2);
      if (recovery != null)
        this.recovery = recovery;
      Object.freeze(this);
    }
    static fromBytes(bytes, format2 = defaultSigOpts_format) {
      validateSigLength(bytes, format2);
      let recid;
      if (format2 === "der") {
        const { r: r3, s: s3 } = DER2.toSig(_abytes2(bytes));
        return new Signature2(r3, s3);
      }
      if (format2 === "recovered") {
        recid = bytes[0];
        format2 = "compact";
        bytes = bytes.subarray(1);
      }
      const L = Fn3.BYTES;
      const r2 = bytes.subarray(0, L);
      const s2 = bytes.subarray(L, L * 2);
      return new Signature2(Fn3.fromBytes(r2), Fn3.fromBytes(s2), recid);
    }
    static fromHex(hex, format2) {
      return this.fromBytes(hexToBytes(hex), format2);
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(messageHash2) {
      const FIELD_ORDER = Fp3.ORDER;
      const { r: r2, s: s2, recovery: rec } = this;
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const hasCofactor = CURVE_ORDER * _2n12 < FIELD_ORDER;
      if (hasCofactor && rec > 1)
        throw new Error("recovery id is ambiguous for h>1 curve");
      const radj = rec === 2 || rec === 3 ? r2 + CURVE_ORDER : r2;
      if (!Fp3.isValid(radj))
        throw new Error("recovery id 2 or 3 invalid");
      const x = Fp3.toBytes(radj);
      const R = Point2.fromBytes(concatBytes(pprefix2((rec & 1) === 0), x));
      const ir = Fn3.inv(radj);
      const h = bits2int_modN(ensureBytes("msgHash", messageHash2));
      const u1 = Fn3.create(-h * ir);
      const u2 = Fn3.create(s2 * ir);
      const Q = Point2.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
      if (Q.is0())
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    toBytes(format2 = defaultSigOpts_format) {
      validateSigFormat2(format2);
      if (format2 === "der")
        return hexToBytes(DER2.hexFromSig(this));
      const r2 = Fn3.toBytes(this.r);
      const s2 = Fn3.toBytes(this.s);
      if (format2 === "recovered") {
        if (this.recovery == null)
          throw new Error("recovery bit must be present");
        return concatBytes(Uint8Array.of(this.recovery), r2, s2);
      }
      return concatBytes(r2, s2);
    }
    toHex(format2) {
      return bytesToHex(this.toBytes(format2));
    }
    // TODO: remove
    assertValidity() {
    }
    static fromCompact(hex) {
      return Signature2.fromBytes(ensureBytes("sig", hex), "compact");
    }
    static fromDER(hex) {
      return Signature2.fromBytes(ensureBytes("sig", hex), "der");
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, Fn3.neg(this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return bytesToHex(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return bytesToHex(this.toBytes("compact"));
    }
  }
  const bits2int2 = ecdsaOpts.bits2int || function bits2int_def(bytes) {
    if (bytes.length > 8192)
      throw new Error("input is too large");
    const num3 = bytesToNumberBE2(bytes);
    const delta = bytes.length * 8 - fnBits;
    return delta > 0 ? num3 >> BigInt(delta) : num3;
  };
  const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {
    return Fn3.create(bits2int2(bytes));
  };
  const ORDER_MASK = bitMask2(fnBits);
  function int2octets2(num3) {
    aInRange2("num < 2^" + fnBits, num3, _0n16, ORDER_MASK);
    return Fn3.toBytes(num3);
  }
  function validateMsgAndHash(message2, prehash) {
    _abytes2(message2, void 0, "message");
    return prehash ? _abytes2(hash(message2), void 0, "prehashed message") : message2;
  }
  function prepSig(message2, privateKey, opts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { lowS, prehash, extraEntropy } = validateSigOpts2(opts, defaultSigOpts);
    message2 = validateMsgAndHash(message2, prehash);
    const h1int = bits2int_modN(message2);
    const d2 = _normFnElement(Fn3, privateKey);
    const seedArgs = [int2octets2(d2), int2octets2(h1int)];
    if (extraEntropy != null && extraEntropy !== false) {
      const e2 = extraEntropy === true ? randomBytes5(lengths.secretKey) : extraEntropy;
      seedArgs.push(ensureBytes("extraEntropy", e2));
    }
    const seed = concatBytes(...seedArgs);
    const m2 = h1int;
    function k2sig(kBytes) {
      const k = bits2int2(kBytes);
      if (!Fn3.isValidNot0(k))
        return;
      const ik = Fn3.inv(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r2 = Fn3.create(q.x);
      if (r2 === _0n16)
        return;
      const s2 = Fn3.create(ik * Fn3.create(m2 + r2 * d2));
      if (s2 === _0n16)
        return;
      let recovery = (q.x === r2 ? 0 : 2) | Number(q.y & _1n15);
      let normS = s2;
      if (lowS && isBiggerThanHalfOrder(s2)) {
        normS = Fn3.neg(s2);
        recovery ^= 1;
      }
      return new Signature2(r2, normS, recovery);
    }
    return { seed, k2sig };
  }
  function sign3(message2, secretKey, opts = {}) {
    message2 = ensureBytes("message", message2);
    const { seed, k2sig } = prepSig(message2, secretKey, opts);
    const drbg = createHmacDrbg2(hash.outputLen, Fn3.BYTES, hmac3);
    const sig = drbg(seed, k2sig);
    return sig;
  }
  function tryParsingSig(sg) {
    let sig = void 0;
    const isHex = typeof sg === "string" || isBytes(sg);
    const isObj = !isHex && sg !== null && typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    if (isObj) {
      sig = new Signature2(sg.r, sg.s);
    } else if (isHex) {
      try {
        sig = Signature2.fromBytes(ensureBytes("sig", sg), "der");
      } catch (derError) {
        if (!(derError instanceof DER2.Err))
          throw derError;
      }
      if (!sig) {
        try {
          sig = Signature2.fromBytes(ensureBytes("sig", sg), "compact");
        } catch (error) {
          return false;
        }
      }
    }
    if (!sig)
      return false;
    return sig;
  }
  function verify2(signature, message2, publicKey, opts = {}) {
    const { lowS, prehash, format: format2 } = validateSigOpts2(opts, defaultSigOpts);
    publicKey = ensureBytes("publicKey", publicKey);
    message2 = validateMsgAndHash(ensureBytes("message", message2), prehash);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const sig = format2 === void 0 ? tryParsingSig(signature) : Signature2.fromBytes(ensureBytes("sig", signature), format2);
    if (sig === false)
      return false;
    try {
      const P = Point2.fromBytes(publicKey);
      if (lowS && sig.hasHighS())
        return false;
      const { r: r2, s: s2 } = sig;
      const h = bits2int_modN(message2);
      const is = Fn3.inv(s2);
      const u1 = Fn3.create(h * is);
      const u2 = Fn3.create(r2 * is);
      const R = Point2.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
      if (R.is0())
        return false;
      const v = Fn3.create(R.x);
      return v === r2;
    } catch (e2) {
      return false;
    }
  }
  function recoverPublicKey(signature, message2, opts = {}) {
    const { prehash } = validateSigOpts2(opts, defaultSigOpts);
    message2 = validateMsgAndHash(message2, prehash);
    return Signature2.fromBytes(signature, "recovered").recoverPublicKey(message2).toBytes();
  }
  return Object.freeze({
    keygen,
    getPublicKey,
    getSharedSecret,
    utils: utils2,
    lengths,
    Point: Point2,
    sign: sign3,
    verify: verify2,
    recoverPublicKey,
    Signature: Signature2,
    hash
  });
}
function _weierstrass_legacy_opts_to_new(c2) {
  const CURVE2 = {
    a: c2.a,
    b: c2.b,
    p: c2.Fp.ORDER,
    n: c2.n,
    h: c2.h,
    Gx: c2.Gx,
    Gy: c2.Gy
  };
  const Fp3 = c2.Fp;
  let allowedLengths = c2.allowedPrivateKeyLengths ? Array.from(new Set(c2.allowedPrivateKeyLengths.map((l2) => Math.ceil(l2 / 2)))) : void 0;
  const Fn3 = Field2(CURVE2.n, {
    BITS: c2.nBitLength,
    allowedLengths,
    modFromBytes: c2.wrapPrivateKey
  });
  const curveOpts = {
    Fp: Fp3,
    Fn: Fn3,
    allowInfinityPoint: c2.allowInfinityPoint,
    endo: c2.endo,
    isTorsionFree: c2.isTorsionFree,
    clearCofactor: c2.clearCofactor,
    fromBytes: c2.fromBytes,
    toBytes: c2.toBytes
  };
  return { CURVE: CURVE2, curveOpts };
}
function _ecdsa_legacy_opts_to_new(c2) {
  const { CURVE: CURVE2, curveOpts } = _weierstrass_legacy_opts_to_new(c2);
  const ecdsaOpts = {
    hmac: c2.hmac,
    randomBytes: c2.randomBytes,
    lowS: c2.lowS,
    bits2int: c2.bits2int,
    bits2int_modN: c2.bits2int_modN
  };
  return { CURVE: CURVE2, curveOpts, hash: c2.hash, ecdsaOpts };
}
function _ecdsa_new_output_to_legacy(c2, _ecdsa) {
  const Point2 = _ecdsa.Point;
  return Object.assign({}, _ecdsa, {
    ProjectivePoint: Point2,
    CURVE: Object.assign({}, c2, nLength2(Point2.Fn.ORDER, Point2.Fn.BITS))
  });
}
function weierstrass3(c2) {
  const { CURVE: CURVE2, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c2);
  const Point2 = weierstrassN(CURVE2, curveOpts);
  const signs = ecdsa2(Point2, hash, ecdsaOpts);
  return _ecdsa_new_output_to_legacy(c2, signs);
}

// node_modules/@noble/curves/esm/_shortw_utils.js
function createCurve(curveDef, defHash) {
  const create4 = (hash) => weierstrass3({ ...curveDef, hash });
  return { ...create4(defHash), create: create4 };
}

// node_modules/@noble/curves/esm/secp256k1.js
var secp256k1_CURVE2 = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var secp256k1_ENDO2 = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
};
var _0n17 = BigInt(0);
var _1n16 = BigInt(1);
var _2n13 = BigInt(2);
function sqrtMod3(y) {
  const P = secp256k1_CURVE2.p;
  const _3n8 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow22(b3, _3n8, P) * b3 % P;
  const b9 = pow22(b6, _3n8, P) * b3 % P;
  const b11 = pow22(b9, _2n13, P) * b2 % P;
  const b22 = pow22(b11, _11n, P) * b11 % P;
  const b44 = pow22(b22, _22n, P) * b22 % P;
  const b88 = pow22(b44, _44n, P) * b44 % P;
  const b176 = pow22(b88, _88n, P) * b88 % P;
  const b220 = pow22(b176, _44n, P) * b44 % P;
  const b223 = pow22(b220, _3n8, P) * b3 % P;
  const t1 = pow22(b223, _23n, P) * b22 % P;
  const t2 = pow22(t1, _6n, P) * b2 % P;
  const root = pow22(t2, _2n13, P);
  if (!Fpk12.eql(Fpk12.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk12 = Field2(secp256k1_CURVE2.p, { sqrt: sqrtMod3 });
var secp256k12 = createCurve({ ...secp256k1_CURVE2, Fp: Fpk12, lowS: true, endo: secp256k1_ENDO2 }, sha2562);
var TAGGED_HASH_PREFIXES3 = {};
function taggedHash2(tag, ...messages2) {
  let tagP = TAGGED_HASH_PREFIXES3[tag];
  if (tagP === void 0) {
    const tagH = sha2562(utf8ToBytes(tag));
    tagP = concatBytes(tagH, tagH);
    TAGGED_HASH_PREFIXES3[tag] = tagP;
  }
  return sha2562(concatBytes(tagP, ...messages2));
}
var pointToBytes2 = (point) => point.toBytes(true).slice(1);
var Pointk12 = (() => secp256k12.Point)();
var hasEven2 = (y) => y % _2n13 === _0n17;
function schnorrGetExtPubKey2(priv) {
  const { Fn: Fn3, BASE } = Pointk12;
  const d_ = _normFnElement(Fn3, priv);
  const p2 = BASE.multiply(d_);
  const scalar = hasEven2(p2.y) ? d_ : Fn3.neg(d_);
  return { scalar, bytes: pointToBytes2(p2) };
}
function lift_x2(x) {
  const Fp3 = Fpk12;
  if (!Fp3.isValidNot0(x))
    throw new Error("invalid x: Fail if x  p");
  const xx = Fp3.create(x * x);
  const c2 = Fp3.create(xx * x + BigInt(7));
  let y = Fp3.sqrt(c2);
  if (!hasEven2(y))
    y = Fp3.neg(y);
  const p2 = Pointk12.fromAffine({ x, y });
  p2.assertValidity();
  return p2;
}
var num2 = bytesToNumberBE2;
function challenge2(...args) {
  return Pointk12.Fn.create(num2(taggedHash2("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey2(secretKey) {
  return schnorrGetExtPubKey2(secretKey).bytes;
}
function schnorrSign2(message2, secretKey, auxRand = randomBytes(32)) {
  const { Fn: Fn3 } = Pointk12;
  const m2 = ensureBytes("message", message2);
  const { bytes: px, scalar: d2 } = schnorrGetExtPubKey2(secretKey);
  const a2 = ensureBytes("auxRand", auxRand, 32);
  const t2 = Fn3.toBytes(d2 ^ num2(taggedHash2("BIP0340/aux", a2)));
  const rand = taggedHash2("BIP0340/nonce", t2, px, m2);
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey2(rand);
  const e2 = challenge2(rx, px, m2);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(Fn3.toBytes(Fn3.create(k + e2 * d2)), 32);
  if (!schnorrVerify2(sig, m2, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify2(signature, message2, publicKey) {
  const { Fn: Fn3, BASE } = Pointk12;
  const sig = ensureBytes("signature", signature, 64);
  const m2 = ensureBytes("message", message2);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x2(num2(pub));
    const r2 = num2(sig.subarray(0, 32));
    if (!inRange2(r2, _1n16, secp256k1_CURVE2.p))
      return false;
    const s2 = num2(sig.subarray(32, 64));
    if (!inRange2(s2, _1n16, secp256k1_CURVE2.n))
      return false;
    const e2 = challenge2(Fn3.toBytes(r2), pointToBytes2(P), m2);
    const R = BASE.multiplyUnsafe(s2).add(P.multiplyUnsafe(Fn3.neg(e2)));
    const { x, y } = R.toAffine();
    if (R.is0() || !hasEven2(y) || x !== r2)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr2 = (() => {
  const size = 32;
  const seedLength = 48;
  const randomSecretKey = (seed = randomBytes(seedLength)) => {
    return mapHashToField2(seed, secp256k1_CURVE2.n);
  };
  secp256k12.utils.randomSecretKey;
  function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: schnorrGetPublicKey2(secretKey) };
  }
  return {
    keygen,
    getPublicKey: schnorrGetPublicKey2,
    sign: schnorrSign2,
    verify: schnorrVerify2,
    Point: Pointk12,
    utils: {
      randomSecretKey,
      randomPrivateKey: randomSecretKey,
      taggedHash: taggedHash2,
      // TODO: remove
      lift_x: lift_x2,
      pointToBytes: pointToBytes2,
      numberToBytesBE: numberToBytesBE2,
      bytesToNumberBE: bytesToNumberBE2,
      mod: mod2
    },
    lengths: {
      secretKey: size,
      publicKey: size,
      publicKeyHasPrefix: false,
      signature: size * 2,
      seed: seedLength
    }
  };
})();
var isoMap2 = (() => isogenyMap2(Fpk12, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i2) => i2.map((j) => BigInt(j)))))();
var mapSWU2 = (() => mapToCurveSimpleSWU2(Fpk12, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fpk12.create(BigInt("-11"))
}))();
var secp256k1_hasher2 = (() => createHasher4(secp256k12.Point, (scalars) => {
  const { x, y } = mapSWU2(Fpk12.create(scalars[0]));
  return isoMap2(x, y);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fpk12.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha2562
}))();
var hashToCurve2 = (() => secp256k1_hasher2.hashToCurve)();
var encodeToCurve2 = (() => secp256k1_hasher2.encodeToCurve)();

// node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/secp256k1/index.browser.js
var PUBLIC_KEY_BYTE_LENGTH4 = 33;
function hashAndVerify8(key, sig, msg, options) {
  var _a27;
  const p2 = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray());
  if (isPromise4(p2)) {
    return p2.then(({ digest: digest2 }) => {
      var _a28;
      (_a28 = options == null ? void 0 : options.signal) == null ? void 0 : _a28.throwIfAborted();
      return secp256k12.verify(sig, digest2, key);
    }).catch((err) => {
      if (err.name === "AbortError") {
        throw err;
      }
      throw new VerificationError2(String(err));
    });
  }
  try {
    (_a27 = options == null ? void 0 : options.signal) == null ? void 0 : _a27.throwIfAborted();
    return secp256k12.verify(sig, p2.digest, key);
  } catch (err) {
    throw new VerificationError2(String(err));
  }
}

// node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/secp256k1/secp256k1.js
var Secp256k1PublicKey2 = class {
  constructor(key) {
    __publicField(this, "type", "secp256k1");
    __publicField(this, "raw");
    __publicField(this, "_key");
    this._key = validateSecp256k1PublicKey2(key);
    this.raw = compressSecp256k1PublicKey2(this._key);
  }
  toMultihash() {
    return identity2.digest(publicKeyToProtobuf2(this));
  }
  toCID() {
    return CID.createV1(114, this.toMultihash());
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.raw, key.raw);
  }
  verify(data, sig, options) {
    return hashAndVerify8(this._key, sig, data, options);
  }
};

// node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/secp256k1/utils.js
function unmarshalSecp256k1PublicKey2(bytes) {
  return new Secp256k1PublicKey2(bytes);
}
function compressSecp256k1PublicKey2(key) {
  const point = secp256k12.ProjectivePoint.fromHex(key).toRawBytes(true);
  return point;
}
function validateSecp256k1PublicKey2(key) {
  try {
    secp256k12.ProjectivePoint.fromHex(key);
    return key;
  } catch (err) {
    throw new InvalidPublicKeyError(String(err));
  }
}

// node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/ecdh/index.browser.js
var curveLengths2 = {
  "P-256": 32,
  "P-384": 48,
  "P-521": 66
};
var curveTypes2 = Object.keys(curveLengths2);
var names3 = curveTypes2.join(" / ");

// node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/index.js
function publicKeyFromRaw(buf) {
  var _a27, _b14;
  if (buf.byteLength === PUBLIC_KEY_BYTE_LENGTH3) {
    return unmarshalEd25519PublicKey2(buf);
  } else if (buf.byteLength === PUBLIC_KEY_BYTE_LENGTH4) {
    return unmarshalSecp256k1PublicKey2(buf);
  }
  const message2 = decodeDer2(buf);
  const ecdsaOid = (_a27 = message2[1]) == null ? void 0 : _a27[0];
  if (ecdsaOid === ECDSA_P_256_OID2 || ecdsaOid === ECDSA_P_384_OID2 || ecdsaOid === ECDSA_P_521_OID2) {
    return pkiMessageToECDSAPublicKey2(message2);
  }
  if (((_b14 = message2[0]) == null ? void 0 : _b14[0]) === RSAES_PKCS1_V1_5_OID2) {
    return pkixMessageToRSAPublicKey2(message2, buf);
  }
  throw new InvalidParametersError("Could not extract public key from raw bytes");
}
function publicKeyToProtobuf2(key) {
  return PublicKey2.encode({
    Type: KeyType2[key.type],
    Data: key.raw
  });
}

// node_modules/@waku/enr/node_modules/@libp2p/peer-id/dist/src/peer-id.js
var inspect3 = Symbol.for("nodejs.util.inspect.custom");
var LIBP2P_KEY_CODE3 = 114;
var _a25;
var PeerIdImpl2 = class {
  constructor(init) {
    __publicField(this, "type");
    __publicField(this, "multihash");
    __publicField(this, "publicKey");
    __publicField(this, "string");
    __publicField(this, _a25, true);
    this.type = init.type;
    this.multihash = init.multihash;
    Object.defineProperty(this, "string", {
      enumerable: false,
      writable: true
    });
  }
  get [Symbol.toStringTag]() {
    return `PeerId(${this.toString()})`;
  }
  toString() {
    if (this.string == null) {
      this.string = base58btc.encode(this.multihash.bytes).slice(1);
    }
    return this.string;
  }
  toMultihash() {
    return this.multihash;
  }
  // return self-describing String representation
  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
  toCID() {
    return CID.createV1(LIBP2P_KEY_CODE3, this.multihash);
  }
  toJSON() {
    return this.toString();
  }
  /**
   * Checks the equality of `this` peer against a given PeerId
   */
  equals(id) {
    var _a27;
    if (id == null) {
      return false;
    }
    if (id instanceof Uint8Array) {
      return equals3(this.multihash.bytes, id);
    } else if (typeof id === "string") {
      return this.toString() === id;
    } else if (((_a27 = id == null ? void 0 : id.toMultihash()) == null ? void 0 : _a27.bytes) != null) {
      return equals3(this.multihash.bytes, id.toMultihash().bytes);
    } else {
      throw new Error("not valid Id");
    }
  }
  /**
   * Returns PeerId as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```TypeScript
   * import { peerIdFromString } from '@libp2p/peer-id'
   *
   * console.info(peerIdFromString('QmFoo'))
   * // 'PeerId(QmFoo)'
   * ```
   */
  [(_a25 = peerIdSymbol, inspect3)]() {
    return `PeerId(${this.toString()})`;
  }
};
var RSAPeerId2 = class extends PeerIdImpl2 {
  constructor(init) {
    super({ ...init, type: "RSA" });
    __publicField(this, "type", "RSA");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var Ed25519PeerId2 = class extends PeerIdImpl2 {
  constructor(init) {
    super({ ...init, type: "Ed25519" });
    __publicField(this, "type", "Ed25519");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var Secp256k1PeerId2 = class extends PeerIdImpl2 {
  constructor(init) {
    super({ ...init, type: "secp256k1" });
    __publicField(this, "type", "secp256k1");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var TRANSPORT_IPFS_GATEWAY_HTTP_CODE3 = 2336;
var _a26, _b13;
var URLPeerId2 = class {
  constructor(url) {
    __publicField(this, "type", "url");
    __publicField(this, "multihash");
    __publicField(this, "publicKey");
    __publicField(this, "url");
    __publicField(this, _a26, true);
    this.url = url.toString();
    this.multihash = identity2.digest(fromString2(this.url));
  }
  [(_b13 = inspect3, _a26 = peerIdSymbol, _b13)]() {
    return `PeerId(${this.url})`;
  }
  toString() {
    return this.toCID().toString();
  }
  toMultihash() {
    return this.multihash;
  }
  toCID() {
    return CID.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE3, this.toMultihash());
  }
  toJSON() {
    return this.toString();
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (other instanceof Uint8Array) {
      other = toString2(other);
    }
    return other.toString() === this.toString();
  }
};

// node_modules/@waku/enr/node_modules/@libp2p/peer-id/dist/src/index.js
function peerIdFromPublicKey2(publicKey) {
  if (publicKey.type === "Ed25519") {
    return new Ed25519PeerId2({
      multihash: publicKey.toCID().multihash,
      publicKey
    });
  } else if (publicKey.type === "secp256k1") {
    return new Secp256k1PeerId2({
      multihash: publicKey.toCID().multihash,
      publicKey
    });
  } else if (publicKey.type === "RSA") {
    return new RSAPeerId2({
      multihash: publicKey.toCID().multihash,
      publicKey
    });
  }
  throw new UnsupportedKeyTypeError();
}

// node_modules/@waku/enr/dist/peer_id.js
var ERR_TYPE_NOT_IMPLEMENTED = "Keypair type not implemented";
function createPeerIdFromPublicKey(publicKey) {
  const pubKey = publicKeyFromRaw(publicKey);
  if (pubKey.type !== "secp256k1") {
    throw new Error(ERR_TYPE_NOT_IMPLEMENTED);
  }
  return peerIdFromPublicKey2(pubKey);
}

// node_modules/@waku/enr/dist/multiaddrs_codec.js
function decodeMultiaddrs(bytes) {
  const multiaddrs = [];
  let index = 0;
  while (index < bytes.length) {
    const sizeDataView = new DataView(bytes.buffer, index, MULTIADDR_LENGTH_SIZE);
    const size = sizeDataView.getUint16(0);
    index += MULTIADDR_LENGTH_SIZE;
    const multiaddrBytes = bytes.slice(index, index + size);
    index += size;
    multiaddrs.push(multiaddr(multiaddrBytes));
  }
  return multiaddrs;
}
function encodeMultiaddrs(multiaddrs) {
  const totalLength = multiaddrs.reduce((acc, ma) => acc + MULTIADDR_LENGTH_SIZE + ma.bytes.length, 0);
  const bytes = new Uint8Array(totalLength);
  const dataView = new DataView(bytes.buffer);
  let index = 0;
  multiaddrs.forEach((multiaddr2) => {
    if (multiaddr2.getPeerId())
      throw new Error("`multiaddr` field MUST not contain peer id");
    dataView.setUint16(index, multiaddr2.bytes.length);
    index += MULTIADDR_LENGTH_SIZE;
    bytes.set(multiaddr2.bytes, index);
    index += multiaddr2.bytes.length;
  });
  return bytes;
}

// node_modules/@waku/enr/dist/waku2_codec.js
function encodeWaku2(protocols2) {
  let byte = 0;
  if (protocols2.lightPush)
    byte += 1;
  byte = byte << 1;
  if (protocols2.filter)
    byte += 1;
  byte = byte << 1;
  if (protocols2.store)
    byte += 1;
  byte = byte << 1;
  if (protocols2.relay)
    byte += 1;
  return byte;
}
function decodeWaku2(byte) {
  const waku2 = {
    relay: false,
    store: false,
    filter: false,
    lightPush: false
  };
  if (byte % 2)
    waku2.relay = true;
  byte = byte >> 1;
  if (byte % 2)
    waku2.store = true;
  byte = byte >> 1;
  if (byte % 2)
    waku2.filter = true;
  byte = byte >> 1;
  if (byte % 2)
    waku2.lightPush = true;
  return waku2;
}

// node_modules/@waku/enr/dist/raw_enr.js
var RawEnr = class extends Map {
  constructor(kvs = {}, seq = BigInt(1), signature) {
    super(Object.entries(kvs));
    __publicField(this, "seq");
    __publicField(this, "signature");
    this.seq = seq;
    this.signature = signature;
  }
  set(k, v) {
    this.signature = void 0;
    this.seq++;
    return super.set(k, v);
  }
  get id() {
    const id = this.get("id");
    if (!id)
      throw new Error("id not found.");
    return bytesToUtf8(id);
  }
  get publicKey() {
    switch (this.id) {
      case "v4":
        return this.get("secp256k1");
      default:
        throw new Error(ERR_INVALID_ID);
    }
  }
  get rs() {
    const rs = this.get("rs");
    if (!rs)
      return void 0;
    return decodeRelayShard(rs);
  }
  get rsv() {
    const rsv = this.get("rsv");
    if (!rsv)
      return void 0;
    return decodeRelayShard(rsv);
  }
  get ip() {
    return getStringValue(this, "ip", "ip4");
  }
  set ip(ip) {
    setStringValue(this, "ip", "ip4", ip);
  }
  get tcp() {
    return getNumberAsStringValue(this, "tcp", "tcp");
  }
  set tcp(port) {
    setNumberAsStringValue(this, "tcp", "tcp", port);
  }
  get udp() {
    return getNumberAsStringValue(this, "udp", "udp");
  }
  set udp(port) {
    setNumberAsStringValue(this, "udp", "udp", port);
  }
  get ip6() {
    return getStringValue(this, "ip6", "ip6");
  }
  set ip6(ip) {
    setStringValue(this, "ip6", "ip6", ip);
  }
  get tcp6() {
    return getNumberAsStringValue(this, "tcp6", "tcp");
  }
  set tcp6(port) {
    setNumberAsStringValue(this, "tcp6", "tcp", port);
  }
  get udp6() {
    return getNumberAsStringValue(this, "udp6", "udp");
  }
  set udp6(port) {
    setNumberAsStringValue(this, "udp6", "udp", port);
  }
  /**
   * Get the `multiaddrs` field from ENR.
   *
   * This field is used to store multiaddresses that cannot be stored with the current ENR pre-defined keys.
   * These can be a multiaddresses that include encapsulation (e.g. wss) or do not use `ip4` nor `ip6` for the host
   * address (e.g. `dns4`, `dnsaddr`, etc)..
   *
   * If the peer information only contains information that can be represented with the ENR pre-defined keys
   * (ip, tcp, etc) then the usage of { @link ENR.getLocationMultiaddr } should be preferred.
   *
   * The multiaddresses stored in this field are expected to be location multiaddresses, ie, peer id less.
   */
  get multiaddrs() {
    const raw = this.get("multiaddrs");
    if (raw)
      return decodeMultiaddrs(raw);
    return;
  }
  /**
   * Set the `multiaddrs` field on the ENR.
   *
   * This field is used to store multiaddresses that cannot be stored with the current ENR pre-defined keys.
   * These can be a multiaddresses that include encapsulation (e.g. wss) or do not use `ip4` nor `ip6` for the host
   * address (e.g. `dns4`, `dnsaddr`, etc)..
   *
   * If the peer information only contains information that can be represented with the ENR pre-defined keys
   * (ip, tcp, etc) then the usage of { @link ENR.setLocationMultiaddr } should be preferred.
   * The multiaddresses stored in this field must be location multiaddresses,
   * ie, without a peer id.
   */
  set multiaddrs(multiaddrs) {
    deleteUndefined(this, "multiaddrs", multiaddrs, encodeMultiaddrs);
  }
  /**
   * Get the `waku2` field from ENR.
   */
  get waku2() {
    const raw = this.get("waku2");
    if (raw)
      return decodeWaku2(raw[0]);
    return;
  }
  /**
   * Set the `waku2` field on the ENR.
   */
  set waku2(waku2) {
    deleteUndefined(this, "waku2", waku2, (w) => new Uint8Array([encodeWaku2(w)]));
  }
};
function getStringValue(map2, key, proto) {
  const raw = map2.get(key);
  if (!raw)
    return;
  return convertToString(proto, raw);
}
function getNumberAsStringValue(map2, key, proto) {
  const raw = map2.get(key);
  if (!raw)
    return;
  return Number(convertToString(proto, raw));
}
function setStringValue(map2, key, proto, value) {
  deleteUndefined(map2, key, value, convertToBytes.bind({}, proto));
}
function setNumberAsStringValue(map2, key, proto, value) {
  setStringValue(map2, key, proto, value == null ? void 0 : value.toString(10));
}
function deleteUndefined(map2, key, value, transform) {
  if (value !== void 0) {
    map2.set(key, transform(value));
  } else {
    map2.delete(key);
  }
}

// node_modules/@waku/enr/dist/v4.js
async function sign2(privKey, msg) {
  return sign(keccak256(msg), privKey, {
    der: false
  });
}
function nodeId(pubKey) {
  const publicKey = Point.fromHex(pubKey);
  const uncompressedPubkey = publicKey.toRawBytes(false);
  return bytesToHex2(keccak256(uncompressedPubkey.slice(1)));
}

// node_modules/@waku/enr/dist/enr.js
var log23 = new Logger("enr");
var TransportProtocol;
(function(TransportProtocol2) {
  TransportProtocol2["TCP"] = "tcp";
  TransportProtocol2["UDP"] = "udp";
})(TransportProtocol || (TransportProtocol = {}));
var TransportProtocolPerIpVersion;
(function(TransportProtocolPerIpVersion2) {
  TransportProtocolPerIpVersion2["TCP4"] = "tcp4";
  TransportProtocolPerIpVersion2["UDP4"] = "udp4";
  TransportProtocolPerIpVersion2["TCP6"] = "tcp6";
  TransportProtocolPerIpVersion2["UDP6"] = "udp6";
})(TransportProtocolPerIpVersion || (TransportProtocolPerIpVersion = {}));
var _ENR = class _ENR extends RawEnr {
  constructor() {
    super(...arguments);
    __publicField(this, "peerId");
    __publicField(this, "getLocationMultiaddr", locationMultiaddrFromEnrFields.bind({}, this));
  }
  static create(kvs = {}, seq = BigInt(1), signature) {
    const enr = new _ENR(kvs, seq, signature);
    try {
      const publicKey = enr.publicKey;
      if (publicKey) {
        enr.peerId = createPeerIdFromPublicKey(publicKey);
      }
    } catch (e2) {
      log23.error("Could not calculate peer id for ENR", e2);
    }
    return enr;
  }
  get nodeId() {
    switch (this.id) {
      case "v4":
        return this.publicKey ? nodeId(this.publicKey) : void 0;
      default:
        throw new Error(ERR_INVALID_ID);
    }
  }
  get shardInfo() {
    if (this.rs && this.rsv) {
      log23.warn("ENR contains both `rs` and `rsv` fields.");
    }
    return this.rs || this.rsv;
  }
  setLocationMultiaddr(multiaddr2) {
    const protoNames = multiaddr2.protoNames();
    if (protoNames.length !== 2 && protoNames[1] !== "udp" && protoNames[1] !== "tcp") {
      throw new Error("Invalid multiaddr");
    }
    const tuples = multiaddr2.tuples();
    if (!tuples[0][1] || !tuples[1][1]) {
      throw new Error("Invalid multiaddr");
    }
    if (tuples[0][0] === 4) {
      this.set("ip", tuples[0][1]);
      this.set(protoNames[1], tuples[1][1]);
    } else {
      this.set("ip6", tuples[0][1]);
      this.set(protoNames[1] + "6", tuples[1][1]);
    }
  }
  getAllLocationMultiaddrs() {
    const multiaddrs = [];
    for (const protocol of Object.values(TransportProtocolPerIpVersion)) {
      const ma = this.getLocationMultiaddr(protocol);
      if (ma)
        multiaddrs.push(ma);
    }
    const _multiaddrs = this.multiaddrs ?? [];
    return multiaddrs.concat(_multiaddrs).map((ma) => {
      if (this.peerId) {
        return ma.encapsulate(`/p2p/${this.peerId.toString()}`);
      }
      return ma;
    });
  }
  get peerInfo() {
    const id = this.peerId;
    if (!id)
      return;
    return {
      id,
      multiaddrs: this.getAllLocationMultiaddrs()
    };
  }
  /**
   * Returns the full multiaddr from the ENR fields matching the provided
   * `protocol` parameter.
   * To return full multiaddrs from the `multiaddrs` ENR field,
   * use { @link ENR.getFullMultiaddrs }.
   *
   * @param protocol
   */
  getFullMultiaddr(protocol) {
    if (this.peerId) {
      const locationMultiaddr = this.getLocationMultiaddr(protocol);
      if (locationMultiaddr) {
        return locationMultiaddr.encapsulate(`/p2p/${this.peerId.toString()}`);
      }
    }
    return;
  }
  /**
   * Returns the full multiaddrs from the `multiaddrs` ENR field.
   */
  getFullMultiaddrs() {
    if (this.peerId && this.multiaddrs) {
      const peerId2 = this.peerId;
      return this.multiaddrs.map((ma) => {
        return ma.encapsulate(`/p2p/${peerId2.toString()}`);
      });
    }
    return [];
  }
  verify(data, signature) {
    if (!this.get("id") || this.id !== "v4") {
      throw new Error(ERR_INVALID_ID);
    }
    if (!this.publicKey) {
      throw new Error("Failed to verify ENR: No public key");
    }
    return verifySignature(signature, keccak256(data), this.publicKey);
  }
  async sign(data, privateKey) {
    switch (this.id) {
      case "v4":
        this.signature = await sign2(privateKey, data);
        break;
      default:
        throw new Error(ERR_INVALID_ID);
    }
    return this.signature;
  }
};
__publicField(_ENR, "RECORD_PREFIX", "enr:");
var ENR = _ENR;

// node_modules/@ethersproject/logger/lib.esm/_version.js
var version2 = "logger/5.8.0";

// node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors = false;
var _censorErrors = false;
var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel = LogLevels["default"];
var _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel2) {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
var HEX = "0123456789abcdef";
var Logger2 = class _Logger {
  constructor(version5) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version5,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(_Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(_Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(_Logger.levels.WARNING, args);
  }
  makeError(message2, code2, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code2, {});
    }
    if (!code2) {
      code2 = _Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key) => {
      const value = params[key];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX[value[i2] >> 4];
            hex += HEX[value[i2] & 15];
          }
          messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
      }
    });
    messageDetails.push(`code=${code2}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message2;
    let url = "";
    switch (code2) {
      case ErrorCode.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message2;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code2;
        break;
    }
    if (url) {
      message2 += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message2 += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message2);
    error.reason = reason;
    error.code = code2;
    Object.keys(params).forEach(function(key) {
      error[key] = params[key];
    });
    return error;
  }
  throwError(message2, code2, params) {
    throw this.makeError(message2, code2, params);
  }
  throwArgumentError(message2, name3, value) {
    return this.throwError(message2, _Logger.errors.INVALID_ARGUMENT, {
      argument: name3,
      value
    });
  }
  assert(condition, message2, code2, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message2, code2, params);
  }
  assertArgument(condition, message2, name3, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message2, name3, value);
  }
  checkNormalize(message2) {
    if (message2 == null) {
      message2 = "platform missing String.prototype.normalize";
    }
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", _Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message2) {
    if (typeof value !== "number") {
      return;
    }
    if (message2 == null) {
      message2 = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message2, _Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message2, _Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message2) {
    if (message2) {
      message2 = ": " + message2;
    } else {
      message2 = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message2, _Logger.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message2, _Logger.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", _Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new _Logger(version2);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", _Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", _Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      _Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version5) {
    return new _Logger(version5);
  }
};
Logger2.errors = ErrorCode;
Logger2.levels = LogLevel;

// node_modules/@ethersproject/bytes/lib.esm/_version.js
var version3 = "bytes/5.8.0";

// node_modules/@ethersproject/bytes/lib.esm/index.js
var logger2 = new Logger2(version3);
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes5(value);
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes5(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v = value[i2];
    if (!isInteger(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger2.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger2.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes5(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger2.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString(value, length3) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length3 && value.length !== 2 + 2 * length3) {
    return false;
  }
  return true;
}
var HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger2.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger2.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes5(value)) {
    let result = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      let v = value[i2];
      result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
    }
    return result;
  }
  return logger2.throwArgumentError("invalid hexlify value", "value", value);
}

// node_modules/@ethersproject/rlp/lib.esm/_version.js
var version4 = "rlp/5.8.0";

// node_modules/@ethersproject/rlp/lib.esm/index.js
var logger3 = new Logger2(version4);
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger(data, offset, length3) {
  let result = 0;
  for (let i2 = 0; i2 < length3; i2++) {
    result = result * 256 + data[offset + i2];
  }
  return result;
}
function _encode(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length4 = arrayifyInteger(payload.length);
    length4.unshift(247 + length4.length);
    return length4.concat(payload);
  }
  if (!isBytesLike(object)) {
    logger3.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data = Array.prototype.slice.call(arrayify(object));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length3 = arrayifyInteger(data.length);
  length3.unshift(183 + length3.length);
  return length3.concat(data);
}
function encode9(object) {
  return hexlify(_encode(object));
}
function _decodeChildren(data, offset, childOffset, length3) {
  const result = [];
  while (childOffset < offset + 1 + length3) {
    const decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length3) {
      logger3.throwError("child data too short", Logger2.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length3, result };
}
function _decode(data, offset) {
  if (data.length === 0) {
    logger3.throwError("data too short", Logger2.errors.BUFFER_OVERRUN, {});
  }
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    if (offset + 1 + lengthLength > data.length) {
      logger3.throwError("data short segment too short", Logger2.errors.BUFFER_OVERRUN, {});
    }
    const length3 = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length3 > data.length) {
      logger3.throwError("data long segment too short", Logger2.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length3);
  } else if (data[offset] >= 192) {
    const length3 = data[offset] - 192;
    if (offset + 1 + length3 > data.length) {
      logger3.throwError("data array too short", Logger2.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1, length3);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    if (offset + 1 + lengthLength > data.length) {
      logger3.throwError("data array too short", Logger2.errors.BUFFER_OVERRUN, {});
    }
    const length3 = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length3 > data.length) {
      logger3.throwError("data array too short", Logger2.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length3));
    return { consumed: 1 + lengthLength + length3, result };
  } else if (data[offset] >= 128) {
    const length3 = data[offset] - 128;
    if (offset + 1 + length3 > data.length) {
      logger3.throwError("data too short", Logger2.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1, offset + 1 + length3));
    return { consumed: 1 + length3, result };
  }
  return { consumed: 1, result: hexlify(data[offset]) };
}
function decode9(data) {
  const bytes = arrayify(data);
  const decoded = _decode(bytes, 0);
  if (decoded.consumed !== bytes.length) {
    logger3.throwArgumentError("invalid rlp data", "data", data);
  }
  return decoded.result;
}

// node_modules/@waku/enr/dist/decoder.js
var log24 = new Logger("enr:decoder");
var EnrDecoder = class _EnrDecoder {
  static fromString(encoded) {
    if (!encoded.startsWith(ENR.RECORD_PREFIX)) {
      throw new Error(`"string encoded ENR must start with '${ENR.RECORD_PREFIX}'`);
    }
    return _EnrDecoder.fromRLP(fromString2(encoded.slice(4), "base64url"));
  }
  static fromRLP(encoded) {
    const decoded = decode9(encoded).map(hexToBytes2);
    return fromValues(decoded);
  }
};
async function fromValues(values) {
  const { signature, seq, kvs } = checkValues(values);
  const obj = {};
  for (let i2 = 0; i2 < kvs.length; i2 += 2) {
    try {
      obj[bytesToUtf8(kvs[i2])] = kvs[i2 + 1];
    } catch (e2) {
      log24.error("Failed to decode ENR key to UTF-8, skipping it", kvs[i2], e2);
    }
  }
  const _seq = decodeSeq(seq);
  const enr = ENR.create(obj, _seq, signature);
  checkSignature(seq, kvs, enr, signature);
  return enr;
}
function decodeSeq(seq) {
  if (!seq.length)
    return BigInt(0);
  return BigInt("0x" + bytesToHex2(seq));
}
function checkValues(values) {
  if (!Array.isArray(values)) {
    throw new Error("Decoded ENR must be an array");
  }
  if (values.length % 2 !== 0) {
    throw new Error("Decoded ENR must have an even number of elements");
  }
  const [signature, seq, ...kvs] = values;
  if (!signature || Array.isArray(signature)) {
    throw new Error("Decoded ENR invalid signature: must be a byte array");
  }
  if (!seq || Array.isArray(seq)) {
    throw new Error("Decoded ENR invalid sequence number: must be a byte array");
  }
  return { signature, seq, kvs };
}
function checkSignature(seq, kvs, enr, signature) {
  const rlpEncodedBytes = hexToBytes2(encode9([seq, ...kvs]));
  if (!enr.verify(rlpEncodedBytes, signature)) {
    throw new Error("Unable to verify ENR signature");
  }
}

// node_modules/quick-lru/index.js
var _size, _cache, _oldCache, _maxSize, _maxAge, _onEviction, _QuickLRU_instances, emitEvictions_fn, deleteIfExpired_fn, getOrDeleteIfExpired_fn, getItemValue_fn, peek_fn, set_fn, moveToRecent_fn, entriesAscending_fn;
var QuickLRU = class extends Map {
  constructor(options = {}) {
    super();
    __privateAdd(this, _QuickLRU_instances);
    __privateAdd(this, _size, 0);
    __privateAdd(this, _cache, /* @__PURE__ */ new Map());
    __privateAdd(this, _oldCache, /* @__PURE__ */ new Map());
    __privateAdd(this, _maxSize);
    __privateAdd(this, _maxAge);
    __privateAdd(this, _onEviction);
    if (!(options.maxSize && options.maxSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    if (typeof options.maxAge === "number" && options.maxAge === 0) {
      throw new TypeError("`maxAge` must be a number greater than 0");
    }
    __privateSet(this, _maxSize, options.maxSize);
    __privateSet(this, _maxAge, options.maxAge || Number.POSITIVE_INFINITY);
    __privateSet(this, _onEviction, options.onEviction);
  }
  // For tests.
  get __oldCache() {
    return __privateGet(this, _oldCache);
  }
  get(key) {
    if (__privateGet(this, _cache).has(key)) {
      const item = __privateGet(this, _cache).get(key);
      return __privateMethod(this, _QuickLRU_instances, getItemValue_fn).call(this, key, item);
    }
    if (__privateGet(this, _oldCache).has(key)) {
      const item = __privateGet(this, _oldCache).get(key);
      if (__privateMethod(this, _QuickLRU_instances, deleteIfExpired_fn).call(this, key, item) === false) {
        __privateMethod(this, _QuickLRU_instances, moveToRecent_fn).call(this, key, item);
        return item.value;
      }
    }
  }
  set(key, value, { maxAge = __privateGet(this, _maxAge) } = {}) {
    const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
    if (__privateGet(this, _cache).has(key)) {
      __privateGet(this, _cache).set(key, {
        value,
        expiry
      });
    } else {
      __privateMethod(this, _QuickLRU_instances, set_fn).call(this, key, { value, expiry });
    }
    return this;
  }
  has(key) {
    if (__privateGet(this, _cache).has(key)) {
      return !__privateMethod(this, _QuickLRU_instances, deleteIfExpired_fn).call(this, key, __privateGet(this, _cache).get(key));
    }
    if (__privateGet(this, _oldCache).has(key)) {
      return !__privateMethod(this, _QuickLRU_instances, deleteIfExpired_fn).call(this, key, __privateGet(this, _oldCache).get(key));
    }
    return false;
  }
  peek(key) {
    if (__privateGet(this, _cache).has(key)) {
      return __privateMethod(this, _QuickLRU_instances, peek_fn).call(this, key, __privateGet(this, _cache));
    }
    if (__privateGet(this, _oldCache).has(key)) {
      return __privateMethod(this, _QuickLRU_instances, peek_fn).call(this, key, __privateGet(this, _oldCache));
    }
  }
  expiresIn(key) {
    const item = __privateGet(this, _cache).get(key) ?? __privateGet(this, _oldCache).get(key);
    if (item) {
      return item.expiry ? item.expiry - Date.now() : Number.POSITIVE_INFINITY;
    }
  }
  delete(key) {
    const deleted = __privateGet(this, _cache).delete(key);
    if (deleted) {
      __privateWrapper(this, _size)._--;
    }
    return __privateGet(this, _oldCache).delete(key) || deleted;
  }
  clear() {
    __privateGet(this, _cache).clear();
    __privateGet(this, _oldCache).clear();
    __privateSet(this, _size, 0);
  }
  resize(newSize) {
    if (!(newSize && newSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    const items = [...__privateMethod(this, _QuickLRU_instances, entriesAscending_fn).call(this)];
    const removeCount = items.length - newSize;
    if (removeCount < 0) {
      __privateSet(this, _cache, new Map(items));
      __privateSet(this, _oldCache, /* @__PURE__ */ new Map());
      __privateSet(this, _size, items.length);
    } else {
      if (removeCount > 0) {
        __privateMethod(this, _QuickLRU_instances, emitEvictions_fn).call(this, items.slice(0, removeCount));
      }
      __privateSet(this, _oldCache, new Map(items.slice(removeCount)));
      __privateSet(this, _cache, /* @__PURE__ */ new Map());
      __privateSet(this, _size, 0);
    }
    __privateSet(this, _maxSize, newSize);
  }
  evict(count = 1) {
    const requested = Number(count);
    if (!requested || requested <= 0) {
      return;
    }
    const items = [...__privateMethod(this, _QuickLRU_instances, entriesAscending_fn).call(this)];
    const evictCount = Math.trunc(Math.min(requested, Math.max(items.length - 1, 0)));
    if (evictCount <= 0) {
      return;
    }
    __privateMethod(this, _QuickLRU_instances, emitEvictions_fn).call(this, items.slice(0, evictCount));
    __privateSet(this, _oldCache, new Map(items.slice(evictCount)));
    __privateSet(this, _cache, /* @__PURE__ */ new Map());
    __privateSet(this, _size, 0);
  }
  *keys() {
    for (const [key] of this) {
      yield key;
    }
  }
  *values() {
    for (const [, value] of this) {
      yield value;
    }
  }
  *[Symbol.iterator]() {
    for (const item of __privateGet(this, _cache)) {
      const [key, value] = item;
      const deleted = __privateMethod(this, _QuickLRU_instances, deleteIfExpired_fn).call(this, key, value);
      if (deleted === false) {
        yield [key, value.value];
      }
    }
    for (const item of __privateGet(this, _oldCache)) {
      const [key, value] = item;
      if (!__privateGet(this, _cache).has(key)) {
        const deleted = __privateMethod(this, _QuickLRU_instances, deleteIfExpired_fn).call(this, key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
    }
  }
  *entriesDescending() {
    let items = [...__privateGet(this, _cache)];
    for (let i2 = items.length - 1; i2 >= 0; --i2) {
      const item = items[i2];
      const [key, value] = item;
      const deleted = __privateMethod(this, _QuickLRU_instances, deleteIfExpired_fn).call(this, key, value);
      if (deleted === false) {
        yield [key, value.value];
      }
    }
    items = [...__privateGet(this, _oldCache)];
    for (let i2 = items.length - 1; i2 >= 0; --i2) {
      const item = items[i2];
      const [key, value] = item;
      if (!__privateGet(this, _cache).has(key)) {
        const deleted = __privateMethod(this, _QuickLRU_instances, deleteIfExpired_fn).call(this, key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
    }
  }
  *entriesAscending() {
    for (const [key, value] of __privateMethod(this, _QuickLRU_instances, entriesAscending_fn).call(this)) {
      yield [key, value.value];
    }
  }
  get size() {
    if (!__privateGet(this, _size)) {
      return __privateGet(this, _oldCache).size;
    }
    let oldCacheSize = 0;
    for (const key of __privateGet(this, _oldCache).keys()) {
      if (!__privateGet(this, _cache).has(key)) {
        oldCacheSize++;
      }
    }
    return Math.min(__privateGet(this, _size) + oldCacheSize, __privateGet(this, _maxSize));
  }
  get maxSize() {
    return __privateGet(this, _maxSize);
  }
  get maxAge() {
    return __privateGet(this, _maxAge);
  }
  entries() {
    return this.entriesAscending();
  }
  forEach(callbackFunction, thisArgument = this) {
    for (const [key, value] of this.entriesAscending()) {
      callbackFunction.call(thisArgument, value, key, this);
    }
  }
  get [Symbol.toStringTag]() {
    return "QuickLRU";
  }
  toString() {
    return `QuickLRU(${this.size}/${this.maxSize})`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toString();
  }
};
_size = new WeakMap();
_cache = new WeakMap();
_oldCache = new WeakMap();
_maxSize = new WeakMap();
_maxAge = new WeakMap();
_onEviction = new WeakMap();
_QuickLRU_instances = new WeakSet();
emitEvictions_fn = function(cache3) {
  if (typeof __privateGet(this, _onEviction) !== "function") {
    return;
  }
  for (const [key, item] of cache3) {
    __privateGet(this, _onEviction).call(this, key, item.value);
  }
};
deleteIfExpired_fn = function(key, item) {
  if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
    if (typeof __privateGet(this, _onEviction) === "function") {
      __privateGet(this, _onEviction).call(this, key, item.value);
    }
    return this.delete(key);
  }
  return false;
};
getOrDeleteIfExpired_fn = function(key, item) {
  const deleted = __privateMethod(this, _QuickLRU_instances, deleteIfExpired_fn).call(this, key, item);
  if (deleted === false) {
    return item.value;
  }
};
getItemValue_fn = function(key, item) {
  return item.expiry ? __privateMethod(this, _QuickLRU_instances, getOrDeleteIfExpired_fn).call(this, key, item) : item.value;
};
peek_fn = function(key, cache3) {
  const item = cache3.get(key);
  return __privateMethod(this, _QuickLRU_instances, getItemValue_fn).call(this, key, item);
};
set_fn = function(key, value) {
  __privateGet(this, _cache).set(key, value);
  __privateWrapper(this, _size)._++;
  if (__privateGet(this, _size) >= __privateGet(this, _maxSize)) {
    __privateSet(this, _size, 0);
    __privateMethod(this, _QuickLRU_instances, emitEvictions_fn).call(this, __privateGet(this, _oldCache));
    __privateSet(this, _oldCache, __privateGet(this, _cache));
    __privateSet(this, _cache, /* @__PURE__ */ new Map());
  }
};
moveToRecent_fn = function(key, item) {
  __privateGet(this, _oldCache).delete(key);
  __privateMethod(this, _QuickLRU_instances, set_fn).call(this, key, item);
};
entriesAscending_fn = function* () {
  for (const item of __privateGet(this, _oldCache)) {
    const [key, value] = item;
    if (!__privateGet(this, _cache).has(key)) {
      const deleted = __privateMethod(this, _QuickLRU_instances, deleteIfExpired_fn).call(this, key, value);
      if (deleted === false) {
        yield item;
      }
    }
  }
  for (const item of __privateGet(this, _cache)) {
    const [key, value] = item;
    const deleted = __privateMethod(this, _QuickLRU_instances, deleteIfExpired_fn).call(this, key, value);
    if (deleted === false) {
      yield item;
    }
  }
};

// node_modules/dns-over-http-resolver/dist/src/utils.js
function buildResource(serverResolver, hostname, recordType) {
  return `${serverResolver}?name=${hostname}&type=${recordType}`;
}
async function request(resource, signal) {
  const req = await fetch(resource, {
    headers: new Headers({
      accept: "application/dns-json"
    }),
    signal
  });
  const res = await req.json();
  return res;
}
function getCacheKey(hostname, recordType) {
  return `${recordType}_${hostname}`;
}

// node_modules/dns-over-http-resolver/dist/src/index.js
var log25 = Object.assign(src_default4("dns-over-http-resolver"), {
  error: src_default4("dns-over-http-resolver:error")
});
var Resolver = class {
  /**
   * @class
   * @param {object} [options]
   * @param {number} [options.maxCache = 100] - maximum number of cached dns records
   * @param {Request} [options.request] - function to return DNSJSON
   */
  constructor(options = {}) {
    __publicField(this, "_cache");
    __publicField(this, "_TXTcache");
    __publicField(this, "_servers");
    __publicField(this, "_request");
    __publicField(this, "_abortControllers");
    this._cache = new QuickLRU({ maxSize: (options == null ? void 0 : options.maxCache) ?? 100 });
    this._TXTcache = new QuickLRU({ maxSize: (options == null ? void 0 : options.maxCache) ?? 100 });
    this._servers = [
      "https://cloudflare-dns.com/dns-query",
      "https://dns.google/resolve"
    ];
    this._request = options.request ?? request;
    this._abortControllers = [];
  }
  /**
   * Cancel all outstanding DNS queries made by this resolver. Any outstanding
   * requests will be aborted and promises rejected.
   */
  cancel() {
    this._abortControllers.forEach((controller) => {
      controller.abort();
    });
  }
  /**
   * Get an array of the IP addresses currently configured for DNS resolution.
   * These addresses are formatted according to RFC 5952. It can include a custom port.
   */
  getServers() {
    return this._servers;
  }
  /**
   * Get a shuffled array of the IP addresses currently configured for DNS resolution.
   * These addresses are formatted according to RFC 5952. It can include a custom port.
   */
  _getShuffledServers() {
    const newServers = [...this._servers];
    for (let i2 = newServers.length - 1; i2 > 0; i2--) {
      const j = Math.floor(Math.random() * i2);
      const temp = newServers[i2];
      newServers[i2] = newServers[j];
      newServers[j] = temp;
    }
    return newServers;
  }
  /**
   * Sets the IP address and port of servers to be used when performing DNS resolution.
   *
   * @param {string[]} servers - array of RFC 5952 formatted addresses.
   */
  setServers(servers) {
    this._servers = servers;
  }
  async resolve(hostname, rrType = "A") {
    switch (rrType) {
      case "A":
        return this.resolve4(hostname);
      case "AAAA":
        return this.resolve6(hostname);
      case "TXT":
        return this.resolveTxt(hostname);
      default:
        throw new Error(`${rrType} is not supported`);
    }
  }
  /**
   * Uses the DNS protocol to resolve the given host name into IPv4 addresses
   *
   * @param {string} hostname - host name to resolve
   */
  async resolve4(hostname) {
    const recordType = "A";
    const cached = this._cache.get(getCacheKey(hostname, recordType));
    if (cached != null) {
      return cached;
    }
    let aborted = false;
    for (const server of this._getShuffledServers()) {
      const controller = new AbortController();
      this._abortControllers.push(controller);
      try {
        const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
        const data = response.Answer.map((a2) => a2.data);
        const ttl = Math.min(...response.Answer.map((a2) => a2.TTL));
        this._cache.set(getCacheKey(hostname, recordType), data, { maxAge: ttl });
        return data;
      } catch (err) {
        if (controller.signal.aborted) {
          aborted = true;
        }
        log25.error(`${server} could not resolve ${hostname} record ${recordType}`);
      } finally {
        this._abortControllers = this._abortControllers.filter((c2) => c2 !== controller);
      }
    }
    if (aborted) {
      throw Object.assign(new Error("queryA ECANCELLED"), {
        code: "ECANCELLED"
      });
    }
    throw new Error(`Could not resolve ${hostname} record ${recordType}`);
  }
  /**
   * Uses the DNS protocol to resolve the given host name into IPv6 addresses
   *
   * @param {string} hostname - host name to resolve
   */
  async resolve6(hostname) {
    const recordType = "AAAA";
    const cached = this._cache.get(getCacheKey(hostname, recordType));
    if (cached != null) {
      return cached;
    }
    let aborted = false;
    for (const server of this._getShuffledServers()) {
      const controller = new AbortController();
      this._abortControllers.push(controller);
      try {
        const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
        const data = response.Answer.map((a2) => a2.data);
        const ttl = Math.min(...response.Answer.map((a2) => a2.TTL));
        this._cache.set(getCacheKey(hostname, recordType), data, { maxAge: ttl });
        return data;
      } catch (err) {
        if (controller.signal.aborted) {
          aborted = true;
        }
        log25.error(`${server} could not resolve ${hostname} record ${recordType}`);
      } finally {
        this._abortControllers = this._abortControllers.filter((c2) => c2 !== controller);
      }
    }
    if (aborted) {
      throw Object.assign(new Error("queryAaaa ECANCELLED"), {
        code: "ECANCELLED"
      });
    }
    throw new Error(`Could not resolve ${hostname} record ${recordType}`);
  }
  /**
   * Uses the DNS protocol to resolve the given host name into a Text record
   *
   * @param {string} hostname - host name to resolve
   */
  async resolveTxt(hostname) {
    const recordType = "TXT";
    const cached = this._TXTcache.get(getCacheKey(hostname, recordType));
    if (cached != null) {
      return cached;
    }
    let aborted = false;
    for (const server of this._getShuffledServers()) {
      const controller = new AbortController();
      this._abortControllers.push(controller);
      try {
        const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
        const data = response.Answer.map((a2) => [a2.data.replace(/['"]+/g, "")]);
        const ttl = Math.min(...response.Answer.map((a2) => a2.TTL));
        this._TXTcache.set(getCacheKey(hostname, recordType), data, { maxAge: ttl });
        return data;
      } catch (err) {
        if (controller.signal.aborted) {
          aborted = true;
        }
        log25.error(`${server} could not resolve ${hostname} record ${recordType}`);
      } finally {
        this._abortControllers = this._abortControllers.filter((c2) => c2 !== controller);
      }
    }
    if (aborted) {
      throw Object.assign(new Error("queryTxt ECANCELLED"), {
        code: "ECANCELLED"
      });
    }
    throw new Error(`Could not resolve ${hostname} record ${recordType}`);
  }
  clearCache() {
    this._cache.clear();
    this._TXTcache.clear();
  }
};
var src_default9 = Resolver;

// node_modules/@waku/discovery/dist/dns/dns_over_https.js
var log26 = new Logger("dns-over-https");
var DnsOverHttps = class _DnsOverHttps {
  constructor(resolver = new src_default9()) {
    __publicField(this, "resolver");
    this.resolver = resolver;
  }
  /**
   * Create new Dns-Over-Http DNS client.
   *
   * @throws {code: string} If DNS query fails.
   */
  static async create() {
    return new _DnsOverHttps();
  }
  /**
   * Resolves a TXT record
   *
   * @param domain The domain name
   *
   * @throws if the query fails
   */
  async resolveTXT(domain) {
    let answers;
    try {
      answers = await this.resolver.resolveTxt(domain);
    } catch (error) {
      log26.error("query failed: ", error);
      throw new Error("DNS query failed");
    }
    if (!answers)
      throw new Error(`Could not resolve ${domain}`);
    const result = [];
    answers.forEach((d2) => {
      if (typeof d2 === "string") {
        result.push(d2);
      } else if (Array.isArray(d2)) {
        d2.forEach((sd) => {
          if (typeof sd === "string") {
            result.push(sd);
          } else {
            result.push(bytesToUtf8(sd));
          }
        });
      } else {
        result.push(bytesToUtf8(d2));
      }
    });
    return result;
  }
};

// node_modules/@waku/discovery/dist/dns/enrtree.js
var import_hi_base32 = __toESM(require_base32(), 1);
var _ENRTree = class _ENRTree {
  /**
   * Extracts the branch subdomain referenced by a DNS tree root string after verifying
   * the root record signature with its base32 compressed public key.
   */
  static parseAndVerifyRoot(root, publicKey) {
    if (!root.startsWith(this.ROOT_PREFIX))
      throw new Error(`ENRTree root entry must start with '${this.ROOT_PREFIX}'`);
    const rootValues = _ENRTree.parseRootValues(root);
    const decodedPublicKey = import_hi_base32.default.decode.asBytes(publicKey);
    const signedComponent = root.split(" sig")[0];
    const signedComponentBuffer = utf8ToBytes2(signedComponent);
    const signatureBuffer = fromString2(rootValues.signature, "base64url").slice(0, 64);
    const isVerified = verifySignature(signatureBuffer, keccak256(signedComponentBuffer), new Uint8Array(decodedPublicKey));
    if (!isVerified)
      throw new Error("Unable to verify ENRTree root signature");
    return rootValues.eRoot;
  }
  static parseRootValues(txt) {
    const matches = txt.match(/^enrtree-root:v1 e=([^ ]+) l=([^ ]+) seq=(\d+) sig=([^ ]+)$/);
    if (!Array.isArray(matches))
      throw new Error("Could not parse ENRTree root entry");
    matches.shift();
    const [eRoot, lRoot, seq, signature] = matches;
    if (!eRoot)
      throw new Error("Could not parse 'e' value from ENRTree root entry");
    if (!lRoot)
      throw new Error("Could not parse 'l' value from ENRTree root entry");
    if (!seq)
      throw new Error("Could not parse 'seq' value from ENRTree root entry");
    if (!signature)
      throw new Error("Could not parse 'sig' value from ENRTree root entry");
    return { eRoot, lRoot, seq: Number(seq), signature };
  }
  /**
   * Returns the public key and top level domain of an ENR tree entry.
   * The domain is the starting point for traversing a set of linked DNS TXT records
   * and the public key is used to verify the root entry record
   */
  static parseTree(tree) {
    if (!tree.startsWith(this.TREE_PREFIX))
      throw new Error(`ENRTree tree entry must start with '${this.TREE_PREFIX}'`);
    const matches = tree.match(/^enrtree:\/\/([^@]+)@(.+)$/);
    if (!Array.isArray(matches))
      throw new Error("Could not parse ENRTree tree entry");
    matches.shift();
    const [publicKey, domain] = matches;
    if (!publicKey)
      throw new Error("Could not parse public key from ENRTree tree entry");
    if (!domain)
      throw new Error("Could not parse domain from ENRTree tree entry");
    return { publicKey, domain };
  }
  /**
   * Returns subdomains listed in an ENR branch entry. These in turn lead to
   * either further branch entries or ENR records.
   */
  static parseBranch(branch) {
    if (!branch.startsWith(this.BRANCH_PREFIX))
      throw new Error(`ENRTree branch entry must start with '${this.BRANCH_PREFIX}'`);
    return branch.split(this.BRANCH_PREFIX)[1].split(",");
  }
};
__publicField(_ENRTree, "RECORD_PREFIX", ENR.RECORD_PREFIX);
__publicField(_ENRTree, "TREE_PREFIX", "enrtree:");
__publicField(_ENRTree, "BRANCH_PREFIX", "enrtree-branch:");
__publicField(_ENRTree, "ROOT_PREFIX", "enrtree-root:");
var ENRTree = _ENRTree;

// node_modules/@waku/discovery/dist/dns/fetch_nodes.js
var log27 = new Logger("discovery:fetch_nodes");
async function* fetchNodes(getNode, maxGet = 10, maxErrors = 3) {
  const peerNodeIds = /* @__PURE__ */ new Set();
  let totalSearches = 0;
  let erroneousSearches = 0;
  while (totalSearches < maxGet && erroneousSearches < maxErrors) {
    totalSearches++;
    const peer = await getNode();
    if (!peer || !peer.nodeId) {
      erroneousSearches++;
      continue;
    }
    if (!peerNodeIds.has(peer.nodeId)) {
      peerNodeIds.add(peer.nodeId);
      if (peer.waku2) {
        yield peer;
      }
      log27.info(`got new peer candidate from DNS address=${peer.nodeId}@${peer.ip}`);
    }
  }
}

// node_modules/@waku/discovery/dist/dns/dns.js
var log28 = new Logger("discovery:dns");
var DnsNodeDiscovery = class _DnsNodeDiscovery {
  constructor(dns2) {
    __publicField(this, "dns");
    __publicField(this, "_DNSTreeCache");
    this._DNSTreeCache = {};
    this.dns = dns2;
  }
  static async dnsOverHttp(dnsClient) {
    if (!dnsClient) {
      dnsClient = await DnsOverHttps.create();
    }
    return new _DnsNodeDiscovery(dnsClient);
  }
  /**
   * Retrieve the next peers from the passed [[enrTreeUrls]],
   */
  async *getNextPeer(enrTreeUrls) {
    for (const enrTreeUrl of shuffle(enrTreeUrls)) {
      const { publicKey, domain } = ENRTree.parseTree(enrTreeUrl);
      const context = {
        domain,
        publicKey,
        visits: {}
      };
      for await (const peer of fetchNodes(() => this._search(domain, context))) {
        yield peer;
      }
    }
  }
  /**
   * Runs a recursive, randomized descent of the DNS tree to retrieve a single
   * ENR record as an ENR. Returns null if parsing or DNS resolution fails.
   */
  async _search(subdomain, context) {
    try {
      const entry = await this._getTXTRecord(subdomain, context);
      context.visits[subdomain] = true;
      let next;
      let branches;
      const entryType = getEntryType(entry);
      try {
        switch (entryType) {
          case ENRTree.ROOT_PREFIX:
            next = ENRTree.parseAndVerifyRoot(entry, context.publicKey);
            return await this._search(next, context);
          case ENRTree.BRANCH_PREFIX:
            branches = ENRTree.parseBranch(entry);
            next = selectRandomPath(branches, context);
            return await this._search(next, context);
          case ENRTree.RECORD_PREFIX:
            return EnrDecoder.fromString(entry);
          default:
            return null;
        }
      } catch (error) {
        log28.error(`Failed to search DNS tree ${entryType} at subdomain ${subdomain}: ${error}`);
        return null;
      }
    } catch (error) {
      log28.error(`Failed to retrieve TXT record at subdomain ${subdomain}: ${error}`);
      return null;
    }
  }
  /**
   * Retrieves the TXT record stored at a location from either
   * this DNS tree cache or via DNS query.
   *
   * @throws if the TXT Record contains non-UTF-8 values.
   */
  async _getTXTRecord(subdomain, context) {
    if (this._DNSTreeCache[subdomain]) {
      return this._DNSTreeCache[subdomain];
    }
    const location = subdomain !== context.domain ? `${subdomain}.${context.domain}` : context.domain;
    const response = await this.dns.resolveTXT(location);
    if (!response.length)
      throw new Error("Received empty result array while fetching TXT record");
    if (!response[0].length)
      throw new Error("Received empty TXT record");
    const result = response.join("");
    this._DNSTreeCache[subdomain] = result;
    return result;
  }
};
function getEntryType(entry) {
  if (entry.startsWith(ENRTree.ROOT_PREFIX))
    return ENRTree.ROOT_PREFIX;
  if (entry.startsWith(ENRTree.BRANCH_PREFIX))
    return ENRTree.BRANCH_PREFIX;
  if (entry.startsWith(ENRTree.RECORD_PREFIX))
    return ENRTree.RECORD_PREFIX;
  return "";
}
function selectRandomPath(branches, context) {
  const circularRefs = {};
  for (const [idx, subdomain] of branches.entries()) {
    if (context.visits[subdomain]) {
      circularRefs[idx] = true;
    }
  }
  if (Object.keys(circularRefs).length === branches.length) {
    throw new Error("Unresolvable circular path detected");
  }
  let index;
  do {
    index = Math.floor(Math.random() * branches.length);
  } while (circularRefs[index]);
  return branches[index];
}

// node_modules/@waku/discovery/dist/dns/dns_discovery.js
var log29 = new Logger("peer-discovery-dns");
var PeerDiscoveryDns = class extends TypedEventEmitter {
  constructor(components, options) {
    super();
    __publicField(this, "nextPeer");
    __publicField(this, "_started");
    __publicField(this, "_components");
    __publicField(this, "_options");
    this._started = false;
    this._components = components;
    this._options = options;
    const { enrUrls } = options;
    log29.info("Use following EIP-1459 ENR Tree URLs: ", enrUrls);
  }
  /**
   * Start discovery process
   */
  async start() {
    log29.info("Starting peer discovery via dns");
    this._started = true;
    await this.findPeers();
  }
  async findPeers() {
    if (!this.nextPeer) {
      let { enrUrls } = this._options;
      if (!Array.isArray(enrUrls))
        enrUrls = [enrUrls];
      const dns2 = await DnsNodeDiscovery.dnsOverHttp();
      this.nextPeer = dns2.getNextPeer.bind(dns2, enrUrls);
    }
    for await (const peerEnr of this.nextPeer()) {
      if (!this._started) {
        return;
      }
      const { peerInfo, shardInfo } = peerEnr;
      if (!peerInfo) {
        continue;
      }
      const tagsToUpdate = {
        [DEFAULT_BOOTSTRAP_TAG_NAME2]: {
          value: this._options.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE2,
          ttl: this._options.tagTTL ?? DEFAULT_BOOTSTRAP_TAG_TTL
        }
      };
      let isPeerChanged = false;
      const isPeerAlreadyInPeerStore = await this._components.peerStore.has(peerInfo.id);
      if (isPeerAlreadyInPeerStore) {
        const peer = await this._components.peerStore.get(peerInfo.id);
        const hasBootstrapTag = peer.tags.has(DEFAULT_BOOTSTRAP_TAG_NAME2);
        if (!hasBootstrapTag) {
          isPeerChanged = true;
          await this._components.peerStore.merge(peerInfo.id, {
            tags: tagsToUpdate
          });
        }
      } else {
        isPeerChanged = true;
        await this._components.peerStore.save(peerInfo.id, {
          tags: tagsToUpdate,
          ...shardInfo && {
            metadata: {
              shardInfo: encodeRelayShard(shardInfo)
            }
          }
        });
      }
      if (isPeerChanged) {
        this.dispatchEvent(new CustomEvent("peer", { detail: peerInfo }));
      }
    }
  }
  /**
   * Stop emitting events
   */
  stop() {
    this._started = false;
  }
  get [peerDiscoverySymbol]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return DNS_DISCOVERY_TAG;
  }
};
function wakuDnsDiscovery(enrUrls) {
  return (components) => new PeerDiscoveryDns(components, { enrUrls });
}

// node_modules/@waku/discovery/dist/peer-exchange/constants.js
var DEFAULT_PEER_EXCHANGE_REQUEST_NODES = 60;
var DEFAULT_PEER_EXCHANGE_TAG_NAME = Tags.PEER_EXCHANGE;
var DEFAULT_PEER_EXCHANGE_TAG_VALUE = 50;
var DEFAULT_PEER_EXCHANGE_TAG_TTL = 3e4;
var PeerExchangeCodec = "/vac/waku/peer-exchange/2.0.0-alpha1";

// node_modules/@waku/discovery/dist/peer-exchange/rpc.js
var PeerExchangeRPC2 = class _PeerExchangeRPC {
  constructor(proto) {
    __publicField(this, "proto");
    this.proto = proto;
  }
  static createRequest(params) {
    const { numPeers } = params;
    return new _PeerExchangeRPC({
      query: {
        numPeers
      },
      response: void 0
    });
  }
  /**
   * Encode the current PeerExchangeRPC request to bytes
   * @returns Uint8Array
   */
  encode() {
    return peer_exchange_exports.PeerExchangeRPC.encode(this.proto);
  }
  /**
   * Decode the current PeerExchangeRPC request to bytes
   * @returns Uint8Array
   */
  static decode(bytes) {
    const res = peer_exchange_exports.PeerExchangeRPC.decode(bytes);
    return new _PeerExchangeRPC(res);
  }
  get query() {
    return this.proto.query;
  }
  get response() {
    return this.proto.response;
  }
};

// node_modules/@waku/discovery/dist/peer-exchange/peer_exchange.js
var log30 = new Logger("peer-exchange");
var PeerExchange = class {
  /**
   * @param components - libp2p components
   */
  constructor(components) {
    __publicField(this, "components");
    __publicField(this, "streamManager");
    this.components = components;
    this.streamManager = new StreamManager(PeerExchangeCodec, components);
  }
  /**
   * Make a peer exchange query to a peer
   */
  async query(params) {
    var _a27;
    const { numPeers, peerId: peerId2 } = params;
    const rpcQuery = PeerExchangeRPC2.createRequest({
      numPeers: BigInt(numPeers)
    });
    const hasPeer = await this.components.peerStore.has(peerId2);
    if (!hasPeer) {
      return {
        peerInfos: null,
        error: ProtocolError2.NO_PEER_AVAILABLE
      };
    }
    const stream = await this.streamManager.getStream(peerId2);
    if (!stream) {
      log30.error(`Failed to get a stream for remote peer:${(_a27 = peerId2 == null ? void 0 : peerId2.toString) == null ? void 0 : _a27.call(peerId2)}`);
      return {
        peerInfos: null,
        error: ProtocolError2.NO_STREAM_AVAILABLE
      };
    }
    const res = await pipe([rpcQuery.encode()], encode7, stream, decode8, async (source) => await src_default(source));
    try {
      const bytes = new Uint8ArrayList();
      res.forEach((chunk) => {
        bytes.append(chunk);
      });
      const { response } = PeerExchangeRPC2.decode(bytes);
      if (!response) {
        log30.error("PeerExchangeRPC message did not contains a `response` field");
        return {
          peerInfos: null,
          error: ProtocolError2.EMPTY_PAYLOAD
        };
      }
      const peerInfos = await Promise.all(response.peerInfos.map((peerInfo) => peerInfo.enr).filter(isDefined).map(async (enr) => {
        return { ENR: await EnrDecoder.fromRLP(enr) };
      }));
      return {
        peerInfos,
        error: null
      };
    } catch (err) {
      log30.error("Failed to decode push reply", err);
      return {
        peerInfos: null,
        error: ProtocolError2.DECODE_FAILED
      };
    }
  }
};

// node_modules/@waku/discovery/dist/peer-exchange/peer_exchange_discovery.js
var log31 = new Logger("peer-exchange-discovery");
var PeerExchangeDiscovery = class extends TypedEventEmitter {
  constructor(components, options = {}) {
    super();
    __publicField(this, "components");
    __publicField(this, "peerExchange");
    __publicField(this, "options");
    __publicField(this, "isStarted", false);
    __publicField(this, "queryingPeers", /* @__PURE__ */ new Set());
    __publicField(this, "peerExpirationRecords", /* @__PURE__ */ new Map());
    __publicField(this, "continuousDiscoveryInterval", null);
    this.components = components;
    this.peerExchange = new PeerExchange(components);
    this.options = {
      ...options,
      TTL: options.TTL ?? DEFAULT_PEER_EXCHANGE_TAG_TTL
    };
    this.handleDiscoveredPeer = this.handleDiscoveredPeer.bind(this);
  }
  /**
   * Start Peer Exchange.
   * Subscribe to "peer:identify" events and handle them.
   */
  start() {
    if (this.isStarted) {
      return;
    }
    log31.info("Starting peer exchange node discovery, discovering peers");
    this.isStarted = true;
    this.components.events.addEventListener("peer:identify", this.handleDiscoveredPeer);
    this.continuousDiscoveryInterval = setInterval(() => {
      void this.handlePeriodicDiscovery();
    }, this.options.TTL);
  }
  /**
   * Stop Peer Exchange.
   * Unsubscribe from "peer:identify" events.
   */
  stop() {
    if (!this.isStarted) {
      return;
    }
    log31.info("Stopping peer exchange node discovery");
    this.isStarted = false;
    this.queryingPeers.clear();
    this.peerExpirationRecords.clear();
    if (this.continuousDiscoveryInterval) {
      clearInterval(this.continuousDiscoveryInterval);
    }
    this.components.events.removeEventListener("peer:identify", this.handleDiscoveredPeer);
  }
  get [peerDiscoverySymbol]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@waku/peer-exchange";
  }
  async handleDiscoveredPeer(event) {
    void this.runQuery(event.detail.peerId, event.detail.protocols);
  }
  async handlePeriodicDiscovery() {
    const connections = this.components.connectionManager.getConnections();
    await Promise.all(connections.map(async (connection) => {
      try {
        const peerIdStr = connection.remotePeer.toString();
        const shouldQuery = this.peerExpirationRecords.has(peerIdStr) ? this.peerExpirationRecords.get(peerIdStr) <= Date.now() : true;
        if (!shouldQuery) {
          return null;
        }
        const peer = await this.components.peerStore.get(connection.remotePeer);
        return this.runQuery(connection.remotePeer, peer.protocols);
      } catch (error) {
        log31.warn("Error getting peer info", error);
        return null;
      }
    }));
  }
  async runQuery(peerId2, protocols2) {
    if (!protocols2.includes(PeerExchangeCodec) || this.queryingPeers.has(peerId2.toString())) {
      log31.info(`Skipping peer ${peerId2} as it is already querying or does not support peer exchange`);
      return;
    }
    try {
      this.queryingPeers.add(peerId2.toString());
      await this.query(peerId2);
    } catch (error) {
      log31.error("Error querying peer", error);
    }
    this.peerExpirationRecords.set(peerId2.toString(), Date.now() + this.options.TTL);
    this.queryingPeers.delete(peerId2.toString());
  }
  async query(peerId2) {
    const peerIdStr = peerId2.toString();
    log31.info(`Querying peer exchange for ${peerIdStr}`);
    const { error, peerInfos } = await this.peerExchange.query({
      numPeers: DEFAULT_PEER_EXCHANGE_REQUEST_NODES,
      peerId: peerId2
    });
    if (error) {
      log31.error(`Peer exchange query to ${peerIdStr} failed`, error);
      return;
    }
    for (const { ENR: ENR2 } of peerInfos) {
      if (!ENR2) {
        log31.warn(`No ENR in peerInfo object from ${peerIdStr}, skipping`);
        continue;
      }
      const { peerInfo, shardInfo } = ENR2;
      if (!peerInfo) {
        log31.warn(`No peerInfo in ENR from ${peerIdStr}, skipping`);
        continue;
      }
      const hasPrevShardInfo = await this.hasShardInfo(peerInfo.id);
      const metadata = !hasPrevShardInfo && shardInfo ? { metadata: { shardInfo: encodeRelayShard(shardInfo) } } : void 0;
      await this.components.peerStore.merge(peerInfo.id, {
        tags: {
          [DEFAULT_PEER_EXCHANGE_TAG_NAME]: {
            value: DEFAULT_PEER_EXCHANGE_TAG_VALUE
          }
        },
        ...metadata,
        ...peerInfo.multiaddrs && {
          multiaddrs: peerInfo.multiaddrs
        }
      });
      log31.info(`Discovered peer: ${peerInfo.id.toString()}`);
      this.dispatchEvent(new CustomEvent("peer", {
        detail: {
          id: peerInfo.id,
          multiaddrs: peerInfo.multiaddrs
        }
      }));
    }
  }
  async hasShardInfo(peerId2) {
    try {
      const peer = await this.components.peerStore.get(peerId2);
      if (!peer) {
        return false;
      }
      return peer.metadata.has("shardInfo");
    } catch (err) {
      log31.warn(`Error getting shard info for ${peerId2.toString()}`, err);
    }
    return false;
  }
};
function wakuPeerExchangeDiscovery(options = {}) {
  return (components) => new PeerExchangeDiscovery(components, options);
}

// node_modules/@waku/discovery/dist/peer-cache/constants.js
var DEFAULT_PEER_CACHE_TAG_NAME = Tags.PEER_CACHE;
var DEFAULT_PEER_CACHE_TAG_VALUE = 50;

// node_modules/@waku/discovery/dist/peer-cache/utils.js
var isValidStoredPeer = (peer) => {
  return !!peer && typeof peer === "object" && "id" in peer && typeof peer.id === "string" && "multiaddrs" in peer && Array.isArray(peer.multiaddrs);
};
var NoopCache = class {
  get() {
    return [];
  }
  set(_value) {
    return;
  }
  remove() {
    return;
  }
};
var LocalStorageCache = class {
  get() {
    try {
      const cachedPeers = localStorage.getItem("waku:peers");
      const peers = cachedPeers ? JSON.parse(cachedPeers) : [];
      return peers.filter(isValidStoredPeer);
    } catch (e2) {
      return [];
    }
  }
  set(_value) {
    try {
      localStorage.setItem("waku:peers", JSON.stringify(_value));
    } catch (e2) {
    }
  }
  remove() {
    try {
      localStorage.removeItem("waku:peers");
    } catch (e2) {
    }
  }
};
var defaultCache = () => {
  try {
    if (typeof localStorage !== "undefined") {
      return new LocalStorageCache();
    }
  } catch (_e) {
  }
  return new NoopCache();
};

// node_modules/@waku/discovery/dist/peer-cache/peer_cache.js
var log32 = new Logger("peer-cache");
var PeerCacheDiscovery = class extends TypedEventEmitter {
  constructor(components, options) {
    super();
    __publicField(this, "components");
    __publicField(this, "isStarted", false);
    __publicField(this, "cache");
    __publicField(this, "handleDiscoveredPeer", (event) => {
      const { peerId: peerId2, listenAddrs } = event.detail;
      const multiaddrs = listenAddrs.map((addr) => addr.toString());
      const peerIdStr = peerId2.toString();
      const knownPeers = this.readPeerInfoFromCache();
      const peerIndex = knownPeers.findIndex((p2) => p2.id === peerIdStr);
      if (peerIndex !== -1) {
        knownPeers[peerIndex].multiaddrs = multiaddrs;
      } else {
        knownPeers.push({
          id: peerIdStr,
          multiaddrs
        });
      }
      this.writePeerInfoToCache(knownPeers);
    });
    this.components = components;
    this.cache = (options == null ? void 0 : options.cache) ?? defaultCache();
  }
  get [Symbol.toStringTag]() {
    return `@waku/${DEFAULT_PEER_CACHE_TAG_NAME}`;
  }
  async start() {
    if (this.isStarted) {
      return;
    }
    log32.info("Starting Peer Cache Discovery");
    this.components.events.addEventListener("peer:identify", this.handleDiscoveredPeer);
    await this.discoverPeers();
    this.isStarted = true;
  }
  stop() {
    if (!this.isStarted) {
      return;
    }
    log32.info("Stopping Peer Cache Discovery");
    this.components.events.removeEventListener("peer:identify", this.handleDiscoveredPeer);
    this.isStarted = false;
  }
  async discoverPeers() {
    const knownPeers = this.readPeerInfoFromCache();
    for (const peer of knownPeers) {
      const peerId2 = peerIdFromString(peer.id);
      const multiaddrs = peer.multiaddrs.map((addr) => multiaddr(addr));
      if (await this.components.peerStore.has(peerId2)) {
        continue;
      }
      await this.components.peerStore.save(peerId2, {
        multiaddrs,
        tags: {
          [DEFAULT_PEER_CACHE_TAG_NAME]: {
            value: DEFAULT_PEER_CACHE_TAG_VALUE
          }
        }
      });
      this.dispatchEvent(new CustomEvent("peer", {
        detail: {
          id: peerId2,
          multiaddrs
        }
      }));
    }
  }
  readPeerInfoFromCache() {
    try {
      return this.cache.get();
    } catch (error) {
      log32.error("Error parsing peers from cache:", error);
      return [];
    }
  }
  writePeerInfoToCache(peers) {
    try {
      this.cache.set(peers);
    } catch (error) {
      log32.error("Error saving peers to cache:", error);
    }
  }
};
function wakuPeerCacheDiscovery(options = {}) {
  return (components) => new PeerCacheDiscovery(components, options);
}

// node_modules/@waku/sdk/dist/create/discovery.js
function getPeerDiscoveries(enabled, peerCache) {
  const dnsEnrTrees = [enrTree["SANDBOX"], enrTree["TEST"]];
  const discoveries = [];
  if (enabled == null ? void 0 : enabled.dns) {
    discoveries.push(wakuDnsDiscovery(dnsEnrTrees));
  }
  if ((enabled == null ? void 0 : enabled.peerCache) || peerCache) {
    discoveries.push(wakuPeerCacheDiscovery({ cache: peerCache }));
  }
  if (enabled == null ? void 0 : enabled.peerExchange) {
    discoveries.push(wakuPeerExchangeDiscovery());
  }
  return discoveries;
}

// node_modules/@waku/sdk/dist/create/libp2p.js
var log33 = new Logger("sdk:create");
var DefaultUserAgent = "js-waku";
var DefaultPingMaxInboundStreams = 10;
async function defaultLibp2p(clusterId, options, userAgent2) {
  if (!(options == null ? void 0 : options.hideWebSocketInfo) && !isTestEnvironment()) {
    console.info("%cIgnore WebSocket connection failures", "background: gray; color: white; font-size: x-large");
    console.info("%cWaku tries to discover peers and some of them are expected to fail", "background: gray; color: white; font-size: x-large");
  }
  const filter2 = (options == null ? void 0 : options.filterMultiaddrs) === false || isTestEnvironment() ? all2 : wss;
  return createLibp2p({
    transports: [webSockets({ filter: filter2 })],
    streamMuxers: [mplex()],
    connectionEncrypters: [noise()],
    ...options,
    services: {
      identify: identify({
        agentVersion: userAgent2 ?? DefaultUserAgent
      }),
      ping: ping({
        maxInboundStreams: (options == null ? void 0 : options.pingMaxInboundStreams) ?? DefaultPingMaxInboundStreams
      }),
      metadata: wakuMetadata(clusterId),
      ...options == null ? void 0 : options.services
    }
  });
}
async function createLibp2pAndUpdateOptions(options) {
  var _a27;
  const networkConfig = options.networkConfig ?? DefaultNetworkConfig;
  const clusterId = networkConfig.clusterId ?? DEFAULT_CLUSTER_ID;
  log33.info("Creating Waku node with cluster id: ", clusterId);
  const libp2pOptions = (options == null ? void 0 : options.libp2p) ?? {};
  const peerDiscovery = libp2pOptions.peerDiscovery ?? [];
  if (options == null ? void 0 : options.defaultBootstrap) {
    peerDiscovery.push(...getPeerDiscoveries({
      dns: true,
      peerExchange: true,
      peerCache: true,
      ...options.discovery
    }, options.peerCache));
  } else {
    peerDiscovery.push(...getPeerDiscoveries(options.discovery, options.peerCache));
  }
  const bootstrapPeers = [
    ...options.bootstrapPeers || [],
    ...((_a27 = options.store) == null ? void 0 : _a27.peers) || []
  ];
  if (bootstrapPeers.length) {
    peerDiscovery.push(bootstrap({ list: bootstrapPeers }));
  }
  libp2pOptions.peerDiscovery = peerDiscovery;
  return defaultLibp2p(clusterId, libp2pOptions, options == null ? void 0 : options.userAgent);
}

// node_modules/@waku/sdk/dist/create/create.js
async function createLightNode(options = {}) {
  const libp2p = await createLibp2pAndUpdateOptions(options);
  const node = new WakuNode(options, libp2p, {
    store: true,
    lightpush: true,
    filter: true
  });
  if ((options == null ? void 0 : options.autoStart) !== false) {
    await node.start();
  }
  return node;
}

// node_modules/@waku/sds/dist/nim_hashn/nim_hashn.mjs
var excHandler = 0;
var lastJSError = null;
var NTI134217745 = {
  size: 0,
  kind: 17,
  base: null,
  node: null,
  finalizer: null
};
var NTI134217749 = {
  size: 0,
  kind: 17,
  base: null,
  node: null,
  finalizer: null
};
var NTI134217751 = {
  size: 0,
  kind: 17,
  base: null,
  node: null,
  finalizer: null
};
var NTI134217743 = {
  size: 0,
  kind: 17,
  base: null,
  node: null,
  finalizer: null
};
var NTI33555167 = {
  size: 0,
  kind: 17,
  base: null,
  node: null,
  finalizer: null
};
var NTI33555175 = {
  size: 0,
  kind: 22,
  base: null,
  node: null,
  finalizer: null
};
var NTI33554449 = {
  size: 0,
  kind: 28,
  base: null,
  node: null,
  finalizer: null
};
var NTI33554450 = {
  size: 0,
  kind: 29,
  base: null,
  node: null,
  finalizer: null
};
var NTI33555174 = {
  size: 0,
  kind: 22,
  base: null,
  node: null,
  finalizer: null
};
var NTI33555171 = {
  size: 0,
  kind: 17,
  base: null,
  node: null,
  finalizer: null
};
var NTI33555172 = {
  size: 0,
  kind: 17,
  base: null,
  node: null,
  finalizer: null
};
var NTI134217741 = {
  size: 0,
  kind: 17,
  base: null,
  node: null,
  finalizer: null
};
var NTI134217742 = {
  size: 0,
  kind: 17,
  base: null,
  node: null,
  finalizer: null
};
var NNI134217742 = {
  kind: 2,
  len: 0,
  offset: 0,
  typ: null,
  name: null,
  sons: []
};
NTI134217742.node = NNI134217742;
var NNI134217741 = {
  kind: 2,
  len: 0,
  offset: 0,
  typ: null,
  name: null,
  sons: []
};
NTI134217741.node = NNI134217741;
var NNI33555172 = {
  kind: 2,
  len: 0,
  offset: 0,
  typ: null,
  name: null,
  sons: []
};
NTI33555172.node = NNI33555172;
NTI33555174.base = NTI33555171;
NTI33555175.base = NTI33555171;
var NNI33555171 = {
  kind: 2,
  len: 5,
  offset: 0,
  typ: null,
  name: null,
  sons: [
    {
      kind: 1,
      offset: "parent",
      len: 0,
      typ: NTI33555174,
      name: "parent",
      sons: null
    },
    {
      kind: 1,
      offset: "name",
      len: 0,
      typ: NTI33554450,
      name: "name",
      sons: null
    },
    {
      kind: 1,
      offset: "message",
      len: 0,
      typ: NTI33554449,
      name: "msg",
      sons: null
    },
    {
      kind: 1,
      offset: "trace",
      len: 0,
      typ: NTI33554449,
      name: "trace",
      sons: null
    },
    { kind: 1, offset: "up", len: 0, typ: NTI33555175, name: "up", sons: null }
  ]
};
NTI33555171.node = NNI33555171;
var NNI33555167 = {
  kind: 2,
  len: 0,
  offset: 0,
  typ: null,
  name: null,
  sons: []
};
NTI33555167.node = NNI33555167;
NTI33555171.base = NTI33555167;
NTI33555172.base = NTI33555171;
NTI134217741.base = NTI33555172;
NTI134217742.base = NTI134217741;
var NNI134217743 = {
  kind: 2,
  len: 0,
  offset: 0,
  typ: null,
  name: null,
  sons: []
};
NTI134217743.node = NNI134217743;
NTI134217743.base = NTI134217741;
var NNI134217751 = {
  kind: 2,
  len: 0,
  offset: 0,
  typ: null,
  name: null,
  sons: []
};
NTI134217751.node = NNI134217751;
NTI134217751.base = NTI33555172;
var NNI134217749 = {
  kind: 2,
  len: 0,
  offset: 0,
  typ: null,
  name: null,
  sons: []
};
NTI134217749.node = NNI134217749;
NTI134217749.base = NTI33555172;
var NNI134217745 = {
  kind: 2,
  len: 0,
  offset: 0,
  typ: null,
  name: null,
  sons: []
};
NTI134217745.node = NNI134217745;
NTI134217745.base = NTI33555172;
function toJSStr(s_p0) {
  var result_33556911 = null;
  var res_33556965 = newSeq__system_u2508(s_p0.length);
  var i_33556966 = 0;
  var j_33556967 = 0;
  {
    Label2: while (true) {
      if (!(i_33556966 < s_p0.length))
        break Label2;
      var c_33556968 = s_p0[i_33556966];
      if (c_33556968 < 128) {
        res_33556965[j_33556967] = String.fromCharCode(c_33556968);
        i_33556966 += 1;
      } else {
        var helper_33556994 = newSeq__system_u2508(0);
        Label3: {
          Label4: while (true) {
            if (false)
              break Label4;
            var code_33556995 = c_33556968.toString(16);
            if ((code_33556995 == null ? 0 : code_33556995.length) == 1) {
              helper_33556994.push("%0");
            } else {
              helper_33556994.push("%");
            }
            helper_33556994.push(code_33556995);
            i_33556966 += 1;
            if (s_p0.length <= i_33556966 || s_p0[i_33556966] < 128) {
              break Label3;
            }
            c_33556968 = s_p0[i_33556966];
          }
        }
        ++excHandler;
        try {
          res_33556965[j_33556967] = decodeURIComponent(helper_33556994.join(""));
          --excHandler;
        } catch (EXCEPTION) {
          var prevJSError = lastJSError;
          lastJSError = EXCEPTION;
          --excHandler;
          res_33556965[j_33556967] = helper_33556994.join("");
          lastJSError = prevJSError;
        } finally {
        }
      }
      j_33556967 += 1;
    }
  }
  if (res_33556965.length < j_33556967) {
    for (var i2 = res_33556965.length; i2 < j_33556967; ++i2)
      res_33556965.push(null);
  } else {
    res_33556965.length = j_33556967;
  }
  result_33556911 = res_33556965.join("");
  return result_33556911;
}
function raiseException(e_p0, ename_p1) {
  e_p0.name = ename_p1;
  if (excHandler == 0) {
    unhandledException(e_p0);
  }
  throw e_p0;
}
function modInt(a_p0, b_p1) {
  if (b_p1 == 0)
    raiseDivByZero();
  if (b_p1 == -1 && a_p0 == 2147483647)
    raiseOverflow();
  return Math.trunc(a_p0 % b_p1);
}
function absInt(a_p0) {
  var Temporary1;
  var result_33557134 = 0;
  if (a_p0 < 0) {
    Temporary1 = a_p0 * -1;
  } else {
    Temporary1 = a_p0;
  }
  result_33557134 = Temporary1;
  return result_33557134;
}
function divInt(a_p0, b_p1) {
  if (b_p1 == 0)
    raiseDivByZero();
  if (b_p1 == -1 && a_p0 == 2147483647)
    raiseOverflow();
  return Math.trunc(a_p0 / b_p1);
}
function mulInt(a_p0, b_p1) {
  var result = a_p0 * b_p1;
  checkOverflowInt(result);
  return result;
}
function subInt(a_p0, b_p1) {
  var result = a_p0 - b_p1;
  checkOverflowInt(result);
  return result;
}
function addInt(a_p0, b_p1) {
  var result = a_p0 + b_p1;
  checkOverflowInt(result);
  return result;
}
function chckRange(i_p0, a_p1, b_p2) {
  var result_33557358 = 0;
  BeforeRet: {
    if (a_p1 <= i_p0 && i_p0 <= b_p2) {
      result_33557358 = i_p0;
      break BeforeRet;
    } else {
      raiseRangeError();
    }
  }
  return result_33557358;
}
function setConstr() {
  var result = {};
  for (var i2 = 0; i2 < arguments.length; ++i2) {
    var x = arguments[i2];
    if (typeof x == "object") {
      for (var j = x[0]; j <= x[1]; ++j) {
        result[j] = true;
      }
    } else {
      result[x] = true;
    }
  }
  return result;
}
var ConstSet1 = setConstr(17, 16, 4, 18, 27, 19, 23, 22, 21);
function nimCopy(dest_p0, src_p1, ti_p2) {
  var result_33557318 = null;
  switch (ti_p2.kind) {
    case 21:
    case 22:
    case 23:
    case 5:
      if (!isFatPointer__system_u2866(ti_p2)) {
        result_33557318 = src_p1;
      } else {
        result_33557318 = [src_p1[0], src_p1[1]];
      }
      break;
    case 19:
      if (dest_p0 === null || dest_p0 === void 0) {
        dest_p0 = {};
      } else {
        for (var key in dest_p0) {
          delete dest_p0[key];
        }
      }
      for (var key in src_p1) {
        dest_p0[key] = src_p1[key];
      }
      result_33557318 = dest_p0;
      break;
    case 18:
    case 17:
      if (!(ti_p2.base == null)) {
        result_33557318 = nimCopy(dest_p0, src_p1, ti_p2.base);
      } else {
        if (ti_p2.kind == 17) {
          result_33557318 = dest_p0 === null || dest_p0 === void 0 ? { m_type: ti_p2 } : dest_p0;
        } else {
          result_33557318 = dest_p0 === null || dest_p0 === void 0 ? {} : dest_p0;
        }
      }
      nimCopyAux(result_33557318, src_p1, ti_p2.node);
      break;
    case 4:
    case 16:
      if (ArrayBuffer.isView(src_p1)) {
        if (dest_p0 === null || dest_p0 === void 0 || dest_p0.length != src_p1.length) {
          dest_p0 = new src_p1.constructor(src_p1);
        } else {
          dest_p0.set(src_p1, 0);
        }
        result_33557318 = dest_p0;
      } else {
        if (src_p1 === null) {
          result_33557318 = null;
        } else {
          if (dest_p0 === null || dest_p0 === void 0 || dest_p0.length != src_p1.length) {
            dest_p0 = new Array(src_p1.length);
          }
          result_33557318 = dest_p0;
          for (var i2 = 0; i2 < src_p1.length; ++i2) {
            result_33557318[i2] = nimCopy(result_33557318[i2], src_p1[i2], ti_p2.base);
          }
        }
      }
      break;
    case 24:
    case 27:
      if (src_p1 === null) {
        result_33557318 = null;
      } else {
        if (dest_p0 === null || dest_p0 === void 0 || dest_p0.length != src_p1.length) {
          dest_p0 = new Array(src_p1.length);
        }
        result_33557318 = dest_p0;
        for (var i2 = 0; i2 < src_p1.length; ++i2) {
          result_33557318[i2] = nimCopy(result_33557318[i2], src_p1[i2], ti_p2.base);
        }
      }
      break;
    case 28:
      if (src_p1 !== null) {
        result_33557318 = src_p1.slice(0);
      }
      break;
    default:
      result_33557318 = src_p1;
      break;
  }
  return result_33557318;
}
function chckIndx(i_p0, a_p1, b_p2) {
  var result_33557353 = 0;
  BeforeRet: {
    if (a_p1 <= i_p0 && i_p0 <= b_p2) {
      result_33557353 = i_p0;
      break BeforeRet;
    } else {
      raiseIndexError(i_p0, a_p1, b_p2);
    }
  }
  return result_33557353;
}
function add__system_u1943(x_p0, x_p0_Idx, y_p1) {
  if (x_p0[x_p0_Idx] === null) {
    x_p0[x_p0_Idx] = [];
  }
  var off = x_p0[x_p0_Idx].length;
  x_p0[x_p0_Idx].length += y_p1.length;
  for (var i2 = 0; i2 < y_p1.length; ++i2) {
    x_p0[x_p0_Idx][off + i2] = y_p1.charCodeAt(i2);
  }
}
function newSeq__system_u2508(len_p0) {
  var result_33556944 = [];
  result_33556944 = new Array(len_p0);
  for (var i2 = 0; i2 < len_p0; ++i2) {
    result_33556944[i2] = null;
  }
  return result_33556944;
}
function unhandledException(e_p0) {
  var buf_33556659 = [[]];
  if (!(e_p0.message.length == 0)) {
    buf_33556659[0].push.apply(buf_33556659[0], [
      69,
      114,
      114,
      111,
      114,
      58,
      32,
      117,
      110,
      104,
      97,
      110,
      100,
      108,
      101,
      100,
      32,
      101,
      120,
      99,
      101,
      112,
      116,
      105,
      111,
      110,
      58,
      32
    ]);
    buf_33556659[0].push.apply(buf_33556659[0], e_p0.message);
  } else {
    buf_33556659[0].push.apply(buf_33556659[0], [
      69,
      114,
      114,
      111,
      114,
      58,
      32,
      117,
      110,
      104,
      97,
      110,
      100,
      108,
      101,
      100,
      32,
      101,
      120,
      99,
      101,
      112,
      116,
      105,
      111,
      110
    ]);
  }
  buf_33556659[0].push.apply(buf_33556659[0], [32, 91]);
  add__system_u1943(buf_33556659, 0, e_p0.name);
  buf_33556659[0].push.apply(buf_33556659[0], [93, 10]);
  var cbuf_33556660 = toJSStr(buf_33556659[0]);
  if (typeof Error !== "undefined") {
    throw new Error(cbuf_33556660);
  } else {
    throw cbuf_33556660;
  }
}
function raiseDivByZero() {
  raiseException({
    message: [
      100,
      105,
      118,
      105,
      115,
      105,
      111,
      110,
      32,
      98,
      121,
      32,
      122,
      101,
      114,
      111
    ],
    parent: null,
    m_type: NTI134217742,
    name: null,
    trace: [],
    up: null
  }, "DivByZeroDefect");
}
function raiseOverflow() {
  raiseException({
    message: [
      111,
      118,
      101,
      114,
      45,
      32,
      111,
      114,
      32,
      117,
      110,
      100,
      101,
      114,
      102,
      108,
      111,
      119
    ],
    parent: null,
    m_type: NTI134217743,
    name: null,
    trace: [],
    up: null
  }, "OverflowDefect");
}
function checkOverflowInt(a_p0) {
  if (a_p0 > 2147483647 || a_p0 < -2147483648)
    raiseOverflow();
}
function raiseRangeError() {
  raiseException({
    message: [
      118,
      97,
      108,
      117,
      101,
      32,
      111,
      117,
      116,
      32,
      111,
      102,
      32,
      114,
      97,
      110,
      103,
      101
    ],
    parent: null,
    m_type: NTI134217751,
    name: null,
    trace: [],
    up: null
  }, "RangeDefect");
}
function addChars__stdZprivateZdigitsutils_u202(result_p0, result_p0_Idx, x_p1, start_p2, n_p3) {
  var Temporary1;
  var old_301990096 = result_p0[result_p0_Idx].length;
  if (result_p0[result_p0_Idx].length < (Temporary1 = chckRange(addInt(old_301990096, n_p3), 0, 2147483647), Temporary1)) {
    for (var i2 = result_p0[result_p0_Idx].length; i2 < Temporary1; ++i2)
      result_p0[result_p0_Idx].push(0);
  } else {
    result_p0[result_p0_Idx].length = Temporary1;
  }
  {
    var iHEX60gensym4_301990110 = 0;
    var i_536870936 = 0;
    {
      Label4: while (true) {
        if (!(i_536870936 < n_p3))
          break Label4;
        iHEX60gensym4_301990110 = i_536870936;
        result_p0[result_p0_Idx][chckIndx(addInt(old_301990096, iHEX60gensym4_301990110), 0, result_p0[result_p0_Idx].length - 1)] = x_p1.charCodeAt(chckIndx(addInt(start_p2, iHEX60gensym4_301990110), 0, x_p1.length - 1));
        i_536870936 = addInt(i_536870936, 1);
      }
    }
  }
}
function addChars__stdZprivateZdigitsutils_u198(result_p0, result_p0_Idx, x_p1) {
  addChars__stdZprivateZdigitsutils_u202(result_p0, result_p0_Idx, x_p1, 0, x_p1 == null ? 0 : x_p1.length);
}
function addInt__stdZprivateZdigitsutils_u223(result_p0, result_p0_Idx, x_p1) {
  addChars__stdZprivateZdigitsutils_u198(result_p0, result_p0_Idx, x_p1 + "");
}
function addInt__stdZprivateZdigitsutils_u241(result_p0, result_p0_Idx, x_p1) {
  addInt__stdZprivateZdigitsutils_u223(result_p0, result_p0_Idx, x_p1);
}
function HEX24__systemZdollars_u8(x_p0) {
  var result_385875978 = [[]];
  addInt__stdZprivateZdigitsutils_u241(result_385875978, 0, x_p0);
  return result_385875978[0];
}
function isFatPointer__system_u2866(ti_p0) {
  var result_33557300 = false;
  BeforeRet: {
    result_33557300 = !(ConstSet1[ti_p0.base.kind] != void 0);
    break BeforeRet;
  }
  return result_33557300;
}
function nimCopyAux(dest_p0, src_p1, n_p2) {
  switch (n_p2.kind) {
    case 0:
      break;
    case 1:
      dest_p0[n_p2.offset] = nimCopy(dest_p0[n_p2.offset], src_p1[n_p2.offset], n_p2.typ);
      break;
    case 2:
      for (var i2 = 0; i2 < n_p2.sons.length; i2++) {
        nimCopyAux(dest_p0, src_p1, n_p2.sons[i2]);
      }
      break;
    case 3:
      dest_p0[n_p2.offset] = nimCopy(dest_p0[n_p2.offset], src_p1[n_p2.offset], n_p2.typ);
      for (var i2 = 0; i2 < n_p2.sons.length; ++i2) {
        nimCopyAux(dest_p0, src_p1, n_p2.sons[i2][1]);
      }
      break;
  }
}
function raiseIndexError(i_p0, a_p1, b_p2) {
  var Temporary1;
  if (b_p2 < a_p1) {
    Temporary1 = [
      105,
      110,
      100,
      101,
      120,
      32,
      111,
      117,
      116,
      32,
      111,
      102,
      32,
      98,
      111,
      117,
      110,
      100,
      115,
      44,
      32,
      116,
      104,
      101,
      32,
      99,
      111,
      110,
      116,
      97,
      105,
      110,
      101,
      114,
      32,
      105,
      115,
      32,
      101,
      109,
      112,
      116,
      121
    ];
  } else {
    Temporary1 = [105, 110, 100, 101, 120, 32].concat(HEX24__systemZdollars_u8(i_p0), [32, 110, 111, 116, 32, 105, 110, 32], HEX24__systemZdollars_u8(a_p1), [32, 46, 46, 32], HEX24__systemZdollars_u8(b_p2));
  }
  raiseException({
    message: nimCopy(null, Temporary1, NTI33554449),
    parent: null,
    m_type: NTI134217749,
    name: null,
    trace: [],
    up: null
  }, "IndexDefect");
}
function imul__pureZhashes_u340(a_p0, b_p1) {
  var result_671088983 = 0;
  var mask_671088984 = 65535;
  var aHi_671088989 = (a_p0 >>> 16 & mask_671088984) >>> 0;
  var aLo_671088990 = (a_p0 & mask_671088984) >>> 0;
  var bHi_671088995 = (b_p1 >>> 16 & mask_671088984) >>> 0;
  var bLo_671088996 = (b_p1 & mask_671088984) >>> 0;
  result_671088983 = (aLo_671088990 * bLo_671088996 >>> 0) + ((aHi_671088989 * bLo_671088996 >>> 0) + (aLo_671088990 * bHi_671088995 >>> 0) >>> 0 << 16 >>> 0) >>> 0;
  return result_671088983;
}
function rotl32__pureZhashes_u361(x_p0, r_p1) {
  var result_671089004 = 0;
  result_671089004 = (x_p0 << r_p1 >>> 0 | x_p0 >>> subInt(32, r_p1)) >>> 0;
  return result_671089004;
}
function murmurHash__pureZhashes_u373(x_p0) {
  var result_671089015 = 0;
  BeforeRet: {
    var size_671089024 = x_p0.length;
    var stepSize_671089025 = 4;
    var n_671089026 = divInt(size_671089024, stepSize_671089025);
    var h1_671089027 = 0;
    var i_671089028 = 0;
    {
      Label2: while (true) {
        if (!(i_671089028 < mulInt(n_671089026, stepSize_671089025)))
          break Label2;
        var k1_671089031 = 0;
        var jHEX60gensym11_671089048 = stepSize_671089025;
        {
          Label4: while (true) {
            if (!(0 < jHEX60gensym11_671089048))
              break Label4;
            jHEX60gensym11_671089048 = subInt(jHEX60gensym11_671089048, 1);
            k1_671089031 = (k1_671089031 << 8 >>> 0 | Number(BigInt.asUintN(32, BigInt(x_p0[chckIndx(addInt(i_671089028, jHEX60gensym11_671089048), 0, x_p0.length - 1)])))) >>> 0;
          }
        }
        i_671089028 = addInt(i_671089028, stepSize_671089025);
        k1_671089031 = imul__pureZhashes_u340(k1_671089031, 3432918353);
        k1_671089031 = rotl32__pureZhashes_u361(k1_671089031, 15);
        k1_671089031 = imul__pureZhashes_u340(k1_671089031, 461845907);
        h1_671089027 = (h1_671089027 ^ k1_671089031) >>> 0;
        h1_671089027 = rotl32__pureZhashes_u361(h1_671089027, 13);
        h1_671089027 = (h1_671089027 * 5 >>> 0) + 3864292196 >>> 0;
      }
    }
    var k1_671089066 = 0;
    var rem_671089067 = modInt(size_671089024, stepSize_671089025);
    {
      Label6: while (true) {
        if (!(0 < rem_671089067))
          break Label6;
        rem_671089067 = subInt(rem_671089067, 1);
        k1_671089066 = (k1_671089066 << 8 >>> 0 | Number(BigInt.asUintN(32, BigInt(x_p0[chckIndx(addInt(i_671089028, rem_671089067), 0, x_p0.length - 1)])))) >>> 0;
      }
    }
    k1_671089066 = imul__pureZhashes_u340(k1_671089066, 3432918353);
    k1_671089066 = rotl32__pureZhashes_u361(k1_671089066, 15);
    k1_671089066 = imul__pureZhashes_u340(k1_671089066, 461845907);
    h1_671089027 = (h1_671089027 ^ k1_671089066) >>> 0;
    h1_671089027 = (h1_671089027 ^ Number(BigInt.asUintN(32, BigInt(size_671089024)))) >>> 0;
    h1_671089027 = (h1_671089027 ^ h1_671089027 >>> 16) >>> 0;
    h1_671089027 = imul__pureZhashes_u340(h1_671089027, 2246822507);
    h1_671089027 = (h1_671089027 ^ h1_671089027 >>> 13) >>> 0;
    h1_671089027 = imul__pureZhashes_u340(h1_671089027, 3266489909);
    h1_671089027 = (h1_671089027 ^ h1_671089027 >>> 16) >>> 0;
    result_671089015 = Number(BigInt.asIntN(32, BigInt(h1_671089027)));
    break BeforeRet;
  }
  return result_671089015;
}
function hash__pureZhashes_u782(x_p0) {
  var result_671089424 = 0;
  result_671089424 = murmurHash__pureZhashes_u373(x_p0.slice(0, x_p0.length - 1 + 1));
  return result_671089424;
}
function hashN__nim95hash_u2(item_p0, n_p1, maxValue_p2) {
  var result_536870918 = 0;
  var hashA_536870919 = modInt(absInt(hash__pureZhashes_u782(item_p0)), maxValue_p2);
  var hashB_536870920 = modInt(absInt(hash__pureZhashes_u782(item_p0.concat([32, 98]))), maxValue_p2);
  result_536870918 = modInt(absInt(addInt(hashA_536870919, mulInt(n_p1, hashB_536870920))), maxValue_p2);
  return result_536870918;
}
function sysFatal__stdZassertions_u45(message_p1) {
  raiseException({
    message: nimCopy(null, message_p1, NTI33554449),
    m_type: NTI134217745,
    parent: null,
    name: null,
    trace: [],
    up: null
  }, "AssertionDefect");
}
function raiseAssert__stdZassertions_u43(msg_p0) {
  sysFatal__stdZassertions_u45(msg_p0);
}
function failedAssertImpl__stdZassertions_u85(msg_p0) {
  raiseAssert__stdZassertions_u43(msg_p0);
}
if (!(hashN__nim95hash_u2([100, 117, 109, 109, 121], 0, 1) == 0)) {
  failedAssertImpl__stdZassertions_u85([
    110,
    105,
    109,
    95,
    104,
    97,
    115,
    104,
    46,
    110,
    105,
    109,
    40,
    50,
    54,
    44,
    32,
    51,
    41,
    32,
    96,
    104,
    97,
    115,
    104,
    78,
    40,
    34,
    100,
    117,
    109,
    109,
    121,
    34,
    44,
    32,
    48,
    44,
    32,
    49,
    41,
    32,
    61,
    61,
    32,
    48,
    96,
    32
  ]);
}
function hashN(item, n2, maxValue2) {
  const itemArray = Array.from(item).map((char) => char.charCodeAt(0));
  return hashN__nim95hash_u2(itemArray, n2, maxValue2);
}

// node_modules/@waku/sds/dist/probabilities.js
var kErrors = [
  new Float32Array([1]),
  new Float32Array([
    1,
    1,
    0.393,
    0.283,
    0.221,
    0.181,
    0.154,
    0.133,
    0.118,
    0.105,
    0.0952,
    0.0869,
    0.08,
    0.074,
    0.0689,
    0.0645,
    0.0606,
    0.0571,
    0.054,
    0.0513,
    0.0488,
    0.0465,
    0.0444,
    0.0425,
    0.0408,
    0.0392,
    0.0377,
    0.0364,
    0.0351,
    0.0339,
    0.0328,
    0.0317,
    0.0308
  ]),
  new Float32Array([
    1,
    1,
    0.4,
    0.237,
    0.155,
    0.109,
    0.0804,
    0.0618,
    0.0489,
    0.0397,
    0.0329,
    0.0276,
    0.0236,
    0.0203,
    0.0177,
    0.0156,
    0.0138,
    0.0123,
    0.0111,
    998e-5,
    906e-5,
    825e-5,
    755e-5,
    694e-5,
    639e-5,
    591e-5,
    548e-5,
    51e-4,
    475e-5,
    444e-5,
    416e-5,
    39e-4,
    367e-5
  ]),
  new Float32Array([
    1,
    1,
    1,
    0.253,
    0.147,
    0.092,
    0.0609,
    0.0423,
    0.0306,
    0.0228,
    0.0174,
    0.0136,
    0.0108,
    875e-5,
    718e-5,
    596e-5,
    0.0108,
    875e-5,
    718e-5,
    596e-5,
    5e-3,
    423e-5,
    362e-5,
    312e-5,
    27e-4,
    236e-5,
    207e-5,
    183e-5,
    162e-5,
    145e-5,
    129e-5,
    116e-5,
    105e-5,
    949e-6,
    862e-6,
    785e-6,
    717e-6
  ]),
  new Float32Array([
    1,
    1,
    1,
    1,
    0.16,
    0.092,
    0.0561,
    0.0359,
    0.024,
    0.0166,
    0.0118,
    864e-5,
    646e-5,
    492e-5,
    381e-5,
    3e-3,
    239e-5,
    193e-5,
    158e-5,
    13e-4,
    108e-5,
    905e-6,
    764e-6,
    649e-6,
    555e-6,
    478e-6,
    413e-6,
    359e-6,
    314e-6,
    276e-6,
    243e-6,
    215e-6,
    191e-6
  ]),
  new Float32Array([
    1,
    1,
    1,
    1,
    1,
    0.101,
    0.0578,
    0.0347,
    0.0217,
    0.0141,
    943e-5,
    65e-4,
    459e-5,
    332e-5,
    244e-5,
    183e-5,
    139e-5,
    107e-5,
    839e-6,
    663e-6,
    53e-5,
    427e-6,
    347e-6,
    285e-6,
    235e-6,
    196e-6,
    164e-6,
    138e-6,
    117e-6,
    996e-7,
    853e-7,
    733e-7,
    633e-7
  ]),
  new Float32Array([
    1,
    1,
    1,
    1,
    1,
    1,
    0.0638,
    0.0364,
    0.0216,
    0.0133,
    844e-5,
    552e-5,
    371e-5,
    255e-5,
    179e-5,
    128e-5,
    935e-6,
    692e-6,
    519e-6,
    394e-6,
    303e-6,
    236e-6,
    185e-6,
    147e-6,
    117e-6,
    944e-7,
    766e-7,
    626e-7,
    515e-7,
    426e-7,
    355e-7,
    297e-7,
    25e-6
  ]),
  new Float32Array([
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.0229,
    0.0135,
    819e-5,
    513e-5,
    329e-5,
    217e-5,
    146e-5,
    1e-3,
    702e-6,
    499e-6,
    36e-5,
    264e-6,
    196e-6,
    147e-6,
    112e-6,
    856e-7,
    663e-7,
    518e-7,
    408e-7,
    324e-7,
    259e-7,
    209e-7,
    169e-7,
    138e-7,
    113e-7
  ]),
  new Float32Array([
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.0145,
    846e-5,
    509e-5,
    314e-5,
    199e-5,
    129e-5,
    852e-6,
    574e-6,
    394e-6,
    275e-6,
    194e-6,
    14e-5,
    101e-6,
    746e-7,
    555e-7,
    417e-7,
    316e-7,
    242e-7,
    187e-7,
    146e-7,
    114e-7,
    901e-8,
    716e-8,
    573e-8
  ]),
  new Float32Array([
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    531e-5,
    317e-5,
    194e-5,
    121e-5,
    775e-6,
    505e-6,
    335e-6,
    226e-6,
    155e-6,
    108e-6,
    759e-7,
    542e-7,
    392e-7,
    286e-7,
    211e-7,
    157e-7,
    118e-7,
    896e-8,
    685e-8,
    528e-8,
    41e-7,
    32e-7
  ]),
  new Float32Array([
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    334e-5,
    198e-5,
    12e-4,
    744e-6,
    47e-5,
    302e-6,
    198e-6,
    132e-6,
    889e-7,
    609e-7,
    423e-7,
    297e-7,
    211e-7,
    152e-7,
    11e-6,
    807e-8,
    597e-8,
    445e-8,
    335e-8,
    254e-8,
    194e-8
  ]),
  new Float32Array([
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    21e-4,
    124e-5,
    747e-6,
    459e-6,
    287e-6,
    183e-6,
    118e-6,
    777e-7,
    518e-7,
    35e-6,
    24e-6,
    166e-7,
    116e-7,
    823e-8,
    589e-8,
    425e-8,
    31e-7,
    228e-8,
    169e-8,
    126e-8
  ]),
  new Float32Array([
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    778e-6,
    466e-6,
    284e-6,
    176e-6,
    111e-6,
    712e-7,
    463e-7,
    305e-7,
    204e-7,
    138e-7,
    942e-8,
    652e-8,
    456e-8,
    322e-8,
    229e-8,
    165e-8,
    12e-7,
    874e-9
  ])
];
var KTooLargeError = "K must be <= 12";
var NoSuitableRatioError = "Specified value of k and error rate not achievable using less than 4 bytes / element.";
function getMOverNBitsForK(k, targetError, probabilityTable = kErrors) {
  if (k < 0 || k > 12) {
    throw new Error(KTooLargeError);
  }
  for (let mOverN = 2; mOverN < probabilityTable[k].length; mOverN++) {
    if (probabilityTable[k][mOverN] < targetError) {
      return mOverN;
    }
  }
  throw new Error(NoSuitableRatioError);
}

// node_modules/@waku/sds/dist/bloom_filter/bloom.js
var sizeOfInt = 8;
var BloomFilter2 = class _BloomFilter {
  constructor(options, hashN2) {
    __publicField(this, "totalBits");
    __publicField(this, "data", []);
    __publicField(this, "kHashes");
    __publicField(this, "errorRate");
    __publicField(this, "options");
    __publicField(this, "hashN");
    this.options = options;
    let nBitsPerElem;
    let k = options.kHashes ?? 0;
    const forceNBitsPerElem = options.forceNBitsPerElem ?? 0;
    if (k < 1) {
      const bitsPerElem = Math.ceil(-1 * (Math.log(options.errorRate) / Math.pow(Math.log(2), 2)));
      k = Math.round(Math.log(2) * bitsPerElem);
      nBitsPerElem = Math.round(bitsPerElem);
    } else {
      if (forceNBitsPerElem < 1) {
        nBitsPerElem = getMOverNBitsForK(k, options.errorRate);
      } else {
        nBitsPerElem = forceNBitsPerElem;
      }
    }
    const mBits = options.capacity * nBitsPerElem;
    const mInts = 1 + Math.floor(mBits / (sizeOfInt * 8));
    this.totalBits = mBits;
    this.data = new Array(mInts);
    this.data.fill(BigInt(0));
    this.kHashes = k;
    this.hashN = hashN2;
    this.errorRate = options.errorRate;
  }
  computeHashes(item) {
    const hashes2 = new Array(this.kHashes);
    for (let i2 = 0; i2 < this.kHashes; i2++) {
      hashes2[i2] = this.hashN(item, i2, this.totalBits);
    }
    return hashes2;
  }
  // Adds an item to the bloom filter by computing its hash values
  // and setting corresponding bits in "data".
  insert(item) {
    const hashSet = this.computeHashes(item);
    for (const h of hashSet) {
      const intAddress = Math.floor(h / (sizeOfInt * 8));
      const bitOffset = h % (sizeOfInt * 8);
      this.data[intAddress] = this.data[intAddress] | BigInt(1) << BigInt(bitOffset);
    }
  }
  // Checks if the item is potentially in the bloom filter.
  // The method is guaranteed to return "true" for items that were inserted,
  // but might also return "true" for items that were never inserted
  // (purpose of false-positive probability).
  lookup(item) {
    const hashSet = this.computeHashes(item);
    for (const h of hashSet) {
      const intAddress = Math.floor(h / (sizeOfInt * 8));
      const bitOffset = h % (sizeOfInt * 8);
      const currentInt = this.data[intAddress];
      if (currentInt != (currentInt | BigInt(1) << BigInt(bitOffset))) {
        return false;
      }
    }
    return true;
  }
  toBytes() {
    const buffer = new ArrayBuffer(this.data.length * 8);
    const view = new DataView(buffer);
    for (let i2 = 0; i2 < this.data.length; i2++) {
      view.setBigInt64(i2 * 8, this.data[i2]);
    }
    return new Uint8Array(buffer);
  }
  static fromBytes(bytes, options, hashN2) {
    const bloomFilter = new _BloomFilter(options, hashN2);
    const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    for (let i2 = 0; i2 < bloomFilter.data.length; i2++) {
      bloomFilter.data[i2] = view.getBigUint64(i2 * 8, false);
    }
    return bloomFilter;
  }
};
var DefaultBloomFilter = class extends BloomFilter2 {
  constructor(options) {
    super(options, hashN);
  }
  static fromBytes(bytes, options) {
    return BloomFilter2.fromBytes(bytes, options, hashN);
  }
};

// node_modules/@waku/sds/dist/message_channel/command_queue.js
var Command;
(function(Command2) {
  Command2["Send"] = "send";
  Command2["Receive"] = "receive";
  Command2["SendEphemeral"] = "sendEphemeral";
})(Command || (Command = {}));

// node_modules/@waku/sds/dist/message_channel/events.js
var MessageChannelEvent;
(function(MessageChannelEvent2) {
  MessageChannelEvent2["OutMessageSent"] = "sds:out:message-sent";
  MessageChannelEvent2["InMessageDelivered"] = "sds:in:message-delivered";
  MessageChannelEvent2["InMessageReceived"] = "sds:in:message-received";
  MessageChannelEvent2["OutMessageAcknowledged"] = "sds:out:message-acknowledged";
  MessageChannelEvent2["OutMessagePossiblyAcknowledged"] = "sds:out:message-possibly-acknowledged";
  MessageChannelEvent2["InMessageMissing"] = "sds:in:message-missing";
  MessageChannelEvent2["OutSyncSent"] = "sds:out:sync-sent";
  MessageChannelEvent2["InSyncReceived"] = "sds:in:sync-received";
  MessageChannelEvent2["InMessageLost"] = "sds:in:message-irretrievably-lost";
  MessageChannelEvent2["ErrorTask"] = "sds:error-task";
  MessageChannelEvent2["RepairRequestQueued"] = "sds:repair:request-queued";
  MessageChannelEvent2["RepairRequestSent"] = "sds:repair:request-sent";
  MessageChannelEvent2["RepairRequestReceived"] = "sds:repair:request-received";
  MessageChannelEvent2["RepairResponseQueued"] = "sds:repair:response-queued";
  MessageChannelEvent2["RepairResponseSent"] = "sds:repair:response-sent";
})(MessageChannelEvent || (MessageChannelEvent = {}));

// node_modules/@waku/sds/node_modules/@libp2p/interface/dist/src/connection.js
var connectionSymbol3 = Symbol.for("@libp2p/connection");

// node_modules/@waku/sds/node_modules/@libp2p/interface/dist/src/content-routing.js
var contentRoutingSymbol3 = Symbol.for("@libp2p/content-routing");

// node_modules/@waku/sds/node_modules/@libp2p/interface/dist/src/peer-discovery.js
var peerDiscoverySymbol3 = Symbol.for("@libp2p/peer-discovery");

// node_modules/@waku/sds/node_modules/@libp2p/interface/dist/src/peer-id.js
var peerIdSymbol3 = Symbol.for("@libp2p/peer-id");

// node_modules/@waku/sds/node_modules/@libp2p/interface/dist/src/peer-routing.js
var peerRoutingSymbol3 = Symbol.for("@libp2p/peer-routing");

// node_modules/@waku/sds/node_modules/@libp2p/interface/dist/src/pubsub.js
var TopicValidatorResult2;
(function(TopicValidatorResult3) {
  TopicValidatorResult3["Accept"] = "accept";
  TopicValidatorResult3["Ignore"] = "ignore";
  TopicValidatorResult3["Reject"] = "reject";
})(TopicValidatorResult2 || (TopicValidatorResult2 = {}));
var pubSubSymbol2 = Symbol.for("@libp2p/pubsub");

// node_modules/@waku/sds/node_modules/@libp2p/interface/dist/src/transport.js
var transportSymbol3 = Symbol.for("@libp2p/transport");
var FaultTolerance3;
(function(FaultTolerance4) {
  FaultTolerance4[FaultTolerance4["FATAL_ALL"] = 0] = "FATAL_ALL";
  FaultTolerance4[FaultTolerance4["NO_FATAL"] = 1] = "NO_FATAL";
})(FaultTolerance3 || (FaultTolerance3 = {}));

// node_modules/@waku/sds/node_modules/@libp2p/interface/dist/src/index.js
var serviceCapabilities3 = Symbol.for("@libp2p/service-capabilities");
var serviceDependencies3 = Symbol.for("@libp2p/service-dependencies");

// node_modules/@waku/sds/dist/message_channel/mem_local_history.js
var import_lodash2 = __toESM(require_lodash2(), 1);

// node_modules/@waku/sds/dist/message_channel/message.js
var log34 = new Logger("sds:message");
var Message = class {
  constructor(messageId, channelId, senderId, causalHistory, lamportTimestamp, bloomFilter, content, repairRequest = [], retrievalHint) {
    __publicField(this, "messageId");
    __publicField(this, "channelId");
    __publicField(this, "senderId");
    __publicField(this, "causalHistory");
    __publicField(this, "lamportTimestamp");
    __publicField(this, "bloomFilter");
    __publicField(this, "content");
    __publicField(this, "repairRequest");
    __publicField(this, "retrievalHint");
    this.messageId = messageId;
    this.channelId = channelId;
    this.senderId = senderId;
    this.causalHistory = causalHistory;
    this.lamportTimestamp = lamportTimestamp;
    this.bloomFilter = bloomFilter;
    this.content = content;
    this.repairRequest = repairRequest;
    this.retrievalHint = retrievalHint;
  }
  encode() {
    return sds_message_exports.SdsMessage.encode(this);
  }
  static decode(data) {
    try {
      const { messageId, channelId, senderId, causalHistory, lamportTimestamp, bloomFilter, content, repairRequest } = sds_message_exports.SdsMessage.decode(data);
      if (testContentMessage({ lamportTimestamp, content })) {
        return new ContentMessage(messageId, channelId, senderId, causalHistory, lamportTimestamp, bloomFilter, content, repairRequest);
      }
      if (testEphemeralMessage({ lamportTimestamp, content })) {
        return new EphemeralMessage(messageId, channelId, senderId, causalHistory, void 0, bloomFilter, content, repairRequest);
      }
      if (testSyncMessage({ lamportTimestamp, content })) {
        return new SyncMessage(messageId, channelId, senderId, causalHistory, lamportTimestamp, bloomFilter, void 0, repairRequest);
      }
      log34.error("message received was of unknown type", lamportTimestamp, content);
    } catch (err) {
      log34.error("failed to decode sds message", err);
    }
    return void 0;
  }
};
var SyncMessage = class extends Message {
  constructor(messageId, channelId, senderId, causalHistory, lamportTimestamp, bloomFilter, content, repairRequest = [], retrievalHint) {
    super(messageId, channelId, senderId, causalHistory, lamportTimestamp, bloomFilter, content, repairRequest, retrievalHint);
    __publicField(this, "messageId");
    __publicField(this, "channelId");
    __publicField(this, "senderId");
    __publicField(this, "causalHistory");
    __publicField(this, "lamportTimestamp");
    __publicField(this, "bloomFilter");
    __publicField(this, "content");
    __publicField(this, "repairRequest");
    __publicField(this, "retrievalHint");
    this.messageId = messageId;
    this.channelId = channelId;
    this.senderId = senderId;
    this.causalHistory = causalHistory;
    this.lamportTimestamp = lamportTimestamp;
    this.bloomFilter = bloomFilter;
    this.content = content;
    this.repairRequest = repairRequest;
    this.retrievalHint = retrievalHint;
  }
};
function testSyncMessage(message2) {
  return Boolean("lamportTimestamp" in message2 && typeof message2.lamportTimestamp === "bigint" && (message2.content === void 0 || message2.content.length === 0));
}
function isSyncMessage(message2) {
  return testSyncMessage(message2);
}
var EphemeralMessage = class extends Message {
  constructor(messageId, channelId, senderId, causalHistory, lamportTimestamp, bloomFilter, content, repairRequest = [], retrievalHint) {
    if (!content || !content.length) {
      throw Error("Ephemeral Message must have content");
    }
    super(messageId, channelId, senderId, causalHistory, lamportTimestamp, bloomFilter, content, repairRequest, retrievalHint);
    __publicField(this, "messageId");
    __publicField(this, "channelId");
    __publicField(this, "senderId");
    __publicField(this, "causalHistory");
    __publicField(this, "lamportTimestamp");
    __publicField(this, "bloomFilter");
    __publicField(this, "content");
    __publicField(this, "repairRequest");
    __publicField(this, "retrievalHint");
    this.messageId = messageId;
    this.channelId = channelId;
    this.senderId = senderId;
    this.causalHistory = causalHistory;
    this.lamportTimestamp = lamportTimestamp;
    this.bloomFilter = bloomFilter;
    this.content = content;
    this.repairRequest = repairRequest;
    this.retrievalHint = retrievalHint;
  }
};
function isEphemeralMessage(message2) {
  return testEphemeralMessage(message2);
}
function testEphemeralMessage(message2) {
  return Boolean(message2.lamportTimestamp === void 0 && "content" in message2 && message2.content && message2.content.length);
}
var ContentMessage = class extends Message {
  constructor(messageId, channelId, senderId, causalHistory, lamportTimestamp, bloomFilter, content, repairRequest = [], retrievalHint) {
    if (!content.length) {
      throw Error("Content Message must have content");
    }
    super(messageId, channelId, senderId, causalHistory, lamportTimestamp, bloomFilter, content, repairRequest, retrievalHint);
    __publicField(this, "messageId");
    __publicField(this, "channelId");
    __publicField(this, "senderId");
    __publicField(this, "causalHistory");
    __publicField(this, "lamportTimestamp");
    __publicField(this, "bloomFilter");
    __publicField(this, "content");
    __publicField(this, "repairRequest");
    __publicField(this, "retrievalHint");
    this.messageId = messageId;
    this.channelId = channelId;
    this.senderId = senderId;
    this.causalHistory = causalHistory;
    this.lamportTimestamp = lamportTimestamp;
    this.bloomFilter = bloomFilter;
    this.content = content;
    this.repairRequest = repairRequest;
    this.retrievalHint = retrievalHint;
  }
  // `valueOf` is used by comparison operands such as `<`
  valueOf() {
    const paddedTimestamp = this.lamportTimestamp.toString().padStart(16, "0");
    return `${paddedTimestamp}_${this.messageId}`;
  }
};
function isContentMessage(message2) {
  return testContentMessage(message2);
}
function testContentMessage(message2) {
  return Boolean("lamportTimestamp" in message2 && typeof message2.lamportTimestamp === "bigint" && message2.content && message2.content.length);
}

// node_modules/@waku/sds/dist/message_channel/mem_local_history.js
var MemLocalHistory = class {
  constructor() {
    __publicField(this, "items", []);
  }
  get length() {
    return this.items.length;
  }
  push(...items) {
    for (const item of items) {
      this.validateMessage(item);
    }
    const combinedItems = [...this.items, ...items];
    combinedItems.sort((a2, b) => a2.valueOf().localeCompare(b.valueOf()));
    this.items = import_lodash2.default.uniqBy(combinedItems, "messageId");
    return this.items.length;
  }
  some(predicate, thisArg) {
    return this.items.some(predicate, thisArg);
  }
  slice(start2, end) {
    return this.items.slice(start2, end);
  }
  find(predicate, thisArg) {
    return this.items.find(predicate, thisArg);
  }
  findIndex(predicate, thisArg) {
    return this.items.findIndex(predicate, thisArg);
  }
  validateMessage(message2) {
    if (!isContentMessage(message2)) {
      throw new Error("Message must have lamportTimestamp and content defined, sync and ephemeral messages cannot be stored");
    }
  }
};

// node_modules/@waku/sds/dist/message_channel/repair/buffers.js
var log35 = new Logger("sds:repair:buffers");
var OutgoingRepairBuffer = class {
  constructor(maxSize = 1e3) {
    // Sorted array by T_req (ascending - earliest first)
    __publicField(this, "items", []);
    __publicField(this, "maxSize");
    this.maxSize = maxSize;
  }
  /**
   * Add a missing message to the outgoing repair request buffer
   * If message already exists, it is not updated (keeps original T_req)
   * @returns true if the entry was added, false if it already existed
   */
  add(entry, tReq) {
    const messageId = entry.messageId;
    if (this.has(messageId)) {
      log35.info(`Message ${messageId} already in outgoing buffer, keeping original T_req`);
      return false;
    }
    if (this.items.length >= this.maxSize) {
      const evicted = this.items.pop();
      log35.warn(`Buffer full, evicted furthest entry ${evicted.entry.messageId} with T_req ${evicted.tReq}`);
    }
    const newEntry = { entry, tReq, requested: false };
    const combined = [...this.items, newEntry];
    combined.sort((a2, b) => a2.tReq - b.tReq);
    this.items = combined;
    log35.info(`Added ${messageId} to outgoing buffer with T_req: ${tReq}`);
    return true;
  }
  /**
   * Remove a message from the buffer (e.g., when received)
   */
  remove(messageId) {
    this.items = this.items.filter((item) => item.entry.messageId !== messageId);
  }
  /**
   * Get eligible repair requests (where T_req <= currentTime)
   * Returns up to maxRequests entries from the front of the sorted array
   * Marks returned entries as requested but keeps them in buffer until received
   */
  getEligible(currentTime = Date.now(), maxRequests = 3) {
    const eligible = [];
    for (const item of this.items) {
      if (item.tReq > currentTime) {
        break;
      }
      if (!item.requested && eligible.length < maxRequests) {
        eligible.push(item.entry);
        item.requested = true;
        log35.info(`Repair request for ${item.entry.messageId} is eligible and marked as requested`);
      }
      if (eligible.length >= maxRequests) {
        break;
      }
    }
    return eligible;
  }
  /**
   * Check if a message is in the buffer
   */
  has(messageId) {
    return this.items.some((item) => item.entry.messageId === messageId);
  }
  /**
   * Get the current buffer size
   */
  get size() {
    return this.items.length;
  }
  /**
   * Clear all entries
   */
  clear() {
    this.items = [];
  }
  /**
   * Get all entries (for testing/debugging)
   */
  getAll() {
    return this.items.map((item) => item.entry);
  }
  /**
   * Get items array directly (for testing)
   */
  getItems() {
    return [...this.items];
  }
};
var IncomingRepairBuffer = class {
  constructor(maxSize = 1e3) {
    // Sorted array by T_resp (ascending - earliest first)
    __publicField(this, "items", []);
    __publicField(this, "maxSize");
    this.maxSize = maxSize;
  }
  /**
   * Add a repair request that we can fulfill
   * If message already exists, it is ignored (not updated)
   * @returns true if the entry was added, false if it already existed
   */
  add(entry, tResp) {
    const messageId = entry.messageId;
    if (this.has(messageId)) {
      log35.info(`Message ${messageId} already in incoming buffer, ignoring`);
      return false;
    }
    if (this.items.length >= this.maxSize) {
      const evicted = this.items.pop();
      log35.warn(`Buffer full, evicted furthest entry ${evicted.entry.messageId} with T_resp ${evicted.tResp}`);
    }
    const newEntry = { entry, tResp };
    const combined = [...this.items, newEntry];
    combined.sort((a2, b) => a2.tResp - b.tResp);
    this.items = combined;
    log35.info(`Added ${messageId} to incoming buffer with T_resp: ${tResp}`);
    return true;
  }
  /**
   * Remove a message from the buffer
   */
  remove(messageId) {
    this.items = this.items.filter((item) => item.entry.messageId !== messageId);
  }
  /**
   * Get repairs ready to be sent (where T_resp <= currentTime)
   * Removes and returns ready entries
   */
  getReady(currentTime) {
    let cutoff = 0;
    for (let i2 = 0; i2 < this.items.length; i2++) {
      if (this.items[i2].tResp > currentTime) {
        cutoff = i2;
        break;
      }
      cutoff = i2 + 1;
    }
    const ready = this.items.slice(0, cutoff).map((item) => {
      log35.info(`Repair for ${item.entry.messageId} is ready to be sent`);
      return item.entry;
    });
    this.items = this.items.slice(cutoff);
    return ready;
  }
  /**
   * Check if a message is in the buffer
   */
  has(messageId) {
    return this.items.some((item) => item.entry.messageId === messageId);
  }
  /**
   * Get the current buffer size
   */
  get size() {
    return this.items.length;
  }
  /**
   * Clear all entries
   */
  clear() {
    this.items = [];
  }
  /**
   * Get all entries (for testing/debugging)
   */
  getAll() {
    return this.items.map((item) => item.entry);
  }
  /**
   * Get items array directly (for testing)
   */
  getItems() {
    return [...this.items];
  }
};

// node_modules/@waku/sds/dist/message_channel/repair/utils.js
function hashToInteger(input) {
  const hashBytes = sha2562(new TextEncoder().encode(input));
  const view = new DataView(hashBytes.buffer, 0, 8);
  return view.getBigUint64(0, false);
}
function combinedHash(participantId, messageId) {
  const combined = `${participantId}${messageId}`;
  return hashToInteger(combined);
}
function participantIdToNumeric(participantId) {
  return hashToInteger(participantId);
}
function calculateXorDistance(participantId1, participantId2) {
  const numeric1 = participantIdToNumeric(participantId1);
  const numeric2 = participantIdToNumeric(participantId2);
  return numeric1 ^ numeric2;
}
function bigintToNumber(value) {
  const maxSafe = BigInt(Number.MAX_SAFE_INTEGER);
  return Number(value % maxSafe);
}
function hashString(input) {
  return hashToInteger(input);
}

// node_modules/@waku/sds/dist/message_channel/repair/repair.js
var log36 = new Logger("sds:repair:manager");
var PARTICIPANTS_PER_RESPONSE_GROUP = 128;
var DEFAULT_REPAIR_CONFIG = {
  tMin: 3e4,
  // 30 seconds
  tMax: 12e4,
  // 120 seconds
  numResponseGroups: 1,
  // Recommendation is 1 group per PARTICIPANTS_PER_RESPONSE_GROUP participants
  bufferSize: 1e3
};
var RepairManager = class {
  constructor(participantId, config = {}, eventEmitter) {
    __publicField(this, "participantId");
    __publicField(this, "config");
    __publicField(this, "outgoingBuffer");
    __publicField(this, "incomingBuffer");
    __publicField(this, "eventEmitter");
    this.participantId = participantId;
    this.config = { ...DEFAULT_REPAIR_CONFIG, ...config };
    this.eventEmitter = eventEmitter;
    this.outgoingBuffer = new OutgoingRepairBuffer(this.config.bufferSize);
    this.incomingBuffer = new IncomingRepairBuffer(this.config.bufferSize);
    log36.info(`RepairManager initialized for participant ${participantId}`);
  }
  /**
   * Calculate T_req - when to request repair for a missing message
   * Per spec: T_req = current_time + hash(participant_id, message_id) % (T_max - T_min) + T_min
   */
  calculateTReq(messageId, currentTime = Date.now()) {
    const hash = combinedHash(this.participantId, messageId);
    const range = BigInt(this.config.tMax - this.config.tMin);
    const offset = bigintToNumber(hash % range) + this.config.tMin;
    return currentTime + offset;
  }
  /**
   * Calculate T_resp - when to respond with a repair
   * Per spec: T_resp = current_time + (distance * hash(message_id)) % T_max
   * where distance = participant_id XOR sender_id
   */
  calculateTResp(senderId, messageId, currentTime = Date.now()) {
    const distance = calculateXorDistance(this.participantId, senderId);
    const messageHash2 = hashString(messageId);
    const product = distance * messageHash2;
    const offset = bigintToNumber(product % BigInt(this.config.tMax));
    return currentTime + offset;
  }
  /**
   * Determine if this participant is in the response group for a message
   * Per spec: (hash(participant_id, message_id) % num_response_groups) ==
   *           (hash(sender_id, message_id) % num_response_groups)
   */
  isInResponseGroup(senderId, messageId) {
    if (!senderId) {
      return false;
    }
    const numGroups = BigInt(this.config.numResponseGroups);
    if (numGroups <= BigInt(1)) {
      return true;
    }
    const participantGroup = combinedHash(this.participantId, messageId) % numGroups;
    const senderGroup = combinedHash(senderId, messageId) % numGroups;
    return participantGroup === senderGroup;
  }
  /**
   * Handle missing dependencies by adding them to outgoing repair buffer
   * Called when causal dependencies are detected as missing
   */
  markDependenciesMissing(missingEntries, currentTime = Date.now()) {
    var _a27;
    for (const entry of missingEntries) {
      const tReq = this.calculateTReq(entry.messageId, currentTime);
      const wasAdded = this.outgoingBuffer.add(entry, tReq);
      if (wasAdded) {
        log36.info(`Added missing dependency ${entry.messageId} to repair buffer with T_req=${tReq}`);
        (_a27 = this.eventEmitter) == null ? void 0 : _a27.call(this, "RepairRequestQueued", {
          messageId: entry.messageId,
          tReq
        });
      }
    }
  }
  /**
   * Handle receipt of a message - remove from repair buffers
   * Called when a message is successfully received
   */
  markMessageReceived(messageId) {
    const wasInOutgoing = this.outgoingBuffer.has(messageId);
    const wasInIncoming = this.incomingBuffer.has(messageId);
    if (wasInOutgoing) {
      this.outgoingBuffer.remove(messageId);
      log36.info(`Removed ${messageId} from outgoing repair buffer after receipt`);
    }
    if (wasInIncoming) {
      this.incomingBuffer.remove(messageId);
      log36.info(`Removed ${messageId} from incoming repair buffer after receipt`);
    }
  }
  /**
   * Get repair requests that are eligible to be sent
   * Returns up to maxRequests entries where T_req <= currentTime
   */
  getRepairRequests(maxRequests = 3, currentTime = Date.now()) {
    return this.outgoingBuffer.getEligible(currentTime, maxRequests);
  }
  /**
   * Process incoming repair requests from other participants
   * Adds to incoming buffer if we can fulfill and are in response group
   */
  processIncomingRepairRequests(requests, localHistory, currentTime = Date.now()) {
    var _a27;
    for (const request2 of requests) {
      this.outgoingBuffer.remove(request2.messageId);
      const message2 = localHistory.find((m2) => m2.messageId === request2.messageId);
      if (!message2) {
        log36.info(`Cannot fulfill repair for ${request2.messageId} - not in local history`);
        continue;
      }
      if (!request2.senderId) {
        log36.warn(`Cannot determine response group for ${request2.messageId} - missing sender_id`);
        continue;
      }
      if (!this.isInResponseGroup(request2.senderId, request2.messageId)) {
        log36.info(`Not in response group for ${request2.messageId}`);
        continue;
      }
      const tResp = this.calculateTResp(request2.senderId, request2.messageId, currentTime);
      const wasAdded = this.incomingBuffer.add(request2, tResp);
      if (wasAdded) {
        log36.info(`Will respond to repair request for ${request2.messageId} at T_resp=${tResp}`);
        (_a27 = this.eventEmitter) == null ? void 0 : _a27.call(this, "RepairResponseQueued", {
          messageId: request2.messageId,
          tResp
        });
      }
    }
  }
  /**
   * Sweep outgoing buffer for repairs that should be requested
   * Returns entries where T_req <= currentTime
   */
  sweepOutgoingBuffer(maxRequests = 3, currentTime = Date.now()) {
    return this.getRepairRequests(maxRequests, currentTime);
  }
  /**
   * Sweep incoming buffer for repairs ready to be sent
   * Returns messages that should be rebroadcast
   */
  sweepIncomingBuffer(localHistory, currentTime = Date.now()) {
    const ready = this.incomingBuffer.getReady(currentTime);
    const messages2 = [];
    for (const entry of ready) {
      const message2 = localHistory.find((m2) => m2.messageId === entry.messageId);
      if (message2) {
        messages2.push(message2);
        log36.info(`Sending repair for ${entry.messageId}`);
      } else {
        log36.warn(`Message ${entry.messageId} no longer in local history`);
      }
    }
    return messages2;
  }
  /**
   * Clear all buffers
   */
  clear() {
    this.outgoingBuffer.clear();
    this.incomingBuffer.clear();
  }
  /**
   * Update number of response groups (e.g., when participants change)
   */
  updateResponseGroups(numParticipants) {
    if (numParticipants < 0 || !Number.isFinite(numParticipants) || !Number.isInteger(numParticipants)) {
      throw new Error(`Invalid numParticipants: ${numParticipants}. Must be a positive integer.`);
    }
    if (numParticipants > Number.MAX_SAFE_INTEGER) {
      log36.warn(`numParticipants ${numParticipants} exceeds MAX_SAFE_INTEGER, using MAX_SAFE_INTEGER`);
      numParticipants = Number.MAX_SAFE_INTEGER;
    }
    this.config.numResponseGroups = Math.max(1, Math.floor(numParticipants / PARTICIPANTS_PER_RESPONSE_GROUP));
    log36.info(`Updated response groups to ${this.config.numResponseGroups} for ${numParticipants} participants`);
  }
};

// node_modules/@waku/sds/dist/message_channel/message_channel.js
var DEFAULT_BLOOM_FILTER_OPTIONS = {
  capacity: 1e4,
  errorRate: 1e-3
};
var MAX_REPAIR_REQUESTS_PER_MESSAGE = 3;
var DEFAULT_CAUSAL_HISTORY_SIZE = 200;
var DEFAULT_POSSIBLE_ACKS_THRESHOLD = 2;
var log37 = new Logger("sds:message-channel");
var MessageChannel = class _MessageChannel extends TypedEventEmitter {
  constructor(channelId, senderId, options = {}, localHistory = new MemLocalHistory()) {
    super();
    __publicField(this, "channelId");
    __publicField(this, "senderId");
    __publicField(this, "lamportTimestamp");
    __publicField(this, "filter");
    __publicField(this, "outgoingBuffer");
    __publicField(this, "possibleAcks");
    __publicField(this, "incomingBuffer");
    __publicField(this, "localHistory");
    __publicField(this, "timeReceived");
    __publicField(this, "causalHistorySize");
    __publicField(this, "possibleAcksThreshold");
    __publicField(this, "timeoutForLostMessagesMs");
    __publicField(this, "repairManager");
    __publicField(this, "tasks", []);
    __publicField(this, "handlers", {
      [Command.Send]: async (params) => {
        await this._pushOutgoingMessage(params.payload, params.callback);
      },
      [Command.Receive]: async (params) => {
        this._pushIncomingMessage(params.message);
      },
      [Command.SendEphemeral]: async (params) => {
        await this._pushOutgoingEphemeralMessage(params.payload, params.callback);
      }
    });
    this.channelId = channelId;
    this.senderId = senderId;
    this.lamportTimestamp = BigInt(Date.now());
    this.filter = new DefaultBloomFilter(DEFAULT_BLOOM_FILTER_OPTIONS);
    this.outgoingBuffer = [];
    this.possibleAcks = /* @__PURE__ */ new Map();
    this.incomingBuffer = [];
    this.localHistory = localHistory;
    this.causalHistorySize = options.causalHistorySize ?? DEFAULT_CAUSAL_HISTORY_SIZE;
    this.possibleAcksThreshold = options.possibleAcksThreshold ?? DEFAULT_POSSIBLE_ACKS_THRESHOLD;
    this.timeReceived = /* @__PURE__ */ new Map();
    this.timeoutForLostMessagesMs = options.timeoutForLostMessagesMs;
    if (options.enableRepair ?? true) {
      this.repairManager = new RepairManager(senderId, options.repairConfig, (event, detail) => {
        this.safeSendEvent(event, { detail });
      });
    }
  }
  static getMessageId(payload) {
    return bytesToHex(sha2562(payload));
  }
  /**
   * Processes all queued tasks sequentially to ensure proper message ordering.
   *
   * This method should be called periodically by the library consumer to execute
   * queued send/receive operations in the correct sequence.
   *
   * @example
   * ```typescript
   * const channel = new MessageChannel("my-channel");
   *
   * // Queue some operations
   * await channel.pushOutgoingMessage(payload, callback);
   * channel.pushIncomingMessage(incomingMessage);
   *
   * // Process all queued operations
   * await channel.processTasks();
   * ```
   *
   * @emits CustomEvent("taskError", { detail: { command, error, params } }
   * if any task fails, but continues processing remaining tasks
   */
  async processTasks() {
    while (this.tasks.length > 0) {
      const item = this.tasks.shift();
      if (!item) {
        continue;
      }
      await this.executeTask(item);
    }
  }
  /**
   * Queues a message to be sent on this channel.
   *
   * The message will be processed sequentially when processTasks() is called.
   * This ensures proper lamport timestamp ordering and causal history tracking.
   *
   * @param payload - The message content as a byte array
   * @param callback - callback function that should propagate the message
   * on the routing layer; `success` should be false if sending irremediably fails,
   * when set to true, the message is finalized into the channel locally.
   * @returns Promise that resolves when the message is queued (not sent)
   *
   * @example
   * ```typescript
   * const channel = new MessageChannel("chat-room");
   * const message = new TextEncoder().encode("Hello, world!");
   *
   * await channel.pushOutgoingMessage(message, async (processedMessage) => {
   *   console.log("Message processed:", processedMessage.messageId);
   *   return { success: true };
   * });
   *
   * // Actually send the message
   * await channel.processTasks();
   * ```
   *
   * @throws Error if the payload is empty
   */
  pushOutgoingMessage(payload, callback) {
    if (!payload || !payload.length) {
      throw Error("Only messages with valid payloads are allowed");
    }
    this.tasks.push({
      command: Command.Send,
      params: {
        payload,
        callback
      }
    });
  }
  /**
   * Sends a short-lived message without synchronization or reliability requirements.
   *
   * Sends a message without a timestamp, causal history, or bloom filter.
   * Ephemeral messages are not added to the outgoing buffer.
   * Upon reception, ephemeral messages are delivered immediately without
   * checking for causal dependencies or including in the local log.
   *
   * See https://rfc.vac.dev/vac/raw/sds/#ephemeral-messages
   *
   * @param payload - The payload to send.
   * @param callback - A callback function that returns a boolean indicating whether the message was sent successfully.
   */
  async pushOutgoingEphemeralMessage(payload, callback) {
    this.tasks.push({
      command: Command.SendEphemeral,
      params: {
        payload,
        callback
      }
    });
  }
  /**
   * Queues a received message for processing.
   *
   * The message will be processed when processTasks() is called, ensuring
   * proper dependency resolution and causal ordering.
   *
   * @param message - The message to receive and process
   * @param retrievalHint - The retrieval hint for the message, provided by the transport layer
   * @example
   * ```typescript
   * const channel = new MessageChannel("chat-room");
   *
   * // Receive a message from the network
   * channel.pushIncomingMessage(incomingMessage);
   *
   * // Process the received message
   * await channel.processTasks();
   * ```
   */
  pushIncomingMessage(message2, retrievalHint) {
    message2.retrievalHint = retrievalHint;
    this.tasks.push({
      command: Command.Receive,
      params: {
        message: message2
      }
    });
  }
  /**
   * Processes messages in the incoming buffer, delivering those with satisfied dependencies.
   *
   * @returns Array of history entries for messages still missing dependencies
   */
  sweepIncomingBuffer() {
    const { buffer, missing } = this.incomingBuffer.reduce(({ buffer: buffer2, missing: missing2 }, message2) => {
      log37.info(this.senderId, "sweeping incoming buffer", message2.messageId, message2.causalHistory.map((ch) => ch.messageId));
      const missingDependencies = message2.causalHistory.filter((messageHistoryEntry) => !this.isMessageAvailable(messageHistoryEntry.messageId));
      if (missingDependencies.length === 0) {
        if (isContentMessage(message2) && this.deliverMessage(message2)) {
          this.safeSendEvent(MessageChannelEvent.InMessageDelivered, {
            detail: message2.messageId
          });
        }
        return { buffer: buffer2, missing: missing2 };
      }
      log37.info(this.senderId, "message from incoming buffer", message2.messageId, "is missing dependencies", missingDependencies.map(({ messageId, retrievalHint }) => {
        return { messageId, retrievalHint };
      }));
      if (this.timeoutForLostMessagesMs) {
        const timeReceived = this.timeReceived.get(message2.messageId);
        if (timeReceived && Date.now() - timeReceived > this.timeoutForLostMessagesMs) {
          this.safeSendEvent(MessageChannelEvent.InMessageLost, {
            detail: Array.from(missingDependencies)
          });
          return { buffer: buffer2, missing: missing2 };
        }
      }
      missingDependencies.forEach((dependency) => {
        missing2.add(dependency);
      });
      return {
        buffer: buffer2.concat(message2),
        missing: missing2
      };
    }, { buffer: new Array(), missing: /* @__PURE__ */ new Set() });
    this.incomingBuffer = buffer;
    this.safeSendEvent(MessageChannelEvent.InMessageMissing, {
      detail: Array.from(missing)
    });
    return Array.from(missing);
  }
  // https://rfc.vac.dev/vac/raw/sds/#periodic-outgoing-buffer-sweep
  sweepOutgoingBuffer() {
    return this.outgoingBuffer.reduce(({ unacknowledged, possiblyAcknowledged }, message2) => {
      if (this.possibleAcks.has(message2.messageId)) {
        return {
          unacknowledged,
          possiblyAcknowledged: possiblyAcknowledged.concat(message2)
        };
      }
      return {
        unacknowledged: unacknowledged.concat(message2),
        possiblyAcknowledged
      };
    }, {
      unacknowledged: new Array(),
      possiblyAcknowledged: new Array()
    });
  }
  /**
   * Sweep repair incoming buffer and rebroadcast messages ready for repair.
   * Per SDS-R spec: periodically check for repair responses that are due.
   *
   * @param callback - callback to rebroadcast the message
   * @returns Promise that resolves when all ready repairs have been sent
   */
  async sweepRepairIncomingBuffer(callback) {
    var _a27;
    const repairsToSend = ((_a27 = this.repairManager) == null ? void 0 : _a27.sweepIncomingBuffer(this.localHistory)) ?? [];
    if (callback) {
      for (const message2 of repairsToSend) {
        try {
          await callback(message2);
          log37.info(this.senderId, "repair message rebroadcast", message2.messageId);
          this.safeSendEvent(MessageChannelEvent.RepairResponseSent, {
            detail: {
              messageId: message2.messageId
            }
          });
        } catch (error) {
          log37.error("Failed to rebroadcast repair message:", error);
        }
      }
    }
    return repairsToSend;
  }
  /**
   * Send a sync message to the SDS channel.
   *
   * Increments the lamport timestamp, constructs a `Message` object
   * with an empty load. Skips outgoing buffer, filter, and local log.
   *
   * See https://rfc.vac.dev/vac/raw/sds/#send-sync-message
   *
   * @param callback - A callback function that returns a boolean indicating whether the message was sent successfully.
   */
  async pushOutgoingSyncMessage(callback) {
    var _a27;
    this.lamportTimestamp = lamportTimestampIncrement(this.lamportTimestamp);
    const repairRequests = ((_a27 = this.repairManager) == null ? void 0 : _a27.getRepairRequests(MAX_REPAIR_REQUESTS_PER_MESSAGE)) ?? [];
    const message2 = new SyncMessage(
      // does not need to be secure randomness
      `sync-${Math.random().toString(36).substring(2)}`,
      this.channelId,
      this.senderId,
      this.localHistory.slice(-this.causalHistorySize).map(({ messageId, retrievalHint, senderId }) => {
        return { messageId, retrievalHint, senderId };
      }),
      this.lamportTimestamp,
      this.filter.toBytes(),
      void 0,
      repairRequests
    );
    if ((!message2.causalHistory || message2.causalHistory.length === 0) && repairRequests.length === 0) {
      log37.info(this.senderId, "no causal history and no repair requests in sync message, aborting sending");
      return false;
    }
    if (callback) {
      try {
        await callback(message2);
        log37.info(this.senderId, "sync message sent", message2.messageId);
        this.safeSendEvent(MessageChannelEvent.OutSyncSent, {
          detail: message2
        });
        if (repairRequests.length > 0) {
          this.safeSendEvent(MessageChannelEvent.RepairRequestSent, {
            detail: {
              messageIds: repairRequests.map((r2) => r2.messageId),
              carrierMessageId: message2.messageId
            }
          });
        }
        return true;
      } catch (error) {
        log37.error("Callback execution failed in pushOutgoingSyncMessage:", error);
        throw error;
      }
    }
    return true;
  }
  _pushIncomingMessage(message2) {
    var _a27, _b14, _c3;
    if (message2.channelId !== this.channelId) {
      log37.warn("dropping message on different channel", message2.channelId);
      return;
    }
    log37.info(`${this.senderId} incoming message ${message2.messageId}`, `retrieval hint: ${bytesToHex(message2.retrievalHint ?? new Uint8Array())}`);
    const isDuplicate = message2.content && message2.content.length > 0 && this.timeReceived.has(message2.messageId);
    if (isDuplicate) {
      log37.info(this.senderId, "dropping dupe incoming message", message2.messageId);
      return;
    }
    const isOwnOutgoingMessage = this.senderId === message2.senderId;
    if (isOwnOutgoingMessage) {
      log37.info(this.senderId, "ignoring own incoming message");
      return;
    }
    if (isEphemeralMessage(message2)) {
      log37.info(this.senderId, "delivering ephemeral message");
      return;
    }
    if (!isSyncMessage(message2) && !isContentMessage(message2)) {
      log37.error(this.senderId, "internal error, a message is neither sync nor ephemeral nor content, ignoring it", message2);
      return;
    }
    if (isSyncMessage(message2)) {
      this.safeSendEvent(MessageChannelEvent.InSyncReceived, {
        detail: message2
      });
    } else {
      this.safeSendEvent(MessageChannelEvent.InMessageReceived, {
        detail: message2
      });
    }
    (_a27 = this.repairManager) == null ? void 0 : _a27.markMessageReceived(message2.messageId);
    if (message2.repairRequest && message2.repairRequest.length > 0) {
      this.safeSendEvent(MessageChannelEvent.RepairRequestReceived, {
        detail: {
          messageIds: message2.repairRequest.map((r2) => r2.messageId),
          fromSenderId: message2.senderId
        }
      });
      (_b14 = this.repairManager) == null ? void 0 : _b14.processIncomingRepairRequests(message2.repairRequest, this.localHistory);
    }
    this.reviewAckStatus(message2);
    if (isContentMessage(message2)) {
      this.filter.insert(message2.messageId);
    }
    const missingDependencies = message2.causalHistory.filter((messageHistoryEntry) => !this.isMessageAvailable(messageHistoryEntry.messageId));
    if (missingDependencies.length > 0) {
      this.incomingBuffer.push(message2);
      this.timeReceived.set(message2.messageId, Date.now());
      log37.info(this.senderId, "new incoming message", message2.messageId, "is missing dependencies", missingDependencies.map((ch) => ch.messageId));
      (_c3 = this.repairManager) == null ? void 0 : _c3.markDependenciesMissing(missingDependencies);
      this.safeSendEvent(MessageChannelEvent.InMessageMissing, {
        detail: Array.from(missingDependencies)
      });
    } else {
      if (isContentMessage(message2) && this.deliverMessage(message2)) {
        this.safeSendEvent(MessageChannelEvent.InMessageDelivered, {
          detail: message2.messageId
        });
      }
    }
  }
  async executeTask(item) {
    try {
      const handler = this.handlers[item.command];
      await handler(item.params);
    } catch (error) {
      log37.error(`Task execution failed for command ${item.command}:`, error);
      this.dispatchEvent(new CustomEvent("taskError", {
        detail: { command: item.command, error, params: item.params }
      }));
      this.safeSendEvent(MessageChannelEvent.ErrorTask, {
        detail: { command: item.command, error, params: item.params }
      });
    }
  }
  safeSendEvent(event, eventInit) {
    try {
      this.dispatchEvent(new CustomEvent(event, eventInit));
    } catch (error) {
      log37.error(`Failed to dispatch event ${event}:`, error);
    }
  }
  async _pushOutgoingMessage(payload, callback) {
    var _a27;
    this.lamportTimestamp = lamportTimestampIncrement(this.lamportTimestamp);
    const messageId = _MessageChannel.getMessageId(payload);
    let message2 = this.outgoingBuffer.find((m2) => m2.messageId === messageId);
    if (!message2) {
      log37.info(this.senderId, "sending new message", messageId);
      const repairRequests = ((_a27 = this.repairManager) == null ? void 0 : _a27.getRepairRequests(MAX_REPAIR_REQUESTS_PER_MESSAGE)) ?? [];
      message2 = new ContentMessage(messageId, this.channelId, this.senderId, this.localHistory.slice(-this.causalHistorySize).map(({ messageId: messageId2, retrievalHint, senderId }) => {
        return { messageId: messageId2, retrievalHint, senderId };
      }), this.lamportTimestamp, this.filter.toBytes(), payload, repairRequests);
      this.outgoingBuffer.push(message2);
    } else {
      log37.info(this.senderId, "resending message", messageId);
    }
    if (callback) {
      try {
        const { success, retrievalHint } = await callback(message2);
        if (success && isContentMessage(message2)) {
          message2.retrievalHint = retrievalHint;
          this.filter.insert(messageId);
          this.localHistory.push(message2);
          this.timeReceived.set(messageId, Date.now());
          this.safeSendEvent(MessageChannelEvent.OutMessageSent, {
            detail: message2
          });
        }
      } catch (error) {
        log37.error("Callback execution failed in _pushOutgoingMessage:", error);
        throw error;
      }
    }
  }
  async _pushOutgoingEphemeralMessage(payload, callback) {
    const message2 = new EphemeralMessage(_MessageChannel.getMessageId(payload), this.channelId, this.senderId, [], void 0, void 0, payload);
    if (callback) {
      try {
        await callback(message2);
      } catch (error) {
        log37.error("Callback execution failed in _pushOutgoingEphemeralMessage:", error);
        throw error;
      }
    }
  }
  /**
   * Check if a message is available (either in localHistory or incomingBuffer)
   * This prevents treating messages as "missing" when they've already been received
   * but are waiting in the incoming buffer for their dependencies.
   *
   * @param messageId - The ID of the message to check
   * @private
   */
  isMessageAvailable(messageId) {
    if (this.localHistory.some((m2) => m2.messageId === messageId)) {
      return true;
    }
    if (this.incomingBuffer.some((m2) => m2.messageId === messageId)) {
      return true;
    }
    return false;
  }
  /**
   * Return true if the message was "delivered"
   *
   * @param message
   * @private
   */
  // See https://rfc.vac.dev/vac/raw/sds/#deliver-message
  deliverMessage(message2) {
    if (!isContentMessage(message2)) {
      return false;
    }
    log37.info(this.senderId, "delivering message", message2.messageId, message2.retrievalHint);
    if (message2.lamportTimestamp > this.lamportTimestamp) {
      this.lamportTimestamp = message2.lamportTimestamp;
    }
    const existingHistoryEntry = this.localHistory.find(({ messageId }) => messageId === message2.messageId);
    if (existingHistoryEntry) {
      return true;
    }
    if (!message2.retrievalHint) {
      log37.warn("message delivered without a retrieval hint", message2.messageId);
    }
    this.localHistory.push(message2);
    return true;
  }
  // For each received message (including sync messages), inspect the causal history and bloom filter
  // to determine the acknowledgement status of messages in the outgoing buffer.
  // See https://rfc.vac.dev/vac/raw/sds/#review-ack-status
  reviewAckStatus(receivedMessage) {
    log37.info(this.senderId, "reviewing ack status using causal history:", receivedMessage.causalHistory.map((ch) => ch.messageId));
    log37.info(this.senderId, "current outgoing buffer:", this.outgoingBuffer.map((b) => b.messageId));
    receivedMessage.causalHistory.forEach(({ messageId }) => {
      this.outgoingBuffer = this.outgoingBuffer.filter(({ messageId: bufferMessageId }) => {
        if (bufferMessageId !== messageId) {
          return true;
        }
        log37.info(this.senderId, "message acknowledged", messageId);
        this.safeSendEvent(MessageChannelEvent.OutMessageAcknowledged, {
          detail: messageId
        });
        return false;
      });
    });
    if (!receivedMessage.bloomFilter) {
      return;
    }
    const messageBloomFilter = DefaultBloomFilter.fromBytes(receivedMessage.bloomFilter, this.filter.options);
    this.outgoingBuffer = this.outgoingBuffer.filter((message2) => {
      if (!messageBloomFilter.lookup(message2.messageId)) {
        return true;
      }
      const count = (this.possibleAcks.get(message2.messageId) ?? 0) + 1;
      if (count < this.possibleAcksThreshold) {
        this.possibleAcks.set(message2.messageId, count);
        log37.info(this.senderId, "message possibly acknowledged", message2.messageId, count);
        this.safeSendEvent(MessageChannelEvent.OutMessagePossiblyAcknowledged, {
          detail: {
            messageId: message2.messageId,
            count
          }
        });
        return true;
      }
      this.possibleAcks.delete(message2.messageId);
      log37.info(this.senderId, "message acknowledged", message2.messageId, count);
      this.safeSendEvent(MessageChannelEvent.OutMessageAcknowledged, {
        detail: message2.messageId
      });
      return false;
    });
  }
};
function lamportTimestampIncrement(lamportTimestamp) {
  const now = BigInt(Date.now());
  lamportTimestamp++;
  if (now > lamportTimestamp) {
    return now;
  }
  return lamportTimestamp;
}

// node_modules/@waku/sdk/dist/query_on_connect/query_on_connect.js
var log38 = new Logger("sdk:query-on-connect");
var DEFAULT_FORCE_QUERY_THRESHOLD_MS = 5 * 60 * 1e3;
var MAX_TIME_RANGE_QUERY_MS = 30 * 24 * 60 * 60 * 1e3;
var QueryOnConnectEvent;
(function(QueryOnConnectEvent2) {
  QueryOnConnectEvent2["MessagesRetrieved"] = "messages:retrieved";
})(QueryOnConnectEvent || (QueryOnConnectEvent = {}));
var QueryOnConnect = class extends TypedEventEmitter {
  constructor(decoders4, stopIfTrue, peerManagerEventEmitter, wakuEventEmitter, _queryGenerator, options) {
    super();
    __publicField(this, "decoders");
    __publicField(this, "stopIfTrue");
    __publicField(this, "peerManagerEventEmitter");
    __publicField(this, "wakuEventEmitter");
    __publicField(this, "_queryGenerator");
    __publicField(this, "lastSuccessfulQuery");
    __publicField(this, "lastTimeOffline");
    __publicField(this, "forceQueryThresholdMs");
    this.decoders = decoders4;
    this.stopIfTrue = stopIfTrue;
    this.peerManagerEventEmitter = peerManagerEventEmitter;
    this.wakuEventEmitter = wakuEventEmitter;
    this._queryGenerator = _queryGenerator;
    this.lastSuccessfulQuery = 0;
    this.lastTimeOffline = 0;
    this.forceQueryThresholdMs = (options == null ? void 0 : options.forceQueryThresholdMs) ?? DEFAULT_FORCE_QUERY_THRESHOLD_MS;
  }
  start() {
    log38.info("starting query-on-connect service");
    this.setupEventListeners();
  }
  stop() {
    this.unsetEventListeners();
  }
  /**
   * Mainly exposed for testing. Only use if you know what you are doing.
   *
   * Proceed with a query if:
   * - No successful query has happened
   * - OR, We detected that we were offline since last successful query
   * - OR, It bas been more than `forceQueryThresholdMs` than last query
   *
   * [[QueryOnConnect]] handles the listening to event to call this function.
   *
   * @param peerId A store peer id. Must be passed as we expect this to be trigger
   * upon a detected connection to a store peer.
   */
  async maybeQuery(peerId2) {
    const timeSinceLastQuery = Date.now() - this.lastSuccessfulQuery;
    log38.info(`maybe do store query to ${peerId2.toString()}`, this.lastSuccessfulQuery, this.lastTimeOffline, timeSinceLastQuery, this.forceQueryThresholdMs);
    if (this.lastSuccessfulQuery === 0 || this.lastTimeOffline > this.lastSuccessfulQuery || timeSinceLastQuery > this.forceQueryThresholdMs) {
      await this.query(peerId2);
    } else {
      log38.info(`no querying`);
    }
  }
  async query(peerId2) {
    log38.info(`perform store query to ${peerId2.toString()}`);
    const { timeStart, timeEnd } = this.queryTimeRange();
    try {
      for await (const page of this._queryGenerator(this.decoders, {
        timeStart,
        timeEnd,
        peerId: peerId2
      })) {
        const messages2 = (await Promise.all(page)).filter((m2) => m2 !== void 0);
        const stop2 = messages2.some((msg) => this.stopIfTrue(msg));
        this.dispatchMessages(messages2);
        if (stop2) {
          break;
        }
      }
      this.lastSuccessfulQuery = Date.now();
    } catch (err) {
      log38.warn(`store query to ${peerId2.toString()} failed`, err);
    }
  }
  queryTimeRange() {
    return calculateTimeRange(Date.now(), this.lastSuccessfulQuery, MAX_TIME_RANGE_QUERY_MS);
  }
  dispatchMessages(messages2) {
    log38.info("dispatching messages", messages2.map((m2) => m2.hashStr));
    this.dispatchEvent(new CustomEvent(QueryOnConnectEvent.MessagesRetrieved, {
      detail: messages2
    }));
  }
  setupEventListeners() {
    this.peerManagerEventEmitter.addEventListener(PeerManagerEventNames.StoreConnect, (event) => void this.maybeQuery(event.detail).catch((err) => log38.error("query-on-connect error", err)));
    this.wakuEventEmitter.addEventListener(WakuEvent.Health, this.updateLastOfflineDate.bind(this));
  }
  unsetEventListeners() {
    this.peerManagerEventEmitter.removeEventListener(PeerManagerEventNames.StoreConnect, (event) => void this.maybeQuery(event.detail).catch((err) => log38.error("query-on-connect error", err)));
    this.wakuEventEmitter.removeEventListener(WakuEvent.Health, this.updateLastOfflineDate.bind(this));
  }
  updateLastOfflineDate(event) {
    if (event.detail === HealthStatus.Unhealthy) {
      this.lastTimeOffline = Date.now();
    }
  }
};
function calculateTimeRange(now, lastSuccessfulQuery, maxTimeRangeQueryMs) {
  const timeRange = Math.min(now - lastSuccessfulQuery, maxTimeRangeQueryMs);
  const timeStart = new Date(now - timeRange);
  const timeEnd = new Date(now);
  return { timeStart, timeEnd };
}

// node_modules/@waku/sdk/dist/reliable_channel/missing_message_retriever.js
var log39 = new Logger("sdk:missing-message-retriever");
var DEFAULT_RETRIEVE_FREQUENCY_MS = 10 * 1e3;
var MissingMessageRetriever = class {
  // Waku Message Ids
  constructor(decoder, retrieveFrequencyMs = DEFAULT_RETRIEVE_FREQUENCY_MS, _retrieve, onMessageRetrieved) {
    __publicField(this, "decoder");
    __publicField(this, "retrieveFrequencyMs");
    __publicField(this, "_retrieve");
    __publicField(this, "onMessageRetrieved");
    __publicField(this, "retrieveInterval");
    __publicField(this, "missingMessages");
    this.decoder = decoder;
    this.retrieveFrequencyMs = retrieveFrequencyMs;
    this._retrieve = _retrieve;
    this.onMessageRetrieved = onMessageRetrieved;
    this.missingMessages = /* @__PURE__ */ new Map();
  }
  start() {
    if (this.retrieveInterval) {
      clearInterval(this.retrieveInterval);
    }
    if (this.retrieveFrequencyMs !== 0) {
      log39.info(`start retrieve loop every ${this.retrieveFrequencyMs}ms`);
      this.retrieveInterval = setInterval(() => {
        void this.retrieveMissingMessage();
      }, this.retrieveFrequencyMs);
    }
  }
  stop() {
    if (this.retrieveInterval) {
      clearInterval(this.retrieveInterval);
    }
  }
  addMissingMessage(messageId, retrievalHint) {
    if (!this.missingMessages.has(messageId)) {
      log39.info("missing message notice", messageId, retrievalHint);
      this.missingMessages.set(messageId, retrievalHint);
    }
  }
  removeMissingMessage(messageId) {
    if (this.missingMessages.has(messageId)) {
      this.missingMessages.delete(messageId);
    }
  }
  async retrieveMissingMessage() {
    if (this.missingMessages.size) {
      const messageHashes = Array.from(this.missingMessages.values());
      log39.info("attempting to retrieve missing message", messageHashes.length);
      for await (const page of this._retrieve([this.decoder], {
        messageHashes
      })) {
        for await (const msg of page) {
          if (msg && this.onMessageRetrieved) {
            await this.onMessageRetrieved(msg);
          }
        }
      }
    }
  }
};

// node_modules/@waku/sdk/dist/reliable_channel/retry_manager.js
var RetryManager2 = class {
  constructor(retryIntervalMs, maxRetryNumber) {
    __publicField(this, "retryIntervalMs");
    __publicField(this, "maxRetryNumber");
    __publicField(this, "timeouts");
    this.retryIntervalMs = retryIntervalMs;
    this.maxRetryNumber = maxRetryNumber;
    this.timeouts = /* @__PURE__ */ new Map();
    if (!retryIntervalMs || retryIntervalMs <= 0 || !maxRetryNumber || maxRetryNumber <= 0) {
      throw Error(`Invalid retryIntervalMs ${retryIntervalMs} or maxRetryNumber ${maxRetryNumber} values`);
    }
  }
  stopRetries(id) {
    const timeout2 = this.timeouts.get(id);
    if (timeout2) {
      clearTimeout(timeout2);
    }
  }
  startRetries(id, retry2) {
    this.retry(id, retry2, 0);
  }
  retry(id, retry2, attemptNumber) {
    clearTimeout(this.timeouts.get(id));
    if (attemptNumber < this.maxRetryNumber) {
      const interval = setTimeout(() => {
        void retry2();
        this.retry(id, retry2, ++attemptNumber);
      }, this.retryIntervalMs);
      this.timeouts.set(id, interval);
    }
  }
};

// node_modules/@waku/sdk/dist/reliable_channel/reliable_channel.js
var log40 = new Logger("sdk:reliable-channel");
var DEFAULT_SYNC_MIN_INTERVAL_MS = 30 * 1e3;
var DEFAULT_RETRY_INTERVAL_MS = 30 * 1e3;
var DEFAULT_MAX_RETRY_ATTEMPTS = 10;
var DEFAULT_SWEEP_IN_BUF_INTERVAL_MS = 5 * 1e3;
var DEFAULT_PROCESS_TASK_MIN_ELAPSE_MS = 1e3;
var IRRECOVERABLE_SENDING_ERRORS = [
  LightPushError.ENCODE_FAILED,
  LightPushError.EMPTY_PAYLOAD,
  LightPushError.SIZE_TOO_BIG,
  LightPushError.RLN_PROOF_GENERATION
];
var ReliableChannel = class _ReliableChannel extends TypedEventEmitter {
  constructor(node, messageChannel, encoder2, decoder, options) {
    var _a27;
    super();
    __publicField(this, "node");
    __publicField(this, "messageChannel");
    __publicField(this, "encoder");
    __publicField(this, "decoder");
    __publicField(this, "_send");
    __publicField(this, "_subscribe");
    __publicField(this, "_retrieve");
    __publicField(this, "syncMinIntervalMs");
    __publicField(this, "syncTimeout");
    __publicField(this, "sweepInBufInterval");
    __publicField(this, "sweepInBufIntervalMs");
    __publicField(this, "processTaskTimeout");
    __publicField(this, "retryManager");
    __publicField(this, "missingMessageRetriever");
    __publicField(this, "queryOnConnect");
    __publicField(this, "processTaskMinElapseMs");
    __publicField(this, "_started");
    this.node = node;
    this.messageChannel = messageChannel;
    this.encoder = encoder2;
    this.decoder = decoder;
    if (node.lightPush) {
      this._send = node.lightPush.send.bind(node.lightPush);
    } else if (node.relay) {
      this._send = node.relay.send.bind(node.relay);
    } else {
      throw "No protocol available to send messages";
    }
    if (node.filter) {
      this._subscribe = node.filter.subscribe.bind(node.filter);
    } else if (node.relay) {
      throw "Not implemented";
    } else {
      throw "No protocol available to receive messages";
    }
    if (node.store) {
      this._retrieve = node.store.queryGenerator.bind(node.store);
      const peerManagerEvents = (_a27 = node == null ? void 0 : node.peerManager) == null ? void 0 : _a27.events;
      if (peerManagerEvents !== void 0 && ((options == null ? void 0 : options.queryOnConnect) ?? true)) {
        this.queryOnConnect = new QueryOnConnect([this.decoder], this.isChannelMessageWithCausalHistory.bind(this), peerManagerEvents, node.events, this._retrieve.bind(this));
      }
    }
    this.syncMinIntervalMs = (options == null ? void 0 : options.syncMinIntervalMs) ?? DEFAULT_SYNC_MIN_INTERVAL_MS;
    this.sweepInBufIntervalMs = (options == null ? void 0 : options.sweepInBufIntervalMs) ?? DEFAULT_SWEEP_IN_BUF_INTERVAL_MS;
    const retryIntervalMs = (options == null ? void 0 : options.retryIntervalMs) ?? DEFAULT_RETRY_INTERVAL_MS;
    const maxRetryAttempts = (options == null ? void 0 : options.maxRetryAttempts) ?? DEFAULT_MAX_RETRY_ATTEMPTS;
    if (retryIntervalMs && maxRetryAttempts) {
      this.retryManager = new RetryManager2(retryIntervalMs, maxRetryAttempts);
    }
    this.processTaskMinElapseMs = (options == null ? void 0 : options.processTaskMinElapseMs) ?? DEFAULT_PROCESS_TASK_MIN_ELAPSE_MS;
    if (this._retrieve) {
      this.missingMessageRetriever = new MissingMessageRetriever(this.decoder, options == null ? void 0 : options.retrieveFrequencyMs, this._retrieve, async (msg) => {
        await this.processIncomingMessage(msg);
      });
    }
    this._started = false;
  }
  get isStarted() {
    return this._started;
  }
  /**
   * Used to identify messages, pass the payload of a message you are
   * about to send to track the events for this message.
   * This is pre-sds wrapping
   * @param messagePayload
   */
  static getMessageId(messagePayload) {
    return MessageChannel.getMessageId(messagePayload);
  }
  /**
   * Create a new message channels. Message channels enables end-to-end
   * reliability by ensuring that all messages in the channel are received
   * by other users, and retrieved by this local node.
   *
   * emits events about outgoing messages, see [[`ReliableChannel`]] docs.
   *
   * Note that all participants in a message channels need to get the messages
   * from the channel. Meaning:
   * - all participants must be able to decrypt the messages
   * - all participants must be subscribing to content topic(s) where the messages are sent
   *
   * @param node The waku node to use to send and receive messages
   * @param channelId An id for the channel, all participants of the channel should use the same id
   * @param senderId An id for the sender, to ensure acknowledgements are only valid if originating from someone else; best if persisted between sessions
   * @param encoder A channel operates within a singular encryption layer, hence the same encoder is needed for all messages
   * @param decoder A channel operates within a singular encryption layer, hence the same decoder is needed for all messages
   * @param options
   */
  static async create(node, channelId, senderId, encoder2, decoder, options) {
    const sdsMessageChannel = new MessageChannel(channelId, senderId, options);
    const messageChannel = new _ReliableChannel(node, sdsMessageChannel, encoder2, decoder, options);
    const autoStart = (options == null ? void 0 : options.autoStart) ?? true;
    if (autoStart) {
      await messageChannel.start();
    }
    return messageChannel;
  }
  /**
   * Sends a message in the channel, will attempt to re-send if not acknowledged
   * by other participants.
   *
   * @param messagePayload
   * @returns the message id
   */
  send(messagePayload) {
    var _a27;
    const messageId = _ReliableChannel.getMessageId(messagePayload);
    if (!this._started) {
      this.safeSendEvent("sending-message-irrecoverable-error", {
        detail: { messageId, error: "channel is not started" }
      });
    }
    const wrapAndSendBind = this._wrapAndSend.bind(this, messagePayload);
    (_a27 = this.retryManager) == null ? void 0 : _a27.startRetries(messageId, wrapAndSendBind);
    wrapAndSendBind();
    return messageId;
  }
  _wrapAndSend(messagePayload) {
    this.messageChannel.pushOutgoingMessage(messagePayload, async (sdsMessage) => {
      const sdsPayload = sdsMessage.encode();
      const wakuMessage = {
        payload: sdsPayload
      };
      const messageId = _ReliableChannel.getMessageId(messagePayload);
      const protoMessage = await this.encoder.toProtoObj(wakuMessage);
      if (!protoMessage) {
        this.safeSendEvent("sending-message-irrecoverable-error", {
          detail: {
            messageId,
            error: "could not encode message"
          }
        });
        return { success: false };
      }
      const retrievalHint = messageHash(this.encoder.pubsubTopic, protoMessage);
      this.safeSendEvent("sending-message", {
        detail: messageId
      });
      const sendRes = await this._send(this.encoder, wakuMessage);
      for (const { error } of sendRes.failures) {
        if (IRRECOVERABLE_SENDING_ERRORS.includes(error)) {
          log40.error("Irrecoverable error, cannot send message: ", error);
          this.safeSendEvent("sending-message-irrecoverable-error", {
            detail: {
              messageId,
              error
            }
          });
          return { success: false, retrievalHint };
        }
      }
      return {
        success: true,
        retrievalHint
      };
    });
    this.messageChannel.processTasks().then(() => {
      this.messageChannel.sweepOutgoingBuffer();
    }).catch((err) => {
      log40.error("error encountered when processing sds tasks", err);
    });
  }
  async subscribe() {
    this.assertStarted();
    return this._subscribe(this.decoder, async (message2) => {
      await this.processIncomingMessage(message2);
    });
  }
  /**
   * Don't forget to call `this.messageChannel.sweepIncomingBuffer();` once done.
   * @param msg
   * @private
   */
  async processIncomingMessage(msg) {
    var _a27;
    const sdsMessage = Message.decode(msg.payload);
    if (!sdsMessage) {
      log40.error("could not SDS decode message", msg);
      return;
    }
    if (sdsMessage.channelId !== this.messageChannel.channelId) {
      log40.warn("ignoring message with different channel id", sdsMessage.channelId);
      return;
    }
    const retrievalHint = msg.hash;
    log40.info(`processing message ${sdsMessage.messageId}:${msg.hashStr}`);
    this.messageChannel.pushIncomingMessage(sdsMessage, retrievalHint);
    (_a27 = this.missingMessageRetriever) == null ? void 0 : _a27.removeMissingMessage(sdsMessage.messageId);
    if (sdsMessage.content && sdsMessage.content.length > 0) {
      const { payload: _p, ...allButPayload } = msg;
      const unwrappedMessage = Object.assign(allButPayload, {
        payload: sdsMessage.content,
        hash: msg.hash,
        hashStr: msg.hashStr,
        version: msg.version,
        contentTopic: msg.contentTopic,
        pubsubTopic: msg.pubsubTopic,
        timestamp: msg.timestamp,
        rateLimitProof: msg.rateLimitProof,
        ephemeral: msg.ephemeral,
        meta: msg.meta
      });
      this.safeSendEvent("message-received", {
        detail: unwrappedMessage
      });
    }
    this.queueProcessTasks();
  }
  async processIncomingMessages(messages2) {
    for (const message2 of messages2) {
      await this.processIncomingMessage(message2);
    }
  }
  // TODO: For now we only queue process tasks for incoming messages
  // As this is where there is most volume
  queueProcessTasks() {
    if (this.processTaskTimeout === void 0) {
      this.processTaskTimeout = setTimeout(() => {
        void this.messageChannel.processTasks().catch((err) => {
          log40.error("error encountered when processing sds tasks", err);
        });
        clearTimeout(this.processTaskTimeout);
        this.processTaskTimeout = void 0;
      }, this.processTaskMinElapseMs);
    }
  }
  async start() {
    var _a27, _b14;
    if (this._started)
      return true;
    this._started = true;
    this.setupEventListeners();
    this.restartSync();
    this.startSweepIncomingBufferLoop();
    if (this._retrieve) {
      (_a27 = this.missingMessageRetriever) == null ? void 0 : _a27.start();
      (_b14 = this.queryOnConnect) == null ? void 0 : _b14.start();
    }
    return this.subscribe();
  }
  stop() {
    var _a27, _b14;
    if (!this._started)
      return;
    this._started = false;
    this.stopSync();
    this.stopSweepIncomingBufferLoop();
    (_a27 = this.missingMessageRetriever) == null ? void 0 : _a27.stop();
    (_b14 = this.queryOnConnect) == null ? void 0 : _b14.stop();
  }
  assertStarted() {
    if (!this._started)
      throw Error("Message Channel must be started");
  }
  startSweepIncomingBufferLoop() {
    this.stopSweepIncomingBufferLoop();
    this.sweepInBufInterval = setInterval(() => {
      log40.info("sweep incoming buffer");
      this.messageChannel.sweepIncomingBuffer();
    }, this.sweepInBufIntervalMs);
  }
  stopSweepIncomingBufferLoop() {
    if (this.sweepInBufInterval)
      clearInterval(this.sweepInBufInterval);
  }
  restartSync(multiplier = 1) {
    if (this.syncTimeout) {
      clearTimeout(this.syncTimeout);
    }
    if (this.syncMinIntervalMs) {
      const timeoutMs = this.random() * this.syncMinIntervalMs * multiplier;
      this.syncTimeout = setTimeout(() => {
        void this.sendSyncMessage();
        void this.restartSync(2);
      }, timeoutMs);
    }
  }
  stopSync() {
    if (this.syncTimeout) {
      clearTimeout(this.syncTimeout);
    }
  }
  // Used to enable overriding when testing
  random() {
    return Math.random();
  }
  safeSendEvent(event, eventInit) {
    try {
      this.dispatchEvent(new CustomEvent(event, eventInit));
    } catch (error) {
      log40.error(`Failed to dispatch event ${event}:`, error);
    }
  }
  async sendSyncMessage() {
    this.assertStarted();
    await this.messageChannel.pushOutgoingSyncMessage(async (syncMessage) => {
      const sdsPayload = syncMessage.encode();
      const wakuMessage = {
        payload: sdsPayload
      };
      const sendRes = await this._send(this.encoder, wakuMessage);
      if (sendRes.failures.length > 0) {
        log40.error("Error sending sync message: ", sendRes);
        return false;
      }
      return true;
    });
    await this.messageChannel.processTasks();
    this.messageChannel.sweepOutgoingBuffer();
  }
  isChannelMessageWithCausalHistory(msg) {
    const sdsMessage = Message.decode(msg.payload);
    if (!sdsMessage) {
      return false;
    }
    if (sdsMessage.channelId !== this.messageChannel.channelId) {
      return false;
    }
    return sdsMessage.causalHistory && sdsMessage.causalHistory.length > 0;
  }
  setupEventListeners() {
    this.messageChannel.addEventListener(MessageChannelEvent.OutMessageSent, (event) => {
      if (event.detail.content) {
        const messageId = _ReliableChannel.getMessageId(event.detail.content);
        this.safeSendEvent("message-sent", {
          detail: messageId
        });
      }
    });
    this.messageChannel.addEventListener(MessageChannelEvent.OutMessageAcknowledged, (event) => {
      var _a27;
      if (event.detail) {
        this.safeSendEvent("message-acknowledged", {
          detail: event.detail
        });
        (_a27 = this.retryManager) == null ? void 0 : _a27.stopRetries(event.detail);
      }
    });
    this.messageChannel.addEventListener(MessageChannelEvent.OutMessagePossiblyAcknowledged, (event) => {
      if (event.detail) {
        this.safeSendEvent("message-possibly-acknowledged", {
          detail: {
            messageId: event.detail.messageId,
            possibleAckCount: event.detail.count
          }
        });
      }
    });
    this.messageChannel.addEventListener(MessageChannelEvent.InSyncReceived, (_event) => {
      this.restartSync();
    });
    this.messageChannel.addEventListener(MessageChannelEvent.InMessageReceived, (event) => {
      if (isContentMessage(event.detail)) {
        this.restartSync(0.5);
      }
    });
    this.messageChannel.addEventListener(MessageChannelEvent.OutMessageSent, (event) => {
      if (isContentMessage(event.detail)) {
        this.restartSync();
      }
    });
    this.messageChannel.addEventListener(MessageChannelEvent.InMessageMissing, (event) => {
      for (const { messageId, retrievalHint } of event.detail) {
        if (retrievalHint && this.missingMessageRetriever) {
          this.missingMessageRetriever.addMissingMessage(messageId, retrievalHint);
        }
      }
    });
    if (this.queryOnConnect) {
      this.queryOnConnect.addEventListener(QueryOnConnectEvent.MessagesRetrieved, (event) => {
        void this.processIncomingMessages(event.detail);
      });
    }
  }
};

// node_modules/@waku/sdk/dist/reliable_channel/events.js
var ReliableChannelEvent = {
  /**
   * The message is being sent over the wire.
   *
   * This event may be emitted several times if the retry mechanism kicks in.
   */
  SendingMessage: "sending-message",
  /**
   * The message has been sent over the wire but has not been acknowledged by
   * any other party yet.
   *
   * We are now waiting for acknowledgements.
   *
   * This event may be emitted several times if the
   * several times if the retry mechanisms kicks in.
   */
  MessageSent: "message-sent",
  /**
   * A received bloom filter seems to indicate that the messages was received
   * by another party.
   *
   * However, this is probabilistic. The retry mechanism will wait a bit longer
   * before trying to send the message again.
   */
  MessagePossiblyAcknowledged: "message-possibly-acknowledged",
  /**
   * The message was fully acknowledged by other members of the channel
   */
  MessageAcknowledged: "message-acknowledged",
  /**
   * It was not possible to send the messages due to a non-recoverable error,
   * most likely an internal error for a developer to resolve.
   */
  SendingMessageIrrecoverableError: "sending-message-irrecoverable-error",
  /**
   * A new message has been received.
   */
  MessageReceived: "message-received",
  /**
   * We are aware of a missing message but failed to retrieve it successfully.
   */
  IrretrievableMessage: "irretrievable-message"
};
export {
  CONNECTION_LOCKED_TAG,
  DEFAULT_CLUSTER_ID,
  DEFAULT_NUM_SHARDS,
  DNS_DISCOVERY_TAG,
  DecodedMessage,
  Decoder2 as Decoder,
  DefaultNetworkConfig,
  Encoder2 as Encoder,
  Filter,
  FilterError,
  HealthStatus,
  LightPush,
  LightPushError,
  LightPushStatusCode,
  ProtocolError2 as ProtocolError,
  Protocols,
  ReliableChannel,
  ReliableChannelEvent,
  StatusDescriptions,
  Store,
  Tags,
  WakuEvent,
  WakuNode,
  bytesToUtf8,
  createDecoder,
  createEncoder,
  createLibp2pAndUpdateOptions,
  createLightNode,
  defaultLibp2p,
  utf8ToBytes2 as utf8ToBytes,
  dist_exports as utils,
  waitForRemotePeer,
  dist_exports2 as waku
};
/*! Bundled license information:

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.9.3
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2023
   * @license MIT
   *)

hi-base32/src/base32.js:
  (*
   * [hi-base32]{@link https://github.com/emn178/hi-base32}
   *
   * @version 0.5.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/edwards.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/montgomery.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/oprf.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/ciphers/esm/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)

@noble/curves/esm/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/edwards.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/montgomery.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/secp256k1/lib/esm/index.js:
  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@waku_sdk.js.map
