(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.ItQueuelessPushable = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var ItQueuelessPushable=(()=>{var a=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var d=Object.getOwnPropertyNames;var c=Object.prototype.hasOwnProperty;var x=(t,e)=>{for(var r in e)a(t,r,{get:e[r],enumerable:!0})},f=(t,e,r,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of d(e))!c.call(t,n)&&n!==r&&a(t,n,{get:()=>e[n],enumerable:!(i=h(e,n))||i.enumerable});return t};var v=t=>f(a({},"__esModule",{value:!0}),t);var N={};x(N,{queuelessPushable:()=>p});function s(){let t={};return t.promise=new Promise((e,r)=>{t.resolve=e,t.reject=r}),t}function w(t){return t.reason}async function l(t,e,r){if(e==null)return t;let i=r?.translateError??w;if(e.aborted)return t.catch(()=>{}),Promise.reject(i(e));let n;try{return await Promise.race([t,new Promise((m,o)=>{n=()=>{o(i(e))},e.addEventListener("abort",n)})])}finally{n!=null&&e.removeEventListener("abort",n)}}var u=class{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=s(),this.haveNext=s()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");let e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=s(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){let e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,r){await this._push(e,r)}async end(e,r){e!=null?await this.throw(e):await this._push(void 0,r)}async _push(e,r){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=s(),await l(this.readNext.promise,r?.signal,r)}};function p(){return new u}return v(N);})();
return ItQueuelessPushable}));
//# sourceMappingURL=index.min.js.map
